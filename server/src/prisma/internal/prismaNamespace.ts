
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.0.0
 * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
 */
export const prismaVersion: PrismaVersion = {
  client: "7.0.0",
  engine: "0c19ccc313cf9911a90d99d2ac2eb0280c76c513"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  activity: 'activity',
  activityLog: 'activityLog',
  activityRegistration: 'activityRegistration',
  badge: 'badge',
  blockedContact: 'blockedContact',
  category: 'category',
  categoryChapter: 'categoryChapter',
  categoryType: 'categoryType',
  cognitiveExercise: 'cognitiveExercise',
  collaborativeProject: 'collaborativeProject',
  contactRequest: 'contactRequest',
  conversation: 'conversation',
  conversationParticipant: 'conversationParticipant',
  exerciseProgram: 'exerciseProgram',
  forumMessage: 'forumMessage',
  forumSection: 'forumSection',
  forumTopic: 'forumTopic',
  healthIndicator: 'healthIndicator',
  helpOffer: 'helpOffer',
  helpRequest: 'helpRequest',
  interest: 'interest',
  localService: 'localService',
  medicationReminder: 'medicationReminder',
  menuItem: 'menuItem',
  message: 'message',
  mood: 'mood',
  municipalEvent: 'municipalEvent',
  notification: 'notification',
  notificationPreferences: 'notificationPreferences',
  nutritionalAdvice: 'nutritionalAdvice',
  projectMember: 'projectMember',
  projectTask: 'projectTask',
  resource: 'resource',
  satisfactionSurvey: 'satisfactionSurvey',
  serviceCompleted: 'serviceCompleted',
  serviceRating: 'serviceRating',
  session: 'session',
  skill: 'skill',
  surveyResponse: 'surveyResponse',
  trustCircle: 'trustCircle',
  trustedContact: 'trustedContact',
  urbanIssueReport: 'urbanIssueReport',
  user: 'user',
  userActivity: 'userActivity',
  userBadge: 'userBadge',
  userContacts: 'userContacts',
  userDevice: 'userDevice',
  userInterest: 'userInterest',
  userPreferences: 'userPreferences',
  userRole: 'userRole',
  userSkill: 'userSkill',
  userStatistics: 'userStatistics',
  videoCall: 'videoCall',
  wellnessBadge: 'wellnessBadge',
  wellnessGoal: 'wellnessGoal',
  wellnessGoalProgress: 'wellnessGoalProgress'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "activity" | "activityLog" | "activityRegistration" | "badge" | "blockedContact" | "category" | "categoryChapter" | "categoryType" | "cognitiveExercise" | "collaborativeProject" | "contactRequest" | "conversation" | "conversationParticipant" | "exerciseProgram" | "forumMessage" | "forumSection" | "forumTopic" | "healthIndicator" | "helpOffer" | "helpRequest" | "interest" | "localService" | "medicationReminder" | "menuItem" | "message" | "mood" | "municipalEvent" | "notification" | "notificationPreferences" | "nutritionalAdvice" | "projectMember" | "projectTask" | "resource" | "satisfactionSurvey" | "serviceCompleted" | "serviceRating" | "session" | "skill" | "surveyResponse" | "trustCircle" | "trustedContact" | "urbanIssueReport" | "user" | "userActivity" | "userBadge" | "userContacts" | "userDevice" | "userInterest" | "userPreferences" | "userRole" | "userSkill" | "userStatistics" | "videoCall" | "wellnessBadge" | "wellnessGoal" | "wellnessGoalProgress"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    activity: {
      payload: Prisma.$activityPayload<ExtArgs>
      fields: Prisma.activityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.activityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.activityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>
        }
        findFirst: {
          args: Prisma.activityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.activityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>
        }
        findMany: {
          args: Prisma.activityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>[]
        }
        create: {
          args: Prisma.activityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>
        }
        createMany: {
          args: Prisma.activityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.activityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>[]
        }
        delete: {
          args: Prisma.activityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>
        }
        update: {
          args: Prisma.activityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>
        }
        deleteMany: {
          args: Prisma.activityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.activityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.activityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>[]
        }
        upsert: {
          args: Prisma.activityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityPayload>
        }
        aggregate: {
          args: Prisma.ActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActivity>
        }
        groupBy: {
          args: Prisma.activityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.activityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityCountAggregateOutputType> | number
        }
      }
    }
    activityLog: {
      payload: Prisma.$activityLogPayload<ExtArgs>
      fields: Prisma.activityLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.activityLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.activityLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>
        }
        findFirst: {
          args: Prisma.activityLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.activityLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>
        }
        findMany: {
          args: Prisma.activityLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>[]
        }
        create: {
          args: Prisma.activityLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>
        }
        createMany: {
          args: Prisma.activityLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.activityLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>[]
        }
        delete: {
          args: Prisma.activityLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>
        }
        update: {
          args: Prisma.activityLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>
        }
        deleteMany: {
          args: Prisma.activityLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.activityLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.activityLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>[]
        }
        upsert: {
          args: Prisma.activityLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityLogPayload>
        }
        aggregate: {
          args: Prisma.ActivityLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActivityLog>
        }
        groupBy: {
          args: Prisma.activityLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.activityLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityLogCountAggregateOutputType> | number
        }
      }
    }
    activityRegistration: {
      payload: Prisma.$activityRegistrationPayload<ExtArgs>
      fields: Prisma.activityRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.activityRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.activityRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
        }
        findFirst: {
          args: Prisma.activityRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.activityRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
        }
        findMany: {
          args: Prisma.activityRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>[]
        }
        create: {
          args: Prisma.activityRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
        }
        createMany: {
          args: Prisma.activityRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.activityRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>[]
        }
        delete: {
          args: Prisma.activityRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
        }
        update: {
          args: Prisma.activityRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.activityRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.activityRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.activityRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.activityRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
        }
        aggregate: {
          args: Prisma.ActivityRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActivityRegistration>
        }
        groupBy: {
          args: Prisma.activityRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.activityRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityRegistrationCountAggregateOutputType> | number
        }
      }
    }
    badge: {
      payload: Prisma.$badgePayload<ExtArgs>
      fields: Prisma.badgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.badgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.badgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>
        }
        findFirst: {
          args: Prisma.badgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.badgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>
        }
        findMany: {
          args: Prisma.badgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>[]
        }
        create: {
          args: Prisma.badgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>
        }
        createMany: {
          args: Prisma.badgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.badgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>[]
        }
        delete: {
          args: Prisma.badgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>
        }
        update: {
          args: Prisma.badgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>
        }
        deleteMany: {
          args: Prisma.badgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.badgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.badgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>[]
        }
        upsert: {
          args: Prisma.badgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$badgePayload>
        }
        aggregate: {
          args: Prisma.BadgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBadge>
        }
        groupBy: {
          args: Prisma.badgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BadgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.badgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BadgeCountAggregateOutputType> | number
        }
      }
    }
    blockedContact: {
      payload: Prisma.$blockedContactPayload<ExtArgs>
      fields: Prisma.blockedContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.blockedContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.blockedContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>
        }
        findFirst: {
          args: Prisma.blockedContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.blockedContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>
        }
        findMany: {
          args: Prisma.blockedContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>[]
        }
        create: {
          args: Prisma.blockedContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>
        }
        createMany: {
          args: Prisma.blockedContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.blockedContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>[]
        }
        delete: {
          args: Prisma.blockedContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>
        }
        update: {
          args: Prisma.blockedContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>
        }
        deleteMany: {
          args: Prisma.blockedContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.blockedContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.blockedContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>[]
        }
        upsert: {
          args: Prisma.blockedContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$blockedContactPayload>
        }
        aggregate: {
          args: Prisma.BlockedContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBlockedContact>
        }
        groupBy: {
          args: Prisma.blockedContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlockedContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.blockedContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlockedContactCountAggregateOutputType> | number
        }
      }
    }
    category: {
      payload: Prisma.$categoryPayload<ExtArgs>
      fields: Prisma.categoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.categoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>
        }
        findFirst: {
          args: Prisma.categoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>
        }
        findMany: {
          args: Prisma.categoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>[]
        }
        create: {
          args: Prisma.categoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>
        }
        createMany: {
          args: Prisma.categoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.categoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>[]
        }
        delete: {
          args: Prisma.categoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>
        }
        update: {
          args: Prisma.categoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>
        }
        deleteMany: {
          args: Prisma.categoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.categoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.categoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>[]
        }
        upsert: {
          args: Prisma.categoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryPayload>
        }
        aggregate: {
          args: Prisma.CategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategory>
        }
        groupBy: {
          args: Prisma.categoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.categoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryCountAggregateOutputType> | number
        }
      }
    }
    categoryChapter: {
      payload: Prisma.$categoryChapterPayload<ExtArgs>
      fields: Prisma.categoryChapterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.categoryChapterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.categoryChapterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>
        }
        findFirst: {
          args: Prisma.categoryChapterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.categoryChapterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>
        }
        findMany: {
          args: Prisma.categoryChapterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>[]
        }
        create: {
          args: Prisma.categoryChapterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>
        }
        createMany: {
          args: Prisma.categoryChapterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.categoryChapterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>[]
        }
        delete: {
          args: Prisma.categoryChapterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>
        }
        update: {
          args: Prisma.categoryChapterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>
        }
        deleteMany: {
          args: Prisma.categoryChapterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.categoryChapterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.categoryChapterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>[]
        }
        upsert: {
          args: Prisma.categoryChapterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryChapterPayload>
        }
        aggregate: {
          args: Prisma.CategoryChapterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategoryChapter>
        }
        groupBy: {
          args: Prisma.categoryChapterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryChapterGroupByOutputType>[]
        }
        count: {
          args: Prisma.categoryChapterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryChapterCountAggregateOutputType> | number
        }
      }
    }
    categoryType: {
      payload: Prisma.$categoryTypePayload<ExtArgs>
      fields: Prisma.categoryTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.categoryTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.categoryTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>
        }
        findFirst: {
          args: Prisma.categoryTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.categoryTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>
        }
        findMany: {
          args: Prisma.categoryTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>[]
        }
        create: {
          args: Prisma.categoryTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>
        }
        createMany: {
          args: Prisma.categoryTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.categoryTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>[]
        }
        delete: {
          args: Prisma.categoryTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>
        }
        update: {
          args: Prisma.categoryTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>
        }
        deleteMany: {
          args: Prisma.categoryTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.categoryTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.categoryTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>[]
        }
        upsert: {
          args: Prisma.categoryTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categoryTypePayload>
        }
        aggregate: {
          args: Prisma.CategoryTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategoryType>
        }
        groupBy: {
          args: Prisma.categoryTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.categoryTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryTypeCountAggregateOutputType> | number
        }
      }
    }
    cognitiveExercise: {
      payload: Prisma.$cognitiveExercisePayload<ExtArgs>
      fields: Prisma.cognitiveExerciseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.cognitiveExerciseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.cognitiveExerciseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
        }
        findFirst: {
          args: Prisma.cognitiveExerciseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.cognitiveExerciseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
        }
        findMany: {
          args: Prisma.cognitiveExerciseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>[]
        }
        create: {
          args: Prisma.cognitiveExerciseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
        }
        createMany: {
          args: Prisma.cognitiveExerciseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.cognitiveExerciseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>[]
        }
        delete: {
          args: Prisma.cognitiveExerciseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
        }
        update: {
          args: Prisma.cognitiveExerciseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
        }
        deleteMany: {
          args: Prisma.cognitiveExerciseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.cognitiveExerciseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.cognitiveExerciseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>[]
        }
        upsert: {
          args: Prisma.cognitiveExerciseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
        }
        aggregate: {
          args: Prisma.CognitiveExerciseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCognitiveExercise>
        }
        groupBy: {
          args: Prisma.cognitiveExerciseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CognitiveExerciseGroupByOutputType>[]
        }
        count: {
          args: Prisma.cognitiveExerciseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CognitiveExerciseCountAggregateOutputType> | number
        }
      }
    }
    collaborativeProject: {
      payload: Prisma.$collaborativeProjectPayload<ExtArgs>
      fields: Prisma.collaborativeProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.collaborativeProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.collaborativeProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
        }
        findFirst: {
          args: Prisma.collaborativeProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.collaborativeProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
        }
        findMany: {
          args: Prisma.collaborativeProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>[]
        }
        create: {
          args: Prisma.collaborativeProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
        }
        createMany: {
          args: Prisma.collaborativeProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.collaborativeProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>[]
        }
        delete: {
          args: Prisma.collaborativeProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
        }
        update: {
          args: Prisma.collaborativeProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
        }
        deleteMany: {
          args: Prisma.collaborativeProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.collaborativeProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.collaborativeProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>[]
        }
        upsert: {
          args: Prisma.collaborativeProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
        }
        aggregate: {
          args: Prisma.CollaborativeProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCollaborativeProject>
        }
        groupBy: {
          args: Prisma.collaborativeProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollaborativeProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.collaborativeProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollaborativeProjectCountAggregateOutputType> | number
        }
      }
    }
    contactRequest: {
      payload: Prisma.$contactRequestPayload<ExtArgs>
      fields: Prisma.contactRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.contactRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.contactRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>
        }
        findFirst: {
          args: Prisma.contactRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.contactRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>
        }
        findMany: {
          args: Prisma.contactRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>[]
        }
        create: {
          args: Prisma.contactRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>
        }
        createMany: {
          args: Prisma.contactRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.contactRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>[]
        }
        delete: {
          args: Prisma.contactRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>
        }
        update: {
          args: Prisma.contactRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>
        }
        deleteMany: {
          args: Prisma.contactRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.contactRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.contactRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>[]
        }
        upsert: {
          args: Prisma.contactRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$contactRequestPayload>
        }
        aggregate: {
          args: Prisma.ContactRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContactRequest>
        }
        groupBy: {
          args: Prisma.contactRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.contactRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactRequestCountAggregateOutputType> | number
        }
      }
    }
    conversation: {
      payload: Prisma.$conversationPayload<ExtArgs>
      fields: Prisma.conversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.conversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.conversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>
        }
        findFirst: {
          args: Prisma.conversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.conversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>
        }
        findMany: {
          args: Prisma.conversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>[]
        }
        create: {
          args: Prisma.conversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>
        }
        createMany: {
          args: Prisma.conversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.conversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>[]
        }
        delete: {
          args: Prisma.conversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>
        }
        update: {
          args: Prisma.conversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>
        }
        deleteMany: {
          args: Prisma.conversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.conversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.conversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>[]
        }
        upsert: {
          args: Prisma.conversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationPayload>
        }
        aggregate: {
          args: Prisma.ConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversation>
        }
        groupBy: {
          args: Prisma.conversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.conversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationCountAggregateOutputType> | number
        }
      }
    }
    conversationParticipant: {
      payload: Prisma.$conversationParticipantPayload<ExtArgs>
      fields: Prisma.conversationParticipantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.conversationParticipantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.conversationParticipantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
        }
        findFirst: {
          args: Prisma.conversationParticipantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.conversationParticipantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
        }
        findMany: {
          args: Prisma.conversationParticipantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>[]
        }
        create: {
          args: Prisma.conversationParticipantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
        }
        createMany: {
          args: Prisma.conversationParticipantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.conversationParticipantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>[]
        }
        delete: {
          args: Prisma.conversationParticipantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
        }
        update: {
          args: Prisma.conversationParticipantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
        }
        deleteMany: {
          args: Prisma.conversationParticipantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.conversationParticipantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.conversationParticipantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>[]
        }
        upsert: {
          args: Prisma.conversationParticipantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
        }
        aggregate: {
          args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversationParticipant>
        }
        groupBy: {
          args: Prisma.conversationParticipantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationParticipantGroupByOutputType>[]
        }
        count: {
          args: Prisma.conversationParticipantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationParticipantCountAggregateOutputType> | number
        }
      }
    }
    exerciseProgram: {
      payload: Prisma.$exerciseProgramPayload<ExtArgs>
      fields: Prisma.exerciseProgramFieldRefs
      operations: {
        findUnique: {
          args: Prisma.exerciseProgramFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.exerciseProgramFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
        }
        findFirst: {
          args: Prisma.exerciseProgramFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.exerciseProgramFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
        }
        findMany: {
          args: Prisma.exerciseProgramFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>[]
        }
        create: {
          args: Prisma.exerciseProgramCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
        }
        createMany: {
          args: Prisma.exerciseProgramCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.exerciseProgramCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>[]
        }
        delete: {
          args: Prisma.exerciseProgramDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
        }
        update: {
          args: Prisma.exerciseProgramUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
        }
        deleteMany: {
          args: Prisma.exerciseProgramDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.exerciseProgramUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.exerciseProgramUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>[]
        }
        upsert: {
          args: Prisma.exerciseProgramUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
        }
        aggregate: {
          args: Prisma.ExerciseProgramAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExerciseProgram>
        }
        groupBy: {
          args: Prisma.exerciseProgramGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExerciseProgramGroupByOutputType>[]
        }
        count: {
          args: Prisma.exerciseProgramCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExerciseProgramCountAggregateOutputType> | number
        }
      }
    }
    forumMessage: {
      payload: Prisma.$forumMessagePayload<ExtArgs>
      fields: Prisma.forumMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.forumMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.forumMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>
        }
        findFirst: {
          args: Prisma.forumMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.forumMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>
        }
        findMany: {
          args: Prisma.forumMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>[]
        }
        create: {
          args: Prisma.forumMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>
        }
        createMany: {
          args: Prisma.forumMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.forumMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>[]
        }
        delete: {
          args: Prisma.forumMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>
        }
        update: {
          args: Prisma.forumMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>
        }
        deleteMany: {
          args: Prisma.forumMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.forumMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.forumMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>[]
        }
        upsert: {
          args: Prisma.forumMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumMessagePayload>
        }
        aggregate: {
          args: Prisma.ForumMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForumMessage>
        }
        groupBy: {
          args: Prisma.forumMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.forumMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumMessageCountAggregateOutputType> | number
        }
      }
    }
    forumSection: {
      payload: Prisma.$forumSectionPayload<ExtArgs>
      fields: Prisma.forumSectionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.forumSectionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.forumSectionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>
        }
        findFirst: {
          args: Prisma.forumSectionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.forumSectionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>
        }
        findMany: {
          args: Prisma.forumSectionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>[]
        }
        create: {
          args: Prisma.forumSectionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>
        }
        createMany: {
          args: Prisma.forumSectionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.forumSectionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>[]
        }
        delete: {
          args: Prisma.forumSectionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>
        }
        update: {
          args: Prisma.forumSectionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>
        }
        deleteMany: {
          args: Prisma.forumSectionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.forumSectionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.forumSectionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>[]
        }
        upsert: {
          args: Prisma.forumSectionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumSectionPayload>
        }
        aggregate: {
          args: Prisma.ForumSectionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForumSection>
        }
        groupBy: {
          args: Prisma.forumSectionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumSectionGroupByOutputType>[]
        }
        count: {
          args: Prisma.forumSectionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumSectionCountAggregateOutputType> | number
        }
      }
    }
    forumTopic: {
      payload: Prisma.$forumTopicPayload<ExtArgs>
      fields: Prisma.forumTopicFieldRefs
      operations: {
        findUnique: {
          args: Prisma.forumTopicFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.forumTopicFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>
        }
        findFirst: {
          args: Prisma.forumTopicFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.forumTopicFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>
        }
        findMany: {
          args: Prisma.forumTopicFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>[]
        }
        create: {
          args: Prisma.forumTopicCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>
        }
        createMany: {
          args: Prisma.forumTopicCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.forumTopicCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>[]
        }
        delete: {
          args: Prisma.forumTopicDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>
        }
        update: {
          args: Prisma.forumTopicUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>
        }
        deleteMany: {
          args: Prisma.forumTopicDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.forumTopicUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.forumTopicUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>[]
        }
        upsert: {
          args: Prisma.forumTopicUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$forumTopicPayload>
        }
        aggregate: {
          args: Prisma.ForumTopicAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForumTopic>
        }
        groupBy: {
          args: Prisma.forumTopicGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumTopicGroupByOutputType>[]
        }
        count: {
          args: Prisma.forumTopicCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumTopicCountAggregateOutputType> | number
        }
      }
    }
    healthIndicator: {
      payload: Prisma.$healthIndicatorPayload<ExtArgs>
      fields: Prisma.healthIndicatorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.healthIndicatorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.healthIndicatorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
        }
        findFirst: {
          args: Prisma.healthIndicatorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.healthIndicatorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
        }
        findMany: {
          args: Prisma.healthIndicatorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>[]
        }
        create: {
          args: Prisma.healthIndicatorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
        }
        createMany: {
          args: Prisma.healthIndicatorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.healthIndicatorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>[]
        }
        delete: {
          args: Prisma.healthIndicatorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
        }
        update: {
          args: Prisma.healthIndicatorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
        }
        deleteMany: {
          args: Prisma.healthIndicatorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.healthIndicatorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.healthIndicatorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>[]
        }
        upsert: {
          args: Prisma.healthIndicatorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
        }
        aggregate: {
          args: Prisma.HealthIndicatorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHealthIndicator>
        }
        groupBy: {
          args: Prisma.healthIndicatorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HealthIndicatorGroupByOutputType>[]
        }
        count: {
          args: Prisma.healthIndicatorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HealthIndicatorCountAggregateOutputType> | number
        }
      }
    }
    helpOffer: {
      payload: Prisma.$helpOfferPayload<ExtArgs>
      fields: Prisma.helpOfferFieldRefs
      operations: {
        findUnique: {
          args: Prisma.helpOfferFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.helpOfferFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>
        }
        findFirst: {
          args: Prisma.helpOfferFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.helpOfferFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>
        }
        findMany: {
          args: Prisma.helpOfferFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>[]
        }
        create: {
          args: Prisma.helpOfferCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>
        }
        createMany: {
          args: Prisma.helpOfferCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.helpOfferCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>[]
        }
        delete: {
          args: Prisma.helpOfferDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>
        }
        update: {
          args: Prisma.helpOfferUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>
        }
        deleteMany: {
          args: Prisma.helpOfferDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.helpOfferUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.helpOfferUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>[]
        }
        upsert: {
          args: Prisma.helpOfferUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpOfferPayload>
        }
        aggregate: {
          args: Prisma.HelpOfferAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHelpOffer>
        }
        groupBy: {
          args: Prisma.helpOfferGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HelpOfferGroupByOutputType>[]
        }
        count: {
          args: Prisma.helpOfferCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HelpOfferCountAggregateOutputType> | number
        }
      }
    }
    helpRequest: {
      payload: Prisma.$helpRequestPayload<ExtArgs>
      fields: Prisma.helpRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.helpRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.helpRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>
        }
        findFirst: {
          args: Prisma.helpRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.helpRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>
        }
        findMany: {
          args: Prisma.helpRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>[]
        }
        create: {
          args: Prisma.helpRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>
        }
        createMany: {
          args: Prisma.helpRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.helpRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>[]
        }
        delete: {
          args: Prisma.helpRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>
        }
        update: {
          args: Prisma.helpRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>
        }
        deleteMany: {
          args: Prisma.helpRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.helpRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.helpRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>[]
        }
        upsert: {
          args: Prisma.helpRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$helpRequestPayload>
        }
        aggregate: {
          args: Prisma.HelpRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHelpRequest>
        }
        groupBy: {
          args: Prisma.helpRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HelpRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.helpRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HelpRequestCountAggregateOutputType> | number
        }
      }
    }
    interest: {
      payload: Prisma.$interestPayload<ExtArgs>
      fields: Prisma.interestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.interestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.interestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>
        }
        findFirst: {
          args: Prisma.interestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.interestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>
        }
        findMany: {
          args: Prisma.interestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>[]
        }
        create: {
          args: Prisma.interestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>
        }
        createMany: {
          args: Prisma.interestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.interestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>[]
        }
        delete: {
          args: Prisma.interestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>
        }
        update: {
          args: Prisma.interestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>
        }
        deleteMany: {
          args: Prisma.interestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.interestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.interestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>[]
        }
        upsert: {
          args: Prisma.interestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$interestPayload>
        }
        aggregate: {
          args: Prisma.InterestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInterest>
        }
        groupBy: {
          args: Prisma.interestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InterestGroupByOutputType>[]
        }
        count: {
          args: Prisma.interestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InterestCountAggregateOutputType> | number
        }
      }
    }
    localService: {
      payload: Prisma.$localServicePayload<ExtArgs>
      fields: Prisma.localServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.localServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.localServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>
        }
        findFirst: {
          args: Prisma.localServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.localServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>
        }
        findMany: {
          args: Prisma.localServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>[]
        }
        create: {
          args: Prisma.localServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>
        }
        createMany: {
          args: Prisma.localServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.localServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>[]
        }
        delete: {
          args: Prisma.localServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>
        }
        update: {
          args: Prisma.localServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>
        }
        deleteMany: {
          args: Prisma.localServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.localServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.localServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>[]
        }
        upsert: {
          args: Prisma.localServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$localServicePayload>
        }
        aggregate: {
          args: Prisma.LocalServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLocalService>
        }
        groupBy: {
          args: Prisma.localServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocalServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.localServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocalServiceCountAggregateOutputType> | number
        }
      }
    }
    medicationReminder: {
      payload: Prisma.$medicationReminderPayload<ExtArgs>
      fields: Prisma.medicationReminderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.medicationReminderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.medicationReminderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>
        }
        findFirst: {
          args: Prisma.medicationReminderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.medicationReminderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>
        }
        findMany: {
          args: Prisma.medicationReminderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>[]
        }
        create: {
          args: Prisma.medicationReminderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>
        }
        createMany: {
          args: Prisma.medicationReminderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.medicationReminderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>[]
        }
        delete: {
          args: Prisma.medicationReminderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>
        }
        update: {
          args: Prisma.medicationReminderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>
        }
        deleteMany: {
          args: Prisma.medicationReminderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.medicationReminderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.medicationReminderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>[]
        }
        upsert: {
          args: Prisma.medicationReminderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$medicationReminderPayload>
        }
        aggregate: {
          args: Prisma.MedicationReminderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedicationReminder>
        }
        groupBy: {
          args: Prisma.medicationReminderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MedicationReminderGroupByOutputType>[]
        }
        count: {
          args: Prisma.medicationReminderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MedicationReminderCountAggregateOutputType> | number
        }
      }
    }
    menuItem: {
      payload: Prisma.$menuItemPayload<ExtArgs>
      fields: Prisma.menuItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.menuItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.menuItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>
        }
        findFirst: {
          args: Prisma.menuItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.menuItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>
        }
        findMany: {
          args: Prisma.menuItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>[]
        }
        create: {
          args: Prisma.menuItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>
        }
        createMany: {
          args: Prisma.menuItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.menuItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>[]
        }
        delete: {
          args: Prisma.menuItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>
        }
        update: {
          args: Prisma.menuItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>
        }
        deleteMany: {
          args: Prisma.menuItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.menuItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.menuItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>[]
        }
        upsert: {
          args: Prisma.menuItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$menuItemPayload>
        }
        aggregate: {
          args: Prisma.MenuItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMenuItem>
        }
        groupBy: {
          args: Prisma.menuItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MenuItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.menuItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MenuItemCountAggregateOutputType> | number
        }
      }
    }
    message: {
      payload: Prisma.$messagePayload<ExtArgs>
      fields: Prisma.messageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.messageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>
        }
        findFirst: {
          args: Prisma.messageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>
        }
        findMany: {
          args: Prisma.messageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>[]
        }
        create: {
          args: Prisma.messageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>
        }
        createMany: {
          args: Prisma.messageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.messageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>[]
        }
        delete: {
          args: Prisma.messageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>
        }
        update: {
          args: Prisma.messageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>
        }
        deleteMany: {
          args: Prisma.messageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.messageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.messageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>[]
        }
        upsert: {
          args: Prisma.messageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$messagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.messageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.messageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    mood: {
      payload: Prisma.$moodPayload<ExtArgs>
      fields: Prisma.moodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.moodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.moodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>
        }
        findFirst: {
          args: Prisma.moodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.moodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>
        }
        findMany: {
          args: Prisma.moodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>[]
        }
        create: {
          args: Prisma.moodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>
        }
        createMany: {
          args: Prisma.moodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.moodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>[]
        }
        delete: {
          args: Prisma.moodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>
        }
        update: {
          args: Prisma.moodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>
        }
        deleteMany: {
          args: Prisma.moodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.moodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.moodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>[]
        }
        upsert: {
          args: Prisma.moodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$moodPayload>
        }
        aggregate: {
          args: Prisma.MoodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMood>
        }
        groupBy: {
          args: Prisma.moodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MoodGroupByOutputType>[]
        }
        count: {
          args: Prisma.moodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MoodCountAggregateOutputType> | number
        }
      }
    }
    municipalEvent: {
      payload: Prisma.$municipalEventPayload<ExtArgs>
      fields: Prisma.municipalEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.municipalEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.municipalEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>
        }
        findFirst: {
          args: Prisma.municipalEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.municipalEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>
        }
        findMany: {
          args: Prisma.municipalEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>[]
        }
        create: {
          args: Prisma.municipalEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>
        }
        createMany: {
          args: Prisma.municipalEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.municipalEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>[]
        }
        delete: {
          args: Prisma.municipalEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>
        }
        update: {
          args: Prisma.municipalEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>
        }
        deleteMany: {
          args: Prisma.municipalEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.municipalEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.municipalEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>[]
        }
        upsert: {
          args: Prisma.municipalEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$municipalEventPayload>
        }
        aggregate: {
          args: Prisma.MunicipalEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMunicipalEvent>
        }
        groupBy: {
          args: Prisma.municipalEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MunicipalEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.municipalEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MunicipalEventCountAggregateOutputType> | number
        }
      }
    }
    notification: {
      payload: Prisma.$notificationPayload<ExtArgs>
      fields: Prisma.notificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.notificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>
        }
        findFirst: {
          args: Prisma.notificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>
        }
        findMany: {
          args: Prisma.notificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>[]
        }
        create: {
          args: Prisma.notificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>
        }
        createMany: {
          args: Prisma.notificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.notificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>[]
        }
        delete: {
          args: Prisma.notificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>
        }
        update: {
          args: Prisma.notificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>
        }
        deleteMany: {
          args: Prisma.notificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.notificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.notificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>[]
        }
        upsert: {
          args: Prisma.notificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.notificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.notificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    notificationPreferences: {
      payload: Prisma.$notificationPreferencesPayload<ExtArgs>
      fields: Prisma.notificationPreferencesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.notificationPreferencesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.notificationPreferencesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
        }
        findFirst: {
          args: Prisma.notificationPreferencesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.notificationPreferencesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
        }
        findMany: {
          args: Prisma.notificationPreferencesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>[]
        }
        create: {
          args: Prisma.notificationPreferencesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
        }
        createMany: {
          args: Prisma.notificationPreferencesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.notificationPreferencesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>[]
        }
        delete: {
          args: Prisma.notificationPreferencesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
        }
        update: {
          args: Prisma.notificationPreferencesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
        }
        deleteMany: {
          args: Prisma.notificationPreferencesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.notificationPreferencesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.notificationPreferencesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>[]
        }
        upsert: {
          args: Prisma.notificationPreferencesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
        }
        aggregate: {
          args: Prisma.NotificationPreferencesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationPreferences>
        }
        groupBy: {
          args: Prisma.notificationPreferencesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferencesGroupByOutputType>[]
        }
        count: {
          args: Prisma.notificationPreferencesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferencesCountAggregateOutputType> | number
        }
      }
    }
    nutritionalAdvice: {
      payload: Prisma.$nutritionalAdvicePayload<ExtArgs>
      fields: Prisma.nutritionalAdviceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.nutritionalAdviceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.nutritionalAdviceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
        }
        findFirst: {
          args: Prisma.nutritionalAdviceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.nutritionalAdviceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
        }
        findMany: {
          args: Prisma.nutritionalAdviceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>[]
        }
        create: {
          args: Prisma.nutritionalAdviceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
        }
        createMany: {
          args: Prisma.nutritionalAdviceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.nutritionalAdviceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>[]
        }
        delete: {
          args: Prisma.nutritionalAdviceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
        }
        update: {
          args: Prisma.nutritionalAdviceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
        }
        deleteMany: {
          args: Prisma.nutritionalAdviceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.nutritionalAdviceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.nutritionalAdviceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>[]
        }
        upsert: {
          args: Prisma.nutritionalAdviceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
        }
        aggregate: {
          args: Prisma.NutritionalAdviceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNutritionalAdvice>
        }
        groupBy: {
          args: Prisma.nutritionalAdviceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NutritionalAdviceGroupByOutputType>[]
        }
        count: {
          args: Prisma.nutritionalAdviceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NutritionalAdviceCountAggregateOutputType> | number
        }
      }
    }
    projectMember: {
      payload: Prisma.$projectMemberPayload<ExtArgs>
      fields: Prisma.projectMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.projectMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.projectMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>
        }
        findFirst: {
          args: Prisma.projectMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.projectMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>
        }
        findMany: {
          args: Prisma.projectMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>[]
        }
        create: {
          args: Prisma.projectMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>
        }
        createMany: {
          args: Prisma.projectMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.projectMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>[]
        }
        delete: {
          args: Prisma.projectMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>
        }
        update: {
          args: Prisma.projectMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>
        }
        deleteMany: {
          args: Prisma.projectMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.projectMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.projectMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>[]
        }
        upsert: {
          args: Prisma.projectMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectMemberPayload>
        }
        aggregate: {
          args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectMember>
        }
        groupBy: {
          args: Prisma.projectMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.projectMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectMemberCountAggregateOutputType> | number
        }
      }
    }
    projectTask: {
      payload: Prisma.$projectTaskPayload<ExtArgs>
      fields: Prisma.projectTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.projectTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.projectTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>
        }
        findFirst: {
          args: Prisma.projectTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.projectTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>
        }
        findMany: {
          args: Prisma.projectTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>[]
        }
        create: {
          args: Prisma.projectTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>
        }
        createMany: {
          args: Prisma.projectTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.projectTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>[]
        }
        delete: {
          args: Prisma.projectTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>
        }
        update: {
          args: Prisma.projectTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>
        }
        deleteMany: {
          args: Prisma.projectTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.projectTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.projectTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>[]
        }
        upsert: {
          args: Prisma.projectTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$projectTaskPayload>
        }
        aggregate: {
          args: Prisma.ProjectTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectTask>
        }
        groupBy: {
          args: Prisma.projectTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.projectTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectTaskCountAggregateOutputType> | number
        }
      }
    }
    resource: {
      payload: Prisma.$resourcePayload<ExtArgs>
      fields: Prisma.resourceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.resourceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.resourceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>
        }
        findFirst: {
          args: Prisma.resourceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.resourceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>
        }
        findMany: {
          args: Prisma.resourceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>[]
        }
        create: {
          args: Prisma.resourceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>
        }
        createMany: {
          args: Prisma.resourceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.resourceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>[]
        }
        delete: {
          args: Prisma.resourceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>
        }
        update: {
          args: Prisma.resourceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>
        }
        deleteMany: {
          args: Prisma.resourceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.resourceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.resourceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>[]
        }
        upsert: {
          args: Prisma.resourceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$resourcePayload>
        }
        aggregate: {
          args: Prisma.ResourceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateResource>
        }
        groupBy: {
          args: Prisma.resourceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ResourceGroupByOutputType>[]
        }
        count: {
          args: Prisma.resourceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ResourceCountAggregateOutputType> | number
        }
      }
    }
    satisfactionSurvey: {
      payload: Prisma.$satisfactionSurveyPayload<ExtArgs>
      fields: Prisma.satisfactionSurveyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.satisfactionSurveyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.satisfactionSurveyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
        }
        findFirst: {
          args: Prisma.satisfactionSurveyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.satisfactionSurveyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
        }
        findMany: {
          args: Prisma.satisfactionSurveyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>[]
        }
        create: {
          args: Prisma.satisfactionSurveyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
        }
        createMany: {
          args: Prisma.satisfactionSurveyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.satisfactionSurveyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>[]
        }
        delete: {
          args: Prisma.satisfactionSurveyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
        }
        update: {
          args: Prisma.satisfactionSurveyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
        }
        deleteMany: {
          args: Prisma.satisfactionSurveyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.satisfactionSurveyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.satisfactionSurveyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>[]
        }
        upsert: {
          args: Prisma.satisfactionSurveyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
        }
        aggregate: {
          args: Prisma.SatisfactionSurveyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSatisfactionSurvey>
        }
        groupBy: {
          args: Prisma.satisfactionSurveyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SatisfactionSurveyGroupByOutputType>[]
        }
        count: {
          args: Prisma.satisfactionSurveyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SatisfactionSurveyCountAggregateOutputType> | number
        }
      }
    }
    serviceCompleted: {
      payload: Prisma.$serviceCompletedPayload<ExtArgs>
      fields: Prisma.serviceCompletedFieldRefs
      operations: {
        findUnique: {
          args: Prisma.serviceCompletedFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.serviceCompletedFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
        }
        findFirst: {
          args: Prisma.serviceCompletedFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.serviceCompletedFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
        }
        findMany: {
          args: Prisma.serviceCompletedFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>[]
        }
        create: {
          args: Prisma.serviceCompletedCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
        }
        createMany: {
          args: Prisma.serviceCompletedCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.serviceCompletedCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>[]
        }
        delete: {
          args: Prisma.serviceCompletedDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
        }
        update: {
          args: Prisma.serviceCompletedUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
        }
        deleteMany: {
          args: Prisma.serviceCompletedDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.serviceCompletedUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.serviceCompletedUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>[]
        }
        upsert: {
          args: Prisma.serviceCompletedUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
        }
        aggregate: {
          args: Prisma.ServiceCompletedAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServiceCompleted>
        }
        groupBy: {
          args: Prisma.serviceCompletedGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceCompletedGroupByOutputType>[]
        }
        count: {
          args: Prisma.serviceCompletedCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceCompletedCountAggregateOutputType> | number
        }
      }
    }
    serviceRating: {
      payload: Prisma.$serviceRatingPayload<ExtArgs>
      fields: Prisma.serviceRatingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.serviceRatingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.serviceRatingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>
        }
        findFirst: {
          args: Prisma.serviceRatingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.serviceRatingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>
        }
        findMany: {
          args: Prisma.serviceRatingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>[]
        }
        create: {
          args: Prisma.serviceRatingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>
        }
        createMany: {
          args: Prisma.serviceRatingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.serviceRatingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>[]
        }
        delete: {
          args: Prisma.serviceRatingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>
        }
        update: {
          args: Prisma.serviceRatingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>
        }
        deleteMany: {
          args: Prisma.serviceRatingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.serviceRatingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.serviceRatingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>[]
        }
        upsert: {
          args: Prisma.serviceRatingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$serviceRatingPayload>
        }
        aggregate: {
          args: Prisma.ServiceRatingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServiceRating>
        }
        groupBy: {
          args: Prisma.serviceRatingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceRatingGroupByOutputType>[]
        }
        count: {
          args: Prisma.serviceRatingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceRatingCountAggregateOutputType> | number
        }
      }
    }
    session: {
      payload: Prisma.$sessionPayload<ExtArgs>
      fields: Prisma.sessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.sessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        findFirst: {
          args: Prisma.sessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        findMany: {
          args: Prisma.sessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]
        }
        create: {
          args: Prisma.sessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        createMany: {
          args: Prisma.sessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]
        }
        delete: {
          args: Prisma.sessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        update: {
          args: Prisma.sessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        deleteMany: {
          args: Prisma.sessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.sessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]
        }
        upsert: {
          args: Prisma.sessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.sessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.sessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    skill: {
      payload: Prisma.$skillPayload<ExtArgs>
      fields: Prisma.skillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.skillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.skillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>
        }
        findFirst: {
          args: Prisma.skillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.skillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>
        }
        findMany: {
          args: Prisma.skillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>[]
        }
        create: {
          args: Prisma.skillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>
        }
        createMany: {
          args: Prisma.skillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.skillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>[]
        }
        delete: {
          args: Prisma.skillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>
        }
        update: {
          args: Prisma.skillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>
        }
        deleteMany: {
          args: Prisma.skillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.skillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.skillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>[]
        }
        upsert: {
          args: Prisma.skillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$skillPayload>
        }
        aggregate: {
          args: Prisma.SkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSkill>
        }
        groupBy: {
          args: Prisma.skillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.skillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SkillCountAggregateOutputType> | number
        }
      }
    }
    surveyResponse: {
      payload: Prisma.$surveyResponsePayload<ExtArgs>
      fields: Prisma.surveyResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.surveyResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.surveyResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>
        }
        findFirst: {
          args: Prisma.surveyResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.surveyResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>
        }
        findMany: {
          args: Prisma.surveyResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>[]
        }
        create: {
          args: Prisma.surveyResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>
        }
        createMany: {
          args: Prisma.surveyResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.surveyResponseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>[]
        }
        delete: {
          args: Prisma.surveyResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>
        }
        update: {
          args: Prisma.surveyResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>
        }
        deleteMany: {
          args: Prisma.surveyResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.surveyResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.surveyResponseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>[]
        }
        upsert: {
          args: Prisma.surveyResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$surveyResponsePayload>
        }
        aggregate: {
          args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyResponse>
        }
        groupBy: {
          args: Prisma.surveyResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.surveyResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseCountAggregateOutputType> | number
        }
      }
    }
    trustCircle: {
      payload: Prisma.$trustCirclePayload<ExtArgs>
      fields: Prisma.trustCircleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trustCircleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trustCircleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>
        }
        findFirst: {
          args: Prisma.trustCircleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trustCircleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>
        }
        findMany: {
          args: Prisma.trustCircleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>[]
        }
        create: {
          args: Prisma.trustCircleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>
        }
        createMany: {
          args: Prisma.trustCircleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trustCircleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>[]
        }
        delete: {
          args: Prisma.trustCircleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>
        }
        update: {
          args: Prisma.trustCircleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>
        }
        deleteMany: {
          args: Prisma.trustCircleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trustCircleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trustCircleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>[]
        }
        upsert: {
          args: Prisma.trustCircleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustCirclePayload>
        }
        aggregate: {
          args: Prisma.TrustCircleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrustCircle>
        }
        groupBy: {
          args: Prisma.trustCircleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrustCircleGroupByOutputType>[]
        }
        count: {
          args: Prisma.trustCircleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrustCircleCountAggregateOutputType> | number
        }
      }
    }
    trustedContact: {
      payload: Prisma.$trustedContactPayload<ExtArgs>
      fields: Prisma.trustedContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trustedContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trustedContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>
        }
        findFirst: {
          args: Prisma.trustedContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trustedContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>
        }
        findMany: {
          args: Prisma.trustedContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>[]
        }
        create: {
          args: Prisma.trustedContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>
        }
        createMany: {
          args: Prisma.trustedContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trustedContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>[]
        }
        delete: {
          args: Prisma.trustedContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>
        }
        update: {
          args: Prisma.trustedContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>
        }
        deleteMany: {
          args: Prisma.trustedContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trustedContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trustedContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>[]
        }
        upsert: {
          args: Prisma.trustedContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trustedContactPayload>
        }
        aggregate: {
          args: Prisma.TrustedContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrustedContact>
        }
        groupBy: {
          args: Prisma.trustedContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrustedContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.trustedContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrustedContactCountAggregateOutputType> | number
        }
      }
    }
    urbanIssueReport: {
      payload: Prisma.$urbanIssueReportPayload<ExtArgs>
      fields: Prisma.urbanIssueReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.urbanIssueReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.urbanIssueReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
        }
        findFirst: {
          args: Prisma.urbanIssueReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.urbanIssueReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
        }
        findMany: {
          args: Prisma.urbanIssueReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>[]
        }
        create: {
          args: Prisma.urbanIssueReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
        }
        createMany: {
          args: Prisma.urbanIssueReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.urbanIssueReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>[]
        }
        delete: {
          args: Prisma.urbanIssueReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
        }
        update: {
          args: Prisma.urbanIssueReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
        }
        deleteMany: {
          args: Prisma.urbanIssueReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.urbanIssueReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.urbanIssueReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>[]
        }
        upsert: {
          args: Prisma.urbanIssueReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
        }
        aggregate: {
          args: Prisma.UrbanIssueReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUrbanIssueReport>
        }
        groupBy: {
          args: Prisma.urbanIssueReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UrbanIssueReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.urbanIssueReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UrbanIssueReportCountAggregateOutputType> | number
        }
      }
    }
    user: {
      payload: Prisma.$userPayload<ExtArgs>
      fields: Prisma.userFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        findFirst: {
          args: Prisma.userFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        findMany: {
          args: Prisma.userFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]
        }
        create: {
          args: Prisma.userCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        createMany: {
          args: Prisma.userCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]
        }
        delete: {
          args: Prisma.userDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        update: {
          args: Prisma.userUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        deleteMany: {
          args: Prisma.userDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]
        }
        upsert: {
          args: Prisma.userUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.userGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.userCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    userActivity: {
      payload: Prisma.$userActivityPayload<ExtArgs>
      fields: Prisma.userActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>
        }
        findFirst: {
          args: Prisma.userActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>
        }
        findMany: {
          args: Prisma.userActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>[]
        }
        create: {
          args: Prisma.userActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>
        }
        createMany: {
          args: Prisma.userActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>[]
        }
        delete: {
          args: Prisma.userActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>
        }
        update: {
          args: Prisma.userActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>
        }
        deleteMany: {
          args: Prisma.userActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>[]
        }
        upsert: {
          args: Prisma.userActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userActivityPayload>
        }
        aggregate: {
          args: Prisma.UserActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserActivity>
        }
        groupBy: {
          args: Prisma.userActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.userActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserActivityCountAggregateOutputType> | number
        }
      }
    }
    userBadge: {
      payload: Prisma.$userBadgePayload<ExtArgs>
      fields: Prisma.userBadgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userBadgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userBadgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>
        }
        findFirst: {
          args: Prisma.userBadgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userBadgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>
        }
        findMany: {
          args: Prisma.userBadgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>[]
        }
        create: {
          args: Prisma.userBadgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>
        }
        createMany: {
          args: Prisma.userBadgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userBadgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>[]
        }
        delete: {
          args: Prisma.userBadgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>
        }
        update: {
          args: Prisma.userBadgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>
        }
        deleteMany: {
          args: Prisma.userBadgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userBadgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userBadgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>[]
        }
        upsert: {
          args: Prisma.userBadgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userBadgePayload>
        }
        aggregate: {
          args: Prisma.UserBadgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserBadge>
        }
        groupBy: {
          args: Prisma.userBadgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBadgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.userBadgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBadgeCountAggregateOutputType> | number
        }
      }
    }
    userContacts: {
      payload: Prisma.$userContactsPayload<ExtArgs>
      fields: Prisma.userContactsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userContactsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userContactsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>
        }
        findFirst: {
          args: Prisma.userContactsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userContactsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>
        }
        findMany: {
          args: Prisma.userContactsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>[]
        }
        create: {
          args: Prisma.userContactsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>
        }
        createMany: {
          args: Prisma.userContactsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userContactsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>[]
        }
        delete: {
          args: Prisma.userContactsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>
        }
        update: {
          args: Prisma.userContactsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>
        }
        deleteMany: {
          args: Prisma.userContactsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userContactsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userContactsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>[]
        }
        upsert: {
          args: Prisma.userContactsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userContactsPayload>
        }
        aggregate: {
          args: Prisma.UserContactsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserContacts>
        }
        groupBy: {
          args: Prisma.userContactsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserContactsGroupByOutputType>[]
        }
        count: {
          args: Prisma.userContactsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserContactsCountAggregateOutputType> | number
        }
      }
    }
    userDevice: {
      payload: Prisma.$userDevicePayload<ExtArgs>
      fields: Prisma.userDeviceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userDeviceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userDeviceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>
        }
        findFirst: {
          args: Prisma.userDeviceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userDeviceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>
        }
        findMany: {
          args: Prisma.userDeviceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>[]
        }
        create: {
          args: Prisma.userDeviceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>
        }
        createMany: {
          args: Prisma.userDeviceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userDeviceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>[]
        }
        delete: {
          args: Prisma.userDeviceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>
        }
        update: {
          args: Prisma.userDeviceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>
        }
        deleteMany: {
          args: Prisma.userDeviceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userDeviceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userDeviceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>[]
        }
        upsert: {
          args: Prisma.userDeviceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userDevicePayload>
        }
        aggregate: {
          args: Prisma.UserDeviceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserDevice>
        }
        groupBy: {
          args: Prisma.userDeviceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDeviceGroupByOutputType>[]
        }
        count: {
          args: Prisma.userDeviceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDeviceCountAggregateOutputType> | number
        }
      }
    }
    userInterest: {
      payload: Prisma.$userInterestPayload<ExtArgs>
      fields: Prisma.userInterestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userInterestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userInterestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>
        }
        findFirst: {
          args: Prisma.userInterestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userInterestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>
        }
        findMany: {
          args: Prisma.userInterestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>[]
        }
        create: {
          args: Prisma.userInterestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>
        }
        createMany: {
          args: Prisma.userInterestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userInterestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>[]
        }
        delete: {
          args: Prisma.userInterestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>
        }
        update: {
          args: Prisma.userInterestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>
        }
        deleteMany: {
          args: Prisma.userInterestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userInterestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userInterestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>[]
        }
        upsert: {
          args: Prisma.userInterestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userInterestPayload>
        }
        aggregate: {
          args: Prisma.UserInterestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserInterest>
        }
        groupBy: {
          args: Prisma.userInterestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserInterestGroupByOutputType>[]
        }
        count: {
          args: Prisma.userInterestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserInterestCountAggregateOutputType> | number
        }
      }
    }
    userPreferences: {
      payload: Prisma.$userPreferencesPayload<ExtArgs>
      fields: Prisma.userPreferencesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userPreferencesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userPreferencesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>
        }
        findFirst: {
          args: Prisma.userPreferencesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userPreferencesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>
        }
        findMany: {
          args: Prisma.userPreferencesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>[]
        }
        create: {
          args: Prisma.userPreferencesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>
        }
        createMany: {
          args: Prisma.userPreferencesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userPreferencesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>[]
        }
        delete: {
          args: Prisma.userPreferencesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>
        }
        update: {
          args: Prisma.userPreferencesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>
        }
        deleteMany: {
          args: Prisma.userPreferencesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userPreferencesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userPreferencesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>[]
        }
        upsert: {
          args: Prisma.userPreferencesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPreferencesPayload>
        }
        aggregate: {
          args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPreferences>
        }
        groupBy: {
          args: Prisma.userPreferencesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPreferencesGroupByOutputType>[]
        }
        count: {
          args: Prisma.userPreferencesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPreferencesCountAggregateOutputType> | number
        }
      }
    }
    userRole: {
      payload: Prisma.$userRolePayload<ExtArgs>
      fields: Prisma.userRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>
        }
        findFirst: {
          args: Prisma.userRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>
        }
        findMany: {
          args: Prisma.userRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>[]
        }
        create: {
          args: Prisma.userRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>
        }
        createMany: {
          args: Prisma.userRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>[]
        }
        delete: {
          args: Prisma.userRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>
        }
        update: {
          args: Prisma.userRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>
        }
        deleteMany: {
          args: Prisma.userRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>[]
        }
        upsert: {
          args: Prisma.userRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userRolePayload>
        }
        aggregate: {
          args: Prisma.UserRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRole>
        }
        groupBy: {
          args: Prisma.userRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.userRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleCountAggregateOutputType> | number
        }
      }
    }
    userSkill: {
      payload: Prisma.$userSkillPayload<ExtArgs>
      fields: Prisma.userSkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userSkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userSkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>
        }
        findFirst: {
          args: Prisma.userSkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userSkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>
        }
        findMany: {
          args: Prisma.userSkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>[]
        }
        create: {
          args: Prisma.userSkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>
        }
        createMany: {
          args: Prisma.userSkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userSkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>[]
        }
        delete: {
          args: Prisma.userSkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>
        }
        update: {
          args: Prisma.userSkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>
        }
        deleteMany: {
          args: Prisma.userSkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userSkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userSkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>[]
        }
        upsert: {
          args: Prisma.userSkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userSkillPayload>
        }
        aggregate: {
          args: Prisma.UserSkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSkill>
        }
        groupBy: {
          args: Prisma.userSkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.userSkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSkillCountAggregateOutputType> | number
        }
      }
    }
    userStatistics: {
      payload: Prisma.$userStatisticsPayload<ExtArgs>
      fields: Prisma.userStatisticsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userStatisticsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userStatisticsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>
        }
        findFirst: {
          args: Prisma.userStatisticsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userStatisticsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>
        }
        findMany: {
          args: Prisma.userStatisticsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>[]
        }
        create: {
          args: Prisma.userStatisticsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>
        }
        createMany: {
          args: Prisma.userStatisticsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userStatisticsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>[]
        }
        delete: {
          args: Prisma.userStatisticsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>
        }
        update: {
          args: Prisma.userStatisticsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>
        }
        deleteMany: {
          args: Prisma.userStatisticsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userStatisticsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userStatisticsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>[]
        }
        upsert: {
          args: Prisma.userStatisticsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userStatisticsPayload>
        }
        aggregate: {
          args: Prisma.UserStatisticsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserStatistics>
        }
        groupBy: {
          args: Prisma.userStatisticsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserStatisticsGroupByOutputType>[]
        }
        count: {
          args: Prisma.userStatisticsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserStatisticsCountAggregateOutputType> | number
        }
      }
    }
    videoCall: {
      payload: Prisma.$videoCallPayload<ExtArgs>
      fields: Prisma.videoCallFieldRefs
      operations: {
        findUnique: {
          args: Prisma.videoCallFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.videoCallFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>
        }
        findFirst: {
          args: Prisma.videoCallFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.videoCallFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>
        }
        findMany: {
          args: Prisma.videoCallFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>[]
        }
        create: {
          args: Prisma.videoCallCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>
        }
        createMany: {
          args: Prisma.videoCallCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.videoCallCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>[]
        }
        delete: {
          args: Prisma.videoCallDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>
        }
        update: {
          args: Prisma.videoCallUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>
        }
        deleteMany: {
          args: Prisma.videoCallDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.videoCallUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.videoCallUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>[]
        }
        upsert: {
          args: Prisma.videoCallUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$videoCallPayload>
        }
        aggregate: {
          args: Prisma.VideoCallAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVideoCall>
        }
        groupBy: {
          args: Prisma.videoCallGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VideoCallGroupByOutputType>[]
        }
        count: {
          args: Prisma.videoCallCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VideoCallCountAggregateOutputType> | number
        }
      }
    }
    wellnessBadge: {
      payload: Prisma.$wellnessBadgePayload<ExtArgs>
      fields: Prisma.wellnessBadgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.wellnessBadgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.wellnessBadgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
        }
        findFirst: {
          args: Prisma.wellnessBadgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.wellnessBadgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
        }
        findMany: {
          args: Prisma.wellnessBadgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>[]
        }
        create: {
          args: Prisma.wellnessBadgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
        }
        createMany: {
          args: Prisma.wellnessBadgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.wellnessBadgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>[]
        }
        delete: {
          args: Prisma.wellnessBadgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
        }
        update: {
          args: Prisma.wellnessBadgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
        }
        deleteMany: {
          args: Prisma.wellnessBadgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.wellnessBadgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.wellnessBadgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>[]
        }
        upsert: {
          args: Prisma.wellnessBadgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
        }
        aggregate: {
          args: Prisma.WellnessBadgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWellnessBadge>
        }
        groupBy: {
          args: Prisma.wellnessBadgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WellnessBadgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.wellnessBadgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WellnessBadgeCountAggregateOutputType> | number
        }
      }
    }
    wellnessGoal: {
      payload: Prisma.$wellnessGoalPayload<ExtArgs>
      fields: Prisma.wellnessGoalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.wellnessGoalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.wellnessGoalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
        }
        findFirst: {
          args: Prisma.wellnessGoalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.wellnessGoalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
        }
        findMany: {
          args: Prisma.wellnessGoalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>[]
        }
        create: {
          args: Prisma.wellnessGoalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
        }
        createMany: {
          args: Prisma.wellnessGoalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.wellnessGoalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>[]
        }
        delete: {
          args: Prisma.wellnessGoalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
        }
        update: {
          args: Prisma.wellnessGoalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
        }
        deleteMany: {
          args: Prisma.wellnessGoalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.wellnessGoalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.wellnessGoalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>[]
        }
        upsert: {
          args: Prisma.wellnessGoalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
        }
        aggregate: {
          args: Prisma.WellnessGoalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWellnessGoal>
        }
        groupBy: {
          args: Prisma.wellnessGoalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WellnessGoalGroupByOutputType>[]
        }
        count: {
          args: Prisma.wellnessGoalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WellnessGoalCountAggregateOutputType> | number
        }
      }
    }
    wellnessGoalProgress: {
      payload: Prisma.$wellnessGoalProgressPayload<ExtArgs>
      fields: Prisma.wellnessGoalProgressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.wellnessGoalProgressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.wellnessGoalProgressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
        }
        findFirst: {
          args: Prisma.wellnessGoalProgressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.wellnessGoalProgressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
        }
        findMany: {
          args: Prisma.wellnessGoalProgressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>[]
        }
        create: {
          args: Prisma.wellnessGoalProgressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
        }
        createMany: {
          args: Prisma.wellnessGoalProgressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.wellnessGoalProgressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>[]
        }
        delete: {
          args: Prisma.wellnessGoalProgressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
        }
        update: {
          args: Prisma.wellnessGoalProgressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
        }
        deleteMany: {
          args: Prisma.wellnessGoalProgressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.wellnessGoalProgressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.wellnessGoalProgressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>[]
        }
        upsert: {
          args: Prisma.wellnessGoalProgressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
        }
        aggregate: {
          args: Prisma.WellnessGoalProgressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWellnessGoalProgress>
        }
        groupBy: {
          args: Prisma.wellnessGoalProgressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WellnessGoalProgressGroupByOutputType>[]
        }
        count: {
          args: Prisma.wellnessGoalProgressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WellnessGoalProgressCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ActivityScalarFieldEnum = {
  id: 'id',
  creatorId: 'creatorId',
  title: 'title',
  description: 'description',
  startDate: 'startDate',
  endDate: 'endDate',
  location: 'location',
  maxSpots: 'maxSpots',
  recurring: 'recurring',
  frequency: 'frequency',
  reducedMobilityAccess: 'reducedMobilityAccess',
  cost: 'cost',
  status: 'status',
  weatherRequirements: 'weatherRequirements',
  transportOptions: 'transportOptions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  difficultyLevel: 'difficultyLevel',
  categoryId: 'categoryId',
  latitude: 'latitude',
  longitude: 'longitude',
  estimatedDuration: 'estimatedDuration',
  image: 'image'
} as const

export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


export const ActivityLogScalarFieldEnum = {
  id: 'id',
  actionType: 'actionType',
  description: 'description',
  ipAddress: 'ipAddress',
  device: 'device',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId'
} as const

export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


export const ActivityRegistrationScalarFieldEnum = {
  activityId: 'activityId',
  userId: 'userId',
  registrationDate: 'registrationDate',
  status: 'status',
  attendanceConfirmed: 'attendanceConfirmed',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  id: 'id'
} as const

export type ActivityRegistrationScalarFieldEnum = (typeof ActivityRegistrationScalarFieldEnum)[keyof typeof ActivityRegistrationScalarFieldEnum]


export const BadgeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  icon: 'icon',
  level: 'level',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userBadgeId: 'userBadgeId',
  categoryId: 'categoryId',
  userId: 'userId'
} as const

export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


export const BlockedContactScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  contactId: 'contactId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  reason: 'reason'
} as const

export type BlockedContactScalarFieldEnum = (typeof BlockedContactScalarFieldEnum)[keyof typeof BlockedContactScalarFieldEnum]


export const CategoryScalarFieldEnum = {
  id: 'id',
  description: 'description',
  typeId: 'typeId',
  chapterId: 'chapterId',
  categoryName: 'categoryName',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


export const CategoryChapterScalarFieldEnum = {
  id: 'id',
  chapterId: 'chapterId',
  chapterName: 'chapterName',
  chapterDescription: 'chapterDescription',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CategoryChapterScalarFieldEnum = (typeof CategoryChapterScalarFieldEnum)[keyof typeof CategoryChapterScalarFieldEnum]


export const CategoryTypeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CategoryTypeScalarFieldEnum = (typeof CategoryTypeScalarFieldEnum)[keyof typeof CategoryTypeScalarFieldEnum]


export const CognitiveExerciseScalarFieldEnum = {
  id: 'id',
  name: 'name',
  durationMinutes: 'durationMinutes',
  description: 'description',
  image: 'image',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  difficultyLevel: 'difficultyLevel',
  categoryId: 'categoryId'
} as const

export type CognitiveExerciseScalarFieldEnum = (typeof CognitiveExerciseScalarFieldEnum)[keyof typeof CognitiveExerciseScalarFieldEnum]


export const CollaborativeProjectScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  creatorId: 'creatorId',
  creationDate: 'creationDate',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type CollaborativeProjectScalarFieldEnum = (typeof CollaborativeProjectScalarFieldEnum)[keyof typeof CollaborativeProjectScalarFieldEnum]


export const ContactRequestScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  contactId: 'contactId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  message: 'message',
  status: 'status'
} as const

export type ContactRequestScalarFieldEnum = (typeof ContactRequestScalarFieldEnum)[keyof typeof ContactRequestScalarFieldEnum]


export const ConversationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


export const ConversationParticipantScalarFieldEnum = {
  conversationId: 'conversationId',
  userId: 'userId',
  dateAdded: 'dateAdded',
  administrator: 'administrator',
  lastAccess: 'lastAccess',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  id: 'id'
} as const

export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


export const ExerciseProgramScalarFieldEnum = {
  id: 'id',
  name: 'name',
  adaptedForReducedMobility: 'adaptedForReducedMobility',
  durationMinutes: 'durationMinutes',
  description: 'description',
  videoLink: 'videoLink',
  image: 'image',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  difficultyLevel: 'difficultyLevel',
  categoryId: 'categoryId'
} as const

export type ExerciseProgramScalarFieldEnum = (typeof ExerciseProgramScalarFieldEnum)[keyof typeof ExerciseProgramScalarFieldEnum]


export const ForumMessageScalarFieldEnum = {
  id: 'id',
  topicId: 'topicId',
  authorId: 'authorId',
  content: 'content',
  solutionMessage: 'solutionMessage',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForumMessageScalarFieldEnum = (typeof ForumMessageScalarFieldEnum)[keyof typeof ForumMessageScalarFieldEnum]


export const ForumSectionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  authorId: 'authorId'
} as const

export type ForumSectionScalarFieldEnum = (typeof ForumSectionScalarFieldEnum)[keyof typeof ForumSectionScalarFieldEnum]


export const ForumTopicScalarFieldEnum = {
  id: 'id',
  authorId: 'authorId',
  title: 'title',
  pinned: 'pinned',
  status: 'status',
  views: 'views',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sectionId: 'sectionId',
  userId: 'userId'
} as const

export type ForumTopicScalarFieldEnum = (typeof ForumTopicScalarFieldEnum)[keyof typeof ForumTopicScalarFieldEnum]


export const HealthIndicatorScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  recordingDate: 'recordingDate',
  stepCount: 'stepCount',
  sleepDurationMinutes: 'sleepDurationMinutes',
  sleepQuality: 'sleepQuality',
  weight: 'weight',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  moodId: 'moodId'
} as const

export type HealthIndicatorScalarFieldEnum = (typeof HealthIndicatorScalarFieldEnum)[keyof typeof HealthIndicatorScalarFieldEnum]


export const HelpOfferScalarFieldEnum = {
  id: 'id',
  requestId: 'requestId',
  helperId: 'helperId',
  offerDate: 'offerDate',
  message: 'message',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HelpOfferScalarFieldEnum = (typeof HelpOfferScalarFieldEnum)[keyof typeof HelpOfferScalarFieldEnum]


export const HelpRequestScalarFieldEnum = {
  id: 'id',
  creatorId: 'creatorId',
  title: 'title',
  description: 'description',
  neededDate: 'neededDate',
  estimatedDuration: 'estimatedDuration',
  location: 'location',
  gpsCoordinates: 'gpsCoordinates',
  recurring: 'recurring',
  frequency: 'frequency',
  status: 'status',
  pointsOffered: 'pointsOffered',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type HelpRequestScalarFieldEnum = (typeof HelpRequestScalarFieldEnum)[keyof typeof HelpRequestScalarFieldEnum]


export const InterestScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InterestScalarFieldEnum = (typeof InterestScalarFieldEnum)[keyof typeof InterestScalarFieldEnum]


export const LocalServiceScalarFieldEnum = {
  id: 'id',
  name: 'name',
  address: 'address',
  gpsCoordinates: 'gpsCoordinates',
  phone: 'phone',
  website: 'website',
  description: 'description',
  hours: 'hours',
  seniorFriendly: 'seniorFriendly',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type LocalServiceScalarFieldEnum = (typeof LocalServiceScalarFieldEnum)[keyof typeof LocalServiceScalarFieldEnum]


export const MedicationReminderScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  medicationName: 'medicationName',
  dosage: 'dosage',
  morningReminderTime: 'morningReminderTime',
  noonReminderTime: 'noonReminderTime',
  eveningReminderTime: 'eveningReminderTime',
  nightReminderTime: 'nightReminderTime',
  daysOfWeek: 'daysOfWeek',
  instructions: 'instructions',
  active: 'active',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MedicationReminderScalarFieldEnum = (typeof MedicationReminderScalarFieldEnum)[keyof typeof MedicationReminderScalarFieldEnum]


export const MenuItemScalarFieldEnum = {
  id: 'id',
  label: 'label',
  key: 'key'
} as const

export type MenuItemScalarFieldEnum = (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  senderId: 'senderId',
  content: 'content',
  sendDate: 'sendDate',
  type: 'type',
  read: 'read',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const MoodScalarFieldEnum = {
  id: 'id',
  description: 'description',
  valence: 'valence',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  color: 'color',
  intensity: 'intensity',
  name: 'name'
} as const

export type MoodScalarFieldEnum = (typeof MoodScalarFieldEnum)[keyof typeof MoodScalarFieldEnum]


export const MunicipalEventScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  startDate: 'startDate',
  endDate: 'endDate',
  location: 'location',
  gpsCoordinates: 'gpsCoordinates',
  organizer: 'organizer',
  contact: 'contact',
  officialLink: 'officialLink',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MunicipalEventScalarFieldEnum = (typeof MunicipalEventScalarFieldEnum)[keyof typeof MunicipalEventScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  content: 'content',
  read: 'read',
  actionLink: 'actionLink',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const NotificationPreferencesScalarFieldEnum = {
  userId: 'userId',
  quietHoursStart: 'quietHoursStart',
  quietHoursEnd: 'quietHoursEnd',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  activityNotification: 'activityNotification',
  emailNotification: 'emailNotification',
  forumNotification: 'forumNotification',
  helpNotification: 'helpNotification',
  messageNotification: 'messageNotification',
  pushNotification: 'pushNotification',
  smsNotification: 'smsNotification'
} as const

export type NotificationPreferencesScalarFieldEnum = (typeof NotificationPreferencesScalarFieldEnum)[keyof typeof NotificationPreferencesScalarFieldEnum]


export const NutritionalAdviceScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  season: 'season',
  image: 'image',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type NutritionalAdviceScalarFieldEnum = (typeof NutritionalAdviceScalarFieldEnum)[keyof typeof NutritionalAdviceScalarFieldEnum]


export const ProjectMemberScalarFieldEnum = {
  projectId: 'projectId',
  userId: 'userId',
  role: 'role',
  joinDate: 'joinDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  id: 'id'
} as const

export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


export const ProjectTaskScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  title: 'title',
  description: 'description',
  creationDate: 'creationDate',
  dueDate: 'dueDate',
  status: 'status',
  assigneeId: 'assigneeId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectTaskScalarFieldEnum = (typeof ProjectTaskScalarFieldEnum)[keyof typeof ProjectTaskScalarFieldEnum]


export const ResourceScalarFieldEnum = {
  id: 'id',
  title: 'title',
  content: 'content',
  type: 'type',
  authorId: 'authorId',
  adminValidated: 'adminValidated',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


export const SatisfactionSurveyScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  startDate: 'startDate',
  endDate: 'endDate',
  active: 'active',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SatisfactionSurveyScalarFieldEnum = (typeof SatisfactionSurveyScalarFieldEnum)[keyof typeof SatisfactionSurveyScalarFieldEnum]


export const ServiceCompletedScalarFieldEnum = {
  id: 'id',
  requestId: 'requestId',
  helperId: 'helperId',
  completionDate: 'completionDate',
  actualDuration: 'actualDuration',
  creatorComment: 'creatorComment',
  helperComment: 'helperComment',
  creatorRating: 'creatorRating',
  helperRating: 'helperRating',
  pointsExchanged: 'pointsExchanged',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServiceCompletedScalarFieldEnum = (typeof ServiceCompletedScalarFieldEnum)[keyof typeof ServiceCompletedScalarFieldEnum]


export const ServiceRatingScalarFieldEnum = {
  serviceId: 'serviceId',
  userId: 'userId',
  rating: 'rating',
  comment: 'comment',
  ratingDate: 'ratingDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  id: 'id'
} as const

export type ServiceRatingScalarFieldEnum = (typeof ServiceRatingScalarFieldEnum)[keyof typeof ServiceRatingScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  refreshToken: 'refreshToken',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  expiresAt: 'expiresAt',
  userAgent: 'userAgent',
  ipAddress: 'ipAddress'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const SkillScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


export const SurveyResponseScalarFieldEnum = {
  surveyId: 'surveyId',
  userId: 'userId',
  responses: 'responses',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  id: 'id',
  responseDate: 'responseDate'
} as const

export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


export const TrustCircleScalarFieldEnum = {
  userId: 'userId',
  contactId: 'contactId',
  dateAdded: 'dateAdded',
  accessLevel: 'accessLevel',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  id: 'id'
} as const

export type TrustCircleScalarFieldEnum = (typeof TrustCircleScalarFieldEnum)[keyof typeof TrustCircleScalarFieldEnum]


export const TrustedContactScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  lastName: 'lastName',
  firstName: 'firstName',
  email: 'email',
  phone: 'phone',
  relationship: 'relationship',
  shareMedications: 'shareMedications',
  shareHealthIndicators: 'shareHealthIndicators',
  shareWellnessActivities: 'shareWellnessActivities',
  emergencyAlerts: 'emergencyAlerts',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TrustedContactScalarFieldEnum = (typeof TrustedContactScalarFieldEnum)[keyof typeof TrustedContactScalarFieldEnum]


export const UrbanIssueReportScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  description: 'description',
  address: 'address',
  gpsCoordinates: 'gpsCoordinates',
  reportDate: 'reportDate',
  status: 'status',
  cityReference: 'cityReference',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type UrbanIssueReportScalarFieldEnum = (typeof UrbanIssueReportScalarFieldEnum)[keyof typeof UrbanIssueReportScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  passwordHash: 'passwordHash',
  firstName: 'firstName',
  lastName: 'lastName',
  phone: 'phone',
  registrationDate: 'registrationDate',
  helpPoints: 'helpPoints',
  reducedMobility: 'reducedMobility',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  avatar: 'avatar',
  birthDate: 'birthDate',
  isAdmin: 'isAdmin',
  latitude: 'latitude',
  longitude: 'longitude',
  description: 'description',
  profession: 'profession',
  address: 'address',
  city: 'city',
  postalCode: 'postalCode'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const UserActivityScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  completionDate: 'completionDate',
  exerciseProgramId: 'exerciseProgramId',
  cognitiveExerciseId: 'cognitiveExerciseId',
  durationMinutes: 'durationMinutes',
  perceivedDifficultyLevel: 'perceivedDifficultyLevel',
  enjoymentLevel: 'enjoymentLevel',
  comment: 'comment',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserActivityScalarFieldEnum = (typeof UserActivityScalarFieldEnum)[keyof typeof UserActivityScalarFieldEnum]


export const UserBadgeScalarFieldEnum = {
  userId: 'userId',
  badgeId: 'badgeId',
  achievementDate: 'achievementDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


export const UserContactsScalarFieldEnum = {
  userId: 'userId',
  contactId: 'contactId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserContactsScalarFieldEnum = (typeof UserContactsScalarFieldEnum)[keyof typeof UserContactsScalarFieldEnum]


export const UserDeviceScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  deviceType: 'deviceType',
  deviceName: 'deviceName',
  operatingSystem: 'operatingSystem',
  notificationToken: 'notificationToken',
  lastConnection: 'lastConnection',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserDeviceScalarFieldEnum = (typeof UserDeviceScalarFieldEnum)[keyof typeof UserDeviceScalarFieldEnum]


export const UserInterestScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  interestId: 'interestId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserInterestScalarFieldEnum = (typeof UserInterestScalarFieldEnum)[keyof typeof UserInterestScalarFieldEnum]


export const UserPreferencesScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  emailUpdates: 'emailUpdates',
  smsUpdates: 'smsUpdates',
  fontSize: 'fontSize',
  highContrast: 'highContrast',
  dataSharing: 'dataSharing',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  frequencyDaily: 'frequencyDaily',
  frequencyInstant: 'frequencyInstant',
  messagesFromEverybody: 'messagesFromEverybody',
  messagesFromFriends: 'messagesFromFriends',
  messagesFromNoOne: 'messagesFromNoOne',
  statusVisibilityEverybody: 'statusVisibilityEverybody',
  statusVisibilityFriends: 'statusVisibilityFriends',
  statusVisibilityNoOne: 'statusVisibilityNoOne',
  notificationActivities: 'notificationActivities',
  notificationForum: 'notificationForum',
  notificationMessages: 'notificationMessages'
} as const

export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


export const UserRoleScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  role: 'role'
} as const

export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


export const UserSkillScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  skillId: 'skillId',
  level: 'level',
  updatedAt: 'updatedAt',
  createdAt: 'createdAt'
} as const

export type UserSkillScalarFieldEnum = (typeof UserSkillScalarFieldEnum)[keyof typeof UserSkillScalarFieldEnum]


export const UserStatisticsScalarFieldEnum = {
  userId: 'userId',
  servicesProvided: 'servicesProvided',
  servicesReceived: 'servicesReceived',
  activitiesParticipated: 'activitiesParticipated',
  activitiesOrganized: 'activitiesOrganized',
  forumMessages: 'forumMessages',
  totalHelpPoints: 'totalHelpPoints',
  networkSize: 'networkSize',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserStatisticsScalarFieldEnum = (typeof UserStatisticsScalarFieldEnum)[keyof typeof UserStatisticsScalarFieldEnum]


export const VideoCallScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  initiatorId: 'initiatorId',
  startDate: 'startDate',
  endDate: 'endDate',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VideoCallScalarFieldEnum = (typeof VideoCallScalarFieldEnum)[keyof typeof VideoCallScalarFieldEnum]


export const WellnessBadgeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  image: 'image',
  level: 'level',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type WellnessBadgeScalarFieldEnum = (typeof WellnessBadgeScalarFieldEnum)[keyof typeof WellnessBadgeScalarFieldEnum]


export const WellnessGoalScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  title: 'title',
  targetValue: 'targetValue',
  unit: 'unit',
  frequency: 'frequency',
  startDate: 'startDate',
  endDate: 'endDate',
  active: 'active',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type WellnessGoalScalarFieldEnum = (typeof WellnessGoalScalarFieldEnum)[keyof typeof WellnessGoalScalarFieldEnum]


export const WellnessGoalProgressScalarFieldEnum = {
  id: 'id',
  goalId: 'goalId',
  recordingDate: 'recordingDate',
  achievedValue: 'achievedValue',
  goalAchieved: 'goalAchieved',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WellnessGoalProgressScalarFieldEnum = (typeof WellnessGoalProgressScalarFieldEnum)[keyof typeof WellnessGoalProgressScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Valence'
 */
export type EnumValenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Valence'>
    


/**
 * Reference to a field of type 'Valence[]'
 */
export type ListEnumValenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Valence[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Role'
 */
export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


/**
 * Reference to a field of type 'Role[]'
 */
export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  activity?: Prisma.activityOmit
  activityLog?: Prisma.activityLogOmit
  activityRegistration?: Prisma.activityRegistrationOmit
  badge?: Prisma.badgeOmit
  blockedContact?: Prisma.blockedContactOmit
  category?: Prisma.categoryOmit
  categoryChapter?: Prisma.categoryChapterOmit
  categoryType?: Prisma.categoryTypeOmit
  cognitiveExercise?: Prisma.cognitiveExerciseOmit
  collaborativeProject?: Prisma.collaborativeProjectOmit
  contactRequest?: Prisma.contactRequestOmit
  conversation?: Prisma.conversationOmit
  conversationParticipant?: Prisma.conversationParticipantOmit
  exerciseProgram?: Prisma.exerciseProgramOmit
  forumMessage?: Prisma.forumMessageOmit
  forumSection?: Prisma.forumSectionOmit
  forumTopic?: Prisma.forumTopicOmit
  healthIndicator?: Prisma.healthIndicatorOmit
  helpOffer?: Prisma.helpOfferOmit
  helpRequest?: Prisma.helpRequestOmit
  interest?: Prisma.interestOmit
  localService?: Prisma.localServiceOmit
  medicationReminder?: Prisma.medicationReminderOmit
  menuItem?: Prisma.menuItemOmit
  message?: Prisma.messageOmit
  mood?: Prisma.moodOmit
  municipalEvent?: Prisma.municipalEventOmit
  notification?: Prisma.notificationOmit
  notificationPreferences?: Prisma.notificationPreferencesOmit
  nutritionalAdvice?: Prisma.nutritionalAdviceOmit
  projectMember?: Prisma.projectMemberOmit
  projectTask?: Prisma.projectTaskOmit
  resource?: Prisma.resourceOmit
  satisfactionSurvey?: Prisma.satisfactionSurveyOmit
  serviceCompleted?: Prisma.serviceCompletedOmit
  serviceRating?: Prisma.serviceRatingOmit
  session?: Prisma.sessionOmit
  skill?: Prisma.skillOmit
  surveyResponse?: Prisma.surveyResponseOmit
  trustCircle?: Prisma.trustCircleOmit
  trustedContact?: Prisma.trustedContactOmit
  urbanIssueReport?: Prisma.urbanIssueReportOmit
  user?: Prisma.userOmit
  userActivity?: Prisma.userActivityOmit
  userBadge?: Prisma.userBadgeOmit
  userContacts?: Prisma.userContactsOmit
  userDevice?: Prisma.userDeviceOmit
  userInterest?: Prisma.userInterestOmit
  userPreferences?: Prisma.userPreferencesOmit
  userRole?: Prisma.userRoleOmit
  userSkill?: Prisma.userSkillOmit
  userStatistics?: Prisma.userStatisticsOmit
  videoCall?: Prisma.videoCallOmit
  wellnessBadge?: Prisma.wellnessBadgeOmit
  wellnessGoal?: Prisma.wellnessGoalOmit
  wellnessGoalProgress?: Prisma.wellnessGoalProgressOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

