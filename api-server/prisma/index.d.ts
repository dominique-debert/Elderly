
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model activity
 * 
 */
export type activity = $Result.DefaultSelection<Prisma.$activityPayload>
/**
 * Model activityLog
 * 
 */
export type activityLog = $Result.DefaultSelection<Prisma.$activityLogPayload>
/**
 * Model activityRegistration
 * 
 */
export type activityRegistration = $Result.DefaultSelection<Prisma.$activityRegistrationPayload>
/**
 * Model badge
 * 
 */
export type badge = $Result.DefaultSelection<Prisma.$badgePayload>
/**
 * Model cognitiveExercise
 * 
 */
export type cognitiveExercise = $Result.DefaultSelection<Prisma.$cognitiveExercisePayload>
/**
 * Model collaborativeProject
 * 
 */
export type collaborativeProject = $Result.DefaultSelection<Prisma.$collaborativeProjectPayload>
/**
 * Model conversation
 * 
 */
export type conversation = $Result.DefaultSelection<Prisma.$conversationPayload>
/**
 * Model conversationParticipant
 * 
 */
export type conversationParticipant = $Result.DefaultSelection<Prisma.$conversationParticipantPayload>
/**
 * Model exerciseProgram
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type exerciseProgram = $Result.DefaultSelection<Prisma.$exerciseProgramPayload>
/**
 * Model forumCategory
 * 
 */
export type forumCategory = $Result.DefaultSelection<Prisma.$forumCategoryPayload>
/**
 * Model forumMessage
 * 
 */
export type forumMessage = $Result.DefaultSelection<Prisma.$forumMessagePayload>
/**
 * Model forumTopic
 * 
 */
export type forumTopic = $Result.DefaultSelection<Prisma.$forumTopicPayload>
/**
 * Model healthIndicator
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type healthIndicator = $Result.DefaultSelection<Prisma.$healthIndicatorPayload>
/**
 * Model helpOffer
 * 
 */
export type helpOffer = $Result.DefaultSelection<Prisma.$helpOfferPayload>
/**
 * Model helpRequest
 * 
 */
export type helpRequest = $Result.DefaultSelection<Prisma.$helpRequestPayload>
/**
 * Model localService
 * 
 */
export type localService = $Result.DefaultSelection<Prisma.$localServicePayload>
/**
 * Model medicationReminder
 * 
 */
export type medicationReminder = $Result.DefaultSelection<Prisma.$medicationReminderPayload>
/**
 * Model message
 * 
 */
export type message = $Result.DefaultSelection<Prisma.$messagePayload>
/**
 * Model municipalEvent
 * 
 */
export type municipalEvent = $Result.DefaultSelection<Prisma.$municipalEventPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model notificationPreferences
 * 
 */
export type notificationPreferences = $Result.DefaultSelection<Prisma.$notificationPreferencesPayload>
/**
 * Model nutritionalAdvice
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type nutritionalAdvice = $Result.DefaultSelection<Prisma.$nutritionalAdvicePayload>
/**
 * Model projectMember
 * 
 */
export type projectMember = $Result.DefaultSelection<Prisma.$projectMemberPayload>
/**
 * Model projectTask
 * 
 */
export type projectTask = $Result.DefaultSelection<Prisma.$projectTaskPayload>
/**
 * Model resource
 * 
 */
export type resource = $Result.DefaultSelection<Prisma.$resourcePayload>
/**
 * Model satisfactionSurvey
 * 
 */
export type satisfactionSurvey = $Result.DefaultSelection<Prisma.$satisfactionSurveyPayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model serviceCompleted
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type serviceCompleted = $Result.DefaultSelection<Prisma.$serviceCompletedPayload>
/**
 * Model serviceRating
 * 
 */
export type serviceRating = $Result.DefaultSelection<Prisma.$serviceRatingPayload>
/**
 * Model skill
 * 
 */
export type skill = $Result.DefaultSelection<Prisma.$skillPayload>
/**
 * Model surveyResponse
 * 
 */
export type surveyResponse = $Result.DefaultSelection<Prisma.$surveyResponsePayload>
/**
 * Model trustCircle
 * 
 */
export type trustCircle = $Result.DefaultSelection<Prisma.$trustCirclePayload>
/**
 * Model trustedContact
 * This table contains check constraStrings and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type trustedContact = $Result.DefaultSelection<Prisma.$trustedContactPayload>
/**
 * Model urbanIssueReport
 * 
 */
export type urbanIssueReport = $Result.DefaultSelection<Prisma.$urbanIssueReportPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model userActivity
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type userActivity = $Result.DefaultSelection<Prisma.$userActivityPayload>
/**
 * Model userBadge
 * 
 */
export type userBadge = $Result.DefaultSelection<Prisma.$userBadgePayload>
/**
 * Model userDevice
 * 
 */
export type userDevice = $Result.DefaultSelection<Prisma.$userDevicePayload>
/**
 * Model userSkill
 * 
 */
export type userSkill = $Result.DefaultSelection<Prisma.$userSkillPayload>
/**
 * Model userStatistics
 * 
 */
export type userStatistics = $Result.DefaultSelection<Prisma.$userStatisticsPayload>
/**
 * Model videoCall
 * 
 */
export type videoCall = $Result.DefaultSelection<Prisma.$videoCallPayload>
/**
 * Model wellnessBadge
 * 
 */
export type wellnessBadge = $Result.DefaultSelection<Prisma.$wellnessBadgePayload>
/**
 * Model wellnessGoal
 * 
 */
export type wellnessGoal = $Result.DefaultSelection<Prisma.$wellnessGoalPayload>
/**
 * Model wellnessGoalProgress
 * 
 */
export type wellnessGoalProgress = $Result.DefaultSelection<Prisma.$wellnessGoalProgressPayload>
/**
 * Model activityCategory
 * 
 */
export type activityCategory = $Result.DefaultSelection<Prisma.$activityCategoryPayload>
/**
 * Model badgeCategory
 * 
 */
export type badgeCategory = $Result.DefaultSelection<Prisma.$badgeCategoryPayload>
/**
 * Model cognitiveCategory
 * 
 */
export type cognitiveCategory = $Result.DefaultSelection<Prisma.$cognitiveCategoryPayload>
/**
 * Model helpCategory
 * 
 */
export type helpCategory = $Result.DefaultSelection<Prisma.$helpCategoryPayload>
/**
 * Model issueCategory
 * 
 */
export type issueCategory = $Result.DefaultSelection<Prisma.$issueCategoryPayload>
/**
 * Model nutritionalCategory
 * 
 */
export type nutritionalCategory = $Result.DefaultSelection<Prisma.$nutritionalCategoryPayload>
/**
 * Model programCategory
 * 
 */
export type programCategory = $Result.DefaultSelection<Prisma.$programCategoryPayload>
/**
 * Model projectCategory
 * 
 */
export type projectCategory = $Result.DefaultSelection<Prisma.$projectCategoryPayload>
/**
 * Model resourceCategory
 * 
 */
export type resourceCategory = $Result.DefaultSelection<Prisma.$resourceCategoryPayload>
/**
 * Model serviceCategory
 * 
 */
export type serviceCategory = $Result.DefaultSelection<Prisma.$serviceCategoryPayload>
/**
 * Model skillCategory
 * 
 */
export type skillCategory = $Result.DefaultSelection<Prisma.$skillCategoryPayload>
/**
 * Model wellnessCategory
 * 
 */
export type wellnessCategory = $Result.DefaultSelection<Prisma.$wellnessCategoryPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activities
 * const activities = await prisma.activity.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activities
   * const activities = await prisma.activity.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activity`: Exposes CRUD operations for the **activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.activityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **activityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.activityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityRegistration`: Exposes CRUD operations for the **activityRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityRegistrations
    * const activityRegistrations = await prisma.activityRegistration.findMany()
    * ```
    */
  get activityRegistration(): Prisma.activityRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.badgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cognitiveExercise`: Exposes CRUD operations for the **cognitiveExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CognitiveExercises
    * const cognitiveExercises = await prisma.cognitiveExercise.findMany()
    * ```
    */
  get cognitiveExercise(): Prisma.cognitiveExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collaborativeProject`: Exposes CRUD operations for the **collaborativeProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollaborativeProjects
    * const collaborativeProjects = await prisma.collaborativeProject.findMany()
    * ```
    */
  get collaborativeProject(): Prisma.collaborativeProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.conversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **conversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.conversationParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciseProgram`: Exposes CRUD operations for the **exerciseProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExercisePrograms
    * const exercisePrograms = await prisma.exerciseProgram.findMany()
    * ```
    */
  get exerciseProgram(): Prisma.exerciseProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumCategory`: Exposes CRUD operations for the **forumCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumCategories
    * const forumCategories = await prisma.forumCategory.findMany()
    * ```
    */
  get forumCategory(): Prisma.forumCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumMessage`: Exposes CRUD operations for the **forumMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumMessages
    * const forumMessages = await prisma.forumMessage.findMany()
    * ```
    */
  get forumMessage(): Prisma.forumMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumTopic`: Exposes CRUD operations for the **forumTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumTopics
    * const forumTopics = await prisma.forumTopic.findMany()
    * ```
    */
  get forumTopic(): Prisma.forumTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.healthIndicator`: Exposes CRUD operations for the **healthIndicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthIndicators
    * const healthIndicators = await prisma.healthIndicator.findMany()
    * ```
    */
  get healthIndicator(): Prisma.healthIndicatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helpOffer`: Exposes CRUD operations for the **helpOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpOffers
    * const helpOffers = await prisma.helpOffer.findMany()
    * ```
    */
  get helpOffer(): Prisma.helpOfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helpRequest`: Exposes CRUD operations for the **helpRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpRequests
    * const helpRequests = await prisma.helpRequest.findMany()
    * ```
    */
  get helpRequest(): Prisma.helpRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localService`: Exposes CRUD operations for the **localService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalServices
    * const localServices = await prisma.localService.findMany()
    * ```
    */
  get localService(): Prisma.localServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicationReminder`: Exposes CRUD operations for the **medicationReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicationReminders
    * const medicationReminders = await prisma.medicationReminder.findMany()
    * ```
    */
  get medicationReminder(): Prisma.medicationReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.messageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.municipalEvent`: Exposes CRUD operations for the **municipalEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MunicipalEvents
    * const municipalEvents = await prisma.municipalEvent.findMany()
    * ```
    */
  get municipalEvent(): Prisma.municipalEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreferences`: Exposes CRUD operations for the **notificationPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreferences.findMany()
    * ```
    */
  get notificationPreferences(): Prisma.notificationPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionalAdvice`: Exposes CRUD operations for the **nutritionalAdvice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionalAdvices
    * const nutritionalAdvices = await prisma.nutritionalAdvice.findMany()
    * ```
    */
  get nutritionalAdvice(): Prisma.nutritionalAdviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **projectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.projectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectTask`: Exposes CRUD operations for the **projectTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTasks
    * const projectTasks = await prisma.projectTask.findMany()
    * ```
    */
  get projectTask(): Prisma.projectTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.resourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.satisfactionSurvey`: Exposes CRUD operations for the **satisfactionSurvey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SatisfactionSurveys
    * const satisfactionSurveys = await prisma.satisfactionSurvey.findMany()
    * ```
    */
  get satisfactionSurvey(): Prisma.satisfactionSurveyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCompleted`: Exposes CRUD operations for the **serviceCompleted** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCompleteds
    * const serviceCompleteds = await prisma.serviceCompleted.findMany()
    * ```
    */
  get serviceCompleted(): Prisma.serviceCompletedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceRating`: Exposes CRUD operations for the **serviceRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRatings
    * const serviceRatings = await prisma.serviceRating.findMany()
    * ```
    */
  get serviceRating(): Prisma.serviceRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.skillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyResponse`: Exposes CRUD operations for the **surveyResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyResponses
    * const surveyResponses = await prisma.surveyResponse.findMany()
    * ```
    */
  get surveyResponse(): Prisma.surveyResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trustCircle`: Exposes CRUD operations for the **trustCircle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrustCircles
    * const trustCircles = await prisma.trustCircle.findMany()
    * ```
    */
  get trustCircle(): Prisma.trustCircleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trustedContact`: Exposes CRUD operations for the **trustedContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrustedContacts
    * const trustedContacts = await prisma.trustedContact.findMany()
    * ```
    */
  get trustedContact(): Prisma.trustedContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.urbanIssueReport`: Exposes CRUD operations for the **urbanIssueReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UrbanIssueReports
    * const urbanIssueReports = await prisma.urbanIssueReport.findMany()
    * ```
    */
  get urbanIssueReport(): Prisma.urbanIssueReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userActivity`: Exposes CRUD operations for the **userActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivities
    * const userActivities = await prisma.userActivity.findMany()
    * ```
    */
  get userActivity(): Prisma.userActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **userBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.userBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDevice`: Exposes CRUD operations for the **userDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDevices
    * const userDevices = await prisma.userDevice.findMany()
    * ```
    */
  get userDevice(): Prisma.userDeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSkill`: Exposes CRUD operations for the **userSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkills
    * const userSkills = await prisma.userSkill.findMany()
    * ```
    */
  get userSkill(): Prisma.userSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStatistics`: Exposes CRUD operations for the **userStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStatistics
    * const userStatistics = await prisma.userStatistics.findMany()
    * ```
    */
  get userStatistics(): Prisma.userStatisticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoCall`: Exposes CRUD operations for the **videoCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoCalls
    * const videoCalls = await prisma.videoCall.findMany()
    * ```
    */
  get videoCall(): Prisma.videoCallDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellnessBadge`: Exposes CRUD operations for the **wellnessBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessBadges
    * const wellnessBadges = await prisma.wellnessBadge.findMany()
    * ```
    */
  get wellnessBadge(): Prisma.wellnessBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellnessGoal`: Exposes CRUD operations for the **wellnessGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessGoals
    * const wellnessGoals = await prisma.wellnessGoal.findMany()
    * ```
    */
  get wellnessGoal(): Prisma.wellnessGoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellnessGoalProgress`: Exposes CRUD operations for the **wellnessGoalProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessGoalProgresses
    * const wellnessGoalProgresses = await prisma.wellnessGoalProgress.findMany()
    * ```
    */
  get wellnessGoalProgress(): Prisma.wellnessGoalProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityCategory`: Exposes CRUD operations for the **activityCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityCategories
    * const activityCategories = await prisma.activityCategory.findMany()
    * ```
    */
  get activityCategory(): Prisma.activityCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badgeCategory`: Exposes CRUD operations for the **badgeCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BadgeCategories
    * const badgeCategories = await prisma.badgeCategory.findMany()
    * ```
    */
  get badgeCategory(): Prisma.badgeCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cognitiveCategory`: Exposes CRUD operations for the **cognitiveCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CognitiveCategories
    * const cognitiveCategories = await prisma.cognitiveCategory.findMany()
    * ```
    */
  get cognitiveCategory(): Prisma.cognitiveCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helpCategory`: Exposes CRUD operations for the **helpCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpCategories
    * const helpCategories = await prisma.helpCategory.findMany()
    * ```
    */
  get helpCategory(): Prisma.helpCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.issueCategory`: Exposes CRUD operations for the **issueCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueCategories
    * const issueCategories = await prisma.issueCategory.findMany()
    * ```
    */
  get issueCategory(): Prisma.issueCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionalCategory`: Exposes CRUD operations for the **nutritionalCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionalCategories
    * const nutritionalCategories = await prisma.nutritionalCategory.findMany()
    * ```
    */
  get nutritionalCategory(): Prisma.nutritionalCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programCategory`: Exposes CRUD operations for the **programCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramCategories
    * const programCategories = await prisma.programCategory.findMany()
    * ```
    */
  get programCategory(): Prisma.programCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectCategory`: Exposes CRUD operations for the **projectCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectCategories
    * const projectCategories = await prisma.projectCategory.findMany()
    * ```
    */
  get projectCategory(): Prisma.projectCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceCategory`: Exposes CRUD operations for the **resourceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceCategories
    * const resourceCategories = await prisma.resourceCategory.findMany()
    * ```
    */
  get resourceCategory(): Prisma.resourceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **serviceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.serviceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skillCategory`: Exposes CRUD operations for the **skillCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillCategories
    * const skillCategories = await prisma.skillCategory.findMany()
    * ```
    */
  get skillCategory(): Prisma.skillCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellnessCategory`: Exposes CRUD operations for the **wellnessCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessCategories
    * const wellnessCategories = await prisma.wellnessCategory.findMany()
    * ```
    */
  get wellnessCategory(): Prisma.wellnessCategoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    activity: 'activity',
    activityLog: 'activityLog',
    activityRegistration: 'activityRegistration',
    badge: 'badge',
    cognitiveExercise: 'cognitiveExercise',
    collaborativeProject: 'collaborativeProject',
    conversation: 'conversation',
    conversationParticipant: 'conversationParticipant',
    exerciseProgram: 'exerciseProgram',
    forumCategory: 'forumCategory',
    forumMessage: 'forumMessage',
    forumTopic: 'forumTopic',
    healthIndicator: 'healthIndicator',
    helpOffer: 'helpOffer',
    helpRequest: 'helpRequest',
    localService: 'localService',
    medicationReminder: 'medicationReminder',
    message: 'message',
    municipalEvent: 'municipalEvent',
    notification: 'notification',
    notificationPreferences: 'notificationPreferences',
    nutritionalAdvice: 'nutritionalAdvice',
    projectMember: 'projectMember',
    projectTask: 'projectTask',
    resource: 'resource',
    satisfactionSurvey: 'satisfactionSurvey',
    session: 'session',
    serviceCompleted: 'serviceCompleted',
    serviceRating: 'serviceRating',
    skill: 'skill',
    surveyResponse: 'surveyResponse',
    trustCircle: 'trustCircle',
    trustedContact: 'trustedContact',
    urbanIssueReport: 'urbanIssueReport',
    user: 'user',
    userActivity: 'userActivity',
    userBadge: 'userBadge',
    userDevice: 'userDevice',
    userSkill: 'userSkill',
    userStatistics: 'userStatistics',
    videoCall: 'videoCall',
    wellnessBadge: 'wellnessBadge',
    wellnessGoal: 'wellnessGoal',
    wellnessGoalProgress: 'wellnessGoalProgress',
    activityCategory: 'activityCategory',
    badgeCategory: 'badgeCategory',
    cognitiveCategory: 'cognitiveCategory',
    helpCategory: 'helpCategory',
    issueCategory: 'issueCategory',
    nutritionalCategory: 'nutritionalCategory',
    programCategory: 'programCategory',
    projectCategory: 'projectCategory',
    resourceCategory: 'resourceCategory',
    serviceCategory: 'serviceCategory',
    skillCategory: 'skillCategory',
    wellnessCategory: 'wellnessCategory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activity" | "activityLog" | "activityRegistration" | "badge" | "cognitiveExercise" | "collaborativeProject" | "conversation" | "conversationParticipant" | "exerciseProgram" | "forumCategory" | "forumMessage" | "forumTopic" | "healthIndicator" | "helpOffer" | "helpRequest" | "localService" | "medicationReminder" | "message" | "municipalEvent" | "notification" | "notificationPreferences" | "nutritionalAdvice" | "projectMember" | "projectTask" | "resource" | "satisfactionSurvey" | "session" | "serviceCompleted" | "serviceRating" | "skill" | "surveyResponse" | "trustCircle" | "trustedContact" | "urbanIssueReport" | "user" | "userActivity" | "userBadge" | "userDevice" | "userSkill" | "userStatistics" | "videoCall" | "wellnessBadge" | "wellnessGoal" | "wellnessGoalProgress" | "activityCategory" | "badgeCategory" | "cognitiveCategory" | "helpCategory" | "issueCategory" | "nutritionalCategory" | "programCategory" | "projectCategory" | "resourceCategory" | "serviceCategory" | "skillCategory" | "wellnessCategory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      activity: {
        payload: Prisma.$activityPayload<ExtArgs>
        fields: Prisma.activityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          findFirst: {
            args: Prisma.activityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          findMany: {
            args: Prisma.activityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>[]
          }
          create: {
            args: Prisma.activityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          createMany: {
            args: Prisma.activityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>[]
          }
          delete: {
            args: Prisma.activityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          update: {
            args: Prisma.activityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          deleteMany: {
            args: Prisma.activityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.activityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>[]
          }
          upsert: {
            args: Prisma.activityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.activityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.activityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      activityLog: {
        payload: Prisma.$activityLogPayload<ExtArgs>
        fields: Prisma.activityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>
          }
          findFirst: {
            args: Prisma.activityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>
          }
          findMany: {
            args: Prisma.activityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>[]
          }
          create: {
            args: Prisma.activityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>
          }
          createMany: {
            args: Prisma.activityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>[]
          }
          delete: {
            args: Prisma.activityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>
          }
          update: {
            args: Prisma.activityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>
          }
          deleteMany: {
            args: Prisma.activityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.activityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>[]
          }
          upsert: {
            args: Prisma.activityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.activityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.activityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      activityRegistration: {
        payload: Prisma.$activityRegistrationPayload<ExtArgs>
        fields: Prisma.activityRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activityRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activityRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
          }
          findFirst: {
            args: Prisma.activityRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activityRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
          }
          findMany: {
            args: Prisma.activityRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>[]
          }
          create: {
            args: Prisma.activityRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
          }
          createMany: {
            args: Prisma.activityRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activityRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>[]
          }
          delete: {
            args: Prisma.activityRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
          }
          update: {
            args: Prisma.activityRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.activityRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activityRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.activityRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.activityRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityRegistrationPayload>
          }
          aggregate: {
            args: Prisma.ActivityRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityRegistration>
          }
          groupBy: {
            args: Prisma.activityRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.activityRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityRegistrationCountAggregateOutputType> | number
          }
        }
      }
      badge: {
        payload: Prisma.$badgePayload<ExtArgs>
        fields: Prisma.badgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.badgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.badgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          findFirst: {
            args: Prisma.badgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.badgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          findMany: {
            args: Prisma.badgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>[]
          }
          create: {
            args: Prisma.badgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          createMany: {
            args: Prisma.badgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.badgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>[]
          }
          delete: {
            args: Prisma.badgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          update: {
            args: Prisma.badgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          deleteMany: {
            args: Prisma.badgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.badgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.badgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>[]
          }
          upsert: {
            args: Prisma.badgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.badgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.badgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      cognitiveExercise: {
        payload: Prisma.$cognitiveExercisePayload<ExtArgs>
        fields: Prisma.cognitiveExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cognitiveExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cognitiveExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
          }
          findFirst: {
            args: Prisma.cognitiveExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cognitiveExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
          }
          findMany: {
            args: Prisma.cognitiveExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>[]
          }
          create: {
            args: Prisma.cognitiveExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
          }
          createMany: {
            args: Prisma.cognitiveExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cognitiveExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>[]
          }
          delete: {
            args: Prisma.cognitiveExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
          }
          update: {
            args: Prisma.cognitiveExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
          }
          deleteMany: {
            args: Prisma.cognitiveExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cognitiveExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cognitiveExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>[]
          }
          upsert: {
            args: Prisma.cognitiveExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveExercisePayload>
          }
          aggregate: {
            args: Prisma.CognitiveExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCognitiveExercise>
          }
          groupBy: {
            args: Prisma.cognitiveExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CognitiveExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.cognitiveExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<CognitiveExerciseCountAggregateOutputType> | number
          }
        }
      }
      collaborativeProject: {
        payload: Prisma.$collaborativeProjectPayload<ExtArgs>
        fields: Prisma.collaborativeProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collaborativeProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collaborativeProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
          }
          findFirst: {
            args: Prisma.collaborativeProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collaborativeProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
          }
          findMany: {
            args: Prisma.collaborativeProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>[]
          }
          create: {
            args: Prisma.collaborativeProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
          }
          createMany: {
            args: Prisma.collaborativeProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collaborativeProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>[]
          }
          delete: {
            args: Prisma.collaborativeProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
          }
          update: {
            args: Prisma.collaborativeProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
          }
          deleteMany: {
            args: Prisma.collaborativeProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collaborativeProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.collaborativeProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>[]
          }
          upsert: {
            args: Prisma.collaborativeProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collaborativeProjectPayload>
          }
          aggregate: {
            args: Prisma.CollaborativeProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollaborativeProject>
          }
          groupBy: {
            args: Prisma.collaborativeProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollaborativeProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.collaborativeProjectCountArgs<ExtArgs>
            result: $Utils.Optional<CollaborativeProjectCountAggregateOutputType> | number
          }
        }
      }
      conversation: {
        payload: Prisma.$conversationPayload<ExtArgs>
        fields: Prisma.conversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          findFirst: {
            args: Prisma.conversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          findMany: {
            args: Prisma.conversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          create: {
            args: Prisma.conversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          createMany: {
            args: Prisma.conversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          delete: {
            args: Prisma.conversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          update: {
            args: Prisma.conversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          deleteMany: {
            args: Prisma.conversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          upsert: {
            args: Prisma.conversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.conversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      conversationParticipant: {
        payload: Prisma.$conversationParticipantPayload<ExtArgs>
        fields: Prisma.conversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.conversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
          }
          findMany: {
            args: Prisma.conversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>[]
          }
          create: {
            args: Prisma.conversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
          }
          createMany: {
            args: Prisma.conversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.conversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
          }
          update: {
            args: Prisma.conversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.conversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conversationParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>[]
          }
          upsert: {
            args: Prisma.conversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.conversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      exerciseProgram: {
        payload: Prisma.$exerciseProgramPayload<ExtArgs>
        fields: Prisma.exerciseProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.exerciseProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.exerciseProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
          }
          findFirst: {
            args: Prisma.exerciseProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.exerciseProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
          }
          findMany: {
            args: Prisma.exerciseProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>[]
          }
          create: {
            args: Prisma.exerciseProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
          }
          createMany: {
            args: Prisma.exerciseProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.exerciseProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>[]
          }
          delete: {
            args: Prisma.exerciseProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
          }
          update: {
            args: Prisma.exerciseProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
          }
          deleteMany: {
            args: Prisma.exerciseProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.exerciseProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.exerciseProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>[]
          }
          upsert: {
            args: Prisma.exerciseProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exerciseProgramPayload>
          }
          aggregate: {
            args: Prisma.ExerciseProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseProgram>
          }
          groupBy: {
            args: Prisma.exerciseProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.exerciseProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseProgramCountAggregateOutputType> | number
          }
        }
      }
      forumCategory: {
        payload: Prisma.$forumCategoryPayload<ExtArgs>
        fields: Prisma.forumCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.forumCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.forumCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>
          }
          findFirst: {
            args: Prisma.forumCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.forumCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>
          }
          findMany: {
            args: Prisma.forumCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>[]
          }
          create: {
            args: Prisma.forumCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>
          }
          createMany: {
            args: Prisma.forumCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.forumCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>[]
          }
          delete: {
            args: Prisma.forumCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>
          }
          update: {
            args: Prisma.forumCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>
          }
          deleteMany: {
            args: Prisma.forumCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.forumCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.forumCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>[]
          }
          upsert: {
            args: Prisma.forumCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumCategoryPayload>
          }
          aggregate: {
            args: Prisma.ForumCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumCategory>
          }
          groupBy: {
            args: Prisma.forumCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.forumCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCategoryCountAggregateOutputType> | number
          }
        }
      }
      forumMessage: {
        payload: Prisma.$forumMessagePayload<ExtArgs>
        fields: Prisma.forumMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.forumMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.forumMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>
          }
          findFirst: {
            args: Prisma.forumMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.forumMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>
          }
          findMany: {
            args: Prisma.forumMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>[]
          }
          create: {
            args: Prisma.forumMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>
          }
          createMany: {
            args: Prisma.forumMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.forumMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>[]
          }
          delete: {
            args: Prisma.forumMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>
          }
          update: {
            args: Prisma.forumMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>
          }
          deleteMany: {
            args: Prisma.forumMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.forumMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.forumMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>[]
          }
          upsert: {
            args: Prisma.forumMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumMessagePayload>
          }
          aggregate: {
            args: Prisma.ForumMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumMessage>
          }
          groupBy: {
            args: Prisma.forumMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.forumMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ForumMessageCountAggregateOutputType> | number
          }
        }
      }
      forumTopic: {
        payload: Prisma.$forumTopicPayload<ExtArgs>
        fields: Prisma.forumTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.forumTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.forumTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>
          }
          findFirst: {
            args: Prisma.forumTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.forumTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>
          }
          findMany: {
            args: Prisma.forumTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>[]
          }
          create: {
            args: Prisma.forumTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>
          }
          createMany: {
            args: Prisma.forumTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.forumTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>[]
          }
          delete: {
            args: Prisma.forumTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>
          }
          update: {
            args: Prisma.forumTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>
          }
          deleteMany: {
            args: Prisma.forumTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.forumTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.forumTopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>[]
          }
          upsert: {
            args: Prisma.forumTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$forumTopicPayload>
          }
          aggregate: {
            args: Prisma.ForumTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumTopic>
          }
          groupBy: {
            args: Prisma.forumTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.forumTopicCountArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicCountAggregateOutputType> | number
          }
        }
      }
      healthIndicator: {
        payload: Prisma.$healthIndicatorPayload<ExtArgs>
        fields: Prisma.healthIndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.healthIndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.healthIndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
          }
          findFirst: {
            args: Prisma.healthIndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.healthIndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
          }
          findMany: {
            args: Prisma.healthIndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>[]
          }
          create: {
            args: Prisma.healthIndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
          }
          createMany: {
            args: Prisma.healthIndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.healthIndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>[]
          }
          delete: {
            args: Prisma.healthIndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
          }
          update: {
            args: Prisma.healthIndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
          }
          deleteMany: {
            args: Prisma.healthIndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.healthIndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.healthIndicatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>[]
          }
          upsert: {
            args: Prisma.healthIndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$healthIndicatorPayload>
          }
          aggregate: {
            args: Prisma.HealthIndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthIndicator>
          }
          groupBy: {
            args: Prisma.healthIndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthIndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.healthIndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<HealthIndicatorCountAggregateOutputType> | number
          }
        }
      }
      helpOffer: {
        payload: Prisma.$helpOfferPayload<ExtArgs>
        fields: Prisma.helpOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.helpOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.helpOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>
          }
          findFirst: {
            args: Prisma.helpOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.helpOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>
          }
          findMany: {
            args: Prisma.helpOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>[]
          }
          create: {
            args: Prisma.helpOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>
          }
          createMany: {
            args: Prisma.helpOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.helpOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>[]
          }
          delete: {
            args: Prisma.helpOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>
          }
          update: {
            args: Prisma.helpOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>
          }
          deleteMany: {
            args: Prisma.helpOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.helpOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.helpOfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>[]
          }
          upsert: {
            args: Prisma.helpOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpOfferPayload>
          }
          aggregate: {
            args: Prisma.HelpOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpOffer>
          }
          groupBy: {
            args: Prisma.helpOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.helpOfferCountArgs<ExtArgs>
            result: $Utils.Optional<HelpOfferCountAggregateOutputType> | number
          }
        }
      }
      helpRequest: {
        payload: Prisma.$helpRequestPayload<ExtArgs>
        fields: Prisma.helpRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.helpRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.helpRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>
          }
          findFirst: {
            args: Prisma.helpRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.helpRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>
          }
          findMany: {
            args: Prisma.helpRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>[]
          }
          create: {
            args: Prisma.helpRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>
          }
          createMany: {
            args: Prisma.helpRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.helpRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>[]
          }
          delete: {
            args: Prisma.helpRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>
          }
          update: {
            args: Prisma.helpRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>
          }
          deleteMany: {
            args: Prisma.helpRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.helpRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.helpRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>[]
          }
          upsert: {
            args: Prisma.helpRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpRequestPayload>
          }
          aggregate: {
            args: Prisma.HelpRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpRequest>
          }
          groupBy: {
            args: Prisma.helpRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.helpRequestCountArgs<ExtArgs>
            result: $Utils.Optional<HelpRequestCountAggregateOutputType> | number
          }
        }
      }
      localService: {
        payload: Prisma.$localServicePayload<ExtArgs>
        fields: Prisma.localServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.localServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.localServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>
          }
          findFirst: {
            args: Prisma.localServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.localServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>
          }
          findMany: {
            args: Prisma.localServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>[]
          }
          create: {
            args: Prisma.localServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>
          }
          createMany: {
            args: Prisma.localServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.localServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>[]
          }
          delete: {
            args: Prisma.localServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>
          }
          update: {
            args: Prisma.localServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>
          }
          deleteMany: {
            args: Prisma.localServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.localServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.localServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>[]
          }
          upsert: {
            args: Prisma.localServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localServicePayload>
          }
          aggregate: {
            args: Prisma.LocalServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalService>
          }
          groupBy: {
            args: Prisma.localServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.localServiceCountArgs<ExtArgs>
            result: $Utils.Optional<LocalServiceCountAggregateOutputType> | number
          }
        }
      }
      medicationReminder: {
        payload: Prisma.$medicationReminderPayload<ExtArgs>
        fields: Prisma.medicationReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medicationReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medicationReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>
          }
          findFirst: {
            args: Prisma.medicationReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medicationReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>
          }
          findMany: {
            args: Prisma.medicationReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>[]
          }
          create: {
            args: Prisma.medicationReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>
          }
          createMany: {
            args: Prisma.medicationReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medicationReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>[]
          }
          delete: {
            args: Prisma.medicationReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>
          }
          update: {
            args: Prisma.medicationReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>
          }
          deleteMany: {
            args: Prisma.medicationReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medicationReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.medicationReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>[]
          }
          upsert: {
            args: Prisma.medicationReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicationReminderPayload>
          }
          aggregate: {
            args: Prisma.MedicationReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicationReminder>
          }
          groupBy: {
            args: Prisma.medicationReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.medicationReminderCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationReminderCountAggregateOutputType> | number
          }
        }
      }
      message: {
        payload: Prisma.$messagePayload<ExtArgs>
        fields: Prisma.messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findFirst: {
            args: Prisma.messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findMany: {
            args: Prisma.messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          create: {
            args: Prisma.messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          createMany: {
            args: Prisma.messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          delete: {
            args: Prisma.messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          update: {
            args: Prisma.messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          deleteMany: {
            args: Prisma.messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          upsert: {
            args: Prisma.messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.messageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      municipalEvent: {
        payload: Prisma.$municipalEventPayload<ExtArgs>
        fields: Prisma.municipalEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.municipalEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.municipalEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>
          }
          findFirst: {
            args: Prisma.municipalEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.municipalEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>
          }
          findMany: {
            args: Prisma.municipalEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>[]
          }
          create: {
            args: Prisma.municipalEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>
          }
          createMany: {
            args: Prisma.municipalEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.municipalEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>[]
          }
          delete: {
            args: Prisma.municipalEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>
          }
          update: {
            args: Prisma.municipalEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>
          }
          deleteMany: {
            args: Prisma.municipalEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.municipalEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.municipalEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>[]
          }
          upsert: {
            args: Prisma.municipalEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipalEventPayload>
          }
          aggregate: {
            args: Prisma.MunicipalEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipalEvent>
          }
          groupBy: {
            args: Prisma.municipalEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipalEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.municipalEventCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipalEventCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      notificationPreferences: {
        payload: Prisma.$notificationPreferencesPayload<ExtArgs>
        fields: Prisma.notificationPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
          }
          findFirst: {
            args: Prisma.notificationPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
          }
          findMany: {
            args: Prisma.notificationPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>[]
          }
          create: {
            args: Prisma.notificationPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
          }
          createMany: {
            args: Prisma.notificationPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>[]
          }
          delete: {
            args: Prisma.notificationPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
          }
          update: {
            args: Prisma.notificationPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.notificationPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.notificationPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPreferencesPayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreferences>
          }
          groupBy: {
            args: Prisma.notificationPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferencesCountAggregateOutputType> | number
          }
        }
      }
      nutritionalAdvice: {
        payload: Prisma.$nutritionalAdvicePayload<ExtArgs>
        fields: Prisma.nutritionalAdviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.nutritionalAdviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.nutritionalAdviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
          }
          findFirst: {
            args: Prisma.nutritionalAdviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.nutritionalAdviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
          }
          findMany: {
            args: Prisma.nutritionalAdviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>[]
          }
          create: {
            args: Prisma.nutritionalAdviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
          }
          createMany: {
            args: Prisma.nutritionalAdviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.nutritionalAdviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>[]
          }
          delete: {
            args: Prisma.nutritionalAdviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
          }
          update: {
            args: Prisma.nutritionalAdviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
          }
          deleteMany: {
            args: Prisma.nutritionalAdviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.nutritionalAdviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.nutritionalAdviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>[]
          }
          upsert: {
            args: Prisma.nutritionalAdviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalAdvicePayload>
          }
          aggregate: {
            args: Prisma.NutritionalAdviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionalAdvice>
          }
          groupBy: {
            args: Prisma.nutritionalAdviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionalAdviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.nutritionalAdviceCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionalAdviceCountAggregateOutputType> | number
          }
        }
      }
      projectMember: {
        payload: Prisma.$projectMemberPayload<ExtArgs>
        fields: Prisma.projectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>
          }
          findFirst: {
            args: Prisma.projectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>
          }
          findMany: {
            args: Prisma.projectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>[]
          }
          create: {
            args: Prisma.projectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>
          }
          createMany: {
            args: Prisma.projectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>[]
          }
          delete: {
            args: Prisma.projectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>
          }
          update: {
            args: Prisma.projectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>
          }
          deleteMany: {
            args: Prisma.projectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>[]
          }
          upsert: {
            args: Prisma.projectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.projectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      projectTask: {
        payload: Prisma.$projectTaskPayload<ExtArgs>
        fields: Prisma.projectTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>
          }
          findFirst: {
            args: Prisma.projectTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>
          }
          findMany: {
            args: Prisma.projectTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>[]
          }
          create: {
            args: Prisma.projectTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>
          }
          createMany: {
            args: Prisma.projectTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>[]
          }
          delete: {
            args: Prisma.projectTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>
          }
          update: {
            args: Prisma.projectTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>
          }
          deleteMany: {
            args: Prisma.projectTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projectTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>[]
          }
          upsert: {
            args: Prisma.projectTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectTaskPayload>
          }
          aggregate: {
            args: Prisma.ProjectTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTask>
          }
          groupBy: {
            args: Prisma.projectTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTaskCountAggregateOutputType> | number
          }
        }
      }
      resource: {
        payload: Prisma.$resourcePayload<ExtArgs>
        fields: Prisma.resourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          findFirst: {
            args: Prisma.resourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          findMany: {
            args: Prisma.resourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>[]
          }
          create: {
            args: Prisma.resourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          createMany: {
            args: Prisma.resourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.resourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>[]
          }
          delete: {
            args: Prisma.resourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          update: {
            args: Prisma.resourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          deleteMany: {
            args: Prisma.resourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.resourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>[]
          }
          upsert: {
            args: Prisma.resourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.resourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.resourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      satisfactionSurvey: {
        payload: Prisma.$satisfactionSurveyPayload<ExtArgs>
        fields: Prisma.satisfactionSurveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.satisfactionSurveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.satisfactionSurveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
          }
          findFirst: {
            args: Prisma.satisfactionSurveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.satisfactionSurveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
          }
          findMany: {
            args: Prisma.satisfactionSurveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>[]
          }
          create: {
            args: Prisma.satisfactionSurveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
          }
          createMany: {
            args: Prisma.satisfactionSurveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.satisfactionSurveyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>[]
          }
          delete: {
            args: Prisma.satisfactionSurveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
          }
          update: {
            args: Prisma.satisfactionSurveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
          }
          deleteMany: {
            args: Prisma.satisfactionSurveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.satisfactionSurveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.satisfactionSurveyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>[]
          }
          upsert: {
            args: Prisma.satisfactionSurveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$satisfactionSurveyPayload>
          }
          aggregate: {
            args: Prisma.SatisfactionSurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSatisfactionSurvey>
          }
          groupBy: {
            args: Prisma.satisfactionSurveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SatisfactionSurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.satisfactionSurveyCountArgs<ExtArgs>
            result: $Utils.Optional<SatisfactionSurveyCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      serviceCompleted: {
        payload: Prisma.$serviceCompletedPayload<ExtArgs>
        fields: Prisma.serviceCompletedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceCompletedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceCompletedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
          }
          findFirst: {
            args: Prisma.serviceCompletedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceCompletedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
          }
          findMany: {
            args: Prisma.serviceCompletedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>[]
          }
          create: {
            args: Prisma.serviceCompletedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
          }
          createMany: {
            args: Prisma.serviceCompletedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.serviceCompletedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>[]
          }
          delete: {
            args: Prisma.serviceCompletedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
          }
          update: {
            args: Prisma.serviceCompletedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
          }
          deleteMany: {
            args: Prisma.serviceCompletedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceCompletedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.serviceCompletedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>[]
          }
          upsert: {
            args: Prisma.serviceCompletedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCompletedPayload>
          }
          aggregate: {
            args: Prisma.ServiceCompletedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCompleted>
          }
          groupBy: {
            args: Prisma.serviceCompletedGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCompletedGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceCompletedCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCompletedCountAggregateOutputType> | number
          }
        }
      }
      serviceRating: {
        payload: Prisma.$serviceRatingPayload<ExtArgs>
        fields: Prisma.serviceRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>
          }
          findFirst: {
            args: Prisma.serviceRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>
          }
          findMany: {
            args: Prisma.serviceRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>[]
          }
          create: {
            args: Prisma.serviceRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>
          }
          createMany: {
            args: Prisma.serviceRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.serviceRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>[]
          }
          delete: {
            args: Prisma.serviceRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>
          }
          update: {
            args: Prisma.serviceRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>
          }
          deleteMany: {
            args: Prisma.serviceRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.serviceRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>[]
          }
          upsert: {
            args: Prisma.serviceRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceRatingPayload>
          }
          aggregate: {
            args: Prisma.ServiceRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRating>
          }
          groupBy: {
            args: Prisma.serviceRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRatingCountAggregateOutputType> | number
          }
        }
      }
      skill: {
        payload: Prisma.$skillPayload<ExtArgs>
        fields: Prisma.skillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>
          }
          findFirst: {
            args: Prisma.skillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>
          }
          findMany: {
            args: Prisma.skillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>[]
          }
          create: {
            args: Prisma.skillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>
          }
          createMany: {
            args: Prisma.skillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.skillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>[]
          }
          delete: {
            args: Prisma.skillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>
          }
          update: {
            args: Prisma.skillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>
          }
          deleteMany: {
            args: Prisma.skillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.skillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>[]
          }
          upsert: {
            args: Prisma.skillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.skillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.skillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      surveyResponse: {
        payload: Prisma.$surveyResponsePayload<ExtArgs>
        fields: Prisma.surveyResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surveyResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surveyResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>
          }
          findFirst: {
            args: Prisma.surveyResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surveyResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>
          }
          findMany: {
            args: Prisma.surveyResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>[]
          }
          create: {
            args: Prisma.surveyResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>
          }
          createMany: {
            args: Prisma.surveyResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.surveyResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>[]
          }
          delete: {
            args: Prisma.surveyResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>
          }
          update: {
            args: Prisma.surveyResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>
          }
          deleteMany: {
            args: Prisma.surveyResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.surveyResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.surveyResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>[]
          }
          upsert: {
            args: Prisma.surveyResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyResponsePayload>
          }
          aggregate: {
            args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyResponse>
          }
          groupBy: {
            args: Prisma.surveyResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.surveyResponseCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseCountAggregateOutputType> | number
          }
        }
      }
      trustCircle: {
        payload: Prisma.$trustCirclePayload<ExtArgs>
        fields: Prisma.trustCircleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trustCircleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trustCircleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>
          }
          findFirst: {
            args: Prisma.trustCircleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trustCircleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>
          }
          findMany: {
            args: Prisma.trustCircleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>[]
          }
          create: {
            args: Prisma.trustCircleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>
          }
          createMany: {
            args: Prisma.trustCircleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trustCircleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>[]
          }
          delete: {
            args: Prisma.trustCircleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>
          }
          update: {
            args: Prisma.trustCircleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>
          }
          deleteMany: {
            args: Prisma.trustCircleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trustCircleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trustCircleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>[]
          }
          upsert: {
            args: Prisma.trustCircleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustCirclePayload>
          }
          aggregate: {
            args: Prisma.TrustCircleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrustCircle>
          }
          groupBy: {
            args: Prisma.trustCircleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrustCircleGroupByOutputType>[]
          }
          count: {
            args: Prisma.trustCircleCountArgs<ExtArgs>
            result: $Utils.Optional<TrustCircleCountAggregateOutputType> | number
          }
        }
      }
      trustedContact: {
        payload: Prisma.$trustedContactPayload<ExtArgs>
        fields: Prisma.trustedContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trustedContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trustedContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>
          }
          findFirst: {
            args: Prisma.trustedContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trustedContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>
          }
          findMany: {
            args: Prisma.trustedContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>[]
          }
          create: {
            args: Prisma.trustedContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>
          }
          createMany: {
            args: Prisma.trustedContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trustedContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>[]
          }
          delete: {
            args: Prisma.trustedContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>
          }
          update: {
            args: Prisma.trustedContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>
          }
          deleteMany: {
            args: Prisma.trustedContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trustedContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trustedContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>[]
          }
          upsert: {
            args: Prisma.trustedContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trustedContactPayload>
          }
          aggregate: {
            args: Prisma.TrustedContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrustedContact>
          }
          groupBy: {
            args: Prisma.trustedContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrustedContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.trustedContactCountArgs<ExtArgs>
            result: $Utils.Optional<TrustedContactCountAggregateOutputType> | number
          }
        }
      }
      urbanIssueReport: {
        payload: Prisma.$urbanIssueReportPayload<ExtArgs>
        fields: Prisma.urbanIssueReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.urbanIssueReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.urbanIssueReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
          }
          findFirst: {
            args: Prisma.urbanIssueReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.urbanIssueReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
          }
          findMany: {
            args: Prisma.urbanIssueReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>[]
          }
          create: {
            args: Prisma.urbanIssueReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
          }
          createMany: {
            args: Prisma.urbanIssueReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.urbanIssueReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>[]
          }
          delete: {
            args: Prisma.urbanIssueReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
          }
          update: {
            args: Prisma.urbanIssueReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
          }
          deleteMany: {
            args: Prisma.urbanIssueReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.urbanIssueReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.urbanIssueReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>[]
          }
          upsert: {
            args: Prisma.urbanIssueReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$urbanIssueReportPayload>
          }
          aggregate: {
            args: Prisma.UrbanIssueReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUrbanIssueReport>
          }
          groupBy: {
            args: Prisma.urbanIssueReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<UrbanIssueReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.urbanIssueReportCountArgs<ExtArgs>
            result: $Utils.Optional<UrbanIssueReportCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      userActivity: {
        payload: Prisma.$userActivityPayload<ExtArgs>
        fields: Prisma.userActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>
          }
          findFirst: {
            args: Prisma.userActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>
          }
          findMany: {
            args: Prisma.userActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>[]
          }
          create: {
            args: Prisma.userActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>
          }
          createMany: {
            args: Prisma.userActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>[]
          }
          delete: {
            args: Prisma.userActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>
          }
          update: {
            args: Prisma.userActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>
          }
          deleteMany: {
            args: Prisma.userActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>[]
          }
          upsert: {
            args: Prisma.userActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivityPayload>
          }
          aggregate: {
            args: Prisma.UserActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivity>
          }
          groupBy: {
            args: Prisma.userActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.userActivityCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivityCountAggregateOutputType> | number
          }
        }
      }
      userBadge: {
        payload: Prisma.$userBadgePayload<ExtArgs>
        fields: Prisma.userBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>
          }
          findFirst: {
            args: Prisma.userBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>
          }
          findMany: {
            args: Prisma.userBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>[]
          }
          create: {
            args: Prisma.userBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>
          }
          createMany: {
            args: Prisma.userBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>[]
          }
          delete: {
            args: Prisma.userBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>
          }
          update: {
            args: Prisma.userBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>
          }
          deleteMany: {
            args: Prisma.userBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>[]
          }
          upsert: {
            args: Prisma.userBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.userBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.userBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      userDevice: {
        payload: Prisma.$userDevicePayload<ExtArgs>
        fields: Prisma.userDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>
          }
          findFirst: {
            args: Prisma.userDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>
          }
          findMany: {
            args: Prisma.userDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>[]
          }
          create: {
            args: Prisma.userDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>
          }
          createMany: {
            args: Prisma.userDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userDeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>[]
          }
          delete: {
            args: Prisma.userDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>
          }
          update: {
            args: Prisma.userDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>
          }
          deleteMany: {
            args: Prisma.userDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userDeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>[]
          }
          upsert: {
            args: Prisma.userDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userDevicePayload>
          }
          aggregate: {
            args: Prisma.UserDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDevice>
          }
          groupBy: {
            args: Prisma.userDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.userDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceCountAggregateOutputType> | number
          }
        }
      }
      userSkill: {
        payload: Prisma.$userSkillPayload<ExtArgs>
        fields: Prisma.userSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>
          }
          findFirst: {
            args: Prisma.userSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>
          }
          findMany: {
            args: Prisma.userSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>[]
          }
          create: {
            args: Prisma.userSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>
          }
          createMany: {
            args: Prisma.userSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>[]
          }
          delete: {
            args: Prisma.userSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>
          }
          update: {
            args: Prisma.userSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>
          }
          deleteMany: {
            args: Prisma.userSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>[]
          }
          upsert: {
            args: Prisma.userSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userSkillPayload>
          }
          aggregate: {
            args: Prisma.UserSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkill>
          }
          groupBy: {
            args: Prisma.userSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.userSkillCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkillCountAggregateOutputType> | number
          }
        }
      }
      userStatistics: {
        payload: Prisma.$userStatisticsPayload<ExtArgs>
        fields: Prisma.userStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>
          }
          findFirst: {
            args: Prisma.userStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>
          }
          findMany: {
            args: Prisma.userStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>[]
          }
          create: {
            args: Prisma.userStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>
          }
          createMany: {
            args: Prisma.userStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>[]
          }
          delete: {
            args: Prisma.userStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>
          }
          update: {
            args: Prisma.userStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.userStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userStatisticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>[]
          }
          upsert: {
            args: Prisma.userStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userStatisticsPayload>
          }
          aggregate: {
            args: Prisma.UserStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStatistics>
          }
          groupBy: {
            args: Prisma.userStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.userStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<UserStatisticsCountAggregateOutputType> | number
          }
        }
      }
      videoCall: {
        payload: Prisma.$videoCallPayload<ExtArgs>
        fields: Prisma.videoCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videoCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videoCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>
          }
          findFirst: {
            args: Prisma.videoCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videoCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>
          }
          findMany: {
            args: Prisma.videoCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>[]
          }
          create: {
            args: Prisma.videoCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>
          }
          createMany: {
            args: Prisma.videoCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.videoCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>[]
          }
          delete: {
            args: Prisma.videoCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>
          }
          update: {
            args: Prisma.videoCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>
          }
          deleteMany: {
            args: Prisma.videoCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videoCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.videoCallUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>[]
          }
          upsert: {
            args: Prisma.videoCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoCallPayload>
          }
          aggregate: {
            args: Prisma.VideoCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoCall>
          }
          groupBy: {
            args: Prisma.videoCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.videoCallCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCallCountAggregateOutputType> | number
          }
        }
      }
      wellnessBadge: {
        payload: Prisma.$wellnessBadgePayload<ExtArgs>
        fields: Prisma.wellnessBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wellnessBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wellnessBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
          }
          findFirst: {
            args: Prisma.wellnessBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wellnessBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
          }
          findMany: {
            args: Prisma.wellnessBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>[]
          }
          create: {
            args: Prisma.wellnessBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
          }
          createMany: {
            args: Prisma.wellnessBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wellnessBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>[]
          }
          delete: {
            args: Prisma.wellnessBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
          }
          update: {
            args: Prisma.wellnessBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
          }
          deleteMany: {
            args: Prisma.wellnessBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wellnessBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.wellnessBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>[]
          }
          upsert: {
            args: Prisma.wellnessBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessBadgePayload>
          }
          aggregate: {
            args: Prisma.WellnessBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessBadge>
          }
          groupBy: {
            args: Prisma.wellnessBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.wellnessBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessBadgeCountAggregateOutputType> | number
          }
        }
      }
      wellnessGoal: {
        payload: Prisma.$wellnessGoalPayload<ExtArgs>
        fields: Prisma.wellnessGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wellnessGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wellnessGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
          }
          findFirst: {
            args: Prisma.wellnessGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wellnessGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
          }
          findMany: {
            args: Prisma.wellnessGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>[]
          }
          create: {
            args: Prisma.wellnessGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
          }
          createMany: {
            args: Prisma.wellnessGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wellnessGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>[]
          }
          delete: {
            args: Prisma.wellnessGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
          }
          update: {
            args: Prisma.wellnessGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
          }
          deleteMany: {
            args: Prisma.wellnessGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wellnessGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.wellnessGoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>[]
          }
          upsert: {
            args: Prisma.wellnessGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalPayload>
          }
          aggregate: {
            args: Prisma.WellnessGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessGoal>
          }
          groupBy: {
            args: Prisma.wellnessGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.wellnessGoalCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessGoalCountAggregateOutputType> | number
          }
        }
      }
      wellnessGoalProgress: {
        payload: Prisma.$wellnessGoalProgressPayload<ExtArgs>
        fields: Prisma.wellnessGoalProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wellnessGoalProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wellnessGoalProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
          }
          findFirst: {
            args: Prisma.wellnessGoalProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wellnessGoalProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
          }
          findMany: {
            args: Prisma.wellnessGoalProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>[]
          }
          create: {
            args: Prisma.wellnessGoalProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
          }
          createMany: {
            args: Prisma.wellnessGoalProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wellnessGoalProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>[]
          }
          delete: {
            args: Prisma.wellnessGoalProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
          }
          update: {
            args: Prisma.wellnessGoalProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
          }
          deleteMany: {
            args: Prisma.wellnessGoalProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wellnessGoalProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.wellnessGoalProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>[]
          }
          upsert: {
            args: Prisma.wellnessGoalProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessGoalProgressPayload>
          }
          aggregate: {
            args: Prisma.WellnessGoalProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessGoalProgress>
          }
          groupBy: {
            args: Prisma.wellnessGoalProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessGoalProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.wellnessGoalProgressCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessGoalProgressCountAggregateOutputType> | number
          }
        }
      }
      activityCategory: {
        payload: Prisma.$activityCategoryPayload<ExtArgs>
        fields: Prisma.activityCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activityCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activityCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>
          }
          findFirst: {
            args: Prisma.activityCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activityCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>
          }
          findMany: {
            args: Prisma.activityCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>[]
          }
          create: {
            args: Prisma.activityCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>
          }
          createMany: {
            args: Prisma.activityCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activityCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>[]
          }
          delete: {
            args: Prisma.activityCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>
          }
          update: {
            args: Prisma.activityCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>
          }
          deleteMany: {
            args: Prisma.activityCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activityCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.activityCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>[]
          }
          upsert: {
            args: Prisma.activityCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityCategoryPayload>
          }
          aggregate: {
            args: Prisma.ActivityCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityCategory>
          }
          groupBy: {
            args: Prisma.activityCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.activityCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCategoryCountAggregateOutputType> | number
          }
        }
      }
      badgeCategory: {
        payload: Prisma.$badgeCategoryPayload<ExtArgs>
        fields: Prisma.badgeCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.badgeCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.badgeCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>
          }
          findFirst: {
            args: Prisma.badgeCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.badgeCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>
          }
          findMany: {
            args: Prisma.badgeCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>[]
          }
          create: {
            args: Prisma.badgeCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>
          }
          createMany: {
            args: Prisma.badgeCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.badgeCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>[]
          }
          delete: {
            args: Prisma.badgeCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>
          }
          update: {
            args: Prisma.badgeCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>
          }
          deleteMany: {
            args: Prisma.badgeCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.badgeCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.badgeCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>[]
          }
          upsert: {
            args: Prisma.badgeCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgeCategoryPayload>
          }
          aggregate: {
            args: Prisma.BadgeCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadgeCategory>
          }
          groupBy: {
            args: Prisma.badgeCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.badgeCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCategoryCountAggregateOutputType> | number
          }
        }
      }
      cognitiveCategory: {
        payload: Prisma.$cognitiveCategoryPayload<ExtArgs>
        fields: Prisma.cognitiveCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cognitiveCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cognitiveCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>
          }
          findFirst: {
            args: Prisma.cognitiveCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cognitiveCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>
          }
          findMany: {
            args: Prisma.cognitiveCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>[]
          }
          create: {
            args: Prisma.cognitiveCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>
          }
          createMany: {
            args: Prisma.cognitiveCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cognitiveCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>[]
          }
          delete: {
            args: Prisma.cognitiveCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>
          }
          update: {
            args: Prisma.cognitiveCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>
          }
          deleteMany: {
            args: Prisma.cognitiveCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cognitiveCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cognitiveCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>[]
          }
          upsert: {
            args: Prisma.cognitiveCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cognitiveCategoryPayload>
          }
          aggregate: {
            args: Prisma.CognitiveCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCognitiveCategory>
          }
          groupBy: {
            args: Prisma.cognitiveCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CognitiveCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.cognitiveCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CognitiveCategoryCountAggregateOutputType> | number
          }
        }
      }
      helpCategory: {
        payload: Prisma.$helpCategoryPayload<ExtArgs>
        fields: Prisma.helpCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.helpCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.helpCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>
          }
          findFirst: {
            args: Prisma.helpCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.helpCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>
          }
          findMany: {
            args: Prisma.helpCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>[]
          }
          create: {
            args: Prisma.helpCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>
          }
          createMany: {
            args: Prisma.helpCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.helpCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>[]
          }
          delete: {
            args: Prisma.helpCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>
          }
          update: {
            args: Prisma.helpCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>
          }
          deleteMany: {
            args: Prisma.helpCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.helpCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.helpCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>[]
          }
          upsert: {
            args: Prisma.helpCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helpCategoryPayload>
          }
          aggregate: {
            args: Prisma.HelpCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpCategory>
          }
          groupBy: {
            args: Prisma.helpCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.helpCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryCountAggregateOutputType> | number
          }
        }
      }
      issueCategory: {
        payload: Prisma.$issueCategoryPayload<ExtArgs>
        fields: Prisma.issueCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.issueCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.issueCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>
          }
          findFirst: {
            args: Prisma.issueCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.issueCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>
          }
          findMany: {
            args: Prisma.issueCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>[]
          }
          create: {
            args: Prisma.issueCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>
          }
          createMany: {
            args: Prisma.issueCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.issueCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>[]
          }
          delete: {
            args: Prisma.issueCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>
          }
          update: {
            args: Prisma.issueCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>
          }
          deleteMany: {
            args: Prisma.issueCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.issueCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.issueCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>[]
          }
          upsert: {
            args: Prisma.issueCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issueCategoryPayload>
          }
          aggregate: {
            args: Prisma.IssueCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssueCategory>
          }
          groupBy: {
            args: Prisma.issueCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssueCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.issueCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<IssueCategoryCountAggregateOutputType> | number
          }
        }
      }
      nutritionalCategory: {
        payload: Prisma.$nutritionalCategoryPayload<ExtArgs>
        fields: Prisma.nutritionalCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.nutritionalCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.nutritionalCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>
          }
          findFirst: {
            args: Prisma.nutritionalCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.nutritionalCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>
          }
          findMany: {
            args: Prisma.nutritionalCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>[]
          }
          create: {
            args: Prisma.nutritionalCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>
          }
          createMany: {
            args: Prisma.nutritionalCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.nutritionalCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>[]
          }
          delete: {
            args: Prisma.nutritionalCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>
          }
          update: {
            args: Prisma.nutritionalCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>
          }
          deleteMany: {
            args: Prisma.nutritionalCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.nutritionalCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.nutritionalCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>[]
          }
          upsert: {
            args: Prisma.nutritionalCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nutritionalCategoryPayload>
          }
          aggregate: {
            args: Prisma.NutritionalCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionalCategory>
          }
          groupBy: {
            args: Prisma.nutritionalCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionalCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.nutritionalCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionalCategoryCountAggregateOutputType> | number
          }
        }
      }
      programCategory: {
        payload: Prisma.$programCategoryPayload<ExtArgs>
        fields: Prisma.programCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.programCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.programCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>
          }
          findFirst: {
            args: Prisma.programCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.programCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>
          }
          findMany: {
            args: Prisma.programCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>[]
          }
          create: {
            args: Prisma.programCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>
          }
          createMany: {
            args: Prisma.programCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.programCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>[]
          }
          delete: {
            args: Prisma.programCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>
          }
          update: {
            args: Prisma.programCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>
          }
          deleteMany: {
            args: Prisma.programCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.programCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.programCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>[]
          }
          upsert: {
            args: Prisma.programCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$programCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProgramCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramCategory>
          }
          groupBy: {
            args: Prisma.programCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.programCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCategoryCountAggregateOutputType> | number
          }
        }
      }
      projectCategory: {
        payload: Prisma.$projectCategoryPayload<ExtArgs>
        fields: Prisma.projectCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>
          }
          findFirst: {
            args: Prisma.projectCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>
          }
          findMany: {
            args: Prisma.projectCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>[]
          }
          create: {
            args: Prisma.projectCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>
          }
          createMany: {
            args: Prisma.projectCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>[]
          }
          delete: {
            args: Prisma.projectCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>
          }
          update: {
            args: Prisma.projectCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>
          }
          deleteMany: {
            args: Prisma.projectCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projectCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>[]
          }
          upsert: {
            args: Prisma.projectCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProjectCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectCategory>
          }
          groupBy: {
            args: Prisma.projectCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCategoryCountAggregateOutputType> | number
          }
        }
      }
      resourceCategory: {
        payload: Prisma.$resourceCategoryPayload<ExtArgs>
        fields: Prisma.resourceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resourceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resourceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>
          }
          findFirst: {
            args: Prisma.resourceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resourceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>
          }
          findMany: {
            args: Prisma.resourceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>[]
          }
          create: {
            args: Prisma.resourceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>
          }
          createMany: {
            args: Prisma.resourceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.resourceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>[]
          }
          delete: {
            args: Prisma.resourceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>
          }
          update: {
            args: Prisma.resourceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.resourceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resourceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.resourceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.resourceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ResourceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceCategory>
          }
          groupBy: {
            args: Prisma.resourceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.resourceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCategoryCountAggregateOutputType> | number
          }
        }
      }
      serviceCategory: {
        payload: Prisma.$serviceCategoryPayload<ExtArgs>
        fields: Prisma.serviceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>
          }
          findFirst: {
            args: Prisma.serviceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>
          }
          findMany: {
            args: Prisma.serviceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>[]
          }
          create: {
            args: Prisma.serviceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>
          }
          createMany: {
            args: Prisma.serviceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.serviceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>[]
          }
          delete: {
            args: Prisma.serviceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>
          }
          update: {
            args: Prisma.serviceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.serviceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.serviceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.serviceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.serviceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      skillCategory: {
        payload: Prisma.$skillCategoryPayload<ExtArgs>
        fields: Prisma.skillCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skillCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skillCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>
          }
          findFirst: {
            args: Prisma.skillCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skillCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>
          }
          findMany: {
            args: Prisma.skillCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>[]
          }
          create: {
            args: Prisma.skillCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>
          }
          createMany: {
            args: Prisma.skillCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.skillCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>[]
          }
          delete: {
            args: Prisma.skillCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>
          }
          update: {
            args: Prisma.skillCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>
          }
          deleteMany: {
            args: Prisma.skillCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skillCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.skillCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>[]
          }
          upsert: {
            args: Prisma.skillCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillCategoryPayload>
          }
          aggregate: {
            args: Prisma.SkillCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillCategory>
          }
          groupBy: {
            args: Prisma.skillCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.skillCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCategoryCountAggregateOutputType> | number
          }
        }
      }
      wellnessCategory: {
        payload: Prisma.$wellnessCategoryPayload<ExtArgs>
        fields: Prisma.wellnessCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wellnessCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wellnessCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>
          }
          findFirst: {
            args: Prisma.wellnessCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wellnessCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>
          }
          findMany: {
            args: Prisma.wellnessCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>[]
          }
          create: {
            args: Prisma.wellnessCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>
          }
          createMany: {
            args: Prisma.wellnessCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wellnessCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>[]
          }
          delete: {
            args: Prisma.wellnessCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>
          }
          update: {
            args: Prisma.wellnessCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>
          }
          deleteMany: {
            args: Prisma.wellnessCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wellnessCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.wellnessCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>[]
          }
          upsert: {
            args: Prisma.wellnessCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wellnessCategoryPayload>
          }
          aggregate: {
            args: Prisma.WellnessCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessCategory>
          }
          groupBy: {
            args: Prisma.wellnessCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.wellnessCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessCategoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activity?: activityOmit
    activityLog?: activityLogOmit
    activityRegistration?: activityRegistrationOmit
    badge?: badgeOmit
    cognitiveExercise?: cognitiveExerciseOmit
    collaborativeProject?: collaborativeProjectOmit
    conversation?: conversationOmit
    conversationParticipant?: conversationParticipantOmit
    exerciseProgram?: exerciseProgramOmit
    forumCategory?: forumCategoryOmit
    forumMessage?: forumMessageOmit
    forumTopic?: forumTopicOmit
    healthIndicator?: healthIndicatorOmit
    helpOffer?: helpOfferOmit
    helpRequest?: helpRequestOmit
    localService?: localServiceOmit
    medicationReminder?: medicationReminderOmit
    message?: messageOmit
    municipalEvent?: municipalEventOmit
    notification?: notificationOmit
    notificationPreferences?: notificationPreferencesOmit
    nutritionalAdvice?: nutritionalAdviceOmit
    projectMember?: projectMemberOmit
    projectTask?: projectTaskOmit
    resource?: resourceOmit
    satisfactionSurvey?: satisfactionSurveyOmit
    session?: sessionOmit
    serviceCompleted?: serviceCompletedOmit
    serviceRating?: serviceRatingOmit
    skill?: skillOmit
    surveyResponse?: surveyResponseOmit
    trustCircle?: trustCircleOmit
    trustedContact?: trustedContactOmit
    urbanIssueReport?: urbanIssueReportOmit
    user?: userOmit
    userActivity?: userActivityOmit
    userBadge?: userBadgeOmit
    userDevice?: userDeviceOmit
    userSkill?: userSkillOmit
    userStatistics?: userStatisticsOmit
    videoCall?: videoCallOmit
    wellnessBadge?: wellnessBadgeOmit
    wellnessGoal?: wellnessGoalOmit
    wellnessGoalProgress?: wellnessGoalProgressOmit
    activityCategory?: activityCategoryOmit
    badgeCategory?: badgeCategoryOmit
    cognitiveCategory?: cognitiveCategoryOmit
    helpCategory?: helpCategoryOmit
    issueCategory?: issueCategoryOmit
    nutritionalCategory?: nutritionalCategoryOmit
    programCategory?: programCategoryOmit
    projectCategory?: projectCategoryOmit
    resourceCategory?: resourceCategoryOmit
    serviceCategory?: serviceCategoryOmit
    skillCategory?: skillCategoryOmit
    wellnessCategory?: wellnessCategoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    activity_registration: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_registration?: boolean | ActivityCountOutputTypeCountActivity_registrationArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountActivity_registrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityRegistrationWhereInput
  }


  /**
   * Count Type CognitiveExerciseCountOutputType
   */

  export type CognitiveExerciseCountOutputType = {
    userActivity: number
  }

  export type CognitiveExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userActivity?: boolean | CognitiveExerciseCountOutputTypeCountUserActivityArgs
  }

  // Custom InputTypes
  /**
   * CognitiveExerciseCountOutputType without action
   */
  export type CognitiveExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CognitiveExerciseCountOutputType
     */
    select?: CognitiveExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CognitiveExerciseCountOutputType without action
   */
  export type CognitiveExerciseCountOutputTypeCountUserActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userActivityWhereInput
  }


  /**
   * Count Type CollaborativeProjectCountOutputType
   */

  export type CollaborativeProjectCountOutputType = {
    projectMember: number
    projectTask: number
  }

  export type CollaborativeProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectMember?: boolean | CollaborativeProjectCountOutputTypeCountProjectMemberArgs
    projectTask?: boolean | CollaborativeProjectCountOutputTypeCountProjectTaskArgs
  }

  // Custom InputTypes
  /**
   * CollaborativeProjectCountOutputType without action
   */
  export type CollaborativeProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaborativeProjectCountOutputType
     */
    select?: CollaborativeProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollaborativeProjectCountOutputType without action
   */
  export type CollaborativeProjectCountOutputTypeCountProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectMemberWhereInput
  }

  /**
   * CollaborativeProjectCountOutputType without action
   */
  export type CollaborativeProjectCountOutputTypeCountProjectTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectTaskWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    conversationParticipant: number
    message: number
    videoCall: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversationParticipant?: boolean | ConversationCountOutputTypeCountConversationParticipantArgs
    message?: boolean | ConversationCountOutputTypeCountMessageArgs
    videoCall?: boolean | ConversationCountOutputTypeCountVideoCallArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountVideoCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videoCallWhereInput
  }


  /**
   * Count Type ExerciseProgramCountOutputType
   */

  export type ExerciseProgramCountOutputType = {
    userActivity: number
  }

  export type ExerciseProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userActivity?: boolean | ExerciseProgramCountOutputTypeCountUserActivityArgs
  }

  // Custom InputTypes
  /**
   * ExerciseProgramCountOutputType without action
   */
  export type ExerciseProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseProgramCountOutputType
     */
    select?: ExerciseProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseProgramCountOutputType without action
   */
  export type ExerciseProgramCountOutputTypeCountUserActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userActivityWhereInput
  }


  /**
   * Count Type ForumCategoryCountOutputType
   */

  export type ForumCategoryCountOutputType = {
    forumTopic: number
  }

  export type ForumCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumTopic?: boolean | ForumCategoryCountOutputTypeCountForumTopicArgs
  }

  // Custom InputTypes
  /**
   * ForumCategoryCountOutputType without action
   */
  export type ForumCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategoryCountOutputType
     */
    select?: ForumCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumCategoryCountOutputType without action
   */
  export type ForumCategoryCountOutputTypeCountForumTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forumTopicWhereInput
  }


  /**
   * Count Type ForumTopicCountOutputType
   */

  export type ForumTopicCountOutputType = {
    forumMessage: number
  }

  export type ForumTopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumMessage?: boolean | ForumTopicCountOutputTypeCountForumMessageArgs
  }

  // Custom InputTypes
  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicCountOutputType
     */
    select?: ForumTopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeCountForumMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forumMessageWhereInput
  }


  /**
   * Count Type HelpRequestCountOutputType
   */

  export type HelpRequestCountOutputType = {
    helpOffer: number
    serviceCompleted: number
  }

  export type HelpRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpOffer?: boolean | HelpRequestCountOutputTypeCountHelpOfferArgs
    serviceCompleted?: boolean | HelpRequestCountOutputTypeCountServiceCompletedArgs
  }

  // Custom InputTypes
  /**
   * HelpRequestCountOutputType without action
   */
  export type HelpRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequestCountOutputType
     */
    select?: HelpRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpRequestCountOutputType without action
   */
  export type HelpRequestCountOutputTypeCountHelpOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helpOfferWhereInput
  }

  /**
   * HelpRequestCountOutputType without action
   */
  export type HelpRequestCountOutputTypeCountServiceCompletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceCompletedWhereInput
  }


  /**
   * Count Type LocalServiceCountOutputType
   */

  export type LocalServiceCountOutputType = {
    serviceRating: number
  }

  export type LocalServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceRating?: boolean | LocalServiceCountOutputTypeCountServiceRatingArgs
  }

  // Custom InputTypes
  /**
   * LocalServiceCountOutputType without action
   */
  export type LocalServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalServiceCountOutputType
     */
    select?: LocalServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalServiceCountOutputType without action
   */
  export type LocalServiceCountOutputTypeCountServiceRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceRatingWhereInput
  }


  /**
   * Count Type SatisfactionSurveyCountOutputType
   */

  export type SatisfactionSurveyCountOutputType = {
    surveyResponse: number
  }

  export type SatisfactionSurveyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyResponse?: boolean | SatisfactionSurveyCountOutputTypeCountSurveyResponseArgs
  }

  // Custom InputTypes
  /**
   * SatisfactionSurveyCountOutputType without action
   */
  export type SatisfactionSurveyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SatisfactionSurveyCountOutputType
     */
    select?: SatisfactionSurveyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SatisfactionSurveyCountOutputType without action
   */
  export type SatisfactionSurveyCountOutputTypeCountSurveyResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyResponseWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    userSkill: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkill?: boolean | SkillCountOutputTypeCountUserSkillArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountUserSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userSkillWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activity: number
    activityLog: number
    activityRegistration: number
    collaborativeProject: number
    conversationParticipant: number
    forumMessage: number
    forumTopic: number
    healthIndicator: number
    helpOffer: number
    helpRequest: number
    medicationReminder: number
    message: number
    notification: number
    projectMember: number
    projectTask: number
    resource: number
    serviceCompleted: number
    serviceRating: number
    surveyResponse: number
    trustedContact: number
    urbanIssueReport: number
    userActivity: number
    userBadge: number
    userDevice: number
    userSkill: number
    videoCall: number
    wellnessGoal: number
    session: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | UserCountOutputTypeCountActivityArgs
    activityLog?: boolean | UserCountOutputTypeCountActivityLogArgs
    activityRegistration?: boolean | UserCountOutputTypeCountActivityRegistrationArgs
    collaborativeProject?: boolean | UserCountOutputTypeCountCollaborativeProjectArgs
    conversationParticipant?: boolean | UserCountOutputTypeCountConversationParticipantArgs
    forumMessage?: boolean | UserCountOutputTypeCountForumMessageArgs
    forumTopic?: boolean | UserCountOutputTypeCountForumTopicArgs
    healthIndicator?: boolean | UserCountOutputTypeCountHealthIndicatorArgs
    helpOffer?: boolean | UserCountOutputTypeCountHelpOfferArgs
    helpRequest?: boolean | UserCountOutputTypeCountHelpRequestArgs
    medicationReminder?: boolean | UserCountOutputTypeCountMedicationReminderArgs
    message?: boolean | UserCountOutputTypeCountMessageArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    projectMember?: boolean | UserCountOutputTypeCountProjectMemberArgs
    projectTask?: boolean | UserCountOutputTypeCountProjectTaskArgs
    resource?: boolean | UserCountOutputTypeCountResourceArgs
    serviceCompleted?: boolean | UserCountOutputTypeCountServiceCompletedArgs
    serviceRating?: boolean | UserCountOutputTypeCountServiceRatingArgs
    surveyResponse?: boolean | UserCountOutputTypeCountSurveyResponseArgs
    trustedContact?: boolean | UserCountOutputTypeCountTrustedContactArgs
    urbanIssueReport?: boolean | UserCountOutputTypeCountUrbanIssueReportArgs
    userActivity?: boolean | UserCountOutputTypeCountUserActivityArgs
    userBadge?: boolean | UserCountOutputTypeCountUserBadgeArgs
    userDevice?: boolean | UserCountOutputTypeCountUserDeviceArgs
    userSkill?: boolean | UserCountOutputTypeCountUserSkillArgs
    videoCall?: boolean | UserCountOutputTypeCountVideoCallArgs
    wellnessGoal?: boolean | UserCountOutputTypeCountWellnessGoalArgs
    session?: boolean | UserCountOutputTypeCountSessionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityRegistrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollaborativeProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collaborativeProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forumMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forumTopicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHealthIndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: healthIndicatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelpOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helpOfferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelpRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helpRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMedicationReminderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicationReminderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceCompletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceCompletedWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSurveyResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrustedContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trustedContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUrbanIssueReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: urbanIssueReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userDeviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userSkillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideoCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videoCallWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWellnessGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessGoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
  }


  /**
   * Count Type WellnessGoalCountOutputType
   */

  export type WellnessGoalCountOutputType = {
    wellnessGoalProgress: number
  }

  export type WellnessGoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessGoalProgress?: boolean | WellnessGoalCountOutputTypeCountWellnessGoalProgressArgs
  }

  // Custom InputTypes
  /**
   * WellnessGoalCountOutputType without action
   */
  export type WellnessGoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGoalCountOutputType
     */
    select?: WellnessGoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WellnessGoalCountOutputType without action
   */
  export type WellnessGoalCountOutputTypeCountWellnessGoalProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessGoalProgressWhereInput
  }


  /**
   * Count Type ActivityCategoryCountOutputType
   */

  export type ActivityCategoryCountOutputType = {
    activity: number
  }

  export type ActivityCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityCategoryCountOutputTypeCountActivityArgs
  }

  // Custom InputTypes
  /**
   * ActivityCategoryCountOutputType without action
   */
  export type ActivityCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategoryCountOutputType
     */
    select?: ActivityCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCategoryCountOutputType without action
   */
  export type ActivityCategoryCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityWhereInput
  }


  /**
   * Count Type BadgeCategoryCountOutputType
   */

  export type BadgeCategoryCountOutputType = {
    badge: number
  }

  export type BadgeCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeCategoryCountOutputTypeCountBadgeArgs
  }

  // Custom InputTypes
  /**
   * BadgeCategoryCountOutputType without action
   */
  export type BadgeCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCategoryCountOutputType
     */
    select?: BadgeCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCategoryCountOutputType without action
   */
  export type BadgeCategoryCountOutputTypeCountBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgeWhereInput
  }


  /**
   * Count Type CognitiveCategoryCountOutputType
   */

  export type CognitiveCategoryCountOutputType = {
    cognitiveExercise: number
  }

  export type CognitiveCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveExercise?: boolean | CognitiveCategoryCountOutputTypeCountCognitiveExerciseArgs
  }

  // Custom InputTypes
  /**
   * CognitiveCategoryCountOutputType without action
   */
  export type CognitiveCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CognitiveCategoryCountOutputType
     */
    select?: CognitiveCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CognitiveCategoryCountOutputType without action
   */
  export type CognitiveCategoryCountOutputTypeCountCognitiveExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cognitiveExerciseWhereInput
  }


  /**
   * Count Type HelpCategoryCountOutputType
   */

  export type HelpCategoryCountOutputType = {
    helpRequest: number
  }

  export type HelpCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpRequest?: boolean | HelpCategoryCountOutputTypeCountHelpRequestArgs
  }

  // Custom InputTypes
  /**
   * HelpCategoryCountOutputType without action
   */
  export type HelpCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryCountOutputType
     */
    select?: HelpCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpCategoryCountOutputType without action
   */
  export type HelpCategoryCountOutputTypeCountHelpRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helpRequestWhereInput
  }


  /**
   * Count Type IssueCategoryCountOutputType
   */

  export type IssueCategoryCountOutputType = {
    urbanIssueReport: number
  }

  export type IssueCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    urbanIssueReport?: boolean | IssueCategoryCountOutputTypeCountUrbanIssueReportArgs
  }

  // Custom InputTypes
  /**
   * IssueCategoryCountOutputType without action
   */
  export type IssueCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueCategoryCountOutputType
     */
    select?: IssueCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IssueCategoryCountOutputType without action
   */
  export type IssueCategoryCountOutputTypeCountUrbanIssueReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: urbanIssueReportWhereInput
  }


  /**
   * Count Type NutritionalCategoryCountOutputType
   */

  export type NutritionalCategoryCountOutputType = {
    nutritionalAdvice: number
  }

  export type NutritionalCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionalAdvice?: boolean | NutritionalCategoryCountOutputTypeCountNutritionalAdviceArgs
  }

  // Custom InputTypes
  /**
   * NutritionalCategoryCountOutputType without action
   */
  export type NutritionalCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCategoryCountOutputType
     */
    select?: NutritionalCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NutritionalCategoryCountOutputType without action
   */
  export type NutritionalCategoryCountOutputTypeCountNutritionalAdviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: nutritionalAdviceWhereInput
  }


  /**
   * Count Type ProgramCategoryCountOutputType
   */

  export type ProgramCategoryCountOutputType = {
    cognitiveExercise: number
    exerciseProgram: number
  }

  export type ProgramCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveExercise?: boolean | ProgramCategoryCountOutputTypeCountCognitiveExerciseArgs
    exerciseProgram?: boolean | ProgramCategoryCountOutputTypeCountExerciseProgramArgs
  }

  // Custom InputTypes
  /**
   * ProgramCategoryCountOutputType without action
   */
  export type ProgramCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCategoryCountOutputType
     */
    select?: ProgramCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCategoryCountOutputType without action
   */
  export type ProgramCategoryCountOutputTypeCountCognitiveExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cognitiveExerciseWhereInput
  }

  /**
   * ProgramCategoryCountOutputType without action
   */
  export type ProgramCategoryCountOutputTypeCountExerciseProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exerciseProgramWhereInput
  }


  /**
   * Count Type ProjectCategoryCountOutputType
   */

  export type ProjectCategoryCountOutputType = {
    collaborativeProject: number
  }

  export type ProjectCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborativeProject?: boolean | ProjectCategoryCountOutputTypeCountCollaborativeProjectArgs
  }

  // Custom InputTypes
  /**
   * ProjectCategoryCountOutputType without action
   */
  export type ProjectCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCategoryCountOutputType
     */
    select?: ProjectCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCategoryCountOutputType without action
   */
  export type ProjectCategoryCountOutputTypeCountCollaborativeProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collaborativeProjectWhereInput
  }


  /**
   * Count Type ResourceCategoryCountOutputType
   */

  export type ResourceCategoryCountOutputType = {
    resource: number
  }

  export type ResourceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceCategoryCountOutputTypeCountResourceArgs
  }

  // Custom InputTypes
  /**
   * ResourceCategoryCountOutputType without action
   */
  export type ResourceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCategoryCountOutputType
     */
    select?: ResourceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCategoryCountOutputType without action
   */
  export type ResourceCategoryCountOutputTypeCountResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourceWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    localService: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localService?: boolean | ServiceCategoryCountOutputTypeCountLocalServiceArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountLocalServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localServiceWhereInput
  }


  /**
   * Count Type SkillCategoryCountOutputType
   */

  export type SkillCategoryCountOutputType = {
    skill: number
  }

  export type SkillCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillCategoryCountOutputTypeCountSkillArgs
  }

  // Custom InputTypes
  /**
   * SkillCategoryCountOutputType without action
   */
  export type SkillCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategoryCountOutputType
     */
    select?: SkillCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCategoryCountOutputType without action
   */
  export type SkillCategoryCountOutputTypeCountSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillWhereInput
  }


  /**
   * Count Type WellnessCategoryCountOutputType
   */

  export type WellnessCategoryCountOutputType = {
    wellnessBadge: number
    wellnessGoal: number
  }

  export type WellnessCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessBadge?: boolean | WellnessCategoryCountOutputTypeCountWellnessBadgeArgs
    wellnessGoal?: boolean | WellnessCategoryCountOutputTypeCountWellnessGoalArgs
  }

  // Custom InputTypes
  /**
   * WellnessCategoryCountOutputType without action
   */
  export type WellnessCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessCategoryCountOutputType
     */
    select?: WellnessCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WellnessCategoryCountOutputType without action
   */
  export type WellnessCategoryCountOutputTypeCountWellnessBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessBadgeWhereInput
  }

  /**
   * WellnessCategoryCountOutputType without action
   */
  export type WellnessCategoryCountOutputTypeCountWellnessGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessGoalWhereInput
  }


  /**
   * Models
   */

  /**
   * Model activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    maxSpots: number | null
    difficultyLevel: number | null
    cost: number | null
  }

  export type ActivitySumAggregateOutputType = {
    maxSpots: number | null
    difficultyLevel: number | null
    cost: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    gpsCoordinates: string | null
    maxSpots: number | null
    categoryId: string | null
    recurring: boolean | null
    frequency: string | null
    reducedMobilityAccess: boolean | null
    difficultyLevel: number | null
    cost: number | null
    status: string | null
    weatherRequirements: string | null
    transportOptions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    gpsCoordinates: string | null
    maxSpots: number | null
    categoryId: string | null
    recurring: boolean | null
    frequency: string | null
    reducedMobilityAccess: boolean | null
    difficultyLevel: number | null
    cost: number | null
    status: string | null
    weatherRequirements: string | null
    transportOptions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    creatorId: number
    title: number
    description: number
    startDate: number
    endDate: number
    location: number
    gpsCoordinates: number
    maxSpots: number
    categoryId: number
    recurring: number
    frequency: number
    reducedMobilityAccess: number
    difficultyLevel: number
    cost: number
    status: number
    weatherRequirements: number
    transportOptions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    maxSpots?: true
    difficultyLevel?: true
    cost?: true
  }

  export type ActivitySumAggregateInputType = {
    maxSpots?: true
    difficultyLevel?: true
    cost?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    gpsCoordinates?: true
    maxSpots?: true
    categoryId?: true
    recurring?: true
    frequency?: true
    reducedMobilityAccess?: true
    difficultyLevel?: true
    cost?: true
    status?: true
    weatherRequirements?: true
    transportOptions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    gpsCoordinates?: true
    maxSpots?: true
    categoryId?: true
    recurring?: true
    frequency?: true
    reducedMobilityAccess?: true
    difficultyLevel?: true
    cost?: true
    status?: true
    weatherRequirements?: true
    transportOptions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    gpsCoordinates?: true
    maxSpots?: true
    categoryId?: true
    recurring?: true
    frequency?: true
    reducedMobilityAccess?: true
    difficultyLevel?: true
    cost?: true
    status?: true
    weatherRequirements?: true
    transportOptions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activity to aggregate.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type activityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityWhereInput
    orderBy?: activityOrderByWithAggregationInput | activityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: activityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    creatorId: string | null
    title: string
    description: string | null
    startDate: Date
    endDate: Date | null
    location: string | null
    gpsCoordinates: string | null
    maxSpots: number | null
    categoryId: string | null
    recurring: boolean | null
    frequency: string | null
    reducedMobilityAccess: boolean
    difficultyLevel: number | null
    cost: number | null
    status: string | null
    weatherRequirements: string | null
    transportOptions: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends activityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type activitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    maxSpots?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    reducedMobilityAccess?: boolean
    difficultyLevel?: boolean
    cost?: boolean
    status?: boolean
    weatherRequirements?: boolean
    transportOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | activity$userArgs<ExtArgs>
    activityCategory?: boolean | activity$activityCategoryArgs<ExtArgs>
    activity_registration?: boolean | activity$activity_registrationArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type activitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    maxSpots?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    reducedMobilityAccess?: boolean
    difficultyLevel?: boolean
    cost?: boolean
    status?: boolean
    weatherRequirements?: boolean
    transportOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | activity$userArgs<ExtArgs>
    activityCategory?: boolean | activity$activityCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type activitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    maxSpots?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    reducedMobilityAccess?: boolean
    difficultyLevel?: boolean
    cost?: boolean
    status?: boolean
    weatherRequirements?: boolean
    transportOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | activity$userArgs<ExtArgs>
    activityCategory?: boolean | activity$activityCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type activitySelectScalar = {
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    maxSpots?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    reducedMobilityAccess?: boolean
    difficultyLevel?: boolean
    cost?: boolean
    status?: boolean
    weatherRequirements?: boolean
    transportOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type activityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorId" | "title" | "description" | "startDate" | "endDate" | "location" | "gpsCoordinates" | "maxSpots" | "categoryId" | "recurring" | "frequency" | "reducedMobilityAccess" | "difficultyLevel" | "cost" | "status" | "weatherRequirements" | "transportOptions" | "createdAt" | "updatedAt", ExtArgs["result"]["activity"]>
  export type activityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activity$userArgs<ExtArgs>
    activityCategory?: boolean | activity$activityCategoryArgs<ExtArgs>
    activity_registration?: boolean | activity$activity_registrationArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type activityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activity$userArgs<ExtArgs>
    activityCategory?: boolean | activity$activityCategoryArgs<ExtArgs>
  }
  export type activityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activity$userArgs<ExtArgs>
    activityCategory?: boolean | activity$activityCategoryArgs<ExtArgs>
  }

  export type $activityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activity"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      activityCategory: Prisma.$activityCategoryPayload<ExtArgs> | null
      activity_registration: Prisma.$activityRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string | null
      title: string
      description: string | null
      startDate: Date
      endDate: Date | null
      location: string | null
      gpsCoordinates: string | null
      maxSpots: number | null
      categoryId: string | null
      recurring: boolean | null
      frequency: string | null
      reducedMobilityAccess: boolean
      difficultyLevel: number | null
      cost: number | null
      status: string | null
      weatherRequirements: string | null
      transportOptions: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type activityGetPayload<S extends boolean | null | undefined | activityDefaultArgs> = $Result.GetResult<Prisma.$activityPayload, S>

  type activityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface activityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activity'], meta: { name: 'activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {activityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activityFindUniqueArgs>(args: SelectSubset<T, activityFindUniqueArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activityFindUniqueOrThrowArgs>(args: SelectSubset<T, activityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activityFindFirstArgs>(args?: SelectSubset<T, activityFindFirstArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activityFindFirstOrThrowArgs>(args?: SelectSubset<T, activityFindFirstOrThrowArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activityFindManyArgs>(args?: SelectSubset<T, activityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {activityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends activityCreateArgs>(args: SelectSubset<T, activityCreateArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {activityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activityCreateManyArgs>(args?: SelectSubset<T, activityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {activityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activityCreateManyAndReturnArgs>(args?: SelectSubset<T, activityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {activityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends activityDeleteArgs>(args: SelectSubset<T, activityDeleteArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {activityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activityUpdateArgs>(args: SelectSubset<T, activityUpdateArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {activityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activityDeleteManyArgs>(args?: SelectSubset<T, activityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activityUpdateManyArgs>(args: SelectSubset<T, activityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {activityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends activityUpdateManyAndReturnArgs>(args: SelectSubset<T, activityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {activityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends activityUpsertArgs>(args: SelectSubset<T, activityUpsertArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends activityCountArgs>(
      args?: Subset<T, activityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activityGroupByArgs['orderBy'] }
        : { orderBy?: activityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activity model
   */
  readonly fields: activityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends activity$userArgs<ExtArgs> = {}>(args?: Subset<T, activity$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activityCategory<T extends activity$activityCategoryArgs<ExtArgs> = {}>(args?: Subset<T, activity$activityCategoryArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activity_registration<T extends activity$activity_registrationArgs<ExtArgs> = {}>(args?: Subset<T, activity$activity_registrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activity model
   */
  interface activityFieldRefs {
    readonly id: FieldRef<"activity", 'String'>
    readonly creatorId: FieldRef<"activity", 'String'>
    readonly title: FieldRef<"activity", 'String'>
    readonly description: FieldRef<"activity", 'String'>
    readonly startDate: FieldRef<"activity", 'DateTime'>
    readonly endDate: FieldRef<"activity", 'DateTime'>
    readonly location: FieldRef<"activity", 'String'>
    readonly gpsCoordinates: FieldRef<"activity", 'String'>
    readonly maxSpots: FieldRef<"activity", 'Int'>
    readonly categoryId: FieldRef<"activity", 'String'>
    readonly recurring: FieldRef<"activity", 'Boolean'>
    readonly frequency: FieldRef<"activity", 'String'>
    readonly reducedMobilityAccess: FieldRef<"activity", 'Boolean'>
    readonly difficultyLevel: FieldRef<"activity", 'Int'>
    readonly cost: FieldRef<"activity", 'Float'>
    readonly status: FieldRef<"activity", 'String'>
    readonly weatherRequirements: FieldRef<"activity", 'String'>
    readonly transportOptions: FieldRef<"activity", 'String'>
    readonly createdAt: FieldRef<"activity", 'DateTime'>
    readonly updatedAt: FieldRef<"activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activity findUnique
   */
  export type activityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity findUniqueOrThrow
   */
  export type activityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity findFirst
   */
  export type activityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activities.
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * activity findFirstOrThrow
   */
  export type activityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activities.
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * activity findMany
   */
  export type activityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activities to fetch.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activities.
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * activity create
   */
  export type activityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * The data needed to create a activity.
     */
    data: XOR<activityCreateInput, activityUncheckedCreateInput>
  }

  /**
   * activity createMany
   */
  export type activityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activities.
     */
    data: activityCreateManyInput | activityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activity createManyAndReturn
   */
  export type activityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * The data used to create many activities.
     */
    data: activityCreateManyInput | activityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * activity update
   */
  export type activityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * The data needed to update a activity.
     */
    data: XOR<activityUpdateInput, activityUncheckedUpdateInput>
    /**
     * Choose, which activity to update.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity updateMany
   */
  export type activityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activities.
     */
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyInput>
    /**
     * Filter which activities to update
     */
    where?: activityWhereInput
    /**
     * Limit how many activities to update.
     */
    limit?: number
  }

  /**
   * activity updateManyAndReturn
   */
  export type activityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * The data used to update activities.
     */
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyInput>
    /**
     * Filter which activities to update
     */
    where?: activityWhereInput
    /**
     * Limit how many activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * activity upsert
   */
  export type activityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * The filter to search for the activity to update in case it exists.
     */
    where: activityWhereUniqueInput
    /**
     * In case the activity found by the `where` argument doesn't exist, create a new activity with this data.
     */
    create: XOR<activityCreateInput, activityUncheckedCreateInput>
    /**
     * In case the activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activityUpdateInput, activityUncheckedUpdateInput>
  }

  /**
   * activity delete
   */
  export type activityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter which activity to delete.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity deleteMany
   */
  export type activityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activities to delete
     */
    where?: activityWhereInput
    /**
     * Limit how many activities to delete.
     */
    limit?: number
  }

  /**
   * activity.user
   */
  export type activity$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * activity.activityCategory
   */
  export type activity$activityCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    where?: activityCategoryWhereInput
  }

  /**
   * activity.activity_registration
   */
  export type activity$activity_registrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    where?: activityRegistrationWhereInput
    orderBy?: activityRegistrationOrderByWithRelationInput | activityRegistrationOrderByWithRelationInput[]
    cursor?: activityRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityRegistrationScalarFieldEnum | ActivityRegistrationScalarFieldEnum[]
  }

  /**
   * activity without action
   */
  export type activityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
  }


  /**
   * Model activityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    actionType: string | null
    description: string | null
    ipAddress: string | null
    device: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    actionType: string | null
    description: string | null
    ipAddress: string | null
    device: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    actionType: number
    description: number
    ipAddress: number
    device: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    description?: true
    ipAddress?: true
    device?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    description?: true
    ipAddress?: true
    device?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    description?: true
    ipAddress?: true
    device?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activityLog to aggregate.
     */
    where?: activityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityLogs to fetch.
     */
    orderBy?: activityLogOrderByWithRelationInput | activityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type activityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityLogWhereInput
    orderBy?: activityLogOrderByWithAggregationInput | activityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: activityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string | null
    actionType: string | null
    description: string | null
    ipAddress: string | null
    device: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends activityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type activityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actionType?: boolean
    description?: boolean
    ipAddress?: boolean
    device?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | activityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type activityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actionType?: boolean
    description?: boolean
    ipAddress?: boolean
    device?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | activityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type activityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actionType?: boolean
    description?: boolean
    ipAddress?: boolean
    device?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | activityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type activityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    actionType?: boolean
    description?: boolean
    ipAddress?: boolean
    device?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type activityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "actionType" | "description" | "ipAddress" | "device" | "createdAt" | "updatedAt", ExtArgs["result"]["activityLog"]>
  export type activityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activityLog$userArgs<ExtArgs>
  }
  export type activityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activityLog$userArgs<ExtArgs>
  }
  export type activityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activityLog$userArgs<ExtArgs>
  }

  export type $activityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activityLog"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      actionType: string | null
      description: string | null
      ipAddress: string | null
      device: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type activityLogGetPayload<S extends boolean | null | undefined | activityLogDefaultArgs> = $Result.GetResult<Prisma.$activityLogPayload, S>

  type activityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface activityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activityLog'], meta: { name: 'activityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {activityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activityLogFindUniqueArgs>(args: SelectSubset<T, activityLogFindUniqueArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, activityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activityLogFindFirstArgs>(args?: SelectSubset<T, activityLogFindFirstArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, activityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activityLogFindManyArgs>(args?: SelectSubset<T, activityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {activityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends activityLogCreateArgs>(args: SelectSubset<T, activityLogCreateArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {activityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activityLogCreateManyArgs>(args?: SelectSubset<T, activityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {activityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, activityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {activityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends activityLogDeleteArgs>(args: SelectSubset<T, activityLogDeleteArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {activityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activityLogUpdateArgs>(args: SelectSubset<T, activityLogUpdateArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {activityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activityLogDeleteManyArgs>(args?: SelectSubset<T, activityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activityLogUpdateManyArgs>(args: SelectSubset<T, activityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {activityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends activityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, activityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {activityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends activityLogUpsertArgs>(args: SelectSubset<T, activityLogUpsertArgs<ExtArgs>>): Prisma__activityLogClient<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends activityLogCountArgs>(
      args?: Subset<T, activityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activityLogGroupByArgs['orderBy'] }
        : { orderBy?: activityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activityLog model
   */
  readonly fields: activityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends activityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, activityLog$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activityLog model
   */
  interface activityLogFieldRefs {
    readonly id: FieldRef<"activityLog", 'String'>
    readonly userId: FieldRef<"activityLog", 'String'>
    readonly actionType: FieldRef<"activityLog", 'String'>
    readonly description: FieldRef<"activityLog", 'String'>
    readonly ipAddress: FieldRef<"activityLog", 'String'>
    readonly device: FieldRef<"activityLog", 'String'>
    readonly createdAt: FieldRef<"activityLog", 'DateTime'>
    readonly updatedAt: FieldRef<"activityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activityLog findUnique
   */
  export type activityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * Filter, which activityLog to fetch.
     */
    where: activityLogWhereUniqueInput
  }

  /**
   * activityLog findUniqueOrThrow
   */
  export type activityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * Filter, which activityLog to fetch.
     */
    where: activityLogWhereUniqueInput
  }

  /**
   * activityLog findFirst
   */
  export type activityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * Filter, which activityLog to fetch.
     */
    where?: activityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityLogs to fetch.
     */
    orderBy?: activityLogOrderByWithRelationInput | activityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activityLogs.
     */
    cursor?: activityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * activityLog findFirstOrThrow
   */
  export type activityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * Filter, which activityLog to fetch.
     */
    where?: activityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityLogs to fetch.
     */
    orderBy?: activityLogOrderByWithRelationInput | activityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activityLogs.
     */
    cursor?: activityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * activityLog findMany
   */
  export type activityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * Filter, which activityLogs to fetch.
     */
    where?: activityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityLogs to fetch.
     */
    orderBy?: activityLogOrderByWithRelationInput | activityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activityLogs.
     */
    cursor?: activityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * activityLog create
   */
  export type activityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a activityLog.
     */
    data?: XOR<activityLogCreateInput, activityLogUncheckedCreateInput>
  }

  /**
   * activityLog createMany
   */
  export type activityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activityLogs.
     */
    data: activityLogCreateManyInput | activityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activityLog createManyAndReturn
   */
  export type activityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * The data used to create many activityLogs.
     */
    data: activityLogCreateManyInput | activityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * activityLog update
   */
  export type activityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a activityLog.
     */
    data: XOR<activityLogUpdateInput, activityLogUncheckedUpdateInput>
    /**
     * Choose, which activityLog to update.
     */
    where: activityLogWhereUniqueInput
  }

  /**
   * activityLog updateMany
   */
  export type activityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activityLogs.
     */
    data: XOR<activityLogUpdateManyMutationInput, activityLogUncheckedUpdateManyInput>
    /**
     * Filter which activityLogs to update
     */
    where?: activityLogWhereInput
    /**
     * Limit how many activityLogs to update.
     */
    limit?: number
  }

  /**
   * activityLog updateManyAndReturn
   */
  export type activityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * The data used to update activityLogs.
     */
    data: XOR<activityLogUpdateManyMutationInput, activityLogUncheckedUpdateManyInput>
    /**
     * Filter which activityLogs to update
     */
    where?: activityLogWhereInput
    /**
     * Limit how many activityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * activityLog upsert
   */
  export type activityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the activityLog to update in case it exists.
     */
    where: activityLogWhereUniqueInput
    /**
     * In case the activityLog found by the `where` argument doesn't exist, create a new activityLog with this data.
     */
    create: XOR<activityLogCreateInput, activityLogUncheckedCreateInput>
    /**
     * In case the activityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activityLogUpdateInput, activityLogUncheckedUpdateInput>
  }

  /**
   * activityLog delete
   */
  export type activityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    /**
     * Filter which activityLog to delete.
     */
    where: activityLogWhereUniqueInput
  }

  /**
   * activityLog deleteMany
   */
  export type activityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activityLogs to delete
     */
    where?: activityLogWhereInput
    /**
     * Limit how many activityLogs to delete.
     */
    limit?: number
  }

  /**
   * activityLog.user
   */
  export type activityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * activityLog without action
   */
  export type activityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
  }


  /**
   * Model activityRegistration
   */

  export type AggregateActivityRegistration = {
    _count: ActivityRegistrationCountAggregateOutputType | null
    _min: ActivityRegistrationMinAggregateOutputType | null
    _max: ActivityRegistrationMaxAggregateOutputType | null
  }

  export type ActivityRegistrationMinAggregateOutputType = {
    id: string | null
    activityId: string | null
    userId: string | null
    registrationDate: Date | null
    status: string | null
    attendanceConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityRegistrationMaxAggregateOutputType = {
    id: string | null
    activityId: string | null
    userId: string | null
    registrationDate: Date | null
    status: string | null
    attendanceConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityRegistrationCountAggregateOutputType = {
    id: number
    activityId: number
    userId: number
    registrationDate: number
    status: number
    attendanceConfirmed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityRegistrationMinAggregateInputType = {
    id?: true
    activityId?: true
    userId?: true
    registrationDate?: true
    status?: true
    attendanceConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityRegistrationMaxAggregateInputType = {
    id?: true
    activityId?: true
    userId?: true
    registrationDate?: true
    status?: true
    attendanceConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityRegistrationCountAggregateInputType = {
    id?: true
    activityId?: true
    userId?: true
    registrationDate?: true
    status?: true
    attendanceConfirmed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activityRegistration to aggregate.
     */
    where?: activityRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityRegistrations to fetch.
     */
    orderBy?: activityRegistrationOrderByWithRelationInput | activityRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activityRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activityRegistrations
    **/
    _count?: true | ActivityRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityRegistrationMaxAggregateInputType
  }

  export type GetActivityRegistrationAggregateType<T extends ActivityRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityRegistration[P]>
      : GetScalarType<T[P], AggregateActivityRegistration[P]>
  }




  export type activityRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityRegistrationWhereInput
    orderBy?: activityRegistrationOrderByWithAggregationInput | activityRegistrationOrderByWithAggregationInput[]
    by: ActivityRegistrationScalarFieldEnum[] | ActivityRegistrationScalarFieldEnum
    having?: activityRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityRegistrationCountAggregateInputType | true
    _min?: ActivityRegistrationMinAggregateInputType
    _max?: ActivityRegistrationMaxAggregateInputType
  }

  export type ActivityRegistrationGroupByOutputType = {
    id: string
    activityId: string
    userId: string
    registrationDate: Date
    status: string | null
    attendanceConfirmed: boolean | null
    createdAt: Date
    updatedAt: Date | null
    _count: ActivityRegistrationCountAggregateOutputType | null
    _min: ActivityRegistrationMinAggregateOutputType | null
    _max: ActivityRegistrationMaxAggregateOutputType | null
  }

  type GetActivityRegistrationGroupByPayload<T extends activityRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type activityRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    userId?: boolean
    registrationDate?: boolean
    status?: boolean
    attendanceConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | activityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityRegistration"]>

  export type activityRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    userId?: boolean
    registrationDate?: boolean
    status?: boolean
    attendanceConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | activityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityRegistration"]>

  export type activityRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    userId?: boolean
    registrationDate?: boolean
    status?: boolean
    attendanceConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | activityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityRegistration"]>

  export type activityRegistrationSelectScalar = {
    id?: boolean
    activityId?: boolean
    userId?: boolean
    registrationDate?: boolean
    status?: boolean
    attendanceConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type activityRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activityId" | "userId" | "registrationDate" | "status" | "attendanceConfirmed" | "createdAt" | "updatedAt", ExtArgs["result"]["activityRegistration"]>
  export type activityRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | activityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type activityRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | activityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type activityRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | activityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $activityRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activityRegistration"
    objects: {
      activity: Prisma.$activityPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activityId: string
      userId: string
      registrationDate: Date
      status: string | null
      attendanceConfirmed: boolean | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["activityRegistration"]>
    composites: {}
  }

  type activityRegistrationGetPayload<S extends boolean | null | undefined | activityRegistrationDefaultArgs> = $Result.GetResult<Prisma.$activityRegistrationPayload, S>

  type activityRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activityRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityRegistrationCountAggregateInputType | true
    }

  export interface activityRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activityRegistration'], meta: { name: 'activityRegistration' } }
    /**
     * Find zero or one ActivityRegistration that matches the filter.
     * @param {activityRegistrationFindUniqueArgs} args - Arguments to find a ActivityRegistration
     * @example
     * // Get one ActivityRegistration
     * const activityRegistration = await prisma.activityRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activityRegistrationFindUniqueArgs>(args: SelectSubset<T, activityRegistrationFindUniqueArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activityRegistrationFindUniqueOrThrowArgs} args - Arguments to find a ActivityRegistration
     * @example
     * // Get one ActivityRegistration
     * const activityRegistration = await prisma.activityRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activityRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, activityRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityRegistrationFindFirstArgs} args - Arguments to find a ActivityRegistration
     * @example
     * // Get one ActivityRegistration
     * const activityRegistration = await prisma.activityRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activityRegistrationFindFirstArgs>(args?: SelectSubset<T, activityRegistrationFindFirstArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityRegistrationFindFirstOrThrowArgs} args - Arguments to find a ActivityRegistration
     * @example
     * // Get one ActivityRegistration
     * const activityRegistration = await prisma.activityRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activityRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, activityRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityRegistrations
     * const activityRegistrations = await prisma.activityRegistration.findMany()
     * 
     * // Get first 10 ActivityRegistrations
     * const activityRegistrations = await prisma.activityRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityRegistrationWithIdOnly = await prisma.activityRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activityRegistrationFindManyArgs>(args?: SelectSubset<T, activityRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityRegistration.
     * @param {activityRegistrationCreateArgs} args - Arguments to create a ActivityRegistration.
     * @example
     * // Create one ActivityRegistration
     * const ActivityRegistration = await prisma.activityRegistration.create({
     *   data: {
     *     // ... data to create a ActivityRegistration
     *   }
     * })
     * 
     */
    create<T extends activityRegistrationCreateArgs>(args: SelectSubset<T, activityRegistrationCreateArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityRegistrations.
     * @param {activityRegistrationCreateManyArgs} args - Arguments to create many ActivityRegistrations.
     * @example
     * // Create many ActivityRegistrations
     * const activityRegistration = await prisma.activityRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activityRegistrationCreateManyArgs>(args?: SelectSubset<T, activityRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityRegistrations and returns the data saved in the database.
     * @param {activityRegistrationCreateManyAndReturnArgs} args - Arguments to create many ActivityRegistrations.
     * @example
     * // Create many ActivityRegistrations
     * const activityRegistration = await prisma.activityRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityRegistrations and only return the `id`
     * const activityRegistrationWithIdOnly = await prisma.activityRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activityRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, activityRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityRegistration.
     * @param {activityRegistrationDeleteArgs} args - Arguments to delete one ActivityRegistration.
     * @example
     * // Delete one ActivityRegistration
     * const ActivityRegistration = await prisma.activityRegistration.delete({
     *   where: {
     *     // ... filter to delete one ActivityRegistration
     *   }
     * })
     * 
     */
    delete<T extends activityRegistrationDeleteArgs>(args: SelectSubset<T, activityRegistrationDeleteArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityRegistration.
     * @param {activityRegistrationUpdateArgs} args - Arguments to update one ActivityRegistration.
     * @example
     * // Update one ActivityRegistration
     * const activityRegistration = await prisma.activityRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activityRegistrationUpdateArgs>(args: SelectSubset<T, activityRegistrationUpdateArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityRegistrations.
     * @param {activityRegistrationDeleteManyArgs} args - Arguments to filter ActivityRegistrations to delete.
     * @example
     * // Delete a few ActivityRegistrations
     * const { count } = await prisma.activityRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activityRegistrationDeleteManyArgs>(args?: SelectSubset<T, activityRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityRegistrations
     * const activityRegistration = await prisma.activityRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activityRegistrationUpdateManyArgs>(args: SelectSubset<T, activityRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityRegistrations and returns the data updated in the database.
     * @param {activityRegistrationUpdateManyAndReturnArgs} args - Arguments to update many ActivityRegistrations.
     * @example
     * // Update many ActivityRegistrations
     * const activityRegistration = await prisma.activityRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityRegistrations and only return the `id`
     * const activityRegistrationWithIdOnly = await prisma.activityRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends activityRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, activityRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityRegistration.
     * @param {activityRegistrationUpsertArgs} args - Arguments to update or create a ActivityRegistration.
     * @example
     * // Update or create a ActivityRegistration
     * const activityRegistration = await prisma.activityRegistration.upsert({
     *   create: {
     *     // ... data to create a ActivityRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityRegistration we want to update
     *   }
     * })
     */
    upsert<T extends activityRegistrationUpsertArgs>(args: SelectSubset<T, activityRegistrationUpsertArgs<ExtArgs>>): Prisma__activityRegistrationClient<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityRegistrationCountArgs} args - Arguments to filter ActivityRegistrations to count.
     * @example
     * // Count the number of ActivityRegistrations
     * const count = await prisma.activityRegistration.count({
     *   where: {
     *     // ... the filter for the ActivityRegistrations we want to count
     *   }
     * })
    **/
    count<T extends activityRegistrationCountArgs>(
      args?: Subset<T, activityRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityRegistrationAggregateArgs>(args: Subset<T, ActivityRegistrationAggregateArgs>): Prisma.PrismaPromise<GetActivityRegistrationAggregateType<T>>

    /**
     * Group by ActivityRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activityRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activityRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: activityRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activityRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activityRegistration model
   */
  readonly fields: activityRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activityRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activityRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends activityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, activityDefaultArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activityRegistration model
   */
  interface activityRegistrationFieldRefs {
    readonly id: FieldRef<"activityRegistration", 'String'>
    readonly activityId: FieldRef<"activityRegistration", 'String'>
    readonly userId: FieldRef<"activityRegistration", 'String'>
    readonly registrationDate: FieldRef<"activityRegistration", 'DateTime'>
    readonly status: FieldRef<"activityRegistration", 'String'>
    readonly attendanceConfirmed: FieldRef<"activityRegistration", 'Boolean'>
    readonly createdAt: FieldRef<"activityRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"activityRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activityRegistration findUnique
   */
  export type activityRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which activityRegistration to fetch.
     */
    where: activityRegistrationWhereUniqueInput
  }

  /**
   * activityRegistration findUniqueOrThrow
   */
  export type activityRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which activityRegistration to fetch.
     */
    where: activityRegistrationWhereUniqueInput
  }

  /**
   * activityRegistration findFirst
   */
  export type activityRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which activityRegistration to fetch.
     */
    where?: activityRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityRegistrations to fetch.
     */
    orderBy?: activityRegistrationOrderByWithRelationInput | activityRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activityRegistrations.
     */
    cursor?: activityRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activityRegistrations.
     */
    distinct?: ActivityRegistrationScalarFieldEnum | ActivityRegistrationScalarFieldEnum[]
  }

  /**
   * activityRegistration findFirstOrThrow
   */
  export type activityRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which activityRegistration to fetch.
     */
    where?: activityRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityRegistrations to fetch.
     */
    orderBy?: activityRegistrationOrderByWithRelationInput | activityRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activityRegistrations.
     */
    cursor?: activityRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activityRegistrations.
     */
    distinct?: ActivityRegistrationScalarFieldEnum | ActivityRegistrationScalarFieldEnum[]
  }

  /**
   * activityRegistration findMany
   */
  export type activityRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which activityRegistrations to fetch.
     */
    where?: activityRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityRegistrations to fetch.
     */
    orderBy?: activityRegistrationOrderByWithRelationInput | activityRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activityRegistrations.
     */
    cursor?: activityRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityRegistrations.
     */
    skip?: number
    distinct?: ActivityRegistrationScalarFieldEnum | ActivityRegistrationScalarFieldEnum[]
  }

  /**
   * activityRegistration create
   */
  export type activityRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a activityRegistration.
     */
    data: XOR<activityRegistrationCreateInput, activityRegistrationUncheckedCreateInput>
  }

  /**
   * activityRegistration createMany
   */
  export type activityRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activityRegistrations.
     */
    data: activityRegistrationCreateManyInput | activityRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activityRegistration createManyAndReturn
   */
  export type activityRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many activityRegistrations.
     */
    data: activityRegistrationCreateManyInput | activityRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * activityRegistration update
   */
  export type activityRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a activityRegistration.
     */
    data: XOR<activityRegistrationUpdateInput, activityRegistrationUncheckedUpdateInput>
    /**
     * Choose, which activityRegistration to update.
     */
    where: activityRegistrationWhereUniqueInput
  }

  /**
   * activityRegistration updateMany
   */
  export type activityRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activityRegistrations.
     */
    data: XOR<activityRegistrationUpdateManyMutationInput, activityRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which activityRegistrations to update
     */
    where?: activityRegistrationWhereInput
    /**
     * Limit how many activityRegistrations to update.
     */
    limit?: number
  }

  /**
   * activityRegistration updateManyAndReturn
   */
  export type activityRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update activityRegistrations.
     */
    data: XOR<activityRegistrationUpdateManyMutationInput, activityRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which activityRegistrations to update
     */
    where?: activityRegistrationWhereInput
    /**
     * Limit how many activityRegistrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * activityRegistration upsert
   */
  export type activityRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the activityRegistration to update in case it exists.
     */
    where: activityRegistrationWhereUniqueInput
    /**
     * In case the activityRegistration found by the `where` argument doesn't exist, create a new activityRegistration with this data.
     */
    create: XOR<activityRegistrationCreateInput, activityRegistrationUncheckedCreateInput>
    /**
     * In case the activityRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activityRegistrationUpdateInput, activityRegistrationUncheckedUpdateInput>
  }

  /**
   * activityRegistration delete
   */
  export type activityRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    /**
     * Filter which activityRegistration to delete.
     */
    where: activityRegistrationWhereUniqueInput
  }

  /**
   * activityRegistration deleteMany
   */
  export type activityRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activityRegistrations to delete
     */
    where?: activityRegistrationWhereInput
    /**
     * Limit how many activityRegistrations to delete.
     */
    limit?: number
  }

  /**
   * activityRegistration without action
   */
  export type activityRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    level: number | null
  }

  export type BadgeSumAggregateOutputType = {
    level: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    description: string | null
    icon: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    description: string | null
    icon: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    description: number
    icon: number
    level: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    level?: true
  }

  export type BadgeSumAggregateInputType = {
    level?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    description?: true
    icon?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    description?: true
    icon?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    description?: true
    icon?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badge to aggregate.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type badgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgeWhereInput
    orderBy?: badgeOrderByWithAggregationInput | badgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: badgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    categoryId: string | null
    description: string | null
    icon: string | null
    level: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends badgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type badgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    icon?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userBadge?: boolean | badge$userBadgeArgs<ExtArgs>
    badgeCategory?: boolean | badge$badgeCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type badgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    icon?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badgeCategory?: boolean | badge$badgeCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type badgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    icon?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badgeCategory?: boolean | badge$badgeCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type badgeSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    icon?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type badgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "description" | "icon" | "level" | "createdAt" | "updatedAt", ExtArgs["result"]["badge"]>
  export type badgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBadge?: boolean | badge$userBadgeArgs<ExtArgs>
    badgeCategory?: boolean | badge$badgeCategoryArgs<ExtArgs>
  }
  export type badgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badgeCategory?: boolean | badge$badgeCategoryArgs<ExtArgs>
  }
  export type badgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badgeCategory?: boolean | badge$badgeCategoryArgs<ExtArgs>
  }

  export type $badgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "badge"
    objects: {
      userBadge: Prisma.$userBadgePayload<ExtArgs> | null
      badgeCategory: Prisma.$badgeCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string | null
      description: string | null
      icon: string | null
      level: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type badgeGetPayload<S extends boolean | null | undefined | badgeDefaultArgs> = $Result.GetResult<Prisma.$badgePayload, S>

  type badgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<badgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface badgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['badge'], meta: { name: 'badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {badgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends badgeFindUniqueArgs>(args: SelectSubset<T, badgeFindUniqueArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {badgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends badgeFindUniqueOrThrowArgs>(args: SelectSubset<T, badgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends badgeFindFirstArgs>(args?: SelectSubset<T, badgeFindFirstArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends badgeFindFirstOrThrowArgs>(args?: SelectSubset<T, badgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends badgeFindManyArgs>(args?: SelectSubset<T, badgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {badgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends badgeCreateArgs>(args: SelectSubset<T, badgeCreateArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {badgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends badgeCreateManyArgs>(args?: SelectSubset<T, badgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {badgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends badgeCreateManyAndReturnArgs>(args?: SelectSubset<T, badgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {badgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends badgeDeleteArgs>(args: SelectSubset<T, badgeDeleteArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {badgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends badgeUpdateArgs>(args: SelectSubset<T, badgeUpdateArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {badgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends badgeDeleteManyArgs>(args?: SelectSubset<T, badgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends badgeUpdateManyArgs>(args: SelectSubset<T, badgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {badgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends badgeUpdateManyAndReturnArgs>(args: SelectSubset<T, badgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {badgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends badgeUpsertArgs>(args: SelectSubset<T, badgeUpsertArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends badgeCountArgs>(
      args?: Subset<T, badgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends badgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: badgeGroupByArgs['orderBy'] }
        : { orderBy?: badgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, badgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the badge model
   */
  readonly fields: badgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__badgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBadge<T extends badge$userBadgeArgs<ExtArgs> = {}>(args?: Subset<T, badge$userBadgeArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    badgeCategory<T extends badge$badgeCategoryArgs<ExtArgs> = {}>(args?: Subset<T, badge$badgeCategoryArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the badge model
   */
  interface badgeFieldRefs {
    readonly id: FieldRef<"badge", 'String'>
    readonly name: FieldRef<"badge", 'String'>
    readonly categoryId: FieldRef<"badge", 'String'>
    readonly description: FieldRef<"badge", 'String'>
    readonly icon: FieldRef<"badge", 'String'>
    readonly level: FieldRef<"badge", 'Int'>
    readonly createdAt: FieldRef<"badge", 'DateTime'>
    readonly updatedAt: FieldRef<"badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * badge findUnique
   */
  export type badgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge findUniqueOrThrow
   */
  export type badgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge findFirst
   */
  export type badgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * badge findFirstOrThrow
   */
  export type badgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * badge findMany
   */
  export type badgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing badges.
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * badge create
   */
  export type badgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * The data needed to create a badge.
     */
    data: XOR<badgeCreateInput, badgeUncheckedCreateInput>
  }

  /**
   * badge createMany
   */
  export type badgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many badges.
     */
    data: badgeCreateManyInput | badgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badge createManyAndReturn
   */
  export type badgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * The data used to create many badges.
     */
    data: badgeCreateManyInput | badgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * badge update
   */
  export type badgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * The data needed to update a badge.
     */
    data: XOR<badgeUpdateInput, badgeUncheckedUpdateInput>
    /**
     * Choose, which badge to update.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge updateMany
   */
  export type badgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update badges.
     */
    data: XOR<badgeUpdateManyMutationInput, badgeUncheckedUpdateManyInput>
    /**
     * Filter which badges to update
     */
    where?: badgeWhereInput
    /**
     * Limit how many badges to update.
     */
    limit?: number
  }

  /**
   * badge updateManyAndReturn
   */
  export type badgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * The data used to update badges.
     */
    data: XOR<badgeUpdateManyMutationInput, badgeUncheckedUpdateManyInput>
    /**
     * Filter which badges to update
     */
    where?: badgeWhereInput
    /**
     * Limit how many badges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * badge upsert
   */
  export type badgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * The filter to search for the badge to update in case it exists.
     */
    where: badgeWhereUniqueInput
    /**
     * In case the badge found by the `where` argument doesn't exist, create a new badge with this data.
     */
    create: XOR<badgeCreateInput, badgeUncheckedCreateInput>
    /**
     * In case the badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<badgeUpdateInput, badgeUncheckedUpdateInput>
  }

  /**
   * badge delete
   */
  export type badgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter which badge to delete.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge deleteMany
   */
  export type badgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges to delete
     */
    where?: badgeWhereInput
    /**
     * Limit how many badges to delete.
     */
    limit?: number
  }

  /**
   * badge.userBadge
   */
  export type badge$userBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    where?: userBadgeWhereInput
  }

  /**
   * badge.badgeCategory
   */
  export type badge$badgeCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    where?: badgeCategoryWhereInput
  }

  /**
   * badge without action
   */
  export type badgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
  }


  /**
   * Model cognitiveExercise
   */

  export type AggregateCognitiveExercise = {
    _count: CognitiveExerciseCountAggregateOutputType | null
    _avg: CognitiveExerciseAvgAggregateOutputType | null
    _sum: CognitiveExerciseSumAggregateOutputType | null
    _min: CognitiveExerciseMinAggregateOutputType | null
    _max: CognitiveExerciseMaxAggregateOutputType | null
  }

  export type CognitiveExerciseAvgAggregateOutputType = {
    difficultyLevel: number | null
    durationMinutes: number | null
  }

  export type CognitiveExerciseSumAggregateOutputType = {
    difficultyLevel: number | null
    durationMinutes: number | null
  }

  export type CognitiveExerciseMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    difficultyLevel: number | null
    durationMinutes: number | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    programCategoryId: string | null
  }

  export type CognitiveExerciseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    difficultyLevel: number | null
    durationMinutes: number | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    programCategoryId: string | null
  }

  export type CognitiveExerciseCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    difficultyLevel: number
    durationMinutes: number
    description: number
    image: number
    createdAt: number
    updatedAt: number
    programCategoryId: number
    _all: number
  }


  export type CognitiveExerciseAvgAggregateInputType = {
    difficultyLevel?: true
    durationMinutes?: true
  }

  export type CognitiveExerciseSumAggregateInputType = {
    difficultyLevel?: true
    durationMinutes?: true
  }

  export type CognitiveExerciseMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    difficultyLevel?: true
    durationMinutes?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    programCategoryId?: true
  }

  export type CognitiveExerciseMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    difficultyLevel?: true
    durationMinutes?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    programCategoryId?: true
  }

  export type CognitiveExerciseCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    difficultyLevel?: true
    durationMinutes?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    programCategoryId?: true
    _all?: true
  }

  export type CognitiveExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cognitiveExercise to aggregate.
     */
    where?: cognitiveExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveExercises to fetch.
     */
    orderBy?: cognitiveExerciseOrderByWithRelationInput | cognitiveExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cognitiveExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cognitiveExercises
    **/
    _count?: true | CognitiveExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CognitiveExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CognitiveExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CognitiveExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CognitiveExerciseMaxAggregateInputType
  }

  export type GetCognitiveExerciseAggregateType<T extends CognitiveExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateCognitiveExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCognitiveExercise[P]>
      : GetScalarType<T[P], AggregateCognitiveExercise[P]>
  }




  export type cognitiveExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cognitiveExerciseWhereInput
    orderBy?: cognitiveExerciseOrderByWithAggregationInput | cognitiveExerciseOrderByWithAggregationInput[]
    by: CognitiveExerciseScalarFieldEnum[] | CognitiveExerciseScalarFieldEnum
    having?: cognitiveExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CognitiveExerciseCountAggregateInputType | true
    _avg?: CognitiveExerciseAvgAggregateInputType
    _sum?: CognitiveExerciseSumAggregateInputType
    _min?: CognitiveExerciseMinAggregateInputType
    _max?: CognitiveExerciseMaxAggregateInputType
  }

  export type CognitiveExerciseGroupByOutputType = {
    id: string
    name: string
    categoryId: string | null
    difficultyLevel: number | null
    durationMinutes: number | null
    description: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date | null
    programCategoryId: string | null
    _count: CognitiveExerciseCountAggregateOutputType | null
    _avg: CognitiveExerciseAvgAggregateOutputType | null
    _sum: CognitiveExerciseSumAggregateOutputType | null
    _min: CognitiveExerciseMinAggregateOutputType | null
    _max: CognitiveExerciseMaxAggregateOutputType | null
  }

  type GetCognitiveExerciseGroupByPayload<T extends cognitiveExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CognitiveExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CognitiveExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CognitiveExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], CognitiveExerciseGroupByOutputType[P]>
        }
      >
    >


  export type cognitiveExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    durationMinutes?: boolean
    description?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programCategoryId?: boolean
    cognitiveCategory?: boolean | cognitiveExercise$cognitiveCategoryArgs<ExtArgs>
    userActivity?: boolean | cognitiveExercise$userActivityArgs<ExtArgs>
    programCategory?: boolean | cognitiveExercise$programCategoryArgs<ExtArgs>
    _count?: boolean | CognitiveExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cognitiveExercise"]>

  export type cognitiveExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    durationMinutes?: boolean
    description?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programCategoryId?: boolean
    cognitiveCategory?: boolean | cognitiveExercise$cognitiveCategoryArgs<ExtArgs>
    programCategory?: boolean | cognitiveExercise$programCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["cognitiveExercise"]>

  export type cognitiveExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    durationMinutes?: boolean
    description?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programCategoryId?: boolean
    cognitiveCategory?: boolean | cognitiveExercise$cognitiveCategoryArgs<ExtArgs>
    programCategory?: boolean | cognitiveExercise$programCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["cognitiveExercise"]>

  export type cognitiveExerciseSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    durationMinutes?: boolean
    description?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programCategoryId?: boolean
  }

  export type cognitiveExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "difficultyLevel" | "durationMinutes" | "description" | "image" | "createdAt" | "updatedAt" | "programCategoryId", ExtArgs["result"]["cognitiveExercise"]>
  export type cognitiveExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveCategory?: boolean | cognitiveExercise$cognitiveCategoryArgs<ExtArgs>
    userActivity?: boolean | cognitiveExercise$userActivityArgs<ExtArgs>
    programCategory?: boolean | cognitiveExercise$programCategoryArgs<ExtArgs>
    _count?: boolean | CognitiveExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cognitiveExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveCategory?: boolean | cognitiveExercise$cognitiveCategoryArgs<ExtArgs>
    programCategory?: boolean | cognitiveExercise$programCategoryArgs<ExtArgs>
  }
  export type cognitiveExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveCategory?: boolean | cognitiveExercise$cognitiveCategoryArgs<ExtArgs>
    programCategory?: boolean | cognitiveExercise$programCategoryArgs<ExtArgs>
  }

  export type $cognitiveExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cognitiveExercise"
    objects: {
      cognitiveCategory: Prisma.$cognitiveCategoryPayload<ExtArgs> | null
      userActivity: Prisma.$userActivityPayload<ExtArgs>[]
      programCategory: Prisma.$programCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string | null
      difficultyLevel: number | null
      durationMinutes: number | null
      description: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date | null
      programCategoryId: string | null
    }, ExtArgs["result"]["cognitiveExercise"]>
    composites: {}
  }

  type cognitiveExerciseGetPayload<S extends boolean | null | undefined | cognitiveExerciseDefaultArgs> = $Result.GetResult<Prisma.$cognitiveExercisePayload, S>

  type cognitiveExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cognitiveExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CognitiveExerciseCountAggregateInputType | true
    }

  export interface cognitiveExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cognitiveExercise'], meta: { name: 'cognitiveExercise' } }
    /**
     * Find zero or one CognitiveExercise that matches the filter.
     * @param {cognitiveExerciseFindUniqueArgs} args - Arguments to find a CognitiveExercise
     * @example
     * // Get one CognitiveExercise
     * const cognitiveExercise = await prisma.cognitiveExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cognitiveExerciseFindUniqueArgs>(args: SelectSubset<T, cognitiveExerciseFindUniqueArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CognitiveExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cognitiveExerciseFindUniqueOrThrowArgs} args - Arguments to find a CognitiveExercise
     * @example
     * // Get one CognitiveExercise
     * const cognitiveExercise = await prisma.cognitiveExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cognitiveExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, cognitiveExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CognitiveExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveExerciseFindFirstArgs} args - Arguments to find a CognitiveExercise
     * @example
     * // Get one CognitiveExercise
     * const cognitiveExercise = await prisma.cognitiveExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cognitiveExerciseFindFirstArgs>(args?: SelectSubset<T, cognitiveExerciseFindFirstArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CognitiveExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveExerciseFindFirstOrThrowArgs} args - Arguments to find a CognitiveExercise
     * @example
     * // Get one CognitiveExercise
     * const cognitiveExercise = await prisma.cognitiveExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cognitiveExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, cognitiveExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CognitiveExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CognitiveExercises
     * const cognitiveExercises = await prisma.cognitiveExercise.findMany()
     * 
     * // Get first 10 CognitiveExercises
     * const cognitiveExercises = await prisma.cognitiveExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cognitiveExerciseWithIdOnly = await prisma.cognitiveExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cognitiveExerciseFindManyArgs>(args?: SelectSubset<T, cognitiveExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CognitiveExercise.
     * @param {cognitiveExerciseCreateArgs} args - Arguments to create a CognitiveExercise.
     * @example
     * // Create one CognitiveExercise
     * const CognitiveExercise = await prisma.cognitiveExercise.create({
     *   data: {
     *     // ... data to create a CognitiveExercise
     *   }
     * })
     * 
     */
    create<T extends cognitiveExerciseCreateArgs>(args: SelectSubset<T, cognitiveExerciseCreateArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CognitiveExercises.
     * @param {cognitiveExerciseCreateManyArgs} args - Arguments to create many CognitiveExercises.
     * @example
     * // Create many CognitiveExercises
     * const cognitiveExercise = await prisma.cognitiveExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cognitiveExerciseCreateManyArgs>(args?: SelectSubset<T, cognitiveExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CognitiveExercises and returns the data saved in the database.
     * @param {cognitiveExerciseCreateManyAndReturnArgs} args - Arguments to create many CognitiveExercises.
     * @example
     * // Create many CognitiveExercises
     * const cognitiveExercise = await prisma.cognitiveExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CognitiveExercises and only return the `id`
     * const cognitiveExerciseWithIdOnly = await prisma.cognitiveExercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cognitiveExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, cognitiveExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CognitiveExercise.
     * @param {cognitiveExerciseDeleteArgs} args - Arguments to delete one CognitiveExercise.
     * @example
     * // Delete one CognitiveExercise
     * const CognitiveExercise = await prisma.cognitiveExercise.delete({
     *   where: {
     *     // ... filter to delete one CognitiveExercise
     *   }
     * })
     * 
     */
    delete<T extends cognitiveExerciseDeleteArgs>(args: SelectSubset<T, cognitiveExerciseDeleteArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CognitiveExercise.
     * @param {cognitiveExerciseUpdateArgs} args - Arguments to update one CognitiveExercise.
     * @example
     * // Update one CognitiveExercise
     * const cognitiveExercise = await prisma.cognitiveExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cognitiveExerciseUpdateArgs>(args: SelectSubset<T, cognitiveExerciseUpdateArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CognitiveExercises.
     * @param {cognitiveExerciseDeleteManyArgs} args - Arguments to filter CognitiveExercises to delete.
     * @example
     * // Delete a few CognitiveExercises
     * const { count } = await prisma.cognitiveExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cognitiveExerciseDeleteManyArgs>(args?: SelectSubset<T, cognitiveExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CognitiveExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CognitiveExercises
     * const cognitiveExercise = await prisma.cognitiveExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cognitiveExerciseUpdateManyArgs>(args: SelectSubset<T, cognitiveExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CognitiveExercises and returns the data updated in the database.
     * @param {cognitiveExerciseUpdateManyAndReturnArgs} args - Arguments to update many CognitiveExercises.
     * @example
     * // Update many CognitiveExercises
     * const cognitiveExercise = await prisma.cognitiveExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CognitiveExercises and only return the `id`
     * const cognitiveExerciseWithIdOnly = await prisma.cognitiveExercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cognitiveExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, cognitiveExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CognitiveExercise.
     * @param {cognitiveExerciseUpsertArgs} args - Arguments to update or create a CognitiveExercise.
     * @example
     * // Update or create a CognitiveExercise
     * const cognitiveExercise = await prisma.cognitiveExercise.upsert({
     *   create: {
     *     // ... data to create a CognitiveExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CognitiveExercise we want to update
     *   }
     * })
     */
    upsert<T extends cognitiveExerciseUpsertArgs>(args: SelectSubset<T, cognitiveExerciseUpsertArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CognitiveExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveExerciseCountArgs} args - Arguments to filter CognitiveExercises to count.
     * @example
     * // Count the number of CognitiveExercises
     * const count = await prisma.cognitiveExercise.count({
     *   where: {
     *     // ... the filter for the CognitiveExercises we want to count
     *   }
     * })
    **/
    count<T extends cognitiveExerciseCountArgs>(
      args?: Subset<T, cognitiveExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CognitiveExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CognitiveExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CognitiveExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CognitiveExerciseAggregateArgs>(args: Subset<T, CognitiveExerciseAggregateArgs>): Prisma.PrismaPromise<GetCognitiveExerciseAggregateType<T>>

    /**
     * Group by CognitiveExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cognitiveExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cognitiveExerciseGroupByArgs['orderBy'] }
        : { orderBy?: cognitiveExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cognitiveExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCognitiveExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cognitiveExercise model
   */
  readonly fields: cognitiveExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cognitiveExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cognitiveExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cognitiveCategory<T extends cognitiveExercise$cognitiveCategoryArgs<ExtArgs> = {}>(args?: Subset<T, cognitiveExercise$cognitiveCategoryArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userActivity<T extends cognitiveExercise$userActivityArgs<ExtArgs> = {}>(args?: Subset<T, cognitiveExercise$userActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programCategory<T extends cognitiveExercise$programCategoryArgs<ExtArgs> = {}>(args?: Subset<T, cognitiveExercise$programCategoryArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cognitiveExercise model
   */
  interface cognitiveExerciseFieldRefs {
    readonly id: FieldRef<"cognitiveExercise", 'String'>
    readonly name: FieldRef<"cognitiveExercise", 'String'>
    readonly categoryId: FieldRef<"cognitiveExercise", 'String'>
    readonly difficultyLevel: FieldRef<"cognitiveExercise", 'Int'>
    readonly durationMinutes: FieldRef<"cognitiveExercise", 'Int'>
    readonly description: FieldRef<"cognitiveExercise", 'String'>
    readonly image: FieldRef<"cognitiveExercise", 'String'>
    readonly createdAt: FieldRef<"cognitiveExercise", 'DateTime'>
    readonly updatedAt: FieldRef<"cognitiveExercise", 'DateTime'>
    readonly programCategoryId: FieldRef<"cognitiveExercise", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cognitiveExercise findUnique
   */
  export type cognitiveExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveExercise to fetch.
     */
    where: cognitiveExerciseWhereUniqueInput
  }

  /**
   * cognitiveExercise findUniqueOrThrow
   */
  export type cognitiveExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveExercise to fetch.
     */
    where: cognitiveExerciseWhereUniqueInput
  }

  /**
   * cognitiveExercise findFirst
   */
  export type cognitiveExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveExercise to fetch.
     */
    where?: cognitiveExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveExercises to fetch.
     */
    orderBy?: cognitiveExerciseOrderByWithRelationInput | cognitiveExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cognitiveExercises.
     */
    cursor?: cognitiveExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cognitiveExercises.
     */
    distinct?: CognitiveExerciseScalarFieldEnum | CognitiveExerciseScalarFieldEnum[]
  }

  /**
   * cognitiveExercise findFirstOrThrow
   */
  export type cognitiveExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveExercise to fetch.
     */
    where?: cognitiveExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveExercises to fetch.
     */
    orderBy?: cognitiveExerciseOrderByWithRelationInput | cognitiveExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cognitiveExercises.
     */
    cursor?: cognitiveExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cognitiveExercises.
     */
    distinct?: CognitiveExerciseScalarFieldEnum | CognitiveExerciseScalarFieldEnum[]
  }

  /**
   * cognitiveExercise findMany
   */
  export type cognitiveExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveExercises to fetch.
     */
    where?: cognitiveExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveExercises to fetch.
     */
    orderBy?: cognitiveExerciseOrderByWithRelationInput | cognitiveExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cognitiveExercises.
     */
    cursor?: cognitiveExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveExercises.
     */
    skip?: number
    distinct?: CognitiveExerciseScalarFieldEnum | CognitiveExerciseScalarFieldEnum[]
  }

  /**
   * cognitiveExercise create
   */
  export type cognitiveExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a cognitiveExercise.
     */
    data: XOR<cognitiveExerciseCreateInput, cognitiveExerciseUncheckedCreateInput>
  }

  /**
   * cognitiveExercise createMany
   */
  export type cognitiveExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cognitiveExercises.
     */
    data: cognitiveExerciseCreateManyInput | cognitiveExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cognitiveExercise createManyAndReturn
   */
  export type cognitiveExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many cognitiveExercises.
     */
    data: cognitiveExerciseCreateManyInput | cognitiveExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cognitiveExercise update
   */
  export type cognitiveExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a cognitiveExercise.
     */
    data: XOR<cognitiveExerciseUpdateInput, cognitiveExerciseUncheckedUpdateInput>
    /**
     * Choose, which cognitiveExercise to update.
     */
    where: cognitiveExerciseWhereUniqueInput
  }

  /**
   * cognitiveExercise updateMany
   */
  export type cognitiveExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cognitiveExercises.
     */
    data: XOR<cognitiveExerciseUpdateManyMutationInput, cognitiveExerciseUncheckedUpdateManyInput>
    /**
     * Filter which cognitiveExercises to update
     */
    where?: cognitiveExerciseWhereInput
    /**
     * Limit how many cognitiveExercises to update.
     */
    limit?: number
  }

  /**
   * cognitiveExercise updateManyAndReturn
   */
  export type cognitiveExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * The data used to update cognitiveExercises.
     */
    data: XOR<cognitiveExerciseUpdateManyMutationInput, cognitiveExerciseUncheckedUpdateManyInput>
    /**
     * Filter which cognitiveExercises to update
     */
    where?: cognitiveExerciseWhereInput
    /**
     * Limit how many cognitiveExercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * cognitiveExercise upsert
   */
  export type cognitiveExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the cognitiveExercise to update in case it exists.
     */
    where: cognitiveExerciseWhereUniqueInput
    /**
     * In case the cognitiveExercise found by the `where` argument doesn't exist, create a new cognitiveExercise with this data.
     */
    create: XOR<cognitiveExerciseCreateInput, cognitiveExerciseUncheckedCreateInput>
    /**
     * In case the cognitiveExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cognitiveExerciseUpdateInput, cognitiveExerciseUncheckedUpdateInput>
  }

  /**
   * cognitiveExercise delete
   */
  export type cognitiveExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    /**
     * Filter which cognitiveExercise to delete.
     */
    where: cognitiveExerciseWhereUniqueInput
  }

  /**
   * cognitiveExercise deleteMany
   */
  export type cognitiveExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cognitiveExercises to delete
     */
    where?: cognitiveExerciseWhereInput
    /**
     * Limit how many cognitiveExercises to delete.
     */
    limit?: number
  }

  /**
   * cognitiveExercise.cognitiveCategory
   */
  export type cognitiveExercise$cognitiveCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    where?: cognitiveCategoryWhereInput
  }

  /**
   * cognitiveExercise.userActivity
   */
  export type cognitiveExercise$userActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    where?: userActivityWhereInput
    orderBy?: userActivityOrderByWithRelationInput | userActivityOrderByWithRelationInput[]
    cursor?: userActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * cognitiveExercise.programCategory
   */
  export type cognitiveExercise$programCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    where?: programCategoryWhereInput
  }

  /**
   * cognitiveExercise without action
   */
  export type cognitiveExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
  }


  /**
   * Model collaborativeProject
   */

  export type AggregateCollaborativeProject = {
    _count: CollaborativeProjectCountAggregateOutputType | null
    _min: CollaborativeProjectMinAggregateOutputType | null
    _max: CollaborativeProjectMaxAggregateOutputType | null
  }

  export type CollaborativeProjectMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    creatorId: string | null
    creationDate: Date | null
    status: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollaborativeProjectMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    creatorId: string | null
    creationDate: Date | null
    status: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollaborativeProjectCountAggregateOutputType = {
    id: number
    title: number
    description: number
    creatorId: number
    creationDate: number
    status: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollaborativeProjectMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    creatorId?: true
    creationDate?: true
    status?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollaborativeProjectMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    creatorId?: true
    creationDate?: true
    status?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollaborativeProjectCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    creatorId?: true
    creationDate?: true
    status?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollaborativeProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collaborativeProject to aggregate.
     */
    where?: collaborativeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collaborativeProjects to fetch.
     */
    orderBy?: collaborativeProjectOrderByWithRelationInput | collaborativeProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collaborativeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collaborativeProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collaborativeProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collaborativeProjects
    **/
    _count?: true | CollaborativeProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollaborativeProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollaborativeProjectMaxAggregateInputType
  }

  export type GetCollaborativeProjectAggregateType<T extends CollaborativeProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCollaborativeProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollaborativeProject[P]>
      : GetScalarType<T[P], AggregateCollaborativeProject[P]>
  }




  export type collaborativeProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collaborativeProjectWhereInput
    orderBy?: collaborativeProjectOrderByWithAggregationInput | collaborativeProjectOrderByWithAggregationInput[]
    by: CollaborativeProjectScalarFieldEnum[] | CollaborativeProjectScalarFieldEnum
    having?: collaborativeProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollaborativeProjectCountAggregateInputType | true
    _min?: CollaborativeProjectMinAggregateInputType
    _max?: CollaborativeProjectMaxAggregateInputType
  }

  export type CollaborativeProjectGroupByOutputType = {
    id: string
    title: string
    description: string | null
    creatorId: string
    creationDate: Date
    status: string | null
    categoryId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: CollaborativeProjectCountAggregateOutputType | null
    _min: CollaborativeProjectMinAggregateOutputType | null
    _max: CollaborativeProjectMaxAggregateOutputType | null
  }

  type GetCollaborativeProjectGroupByPayload<T extends collaborativeProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollaborativeProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollaborativeProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollaborativeProjectGroupByOutputType[P]>
            : GetScalarType<T[P], CollaborativeProjectGroupByOutputType[P]>
        }
      >
    >


  export type collaborativeProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    creationDate?: boolean
    status?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | collaborativeProject$userArgs<ExtArgs>
    projectCategory?: boolean | collaborativeProject$projectCategoryArgs<ExtArgs>
    projectMember?: boolean | collaborativeProject$projectMemberArgs<ExtArgs>
    projectTask?: boolean | collaborativeProject$projectTaskArgs<ExtArgs>
    _count?: boolean | CollaborativeProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collaborativeProject"]>

  export type collaborativeProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    creationDate?: boolean
    status?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | collaborativeProject$userArgs<ExtArgs>
    projectCategory?: boolean | collaborativeProject$projectCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["collaborativeProject"]>

  export type collaborativeProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    creationDate?: boolean
    status?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | collaborativeProject$userArgs<ExtArgs>
    projectCategory?: boolean | collaborativeProject$projectCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["collaborativeProject"]>

  export type collaborativeProjectSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    creationDate?: boolean
    status?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type collaborativeProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "creatorId" | "creationDate" | "status" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["collaborativeProject"]>
  export type collaborativeProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | collaborativeProject$userArgs<ExtArgs>
    projectCategory?: boolean | collaborativeProject$projectCategoryArgs<ExtArgs>
    projectMember?: boolean | collaborativeProject$projectMemberArgs<ExtArgs>
    projectTask?: boolean | collaborativeProject$projectTaskArgs<ExtArgs>
    _count?: boolean | CollaborativeProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type collaborativeProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | collaborativeProject$userArgs<ExtArgs>
    projectCategory?: boolean | collaborativeProject$projectCategoryArgs<ExtArgs>
  }
  export type collaborativeProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | collaborativeProject$userArgs<ExtArgs>
    projectCategory?: boolean | collaborativeProject$projectCategoryArgs<ExtArgs>
  }

  export type $collaborativeProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collaborativeProject"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      projectCategory: Prisma.$projectCategoryPayload<ExtArgs> | null
      projectMember: Prisma.$projectMemberPayload<ExtArgs>[]
      projectTask: Prisma.$projectTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      creatorId: string
      creationDate: Date
      status: string | null
      categoryId: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["collaborativeProject"]>
    composites: {}
  }

  type collaborativeProjectGetPayload<S extends boolean | null | undefined | collaborativeProjectDefaultArgs> = $Result.GetResult<Prisma.$collaborativeProjectPayload, S>

  type collaborativeProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<collaborativeProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollaborativeProjectCountAggregateInputType | true
    }

  export interface collaborativeProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collaborativeProject'], meta: { name: 'collaborativeProject' } }
    /**
     * Find zero or one CollaborativeProject that matches the filter.
     * @param {collaborativeProjectFindUniqueArgs} args - Arguments to find a CollaborativeProject
     * @example
     * // Get one CollaborativeProject
     * const collaborativeProject = await prisma.collaborativeProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collaborativeProjectFindUniqueArgs>(args: SelectSubset<T, collaborativeProjectFindUniqueArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollaborativeProject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {collaborativeProjectFindUniqueOrThrowArgs} args - Arguments to find a CollaborativeProject
     * @example
     * // Get one CollaborativeProject
     * const collaborativeProject = await prisma.collaborativeProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collaborativeProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, collaborativeProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollaborativeProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collaborativeProjectFindFirstArgs} args - Arguments to find a CollaborativeProject
     * @example
     * // Get one CollaborativeProject
     * const collaborativeProject = await prisma.collaborativeProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collaborativeProjectFindFirstArgs>(args?: SelectSubset<T, collaborativeProjectFindFirstArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollaborativeProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collaborativeProjectFindFirstOrThrowArgs} args - Arguments to find a CollaborativeProject
     * @example
     * // Get one CollaborativeProject
     * const collaborativeProject = await prisma.collaborativeProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collaborativeProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, collaborativeProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollaborativeProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collaborativeProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollaborativeProjects
     * const collaborativeProjects = await prisma.collaborativeProject.findMany()
     * 
     * // Get first 10 CollaborativeProjects
     * const collaborativeProjects = await prisma.collaborativeProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collaborativeProjectWithIdOnly = await prisma.collaborativeProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collaborativeProjectFindManyArgs>(args?: SelectSubset<T, collaborativeProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollaborativeProject.
     * @param {collaborativeProjectCreateArgs} args - Arguments to create a CollaborativeProject.
     * @example
     * // Create one CollaborativeProject
     * const CollaborativeProject = await prisma.collaborativeProject.create({
     *   data: {
     *     // ... data to create a CollaborativeProject
     *   }
     * })
     * 
     */
    create<T extends collaborativeProjectCreateArgs>(args: SelectSubset<T, collaborativeProjectCreateArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollaborativeProjects.
     * @param {collaborativeProjectCreateManyArgs} args - Arguments to create many CollaborativeProjects.
     * @example
     * // Create many CollaborativeProjects
     * const collaborativeProject = await prisma.collaborativeProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collaborativeProjectCreateManyArgs>(args?: SelectSubset<T, collaborativeProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollaborativeProjects and returns the data saved in the database.
     * @param {collaborativeProjectCreateManyAndReturnArgs} args - Arguments to create many CollaborativeProjects.
     * @example
     * // Create many CollaborativeProjects
     * const collaborativeProject = await prisma.collaborativeProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollaborativeProjects and only return the `id`
     * const collaborativeProjectWithIdOnly = await prisma.collaborativeProject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collaborativeProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, collaborativeProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollaborativeProject.
     * @param {collaborativeProjectDeleteArgs} args - Arguments to delete one CollaborativeProject.
     * @example
     * // Delete one CollaborativeProject
     * const CollaborativeProject = await prisma.collaborativeProject.delete({
     *   where: {
     *     // ... filter to delete one CollaborativeProject
     *   }
     * })
     * 
     */
    delete<T extends collaborativeProjectDeleteArgs>(args: SelectSubset<T, collaborativeProjectDeleteArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollaborativeProject.
     * @param {collaborativeProjectUpdateArgs} args - Arguments to update one CollaborativeProject.
     * @example
     * // Update one CollaborativeProject
     * const collaborativeProject = await prisma.collaborativeProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collaborativeProjectUpdateArgs>(args: SelectSubset<T, collaborativeProjectUpdateArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollaborativeProjects.
     * @param {collaborativeProjectDeleteManyArgs} args - Arguments to filter CollaborativeProjects to delete.
     * @example
     * // Delete a few CollaborativeProjects
     * const { count } = await prisma.collaborativeProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collaborativeProjectDeleteManyArgs>(args?: SelectSubset<T, collaborativeProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollaborativeProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collaborativeProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollaborativeProjects
     * const collaborativeProject = await prisma.collaborativeProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collaborativeProjectUpdateManyArgs>(args: SelectSubset<T, collaborativeProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollaborativeProjects and returns the data updated in the database.
     * @param {collaborativeProjectUpdateManyAndReturnArgs} args - Arguments to update many CollaborativeProjects.
     * @example
     * // Update many CollaborativeProjects
     * const collaborativeProject = await prisma.collaborativeProject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollaborativeProjects and only return the `id`
     * const collaborativeProjectWithIdOnly = await prisma.collaborativeProject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends collaborativeProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, collaborativeProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollaborativeProject.
     * @param {collaborativeProjectUpsertArgs} args - Arguments to update or create a CollaborativeProject.
     * @example
     * // Update or create a CollaborativeProject
     * const collaborativeProject = await prisma.collaborativeProject.upsert({
     *   create: {
     *     // ... data to create a CollaborativeProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollaborativeProject we want to update
     *   }
     * })
     */
    upsert<T extends collaborativeProjectUpsertArgs>(args: SelectSubset<T, collaborativeProjectUpsertArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollaborativeProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collaborativeProjectCountArgs} args - Arguments to filter CollaborativeProjects to count.
     * @example
     * // Count the number of CollaborativeProjects
     * const count = await prisma.collaborativeProject.count({
     *   where: {
     *     // ... the filter for the CollaborativeProjects we want to count
     *   }
     * })
    **/
    count<T extends collaborativeProjectCountArgs>(
      args?: Subset<T, collaborativeProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollaborativeProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollaborativeProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborativeProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollaborativeProjectAggregateArgs>(args: Subset<T, CollaborativeProjectAggregateArgs>): Prisma.PrismaPromise<GetCollaborativeProjectAggregateType<T>>

    /**
     * Group by CollaborativeProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collaborativeProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collaborativeProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collaborativeProjectGroupByArgs['orderBy'] }
        : { orderBy?: collaborativeProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collaborativeProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollaborativeProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collaborativeProject model
   */
  readonly fields: collaborativeProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collaborativeProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collaborativeProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends collaborativeProject$userArgs<ExtArgs> = {}>(args?: Subset<T, collaborativeProject$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    projectCategory<T extends collaborativeProject$projectCategoryArgs<ExtArgs> = {}>(args?: Subset<T, collaborativeProject$projectCategoryArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    projectMember<T extends collaborativeProject$projectMemberArgs<ExtArgs> = {}>(args?: Subset<T, collaborativeProject$projectMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectTask<T extends collaborativeProject$projectTaskArgs<ExtArgs> = {}>(args?: Subset<T, collaborativeProject$projectTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collaborativeProject model
   */
  interface collaborativeProjectFieldRefs {
    readonly id: FieldRef<"collaborativeProject", 'String'>
    readonly title: FieldRef<"collaborativeProject", 'String'>
    readonly description: FieldRef<"collaborativeProject", 'String'>
    readonly creatorId: FieldRef<"collaborativeProject", 'String'>
    readonly creationDate: FieldRef<"collaborativeProject", 'DateTime'>
    readonly status: FieldRef<"collaborativeProject", 'String'>
    readonly categoryId: FieldRef<"collaborativeProject", 'String'>
    readonly createdAt: FieldRef<"collaborativeProject", 'DateTime'>
    readonly updatedAt: FieldRef<"collaborativeProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * collaborativeProject findUnique
   */
  export type collaborativeProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * Filter, which collaborativeProject to fetch.
     */
    where: collaborativeProjectWhereUniqueInput
  }

  /**
   * collaborativeProject findUniqueOrThrow
   */
  export type collaborativeProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * Filter, which collaborativeProject to fetch.
     */
    where: collaborativeProjectWhereUniqueInput
  }

  /**
   * collaborativeProject findFirst
   */
  export type collaborativeProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * Filter, which collaborativeProject to fetch.
     */
    where?: collaborativeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collaborativeProjects to fetch.
     */
    orderBy?: collaborativeProjectOrderByWithRelationInput | collaborativeProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collaborativeProjects.
     */
    cursor?: collaborativeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collaborativeProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collaborativeProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collaborativeProjects.
     */
    distinct?: CollaborativeProjectScalarFieldEnum | CollaborativeProjectScalarFieldEnum[]
  }

  /**
   * collaborativeProject findFirstOrThrow
   */
  export type collaborativeProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * Filter, which collaborativeProject to fetch.
     */
    where?: collaborativeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collaborativeProjects to fetch.
     */
    orderBy?: collaborativeProjectOrderByWithRelationInput | collaborativeProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collaborativeProjects.
     */
    cursor?: collaborativeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collaborativeProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collaborativeProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collaborativeProjects.
     */
    distinct?: CollaborativeProjectScalarFieldEnum | CollaborativeProjectScalarFieldEnum[]
  }

  /**
   * collaborativeProject findMany
   */
  export type collaborativeProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * Filter, which collaborativeProjects to fetch.
     */
    where?: collaborativeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collaborativeProjects to fetch.
     */
    orderBy?: collaborativeProjectOrderByWithRelationInput | collaborativeProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collaborativeProjects.
     */
    cursor?: collaborativeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collaborativeProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collaborativeProjects.
     */
    skip?: number
    distinct?: CollaborativeProjectScalarFieldEnum | CollaborativeProjectScalarFieldEnum[]
  }

  /**
   * collaborativeProject create
   */
  export type collaborativeProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a collaborativeProject.
     */
    data: XOR<collaborativeProjectCreateInput, collaborativeProjectUncheckedCreateInput>
  }

  /**
   * collaborativeProject createMany
   */
  export type collaborativeProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collaborativeProjects.
     */
    data: collaborativeProjectCreateManyInput | collaborativeProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collaborativeProject createManyAndReturn
   */
  export type collaborativeProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * The data used to create many collaborativeProjects.
     */
    data: collaborativeProjectCreateManyInput | collaborativeProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collaborativeProject update
   */
  export type collaborativeProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a collaborativeProject.
     */
    data: XOR<collaborativeProjectUpdateInput, collaborativeProjectUncheckedUpdateInput>
    /**
     * Choose, which collaborativeProject to update.
     */
    where: collaborativeProjectWhereUniqueInput
  }

  /**
   * collaborativeProject updateMany
   */
  export type collaborativeProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collaborativeProjects.
     */
    data: XOR<collaborativeProjectUpdateManyMutationInput, collaborativeProjectUncheckedUpdateManyInput>
    /**
     * Filter which collaborativeProjects to update
     */
    where?: collaborativeProjectWhereInput
    /**
     * Limit how many collaborativeProjects to update.
     */
    limit?: number
  }

  /**
   * collaborativeProject updateManyAndReturn
   */
  export type collaborativeProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * The data used to update collaborativeProjects.
     */
    data: XOR<collaborativeProjectUpdateManyMutationInput, collaborativeProjectUncheckedUpdateManyInput>
    /**
     * Filter which collaborativeProjects to update
     */
    where?: collaborativeProjectWhereInput
    /**
     * Limit how many collaborativeProjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * collaborativeProject upsert
   */
  export type collaborativeProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the collaborativeProject to update in case it exists.
     */
    where: collaborativeProjectWhereUniqueInput
    /**
     * In case the collaborativeProject found by the `where` argument doesn't exist, create a new collaborativeProject with this data.
     */
    create: XOR<collaborativeProjectCreateInput, collaborativeProjectUncheckedCreateInput>
    /**
     * In case the collaborativeProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collaborativeProjectUpdateInput, collaborativeProjectUncheckedUpdateInput>
  }

  /**
   * collaborativeProject delete
   */
  export type collaborativeProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    /**
     * Filter which collaborativeProject to delete.
     */
    where: collaborativeProjectWhereUniqueInput
  }

  /**
   * collaborativeProject deleteMany
   */
  export type collaborativeProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collaborativeProjects to delete
     */
    where?: collaborativeProjectWhereInput
    /**
     * Limit how many collaborativeProjects to delete.
     */
    limit?: number
  }

  /**
   * collaborativeProject.user
   */
  export type collaborativeProject$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * collaborativeProject.projectCategory
   */
  export type collaborativeProject$projectCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    where?: projectCategoryWhereInput
  }

  /**
   * collaborativeProject.projectMember
   */
  export type collaborativeProject$projectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    where?: projectMemberWhereInput
    orderBy?: projectMemberOrderByWithRelationInput | projectMemberOrderByWithRelationInput[]
    cursor?: projectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * collaborativeProject.projectTask
   */
  export type collaborativeProject$projectTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    where?: projectTaskWhereInput
    orderBy?: projectTaskOrderByWithRelationInput | projectTaskOrderByWithRelationInput[]
    cursor?: projectTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * collaborativeProject without action
   */
  export type collaborativeProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
  }


  /**
   * Model conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversation to aggregate.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type conversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationWhereInput
    orderBy?: conversationOrderByWithAggregationInput | conversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: conversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    type: string
    title: string
    createdAt: Date
    updatedAt: Date | null
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends conversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type conversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationParticipant?: boolean | conversation$conversationParticipantArgs<ExtArgs>
    message?: boolean | conversation$messageArgs<ExtArgs>
    videoCall?: boolean | conversation$videoCallArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type conversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type conversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversationParticipant?: boolean | conversation$conversationParticipantArgs<ExtArgs>
    message?: boolean | conversation$messageArgs<ExtArgs>
    videoCall?: boolean | conversation$videoCallArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type conversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type conversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $conversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversation"
    objects: {
      conversationParticipant: Prisma.$conversationParticipantPayload<ExtArgs>[]
      message: Prisma.$messagePayload<ExtArgs>[]
      videoCall: Prisma.$videoCallPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type conversationGetPayload<S extends boolean | null | undefined | conversationDefaultArgs> = $Result.GetResult<Prisma.$conversationPayload, S>

  type conversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface conversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversation'], meta: { name: 'conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {conversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conversationFindUniqueArgs>(args: SelectSubset<T, conversationFindUniqueArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conversationFindUniqueOrThrowArgs>(args: SelectSubset<T, conversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conversationFindFirstArgs>(args?: SelectSubset<T, conversationFindFirstArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conversationFindFirstOrThrowArgs>(args?: SelectSubset<T, conversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conversationFindManyArgs>(args?: SelectSubset<T, conversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {conversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends conversationCreateArgs>(args: SelectSubset<T, conversationCreateArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {conversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conversationCreateManyArgs>(args?: SelectSubset<T, conversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {conversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conversationCreateManyAndReturnArgs>(args?: SelectSubset<T, conversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {conversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends conversationDeleteArgs>(args: SelectSubset<T, conversationDeleteArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {conversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conversationUpdateArgs>(args: SelectSubset<T, conversationUpdateArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {conversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conversationDeleteManyArgs>(args?: SelectSubset<T, conversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conversationUpdateManyArgs>(args: SelectSubset<T, conversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {conversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conversationUpdateManyAndReturnArgs>(args: SelectSubset<T, conversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {conversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends conversationUpsertArgs>(args: SelectSubset<T, conversationUpsertArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends conversationCountArgs>(
      args?: Subset<T, conversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationGroupByArgs['orderBy'] }
        : { orderBy?: conversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversation model
   */
  readonly fields: conversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversationParticipant<T extends conversation$conversationParticipantArgs<ExtArgs> = {}>(args?: Subset<T, conversation$conversationParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message<T extends conversation$messageArgs<ExtArgs> = {}>(args?: Subset<T, conversation$messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videoCall<T extends conversation$videoCallArgs<ExtArgs> = {}>(args?: Subset<T, conversation$videoCallArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conversation model
   */
  interface conversationFieldRefs {
    readonly id: FieldRef<"conversation", 'String'>
    readonly type: FieldRef<"conversation", 'String'>
    readonly title: FieldRef<"conversation", 'String'>
    readonly createdAt: FieldRef<"conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conversation findUnique
   */
  export type conversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation findUniqueOrThrow
   */
  export type conversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation findFirst
   */
  export type conversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation findFirstOrThrow
   */
  export type conversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation findMany
   */
  export type conversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation create
   */
  export type conversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The data needed to create a conversation.
     */
    data: XOR<conversationCreateInput, conversationUncheckedCreateInput>
  }

  /**
   * conversation createMany
   */
  export type conversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations.
     */
    data: conversationCreateManyInput | conversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversation createManyAndReturn
   */
  export type conversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * The data used to create many conversations.
     */
    data: conversationCreateManyInput | conversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversation update
   */
  export type conversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The data needed to update a conversation.
     */
    data: XOR<conversationUpdateInput, conversationUncheckedUpdateInput>
    /**
     * Choose, which conversation to update.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation updateMany
   */
  export type conversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to update.
     */
    limit?: number
  }

  /**
   * conversation updateManyAndReturn
   */
  export type conversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to update.
     */
    limit?: number
  }

  /**
   * conversation upsert
   */
  export type conversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The filter to search for the conversation to update in case it exists.
     */
    where: conversationWhereUniqueInput
    /**
     * In case the conversation found by the `where` argument doesn't exist, create a new conversation with this data.
     */
    create: XOR<conversationCreateInput, conversationUncheckedCreateInput>
    /**
     * In case the conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationUpdateInput, conversationUncheckedUpdateInput>
  }

  /**
   * conversation delete
   */
  export type conversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter which conversation to delete.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation deleteMany
   */
  export type conversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to delete
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to delete.
     */
    limit?: number
  }

  /**
   * conversation.conversationParticipant
   */
  export type conversation$conversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    where?: conversationParticipantWhereInput
    orderBy?: conversationParticipantOrderByWithRelationInput | conversationParticipantOrderByWithRelationInput[]
    cursor?: conversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * conversation.message
   */
  export type conversation$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * conversation.videoCall
   */
  export type conversation$videoCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    where?: videoCallWhereInput
    orderBy?: videoCallOrderByWithRelationInput | videoCallOrderByWithRelationInput[]
    cursor?: videoCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * conversation without action
   */
  export type conversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
  }


  /**
   * Model conversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    dateAdded: Date | null
    administrator: boolean | null
    lastAccess: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    dateAdded: Date | null
    administrator: boolean | null
    lastAccess: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    dateAdded: number
    administrator: number
    lastAccess: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    dateAdded?: true
    administrator?: true
    lastAccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    dateAdded?: true
    administrator?: true
    lastAccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    dateAdded?: true
    administrator?: true
    lastAccess?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversationParticipant to aggregate.
     */
    where?: conversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversationParticipants to fetch.
     */
    orderBy?: conversationParticipantOrderByWithRelationInput | conversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type conversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationParticipantWhereInput
    orderBy?: conversationParticipantOrderByWithAggregationInput | conversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: conversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    id: string
    conversationId: string
    userId: string
    dateAdded: Date | null
    administrator: boolean | null
    lastAccess: Date
    createdAt: Date
    updatedAt: Date | null
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends conversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type conversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    dateAdded?: boolean
    administrator?: boolean
    lastAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type conversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    dateAdded?: boolean
    administrator?: boolean
    lastAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type conversationParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    dateAdded?: boolean
    administrator?: boolean
    lastAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type conversationParticipantSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    dateAdded?: boolean
    administrator?: boolean
    lastAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type conversationParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "userId" | "dateAdded" | "administrator" | "lastAccess" | "createdAt" | "updatedAt", ExtArgs["result"]["conversationParticipant"]>
  export type conversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type conversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type conversationParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $conversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversationParticipant"
    objects: {
      conversation: Prisma.$conversationPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string
      dateAdded: Date | null
      administrator: boolean | null
      lastAccess: Date
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type conversationParticipantGetPayload<S extends boolean | null | undefined | conversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$conversationParticipantPayload, S>

  type conversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conversationParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface conversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversationParticipant'], meta: { name: 'conversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {conversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conversationParticipantFindUniqueArgs>(args: SelectSubset<T, conversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, conversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conversationParticipantFindFirstArgs>(args?: SelectSubset<T, conversationParticipantFindFirstArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, conversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conversationParticipantFindManyArgs>(args?: SelectSubset<T, conversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationParticipant.
     * @param {conversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends conversationParticipantCreateArgs>(args: SelectSubset<T, conversationParticipantCreateArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationParticipants.
     * @param {conversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conversationParticipantCreateManyArgs>(args?: SelectSubset<T, conversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {conversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, conversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationParticipant.
     * @param {conversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends conversationParticipantDeleteArgs>(args: SelectSubset<T, conversationParticipantDeleteArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationParticipant.
     * @param {conversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conversationParticipantUpdateArgs>(args: SelectSubset<T, conversationParticipantUpdateArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {conversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conversationParticipantDeleteManyArgs>(args?: SelectSubset<T, conversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conversationParticipantUpdateManyArgs>(args: SelectSubset<T, conversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants and returns the data updated in the database.
     * @param {conversationParticipantUpdateManyAndReturnArgs} args - Arguments to update many ConversationParticipants.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conversationParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, conversationParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationParticipant.
     * @param {conversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends conversationParticipantUpsertArgs>(args: SelectSubset<T, conversationParticipantUpsertArgs<ExtArgs>>): Prisma__conversationParticipantClient<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends conversationParticipantCountArgs>(
      args?: Subset<T, conversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: conversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversationParticipant model
   */
  readonly fields: conversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends conversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, conversationDefaultArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conversationParticipant model
   */
  interface conversationParticipantFieldRefs {
    readonly id: FieldRef<"conversationParticipant", 'String'>
    readonly conversationId: FieldRef<"conversationParticipant", 'String'>
    readonly userId: FieldRef<"conversationParticipant", 'String'>
    readonly dateAdded: FieldRef<"conversationParticipant", 'DateTime'>
    readonly administrator: FieldRef<"conversationParticipant", 'Boolean'>
    readonly lastAccess: FieldRef<"conversationParticipant", 'DateTime'>
    readonly createdAt: FieldRef<"conversationParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"conversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conversationParticipant findUnique
   */
  export type conversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which conversationParticipant to fetch.
     */
    where: conversationParticipantWhereUniqueInput
  }

  /**
   * conversationParticipant findUniqueOrThrow
   */
  export type conversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which conversationParticipant to fetch.
     */
    where: conversationParticipantWhereUniqueInput
  }

  /**
   * conversationParticipant findFirst
   */
  export type conversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which conversationParticipant to fetch.
     */
    where?: conversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversationParticipants to fetch.
     */
    orderBy?: conversationParticipantOrderByWithRelationInput | conversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversationParticipants.
     */
    cursor?: conversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * conversationParticipant findFirstOrThrow
   */
  export type conversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which conversationParticipant to fetch.
     */
    where?: conversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversationParticipants to fetch.
     */
    orderBy?: conversationParticipantOrderByWithRelationInput | conversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversationParticipants.
     */
    cursor?: conversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * conversationParticipant findMany
   */
  export type conversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which conversationParticipants to fetch.
     */
    where?: conversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversationParticipants to fetch.
     */
    orderBy?: conversationParticipantOrderByWithRelationInput | conversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversationParticipants.
     */
    cursor?: conversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * conversationParticipant create
   */
  export type conversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a conversationParticipant.
     */
    data: XOR<conversationParticipantCreateInput, conversationParticipantUncheckedCreateInput>
  }

  /**
   * conversationParticipant createMany
   */
  export type conversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversationParticipants.
     */
    data: conversationParticipantCreateManyInput | conversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversationParticipant createManyAndReturn
   */
  export type conversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many conversationParticipants.
     */
    data: conversationParticipantCreateManyInput | conversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * conversationParticipant update
   */
  export type conversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a conversationParticipant.
     */
    data: XOR<conversationParticipantUpdateInput, conversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which conversationParticipant to update.
     */
    where: conversationParticipantWhereUniqueInput
  }

  /**
   * conversationParticipant updateMany
   */
  export type conversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversationParticipants.
     */
    data: XOR<conversationParticipantUpdateManyMutationInput, conversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which conversationParticipants to update
     */
    where?: conversationParticipantWhereInput
    /**
     * Limit how many conversationParticipants to update.
     */
    limit?: number
  }

  /**
   * conversationParticipant updateManyAndReturn
   */
  export type conversationParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to update conversationParticipants.
     */
    data: XOR<conversationParticipantUpdateManyMutationInput, conversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which conversationParticipants to update
     */
    where?: conversationParticipantWhereInput
    /**
     * Limit how many conversationParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * conversationParticipant upsert
   */
  export type conversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the conversationParticipant to update in case it exists.
     */
    where: conversationParticipantWhereUniqueInput
    /**
     * In case the conversationParticipant found by the `where` argument doesn't exist, create a new conversationParticipant with this data.
     */
    create: XOR<conversationParticipantCreateInput, conversationParticipantUncheckedCreateInput>
    /**
     * In case the conversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationParticipantUpdateInput, conversationParticipantUncheckedUpdateInput>
  }

  /**
   * conversationParticipant delete
   */
  export type conversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which conversationParticipant to delete.
     */
    where: conversationParticipantWhereUniqueInput
  }

  /**
   * conversationParticipant deleteMany
   */
  export type conversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversationParticipants to delete
     */
    where?: conversationParticipantWhereInput
    /**
     * Limit how many conversationParticipants to delete.
     */
    limit?: number
  }

  /**
   * conversationParticipant without action
   */
  export type conversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model exerciseProgram
   */

  export type AggregateExerciseProgram = {
    _count: ExerciseProgramCountAggregateOutputType | null
    _avg: ExerciseProgramAvgAggregateOutputType | null
    _sum: ExerciseProgramSumAggregateOutputType | null
    _min: ExerciseProgramMinAggregateOutputType | null
    _max: ExerciseProgramMaxAggregateOutputType | null
  }

  export type ExerciseProgramAvgAggregateOutputType = {
    difficultyLevel: number | null
    durationMinutes: number | null
  }

  export type ExerciseProgramSumAggregateOutputType = {
    difficultyLevel: number | null
    durationMinutes: number | null
  }

  export type ExerciseProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    difficultyLevel: number | null
    adaptedForReducedMobility: boolean | null
    durationMinutes: number | null
    description: string | null
    videoLink: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    difficultyLevel: number | null
    adaptedForReducedMobility: boolean | null
    durationMinutes: number | null
    description: string | null
    videoLink: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseProgramCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    difficultyLevel: number
    adaptedForReducedMobility: number
    durationMinutes: number
    description: number
    videoLink: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseProgramAvgAggregateInputType = {
    difficultyLevel?: true
    durationMinutes?: true
  }

  export type ExerciseProgramSumAggregateInputType = {
    difficultyLevel?: true
    durationMinutes?: true
  }

  export type ExerciseProgramMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    difficultyLevel?: true
    adaptedForReducedMobility?: true
    durationMinutes?: true
    description?: true
    videoLink?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseProgramMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    difficultyLevel?: true
    adaptedForReducedMobility?: true
    durationMinutes?: true
    description?: true
    videoLink?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseProgramCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    difficultyLevel?: true
    adaptedForReducedMobility?: true
    durationMinutes?: true
    description?: true
    videoLink?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exerciseProgram to aggregate.
     */
    where?: exerciseProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exercisePrograms to fetch.
     */
    orderBy?: exerciseProgramOrderByWithRelationInput | exerciseProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: exerciseProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exercisePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exercisePrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exercisePrograms
    **/
    _count?: true | ExerciseProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseProgramMaxAggregateInputType
  }

  export type GetExerciseProgramAggregateType<T extends ExerciseProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseProgram[P]>
      : GetScalarType<T[P], AggregateExerciseProgram[P]>
  }




  export type exerciseProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exerciseProgramWhereInput
    orderBy?: exerciseProgramOrderByWithAggregationInput | exerciseProgramOrderByWithAggregationInput[]
    by: ExerciseProgramScalarFieldEnum[] | ExerciseProgramScalarFieldEnum
    having?: exerciseProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseProgramCountAggregateInputType | true
    _avg?: ExerciseProgramAvgAggregateInputType
    _sum?: ExerciseProgramSumAggregateInputType
    _min?: ExerciseProgramMinAggregateInputType
    _max?: ExerciseProgramMaxAggregateInputType
  }

  export type ExerciseProgramGroupByOutputType = {
    id: string
    name: string
    categoryId: string | null
    difficultyLevel: number | null
    adaptedForReducedMobility: boolean | null
    durationMinutes: number | null
    description: string | null
    videoLink: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ExerciseProgramCountAggregateOutputType | null
    _avg: ExerciseProgramAvgAggregateOutputType | null
    _sum: ExerciseProgramSumAggregateOutputType | null
    _min: ExerciseProgramMinAggregateOutputType | null
    _max: ExerciseProgramMaxAggregateOutputType | null
  }

  type GetExerciseProgramGroupByPayload<T extends exerciseProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseProgramGroupByOutputType[P]>
        }
      >
    >


  export type exerciseProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    adaptedForReducedMobility?: boolean
    durationMinutes?: boolean
    description?: boolean
    videoLink?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programCategory?: boolean | exerciseProgram$programCategoryArgs<ExtArgs>
    userActivity?: boolean | exerciseProgram$userActivityArgs<ExtArgs>
    _count?: boolean | ExerciseProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseProgram"]>

  export type exerciseProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    adaptedForReducedMobility?: boolean
    durationMinutes?: boolean
    description?: boolean
    videoLink?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programCategory?: boolean | exerciseProgram$programCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseProgram"]>

  export type exerciseProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    adaptedForReducedMobility?: boolean
    durationMinutes?: boolean
    description?: boolean
    videoLink?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programCategory?: boolean | exerciseProgram$programCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseProgram"]>

  export type exerciseProgramSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    difficultyLevel?: boolean
    adaptedForReducedMobility?: boolean
    durationMinutes?: boolean
    description?: boolean
    videoLink?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type exerciseProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "difficultyLevel" | "adaptedForReducedMobility" | "durationMinutes" | "description" | "videoLink" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["exerciseProgram"]>
  export type exerciseProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programCategory?: boolean | exerciseProgram$programCategoryArgs<ExtArgs>
    userActivity?: boolean | exerciseProgram$userActivityArgs<ExtArgs>
    _count?: boolean | ExerciseProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type exerciseProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programCategory?: boolean | exerciseProgram$programCategoryArgs<ExtArgs>
  }
  export type exerciseProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programCategory?: boolean | exerciseProgram$programCategoryArgs<ExtArgs>
  }

  export type $exerciseProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exerciseProgram"
    objects: {
      programCategory: Prisma.$programCategoryPayload<ExtArgs> | null
      userActivity: Prisma.$userActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string | null
      difficultyLevel: number | null
      adaptedForReducedMobility: boolean | null
      durationMinutes: number | null
      description: string | null
      videoLink: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["exerciseProgram"]>
    composites: {}
  }

  type exerciseProgramGetPayload<S extends boolean | null | undefined | exerciseProgramDefaultArgs> = $Result.GetResult<Prisma.$exerciseProgramPayload, S>

  type exerciseProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<exerciseProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseProgramCountAggregateInputType | true
    }

  export interface exerciseProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exerciseProgram'], meta: { name: 'exerciseProgram' } }
    /**
     * Find zero or one ExerciseProgram that matches the filter.
     * @param {exerciseProgramFindUniqueArgs} args - Arguments to find a ExerciseProgram
     * @example
     * // Get one ExerciseProgram
     * const exerciseProgram = await prisma.exerciseProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exerciseProgramFindUniqueArgs>(args: SelectSubset<T, exerciseProgramFindUniqueArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExerciseProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exerciseProgramFindUniqueOrThrowArgs} args - Arguments to find a ExerciseProgram
     * @example
     * // Get one ExerciseProgram
     * const exerciseProgram = await prisma.exerciseProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exerciseProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, exerciseProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exerciseProgramFindFirstArgs} args - Arguments to find a ExerciseProgram
     * @example
     * // Get one ExerciseProgram
     * const exerciseProgram = await prisma.exerciseProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exerciseProgramFindFirstArgs>(args?: SelectSubset<T, exerciseProgramFindFirstArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exerciseProgramFindFirstOrThrowArgs} args - Arguments to find a ExerciseProgram
     * @example
     * // Get one ExerciseProgram
     * const exerciseProgram = await prisma.exerciseProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exerciseProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, exerciseProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExercisePrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exerciseProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExercisePrograms
     * const exercisePrograms = await prisma.exerciseProgram.findMany()
     * 
     * // Get first 10 ExercisePrograms
     * const exercisePrograms = await prisma.exerciseProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseProgramWithIdOnly = await prisma.exerciseProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends exerciseProgramFindManyArgs>(args?: SelectSubset<T, exerciseProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExerciseProgram.
     * @param {exerciseProgramCreateArgs} args - Arguments to create a ExerciseProgram.
     * @example
     * // Create one ExerciseProgram
     * const ExerciseProgram = await prisma.exerciseProgram.create({
     *   data: {
     *     // ... data to create a ExerciseProgram
     *   }
     * })
     * 
     */
    create<T extends exerciseProgramCreateArgs>(args: SelectSubset<T, exerciseProgramCreateArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExercisePrograms.
     * @param {exerciseProgramCreateManyArgs} args - Arguments to create many ExercisePrograms.
     * @example
     * // Create many ExercisePrograms
     * const exerciseProgram = await prisma.exerciseProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends exerciseProgramCreateManyArgs>(args?: SelectSubset<T, exerciseProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExercisePrograms and returns the data saved in the database.
     * @param {exerciseProgramCreateManyAndReturnArgs} args - Arguments to create many ExercisePrograms.
     * @example
     * // Create many ExercisePrograms
     * const exerciseProgram = await prisma.exerciseProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExercisePrograms and only return the `id`
     * const exerciseProgramWithIdOnly = await prisma.exerciseProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends exerciseProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, exerciseProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExerciseProgram.
     * @param {exerciseProgramDeleteArgs} args - Arguments to delete one ExerciseProgram.
     * @example
     * // Delete one ExerciseProgram
     * const ExerciseProgram = await prisma.exerciseProgram.delete({
     *   where: {
     *     // ... filter to delete one ExerciseProgram
     *   }
     * })
     * 
     */
    delete<T extends exerciseProgramDeleteArgs>(args: SelectSubset<T, exerciseProgramDeleteArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExerciseProgram.
     * @param {exerciseProgramUpdateArgs} args - Arguments to update one ExerciseProgram.
     * @example
     * // Update one ExerciseProgram
     * const exerciseProgram = await prisma.exerciseProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends exerciseProgramUpdateArgs>(args: SelectSubset<T, exerciseProgramUpdateArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExercisePrograms.
     * @param {exerciseProgramDeleteManyArgs} args - Arguments to filter ExercisePrograms to delete.
     * @example
     * // Delete a few ExercisePrograms
     * const { count } = await prisma.exerciseProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends exerciseProgramDeleteManyArgs>(args?: SelectSubset<T, exerciseProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExercisePrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exerciseProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExercisePrograms
     * const exerciseProgram = await prisma.exerciseProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends exerciseProgramUpdateManyArgs>(args: SelectSubset<T, exerciseProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExercisePrograms and returns the data updated in the database.
     * @param {exerciseProgramUpdateManyAndReturnArgs} args - Arguments to update many ExercisePrograms.
     * @example
     * // Update many ExercisePrograms
     * const exerciseProgram = await prisma.exerciseProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExercisePrograms and only return the `id`
     * const exerciseProgramWithIdOnly = await prisma.exerciseProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends exerciseProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, exerciseProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExerciseProgram.
     * @param {exerciseProgramUpsertArgs} args - Arguments to update or create a ExerciseProgram.
     * @example
     * // Update or create a ExerciseProgram
     * const exerciseProgram = await prisma.exerciseProgram.upsert({
     *   create: {
     *     // ... data to create a ExerciseProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseProgram we want to update
     *   }
     * })
     */
    upsert<T extends exerciseProgramUpsertArgs>(args: SelectSubset<T, exerciseProgramUpsertArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExercisePrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exerciseProgramCountArgs} args - Arguments to filter ExercisePrograms to count.
     * @example
     * // Count the number of ExercisePrograms
     * const count = await prisma.exerciseProgram.count({
     *   where: {
     *     // ... the filter for the ExercisePrograms we want to count
     *   }
     * })
    **/
    count<T extends exerciseProgramCountArgs>(
      args?: Subset<T, exerciseProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseProgramAggregateArgs>(args: Subset<T, ExerciseProgramAggregateArgs>): Prisma.PrismaPromise<GetExerciseProgramAggregateType<T>>

    /**
     * Group by ExerciseProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exerciseProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends exerciseProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exerciseProgramGroupByArgs['orderBy'] }
        : { orderBy?: exerciseProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, exerciseProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exerciseProgram model
   */
  readonly fields: exerciseProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exerciseProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exerciseProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programCategory<T extends exerciseProgram$programCategoryArgs<ExtArgs> = {}>(args?: Subset<T, exerciseProgram$programCategoryArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userActivity<T extends exerciseProgram$userActivityArgs<ExtArgs> = {}>(args?: Subset<T, exerciseProgram$userActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exerciseProgram model
   */
  interface exerciseProgramFieldRefs {
    readonly id: FieldRef<"exerciseProgram", 'String'>
    readonly name: FieldRef<"exerciseProgram", 'String'>
    readonly categoryId: FieldRef<"exerciseProgram", 'String'>
    readonly difficultyLevel: FieldRef<"exerciseProgram", 'Int'>
    readonly adaptedForReducedMobility: FieldRef<"exerciseProgram", 'Boolean'>
    readonly durationMinutes: FieldRef<"exerciseProgram", 'Int'>
    readonly description: FieldRef<"exerciseProgram", 'String'>
    readonly videoLink: FieldRef<"exerciseProgram", 'String'>
    readonly image: FieldRef<"exerciseProgram", 'String'>
    readonly createdAt: FieldRef<"exerciseProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"exerciseProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * exerciseProgram findUnique
   */
  export type exerciseProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * Filter, which exerciseProgram to fetch.
     */
    where: exerciseProgramWhereUniqueInput
  }

  /**
   * exerciseProgram findUniqueOrThrow
   */
  export type exerciseProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * Filter, which exerciseProgram to fetch.
     */
    where: exerciseProgramWhereUniqueInput
  }

  /**
   * exerciseProgram findFirst
   */
  export type exerciseProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * Filter, which exerciseProgram to fetch.
     */
    where?: exerciseProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exercisePrograms to fetch.
     */
    orderBy?: exerciseProgramOrderByWithRelationInput | exerciseProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exercisePrograms.
     */
    cursor?: exerciseProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exercisePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exercisePrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exercisePrograms.
     */
    distinct?: ExerciseProgramScalarFieldEnum | ExerciseProgramScalarFieldEnum[]
  }

  /**
   * exerciseProgram findFirstOrThrow
   */
  export type exerciseProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * Filter, which exerciseProgram to fetch.
     */
    where?: exerciseProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exercisePrograms to fetch.
     */
    orderBy?: exerciseProgramOrderByWithRelationInput | exerciseProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exercisePrograms.
     */
    cursor?: exerciseProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exercisePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exercisePrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exercisePrograms.
     */
    distinct?: ExerciseProgramScalarFieldEnum | ExerciseProgramScalarFieldEnum[]
  }

  /**
   * exerciseProgram findMany
   */
  export type exerciseProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * Filter, which exercisePrograms to fetch.
     */
    where?: exerciseProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exercisePrograms to fetch.
     */
    orderBy?: exerciseProgramOrderByWithRelationInput | exerciseProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exercisePrograms.
     */
    cursor?: exerciseProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exercisePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exercisePrograms.
     */
    skip?: number
    distinct?: ExerciseProgramScalarFieldEnum | ExerciseProgramScalarFieldEnum[]
  }

  /**
   * exerciseProgram create
   */
  export type exerciseProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a exerciseProgram.
     */
    data: XOR<exerciseProgramCreateInput, exerciseProgramUncheckedCreateInput>
  }

  /**
   * exerciseProgram createMany
   */
  export type exerciseProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exercisePrograms.
     */
    data: exerciseProgramCreateManyInput | exerciseProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exerciseProgram createManyAndReturn
   */
  export type exerciseProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * The data used to create many exercisePrograms.
     */
    data: exerciseProgramCreateManyInput | exerciseProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * exerciseProgram update
   */
  export type exerciseProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a exerciseProgram.
     */
    data: XOR<exerciseProgramUpdateInput, exerciseProgramUncheckedUpdateInput>
    /**
     * Choose, which exerciseProgram to update.
     */
    where: exerciseProgramWhereUniqueInput
  }

  /**
   * exerciseProgram updateMany
   */
  export type exerciseProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exercisePrograms.
     */
    data: XOR<exerciseProgramUpdateManyMutationInput, exerciseProgramUncheckedUpdateManyInput>
    /**
     * Filter which exercisePrograms to update
     */
    where?: exerciseProgramWhereInput
    /**
     * Limit how many exercisePrograms to update.
     */
    limit?: number
  }

  /**
   * exerciseProgram updateManyAndReturn
   */
  export type exerciseProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * The data used to update exercisePrograms.
     */
    data: XOR<exerciseProgramUpdateManyMutationInput, exerciseProgramUncheckedUpdateManyInput>
    /**
     * Filter which exercisePrograms to update
     */
    where?: exerciseProgramWhereInput
    /**
     * Limit how many exercisePrograms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * exerciseProgram upsert
   */
  export type exerciseProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the exerciseProgram to update in case it exists.
     */
    where: exerciseProgramWhereUniqueInput
    /**
     * In case the exerciseProgram found by the `where` argument doesn't exist, create a new exerciseProgram with this data.
     */
    create: XOR<exerciseProgramCreateInput, exerciseProgramUncheckedCreateInput>
    /**
     * In case the exerciseProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exerciseProgramUpdateInput, exerciseProgramUncheckedUpdateInput>
  }

  /**
   * exerciseProgram delete
   */
  export type exerciseProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    /**
     * Filter which exerciseProgram to delete.
     */
    where: exerciseProgramWhereUniqueInput
  }

  /**
   * exerciseProgram deleteMany
   */
  export type exerciseProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exercisePrograms to delete
     */
    where?: exerciseProgramWhereInput
    /**
     * Limit how many exercisePrograms to delete.
     */
    limit?: number
  }

  /**
   * exerciseProgram.programCategory
   */
  export type exerciseProgram$programCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    where?: programCategoryWhereInput
  }

  /**
   * exerciseProgram.userActivity
   */
  export type exerciseProgram$userActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    where?: userActivityWhereInput
    orderBy?: userActivityOrderByWithRelationInput | userActivityOrderByWithRelationInput[]
    cursor?: userActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * exerciseProgram without action
   */
  export type exerciseProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
  }


  /**
   * Model forumCategory
   */

  export type AggregateForumCategory = {
    _count: ForumCategoryCountAggregateOutputType | null
    _min: ForumCategoryMinAggregateOutputType | null
    _max: ForumCategoryMaxAggregateOutputType | null
  }

  export type ForumCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentCategoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentCategoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    parentCategoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentCategoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentCategoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentCategoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forumCategory to aggregate.
     */
    where?: forumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumCategories to fetch.
     */
    orderBy?: forumCategoryOrderByWithRelationInput | forumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: forumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned forumCategories
    **/
    _count?: true | ForumCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumCategoryMaxAggregateInputType
  }

  export type GetForumCategoryAggregateType<T extends ForumCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateForumCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumCategory[P]>
      : GetScalarType<T[P], AggregateForumCategory[P]>
  }




  export type forumCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forumCategoryWhereInput
    orderBy?: forumCategoryOrderByWithAggregationInput | forumCategoryOrderByWithAggregationInput[]
    by: ForumCategoryScalarFieldEnum[] | ForumCategoryScalarFieldEnum
    having?: forumCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCategoryCountAggregateInputType | true
    _min?: ForumCategoryMinAggregateInputType
    _max?: ForumCategoryMaxAggregateInputType
  }

  export type ForumCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    parentCategoryId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ForumCategoryCountAggregateOutputType | null
    _min: ForumCategoryMinAggregateOutputType | null
    _max: ForumCategoryMaxAggregateOutputType | null
  }

  type GetForumCategoryGroupByPayload<T extends forumCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ForumCategoryGroupByOutputType[P]>
        }
      >
    >


  export type forumCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forumTopic?: boolean | forumCategory$forumTopicArgs<ExtArgs>
    _count?: boolean | ForumCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumCategory"]>

  export type forumCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["forumCategory"]>

  export type forumCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["forumCategory"]>

  export type forumCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    parentCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type forumCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "parentCategoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["forumCategory"]>
  export type forumCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumTopic?: boolean | forumCategory$forumTopicArgs<ExtArgs>
    _count?: boolean | ForumCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type forumCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type forumCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $forumCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "forumCategory"
    objects: {
      forumTopic: Prisma.$forumTopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      parentCategoryId: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["forumCategory"]>
    composites: {}
  }

  type forumCategoryGetPayload<S extends boolean | null | undefined | forumCategoryDefaultArgs> = $Result.GetResult<Prisma.$forumCategoryPayload, S>

  type forumCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<forumCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumCategoryCountAggregateInputType | true
    }

  export interface forumCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['forumCategory'], meta: { name: 'forumCategory' } }
    /**
     * Find zero or one ForumCategory that matches the filter.
     * @param {forumCategoryFindUniqueArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends forumCategoryFindUniqueArgs>(args: SelectSubset<T, forumCategoryFindUniqueArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {forumCategoryFindUniqueOrThrowArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends forumCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, forumCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumCategoryFindFirstArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends forumCategoryFindFirstArgs>(args?: SelectSubset<T, forumCategoryFindFirstArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumCategoryFindFirstOrThrowArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends forumCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, forumCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumCategories
     * const forumCategories = await prisma.forumCategory.findMany()
     * 
     * // Get first 10 ForumCategories
     * const forumCategories = await prisma.forumCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends forumCategoryFindManyArgs>(args?: SelectSubset<T, forumCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumCategory.
     * @param {forumCategoryCreateArgs} args - Arguments to create a ForumCategory.
     * @example
     * // Create one ForumCategory
     * const ForumCategory = await prisma.forumCategory.create({
     *   data: {
     *     // ... data to create a ForumCategory
     *   }
     * })
     * 
     */
    create<T extends forumCategoryCreateArgs>(args: SelectSubset<T, forumCategoryCreateArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumCategories.
     * @param {forumCategoryCreateManyArgs} args - Arguments to create many ForumCategories.
     * @example
     * // Create many ForumCategories
     * const forumCategory = await prisma.forumCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends forumCategoryCreateManyArgs>(args?: SelectSubset<T, forumCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumCategories and returns the data saved in the database.
     * @param {forumCategoryCreateManyAndReturnArgs} args - Arguments to create many ForumCategories.
     * @example
     * // Create many ForumCategories
     * const forumCategory = await prisma.forumCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumCategories and only return the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends forumCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, forumCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumCategory.
     * @param {forumCategoryDeleteArgs} args - Arguments to delete one ForumCategory.
     * @example
     * // Delete one ForumCategory
     * const ForumCategory = await prisma.forumCategory.delete({
     *   where: {
     *     // ... filter to delete one ForumCategory
     *   }
     * })
     * 
     */
    delete<T extends forumCategoryDeleteArgs>(args: SelectSubset<T, forumCategoryDeleteArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumCategory.
     * @param {forumCategoryUpdateArgs} args - Arguments to update one ForumCategory.
     * @example
     * // Update one ForumCategory
     * const forumCategory = await prisma.forumCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends forumCategoryUpdateArgs>(args: SelectSubset<T, forumCategoryUpdateArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumCategories.
     * @param {forumCategoryDeleteManyArgs} args - Arguments to filter ForumCategories to delete.
     * @example
     * // Delete a few ForumCategories
     * const { count } = await prisma.forumCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends forumCategoryDeleteManyArgs>(args?: SelectSubset<T, forumCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumCategories
     * const forumCategory = await prisma.forumCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends forumCategoryUpdateManyArgs>(args: SelectSubset<T, forumCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumCategories and returns the data updated in the database.
     * @param {forumCategoryUpdateManyAndReturnArgs} args - Arguments to update many ForumCategories.
     * @example
     * // Update many ForumCategories
     * const forumCategory = await prisma.forumCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumCategories and only return the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends forumCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, forumCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumCategory.
     * @param {forumCategoryUpsertArgs} args - Arguments to update or create a ForumCategory.
     * @example
     * // Update or create a ForumCategory
     * const forumCategory = await prisma.forumCategory.upsert({
     *   create: {
     *     // ... data to create a ForumCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumCategory we want to update
     *   }
     * })
     */
    upsert<T extends forumCategoryUpsertArgs>(args: SelectSubset<T, forumCategoryUpsertArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumCategoryCountArgs} args - Arguments to filter ForumCategories to count.
     * @example
     * // Count the number of ForumCategories
     * const count = await prisma.forumCategory.count({
     *   where: {
     *     // ... the filter for the ForumCategories we want to count
     *   }
     * })
    **/
    count<T extends forumCategoryCountArgs>(
      args?: Subset<T, forumCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumCategoryAggregateArgs>(args: Subset<T, ForumCategoryAggregateArgs>): Prisma.PrismaPromise<GetForumCategoryAggregateType<T>>

    /**
     * Group by ForumCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends forumCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: forumCategoryGroupByArgs['orderBy'] }
        : { orderBy?: forumCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, forumCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the forumCategory model
   */
  readonly fields: forumCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for forumCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__forumCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    forumTopic<T extends forumCategory$forumTopicArgs<ExtArgs> = {}>(args?: Subset<T, forumCategory$forumTopicArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the forumCategory model
   */
  interface forumCategoryFieldRefs {
    readonly id: FieldRef<"forumCategory", 'String'>
    readonly name: FieldRef<"forumCategory", 'String'>
    readonly description: FieldRef<"forumCategory", 'String'>
    readonly parentCategoryId: FieldRef<"forumCategory", 'String'>
    readonly createdAt: FieldRef<"forumCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"forumCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * forumCategory findUnique
   */
  export type forumCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which forumCategory to fetch.
     */
    where: forumCategoryWhereUniqueInput
  }

  /**
   * forumCategory findUniqueOrThrow
   */
  export type forumCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which forumCategory to fetch.
     */
    where: forumCategoryWhereUniqueInput
  }

  /**
   * forumCategory findFirst
   */
  export type forumCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which forumCategory to fetch.
     */
    where?: forumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumCategories to fetch.
     */
    orderBy?: forumCategoryOrderByWithRelationInput | forumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forumCategories.
     */
    cursor?: forumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forumCategories.
     */
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * forumCategory findFirstOrThrow
   */
  export type forumCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which forumCategory to fetch.
     */
    where?: forumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumCategories to fetch.
     */
    orderBy?: forumCategoryOrderByWithRelationInput | forumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forumCategories.
     */
    cursor?: forumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forumCategories.
     */
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * forumCategory findMany
   */
  export type forumCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which forumCategories to fetch.
     */
    where?: forumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumCategories to fetch.
     */
    orderBy?: forumCategoryOrderByWithRelationInput | forumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing forumCategories.
     */
    cursor?: forumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumCategories.
     */
    skip?: number
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * forumCategory create
   */
  export type forumCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a forumCategory.
     */
    data: XOR<forumCategoryCreateInput, forumCategoryUncheckedCreateInput>
  }

  /**
   * forumCategory createMany
   */
  export type forumCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many forumCategories.
     */
    data: forumCategoryCreateManyInput | forumCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * forumCategory createManyAndReturn
   */
  export type forumCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many forumCategories.
     */
    data: forumCategoryCreateManyInput | forumCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * forumCategory update
   */
  export type forumCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a forumCategory.
     */
    data: XOR<forumCategoryUpdateInput, forumCategoryUncheckedUpdateInput>
    /**
     * Choose, which forumCategory to update.
     */
    where: forumCategoryWhereUniqueInput
  }

  /**
   * forumCategory updateMany
   */
  export type forumCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update forumCategories.
     */
    data: XOR<forumCategoryUpdateManyMutationInput, forumCategoryUncheckedUpdateManyInput>
    /**
     * Filter which forumCategories to update
     */
    where?: forumCategoryWhereInput
    /**
     * Limit how many forumCategories to update.
     */
    limit?: number
  }

  /**
   * forumCategory updateManyAndReturn
   */
  export type forumCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * The data used to update forumCategories.
     */
    data: XOR<forumCategoryUpdateManyMutationInput, forumCategoryUncheckedUpdateManyInput>
    /**
     * Filter which forumCategories to update
     */
    where?: forumCategoryWhereInput
    /**
     * Limit how many forumCategories to update.
     */
    limit?: number
  }

  /**
   * forumCategory upsert
   */
  export type forumCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the forumCategory to update in case it exists.
     */
    where: forumCategoryWhereUniqueInput
    /**
     * In case the forumCategory found by the `where` argument doesn't exist, create a new forumCategory with this data.
     */
    create: XOR<forumCategoryCreateInput, forumCategoryUncheckedCreateInput>
    /**
     * In case the forumCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<forumCategoryUpdateInput, forumCategoryUncheckedUpdateInput>
  }

  /**
   * forumCategory delete
   */
  export type forumCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    /**
     * Filter which forumCategory to delete.
     */
    where: forumCategoryWhereUniqueInput
  }

  /**
   * forumCategory deleteMany
   */
  export type forumCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forumCategories to delete
     */
    where?: forumCategoryWhereInput
    /**
     * Limit how many forumCategories to delete.
     */
    limit?: number
  }

  /**
   * forumCategory.forumTopic
   */
  export type forumCategory$forumTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    where?: forumTopicWhereInput
    orderBy?: forumTopicOrderByWithRelationInput | forumTopicOrderByWithRelationInput[]
    cursor?: forumTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * forumCategory without action
   */
  export type forumCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
  }


  /**
   * Model forumMessage
   */

  export type AggregateForumMessage = {
    _count: ForumMessageCountAggregateOutputType | null
    _min: ForumMessageMinAggregateOutputType | null
    _max: ForumMessageMaxAggregateOutputType | null
  }

  export type ForumMessageMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    authorId: string | null
    content: string | null
    solutionMessage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumMessageMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    authorId: string | null
    content: string | null
    solutionMessage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumMessageCountAggregateOutputType = {
    id: number
    topicId: number
    authorId: number
    content: number
    solutionMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumMessageMinAggregateInputType = {
    id?: true
    topicId?: true
    authorId?: true
    content?: true
    solutionMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumMessageMaxAggregateInputType = {
    id?: true
    topicId?: true
    authorId?: true
    content?: true
    solutionMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumMessageCountAggregateInputType = {
    id?: true
    topicId?: true
    authorId?: true
    content?: true
    solutionMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forumMessage to aggregate.
     */
    where?: forumMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumMessages to fetch.
     */
    orderBy?: forumMessageOrderByWithRelationInput | forumMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: forumMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned forumMessages
    **/
    _count?: true | ForumMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumMessageMaxAggregateInputType
  }

  export type GetForumMessageAggregateType<T extends ForumMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateForumMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumMessage[P]>
      : GetScalarType<T[P], AggregateForumMessage[P]>
  }




  export type forumMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forumMessageWhereInput
    orderBy?: forumMessageOrderByWithAggregationInput | forumMessageOrderByWithAggregationInput[]
    by: ForumMessageScalarFieldEnum[] | ForumMessageScalarFieldEnum
    having?: forumMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumMessageCountAggregateInputType | true
    _min?: ForumMessageMinAggregateInputType
    _max?: ForumMessageMaxAggregateInputType
  }

  export type ForumMessageGroupByOutputType = {
    id: string
    topicId: string
    authorId: string
    content: string
    solutionMessage: boolean | null
    createdAt: Date
    updatedAt: Date | null
    _count: ForumMessageCountAggregateOutputType | null
    _min: ForumMessageMinAggregateOutputType | null
    _max: ForumMessageMaxAggregateOutputType | null
  }

  type GetForumMessageGroupByPayload<T extends forumMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ForumMessageGroupByOutputType[P]>
        }
      >
    >


  export type forumMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    authorId?: boolean
    content?: boolean
    solutionMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | forumMessage$userArgs<ExtArgs>
    forumTopic?: boolean | forumMessage$forumTopicArgs<ExtArgs>
  }, ExtArgs["result"]["forumMessage"]>

  export type forumMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    authorId?: boolean
    content?: boolean
    solutionMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | forumMessage$userArgs<ExtArgs>
    forumTopic?: boolean | forumMessage$forumTopicArgs<ExtArgs>
  }, ExtArgs["result"]["forumMessage"]>

  export type forumMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    authorId?: boolean
    content?: boolean
    solutionMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | forumMessage$userArgs<ExtArgs>
    forumTopic?: boolean | forumMessage$forumTopicArgs<ExtArgs>
  }, ExtArgs["result"]["forumMessage"]>

  export type forumMessageSelectScalar = {
    id?: boolean
    topicId?: boolean
    authorId?: boolean
    content?: boolean
    solutionMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type forumMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "topicId" | "authorId" | "content" | "solutionMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["forumMessage"]>
  export type forumMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | forumMessage$userArgs<ExtArgs>
    forumTopic?: boolean | forumMessage$forumTopicArgs<ExtArgs>
  }
  export type forumMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | forumMessage$userArgs<ExtArgs>
    forumTopic?: boolean | forumMessage$forumTopicArgs<ExtArgs>
  }
  export type forumMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | forumMessage$userArgs<ExtArgs>
    forumTopic?: boolean | forumMessage$forumTopicArgs<ExtArgs>
  }

  export type $forumMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "forumMessage"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      forumTopic: Prisma.$forumTopicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      authorId: string
      content: string
      solutionMessage: boolean | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["forumMessage"]>
    composites: {}
  }

  type forumMessageGetPayload<S extends boolean | null | undefined | forumMessageDefaultArgs> = $Result.GetResult<Prisma.$forumMessagePayload, S>

  type forumMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<forumMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumMessageCountAggregateInputType | true
    }

  export interface forumMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['forumMessage'], meta: { name: 'forumMessage' } }
    /**
     * Find zero or one ForumMessage that matches the filter.
     * @param {forumMessageFindUniqueArgs} args - Arguments to find a ForumMessage
     * @example
     * // Get one ForumMessage
     * const forumMessage = await prisma.forumMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends forumMessageFindUniqueArgs>(args: SelectSubset<T, forumMessageFindUniqueArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {forumMessageFindUniqueOrThrowArgs} args - Arguments to find a ForumMessage
     * @example
     * // Get one ForumMessage
     * const forumMessage = await prisma.forumMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends forumMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, forumMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumMessageFindFirstArgs} args - Arguments to find a ForumMessage
     * @example
     * // Get one ForumMessage
     * const forumMessage = await prisma.forumMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends forumMessageFindFirstArgs>(args?: SelectSubset<T, forumMessageFindFirstArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumMessageFindFirstOrThrowArgs} args - Arguments to find a ForumMessage
     * @example
     * // Get one ForumMessage
     * const forumMessage = await prisma.forumMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends forumMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, forumMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumMessages
     * const forumMessages = await prisma.forumMessage.findMany()
     * 
     * // Get first 10 ForumMessages
     * const forumMessages = await prisma.forumMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumMessageWithIdOnly = await prisma.forumMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends forumMessageFindManyArgs>(args?: SelectSubset<T, forumMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumMessage.
     * @param {forumMessageCreateArgs} args - Arguments to create a ForumMessage.
     * @example
     * // Create one ForumMessage
     * const ForumMessage = await prisma.forumMessage.create({
     *   data: {
     *     // ... data to create a ForumMessage
     *   }
     * })
     * 
     */
    create<T extends forumMessageCreateArgs>(args: SelectSubset<T, forumMessageCreateArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumMessages.
     * @param {forumMessageCreateManyArgs} args - Arguments to create many ForumMessages.
     * @example
     * // Create many ForumMessages
     * const forumMessage = await prisma.forumMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends forumMessageCreateManyArgs>(args?: SelectSubset<T, forumMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumMessages and returns the data saved in the database.
     * @param {forumMessageCreateManyAndReturnArgs} args - Arguments to create many ForumMessages.
     * @example
     * // Create many ForumMessages
     * const forumMessage = await prisma.forumMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumMessages and only return the `id`
     * const forumMessageWithIdOnly = await prisma.forumMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends forumMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, forumMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumMessage.
     * @param {forumMessageDeleteArgs} args - Arguments to delete one ForumMessage.
     * @example
     * // Delete one ForumMessage
     * const ForumMessage = await prisma.forumMessage.delete({
     *   where: {
     *     // ... filter to delete one ForumMessage
     *   }
     * })
     * 
     */
    delete<T extends forumMessageDeleteArgs>(args: SelectSubset<T, forumMessageDeleteArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumMessage.
     * @param {forumMessageUpdateArgs} args - Arguments to update one ForumMessage.
     * @example
     * // Update one ForumMessage
     * const forumMessage = await prisma.forumMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends forumMessageUpdateArgs>(args: SelectSubset<T, forumMessageUpdateArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumMessages.
     * @param {forumMessageDeleteManyArgs} args - Arguments to filter ForumMessages to delete.
     * @example
     * // Delete a few ForumMessages
     * const { count } = await prisma.forumMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends forumMessageDeleteManyArgs>(args?: SelectSubset<T, forumMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumMessages
     * const forumMessage = await prisma.forumMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends forumMessageUpdateManyArgs>(args: SelectSubset<T, forumMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumMessages and returns the data updated in the database.
     * @param {forumMessageUpdateManyAndReturnArgs} args - Arguments to update many ForumMessages.
     * @example
     * // Update many ForumMessages
     * const forumMessage = await prisma.forumMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumMessages and only return the `id`
     * const forumMessageWithIdOnly = await prisma.forumMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends forumMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, forumMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumMessage.
     * @param {forumMessageUpsertArgs} args - Arguments to update or create a ForumMessage.
     * @example
     * // Update or create a ForumMessage
     * const forumMessage = await prisma.forumMessage.upsert({
     *   create: {
     *     // ... data to create a ForumMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumMessage we want to update
     *   }
     * })
     */
    upsert<T extends forumMessageUpsertArgs>(args: SelectSubset<T, forumMessageUpsertArgs<ExtArgs>>): Prisma__forumMessageClient<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumMessageCountArgs} args - Arguments to filter ForumMessages to count.
     * @example
     * // Count the number of ForumMessages
     * const count = await prisma.forumMessage.count({
     *   where: {
     *     // ... the filter for the ForumMessages we want to count
     *   }
     * })
    **/
    count<T extends forumMessageCountArgs>(
      args?: Subset<T, forumMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumMessageAggregateArgs>(args: Subset<T, ForumMessageAggregateArgs>): Prisma.PrismaPromise<GetForumMessageAggregateType<T>>

    /**
     * Group by ForumMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends forumMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: forumMessageGroupByArgs['orderBy'] }
        : { orderBy?: forumMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, forumMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the forumMessage model
   */
  readonly fields: forumMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for forumMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__forumMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends forumMessage$userArgs<ExtArgs> = {}>(args?: Subset<T, forumMessage$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    forumTopic<T extends forumMessage$forumTopicArgs<ExtArgs> = {}>(args?: Subset<T, forumMessage$forumTopicArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the forumMessage model
   */
  interface forumMessageFieldRefs {
    readonly id: FieldRef<"forumMessage", 'String'>
    readonly topicId: FieldRef<"forumMessage", 'String'>
    readonly authorId: FieldRef<"forumMessage", 'String'>
    readonly content: FieldRef<"forumMessage", 'String'>
    readonly solutionMessage: FieldRef<"forumMessage", 'Boolean'>
    readonly createdAt: FieldRef<"forumMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"forumMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * forumMessage findUnique
   */
  export type forumMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * Filter, which forumMessage to fetch.
     */
    where: forumMessageWhereUniqueInput
  }

  /**
   * forumMessage findUniqueOrThrow
   */
  export type forumMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * Filter, which forumMessage to fetch.
     */
    where: forumMessageWhereUniqueInput
  }

  /**
   * forumMessage findFirst
   */
  export type forumMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * Filter, which forumMessage to fetch.
     */
    where?: forumMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumMessages to fetch.
     */
    orderBy?: forumMessageOrderByWithRelationInput | forumMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forumMessages.
     */
    cursor?: forumMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forumMessages.
     */
    distinct?: ForumMessageScalarFieldEnum | ForumMessageScalarFieldEnum[]
  }

  /**
   * forumMessage findFirstOrThrow
   */
  export type forumMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * Filter, which forumMessage to fetch.
     */
    where?: forumMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumMessages to fetch.
     */
    orderBy?: forumMessageOrderByWithRelationInput | forumMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forumMessages.
     */
    cursor?: forumMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forumMessages.
     */
    distinct?: ForumMessageScalarFieldEnum | ForumMessageScalarFieldEnum[]
  }

  /**
   * forumMessage findMany
   */
  export type forumMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * Filter, which forumMessages to fetch.
     */
    where?: forumMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumMessages to fetch.
     */
    orderBy?: forumMessageOrderByWithRelationInput | forumMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing forumMessages.
     */
    cursor?: forumMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumMessages.
     */
    skip?: number
    distinct?: ForumMessageScalarFieldEnum | ForumMessageScalarFieldEnum[]
  }

  /**
   * forumMessage create
   */
  export type forumMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a forumMessage.
     */
    data: XOR<forumMessageCreateInput, forumMessageUncheckedCreateInput>
  }

  /**
   * forumMessage createMany
   */
  export type forumMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many forumMessages.
     */
    data: forumMessageCreateManyInput | forumMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * forumMessage createManyAndReturn
   */
  export type forumMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * The data used to create many forumMessages.
     */
    data: forumMessageCreateManyInput | forumMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * forumMessage update
   */
  export type forumMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a forumMessage.
     */
    data: XOR<forumMessageUpdateInput, forumMessageUncheckedUpdateInput>
    /**
     * Choose, which forumMessage to update.
     */
    where: forumMessageWhereUniqueInput
  }

  /**
   * forumMessage updateMany
   */
  export type forumMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update forumMessages.
     */
    data: XOR<forumMessageUpdateManyMutationInput, forumMessageUncheckedUpdateManyInput>
    /**
     * Filter which forumMessages to update
     */
    where?: forumMessageWhereInput
    /**
     * Limit how many forumMessages to update.
     */
    limit?: number
  }

  /**
   * forumMessage updateManyAndReturn
   */
  export type forumMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * The data used to update forumMessages.
     */
    data: XOR<forumMessageUpdateManyMutationInput, forumMessageUncheckedUpdateManyInput>
    /**
     * Filter which forumMessages to update
     */
    where?: forumMessageWhereInput
    /**
     * Limit how many forumMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * forumMessage upsert
   */
  export type forumMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the forumMessage to update in case it exists.
     */
    where: forumMessageWhereUniqueInput
    /**
     * In case the forumMessage found by the `where` argument doesn't exist, create a new forumMessage with this data.
     */
    create: XOR<forumMessageCreateInput, forumMessageUncheckedCreateInput>
    /**
     * In case the forumMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<forumMessageUpdateInput, forumMessageUncheckedUpdateInput>
  }

  /**
   * forumMessage delete
   */
  export type forumMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    /**
     * Filter which forumMessage to delete.
     */
    where: forumMessageWhereUniqueInput
  }

  /**
   * forumMessage deleteMany
   */
  export type forumMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forumMessages to delete
     */
    where?: forumMessageWhereInput
    /**
     * Limit how many forumMessages to delete.
     */
    limit?: number
  }

  /**
   * forumMessage.user
   */
  export type forumMessage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * forumMessage.forumTopic
   */
  export type forumMessage$forumTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    where?: forumTopicWhereInput
  }

  /**
   * forumMessage without action
   */
  export type forumMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
  }


  /**
   * Model forumTopic
   */

  export type AggregateForumTopic = {
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  export type ForumTopicAvgAggregateOutputType = {
    views: number | null
  }

  export type ForumTopicSumAggregateOutputType = {
    views: number | null
  }

  export type ForumTopicMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    authorId: string | null
    title: string | null
    pinned: boolean | null
    status: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumTopicMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    authorId: string | null
    title: string | null
    pinned: boolean | null
    status: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumTopicCountAggregateOutputType = {
    id: number
    categoryId: number
    authorId: number
    title: number
    pinned: number
    status: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumTopicAvgAggregateInputType = {
    views?: true
  }

  export type ForumTopicSumAggregateInputType = {
    views?: true
  }

  export type ForumTopicMinAggregateInputType = {
    id?: true
    categoryId?: true
    authorId?: true
    title?: true
    pinned?: true
    status?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumTopicMaxAggregateInputType = {
    id?: true
    categoryId?: true
    authorId?: true
    title?: true
    pinned?: true
    status?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumTopicCountAggregateInputType = {
    id?: true
    categoryId?: true
    authorId?: true
    title?: true
    pinned?: true
    status?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forumTopic to aggregate.
     */
    where?: forumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumTopics to fetch.
     */
    orderBy?: forumTopicOrderByWithRelationInput | forumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: forumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned forumTopics
    **/
    _count?: true | ForumTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumTopicMaxAggregateInputType
  }

  export type GetForumTopicAggregateType<T extends ForumTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateForumTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumTopic[P]>
      : GetScalarType<T[P], AggregateForumTopic[P]>
  }




  export type forumTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forumTopicWhereInput
    orderBy?: forumTopicOrderByWithAggregationInput | forumTopicOrderByWithAggregationInput[]
    by: ForumTopicScalarFieldEnum[] | ForumTopicScalarFieldEnum
    having?: forumTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumTopicCountAggregateInputType | true
    _avg?: ForumTopicAvgAggregateInputType
    _sum?: ForumTopicSumAggregateInputType
    _min?: ForumTopicMinAggregateInputType
    _max?: ForumTopicMaxAggregateInputType
  }

  export type ForumTopicGroupByOutputType = {
    id: string
    categoryId: string
    authorId: string
    title: string
    pinned: boolean | null
    status: string | null
    views: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  type GetForumTopicGroupByPayload<T extends forumTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
            : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
        }
      >
    >


  export type forumTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    authorId?: boolean
    title?: boolean
    pinned?: boolean
    status?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forumMessage?: boolean | forumTopic$forumMessageArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    forumCategory?: boolean | forumTopic$forumCategoryArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type forumTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    authorId?: boolean
    title?: boolean
    pinned?: boolean
    status?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    forumCategory?: boolean | forumTopic$forumCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type forumTopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    authorId?: boolean
    title?: boolean
    pinned?: boolean
    status?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    forumCategory?: boolean | forumTopic$forumCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type forumTopicSelectScalar = {
    id?: boolean
    categoryId?: boolean
    authorId?: boolean
    title?: boolean
    pinned?: boolean
    status?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type forumTopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "authorId" | "title" | "pinned" | "status" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["forumTopic"]>
  export type forumTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumMessage?: boolean | forumTopic$forumMessageArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    forumCategory?: boolean | forumTopic$forumCategoryArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type forumTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    forumCategory?: boolean | forumTopic$forumCategoryArgs<ExtArgs>
  }
  export type forumTopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    forumCategory?: boolean | forumTopic$forumCategoryArgs<ExtArgs>
  }

  export type $forumTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "forumTopic"
    objects: {
      forumMessage: Prisma.$forumMessagePayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>
      forumCategory: Prisma.$forumCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      authorId: string
      title: string
      pinned: boolean | null
      status: string | null
      views: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["forumTopic"]>
    composites: {}
  }

  type forumTopicGetPayload<S extends boolean | null | undefined | forumTopicDefaultArgs> = $Result.GetResult<Prisma.$forumTopicPayload, S>

  type forumTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<forumTopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumTopicCountAggregateInputType | true
    }

  export interface forumTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['forumTopic'], meta: { name: 'forumTopic' } }
    /**
     * Find zero or one ForumTopic that matches the filter.
     * @param {forumTopicFindUniqueArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends forumTopicFindUniqueArgs>(args: SelectSubset<T, forumTopicFindUniqueArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {forumTopicFindUniqueOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends forumTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, forumTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumTopicFindFirstArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends forumTopicFindFirstArgs>(args?: SelectSubset<T, forumTopicFindFirstArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumTopicFindFirstOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends forumTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, forumTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany()
     * 
     * // Get first 10 ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends forumTopicFindManyArgs>(args?: SelectSubset<T, forumTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumTopic.
     * @param {forumTopicCreateArgs} args - Arguments to create a ForumTopic.
     * @example
     * // Create one ForumTopic
     * const ForumTopic = await prisma.forumTopic.create({
     *   data: {
     *     // ... data to create a ForumTopic
     *   }
     * })
     * 
     */
    create<T extends forumTopicCreateArgs>(args: SelectSubset<T, forumTopicCreateArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumTopics.
     * @param {forumTopicCreateManyArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends forumTopicCreateManyArgs>(args?: SelectSubset<T, forumTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumTopics and returns the data saved in the database.
     * @param {forumTopicCreateManyAndReturnArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumTopics and only return the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends forumTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, forumTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumTopic.
     * @param {forumTopicDeleteArgs} args - Arguments to delete one ForumTopic.
     * @example
     * // Delete one ForumTopic
     * const ForumTopic = await prisma.forumTopic.delete({
     *   where: {
     *     // ... filter to delete one ForumTopic
     *   }
     * })
     * 
     */
    delete<T extends forumTopicDeleteArgs>(args: SelectSubset<T, forumTopicDeleteArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumTopic.
     * @param {forumTopicUpdateArgs} args - Arguments to update one ForumTopic.
     * @example
     * // Update one ForumTopic
     * const forumTopic = await prisma.forumTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends forumTopicUpdateArgs>(args: SelectSubset<T, forumTopicUpdateArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumTopics.
     * @param {forumTopicDeleteManyArgs} args - Arguments to filter ForumTopics to delete.
     * @example
     * // Delete a few ForumTopics
     * const { count } = await prisma.forumTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends forumTopicDeleteManyArgs>(args?: SelectSubset<T, forumTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumTopics
     * const forumTopic = await prisma.forumTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends forumTopicUpdateManyArgs>(args: SelectSubset<T, forumTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumTopics and returns the data updated in the database.
     * @param {forumTopicUpdateManyAndReturnArgs} args - Arguments to update many ForumTopics.
     * @example
     * // Update many ForumTopics
     * const forumTopic = await prisma.forumTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumTopics and only return the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends forumTopicUpdateManyAndReturnArgs>(args: SelectSubset<T, forumTopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumTopic.
     * @param {forumTopicUpsertArgs} args - Arguments to update or create a ForumTopic.
     * @example
     * // Update or create a ForumTopic
     * const forumTopic = await prisma.forumTopic.upsert({
     *   create: {
     *     // ... data to create a ForumTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumTopic we want to update
     *   }
     * })
     */
    upsert<T extends forumTopicUpsertArgs>(args: SelectSubset<T, forumTopicUpsertArgs<ExtArgs>>): Prisma__forumTopicClient<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumTopicCountArgs} args - Arguments to filter ForumTopics to count.
     * @example
     * // Count the number of ForumTopics
     * const count = await prisma.forumTopic.count({
     *   where: {
     *     // ... the filter for the ForumTopics we want to count
     *   }
     * })
    **/
    count<T extends forumTopicCountArgs>(
      args?: Subset<T, forumTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumTopicAggregateArgs>(args: Subset<T, ForumTopicAggregateArgs>): Prisma.PrismaPromise<GetForumTopicAggregateType<T>>

    /**
     * Group by ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forumTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends forumTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: forumTopicGroupByArgs['orderBy'] }
        : { orderBy?: forumTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, forumTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the forumTopic model
   */
  readonly fields: forumTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for forumTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__forumTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    forumMessage<T extends forumTopic$forumMessageArgs<ExtArgs> = {}>(args?: Subset<T, forumTopic$forumMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    forumCategory<T extends forumTopic$forumCategoryArgs<ExtArgs> = {}>(args?: Subset<T, forumTopic$forumCategoryArgs<ExtArgs>>): Prisma__forumCategoryClient<$Result.GetResult<Prisma.$forumCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the forumTopic model
   */
  interface forumTopicFieldRefs {
    readonly id: FieldRef<"forumTopic", 'String'>
    readonly categoryId: FieldRef<"forumTopic", 'String'>
    readonly authorId: FieldRef<"forumTopic", 'String'>
    readonly title: FieldRef<"forumTopic", 'String'>
    readonly pinned: FieldRef<"forumTopic", 'Boolean'>
    readonly status: FieldRef<"forumTopic", 'String'>
    readonly views: FieldRef<"forumTopic", 'Int'>
    readonly createdAt: FieldRef<"forumTopic", 'DateTime'>
    readonly updatedAt: FieldRef<"forumTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * forumTopic findUnique
   */
  export type forumTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * Filter, which forumTopic to fetch.
     */
    where: forumTopicWhereUniqueInput
  }

  /**
   * forumTopic findUniqueOrThrow
   */
  export type forumTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * Filter, which forumTopic to fetch.
     */
    where: forumTopicWhereUniqueInput
  }

  /**
   * forumTopic findFirst
   */
  export type forumTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * Filter, which forumTopic to fetch.
     */
    where?: forumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumTopics to fetch.
     */
    orderBy?: forumTopicOrderByWithRelationInput | forumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forumTopics.
     */
    cursor?: forumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * forumTopic findFirstOrThrow
   */
  export type forumTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * Filter, which forumTopic to fetch.
     */
    where?: forumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumTopics to fetch.
     */
    orderBy?: forumTopicOrderByWithRelationInput | forumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forumTopics.
     */
    cursor?: forumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * forumTopic findMany
   */
  export type forumTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * Filter, which forumTopics to fetch.
     */
    where?: forumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forumTopics to fetch.
     */
    orderBy?: forumTopicOrderByWithRelationInput | forumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing forumTopics.
     */
    cursor?: forumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forumTopics.
     */
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * forumTopic create
   */
  export type forumTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a forumTopic.
     */
    data: XOR<forumTopicCreateInput, forumTopicUncheckedCreateInput>
  }

  /**
   * forumTopic createMany
   */
  export type forumTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many forumTopics.
     */
    data: forumTopicCreateManyInput | forumTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * forumTopic createManyAndReturn
   */
  export type forumTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * The data used to create many forumTopics.
     */
    data: forumTopicCreateManyInput | forumTopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * forumTopic update
   */
  export type forumTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a forumTopic.
     */
    data: XOR<forumTopicUpdateInput, forumTopicUncheckedUpdateInput>
    /**
     * Choose, which forumTopic to update.
     */
    where: forumTopicWhereUniqueInput
  }

  /**
   * forumTopic updateMany
   */
  export type forumTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update forumTopics.
     */
    data: XOR<forumTopicUpdateManyMutationInput, forumTopicUncheckedUpdateManyInput>
    /**
     * Filter which forumTopics to update
     */
    where?: forumTopicWhereInput
    /**
     * Limit how many forumTopics to update.
     */
    limit?: number
  }

  /**
   * forumTopic updateManyAndReturn
   */
  export type forumTopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * The data used to update forumTopics.
     */
    data: XOR<forumTopicUpdateManyMutationInput, forumTopicUncheckedUpdateManyInput>
    /**
     * Filter which forumTopics to update
     */
    where?: forumTopicWhereInput
    /**
     * Limit how many forumTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * forumTopic upsert
   */
  export type forumTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the forumTopic to update in case it exists.
     */
    where: forumTopicWhereUniqueInput
    /**
     * In case the forumTopic found by the `where` argument doesn't exist, create a new forumTopic with this data.
     */
    create: XOR<forumTopicCreateInput, forumTopicUncheckedCreateInput>
    /**
     * In case the forumTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<forumTopicUpdateInput, forumTopicUncheckedUpdateInput>
  }

  /**
   * forumTopic delete
   */
  export type forumTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    /**
     * Filter which forumTopic to delete.
     */
    where: forumTopicWhereUniqueInput
  }

  /**
   * forumTopic deleteMany
   */
  export type forumTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forumTopics to delete
     */
    where?: forumTopicWhereInput
    /**
     * Limit how many forumTopics to delete.
     */
    limit?: number
  }

  /**
   * forumTopic.forumMessage
   */
  export type forumTopic$forumMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    where?: forumMessageWhereInput
    orderBy?: forumMessageOrderByWithRelationInput | forumMessageOrderByWithRelationInput[]
    cursor?: forumMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumMessageScalarFieldEnum | ForumMessageScalarFieldEnum[]
  }

  /**
   * forumTopic.forumCategory
   */
  export type forumTopic$forumCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumCategory
     */
    select?: forumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumCategory
     */
    omit?: forumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumCategoryInclude<ExtArgs> | null
    where?: forumCategoryWhereInput
  }

  /**
   * forumTopic without action
   */
  export type forumTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
  }


  /**
   * Model healthIndicator
   */

  export type AggregateHealthIndicator = {
    _count: HealthIndicatorCountAggregateOutputType | null
    _avg: HealthIndicatorAvgAggregateOutputType | null
    _sum: HealthIndicatorSumAggregateOutputType | null
    _min: HealthIndicatorMinAggregateOutputType | null
    _max: HealthIndicatorMaxAggregateOutputType | null
  }

  export type HealthIndicatorAvgAggregateOutputType = {
    stepCount: number | null
    sleepDurationMinutes: number | null
    sleepQuality: number | null
    weight: number | null
  }

  export type HealthIndicatorSumAggregateOutputType = {
    stepCount: number | null
    sleepDurationMinutes: number | null
    sleepQuality: number | null
    weight: number | null
  }

  export type HealthIndicatorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    recordingDate: Date | null
    stepCount: number | null
    sleepDurationMinutes: number | null
    sleepQuality: number | null
    weight: number | null
    mood: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthIndicatorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    recordingDate: Date | null
    stepCount: number | null
    sleepDurationMinutes: number | null
    sleepQuality: number | null
    weight: number | null
    mood: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthIndicatorCountAggregateOutputType = {
    id: number
    userId: number
    recordingDate: number
    stepCount: number
    sleepDurationMinutes: number
    sleepQuality: number
    weight: number
    mood: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthIndicatorAvgAggregateInputType = {
    stepCount?: true
    sleepDurationMinutes?: true
    sleepQuality?: true
    weight?: true
  }

  export type HealthIndicatorSumAggregateInputType = {
    stepCount?: true
    sleepDurationMinutes?: true
    sleepQuality?: true
    weight?: true
  }

  export type HealthIndicatorMinAggregateInputType = {
    id?: true
    userId?: true
    recordingDate?: true
    stepCount?: true
    sleepDurationMinutes?: true
    sleepQuality?: true
    weight?: true
    mood?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthIndicatorMaxAggregateInputType = {
    id?: true
    userId?: true
    recordingDate?: true
    stepCount?: true
    sleepDurationMinutes?: true
    sleepQuality?: true
    weight?: true
    mood?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthIndicatorCountAggregateInputType = {
    id?: true
    userId?: true
    recordingDate?: true
    stepCount?: true
    sleepDurationMinutes?: true
    sleepQuality?: true
    weight?: true
    mood?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthIndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which healthIndicator to aggregate.
     */
    where?: healthIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of healthIndicators to fetch.
     */
    orderBy?: healthIndicatorOrderByWithRelationInput | healthIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: healthIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` healthIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` healthIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned healthIndicators
    **/
    _count?: true | HealthIndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthIndicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthIndicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthIndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthIndicatorMaxAggregateInputType
  }

  export type GetHealthIndicatorAggregateType<T extends HealthIndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthIndicator[P]>
      : GetScalarType<T[P], AggregateHealthIndicator[P]>
  }




  export type healthIndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: healthIndicatorWhereInput
    orderBy?: healthIndicatorOrderByWithAggregationInput | healthIndicatorOrderByWithAggregationInput[]
    by: HealthIndicatorScalarFieldEnum[] | HealthIndicatorScalarFieldEnum
    having?: healthIndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthIndicatorCountAggregateInputType | true
    _avg?: HealthIndicatorAvgAggregateInputType
    _sum?: HealthIndicatorSumAggregateInputType
    _min?: HealthIndicatorMinAggregateInputType
    _max?: HealthIndicatorMaxAggregateInputType
  }

  export type HealthIndicatorGroupByOutputType = {
    id: string
    userId: string
    recordingDate: Date
    stepCount: number | null
    sleepDurationMinutes: number | null
    sleepQuality: number | null
    weight: number | null
    mood: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: HealthIndicatorCountAggregateOutputType | null
    _avg: HealthIndicatorAvgAggregateOutputType | null
    _sum: HealthIndicatorSumAggregateOutputType | null
    _min: HealthIndicatorMinAggregateOutputType | null
    _max: HealthIndicatorMaxAggregateOutputType | null
  }

  type GetHealthIndicatorGroupByPayload<T extends healthIndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthIndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthIndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthIndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], HealthIndicatorGroupByOutputType[P]>
        }
      >
    >


  export type healthIndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recordingDate?: boolean
    stepCount?: boolean
    sleepDurationMinutes?: boolean
    sleepQuality?: boolean
    weight?: boolean
    mood?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | healthIndicator$userArgs<ExtArgs>
  }, ExtArgs["result"]["healthIndicator"]>

  export type healthIndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recordingDate?: boolean
    stepCount?: boolean
    sleepDurationMinutes?: boolean
    sleepQuality?: boolean
    weight?: boolean
    mood?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | healthIndicator$userArgs<ExtArgs>
  }, ExtArgs["result"]["healthIndicator"]>

  export type healthIndicatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recordingDate?: boolean
    stepCount?: boolean
    sleepDurationMinutes?: boolean
    sleepQuality?: boolean
    weight?: boolean
    mood?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | healthIndicator$userArgs<ExtArgs>
  }, ExtArgs["result"]["healthIndicator"]>

  export type healthIndicatorSelectScalar = {
    id?: boolean
    userId?: boolean
    recordingDate?: boolean
    stepCount?: boolean
    sleepDurationMinutes?: boolean
    sleepQuality?: boolean
    weight?: boolean
    mood?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type healthIndicatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "recordingDate" | "stepCount" | "sleepDurationMinutes" | "sleepQuality" | "weight" | "mood" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["healthIndicator"]>
  export type healthIndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | healthIndicator$userArgs<ExtArgs>
  }
  export type healthIndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | healthIndicator$userArgs<ExtArgs>
  }
  export type healthIndicatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | healthIndicator$userArgs<ExtArgs>
  }

  export type $healthIndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "healthIndicator"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      recordingDate: Date
      stepCount: number | null
      sleepDurationMinutes: number | null
      sleepQuality: number | null
      weight: number | null
      mood: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["healthIndicator"]>
    composites: {}
  }

  type healthIndicatorGetPayload<S extends boolean | null | undefined | healthIndicatorDefaultArgs> = $Result.GetResult<Prisma.$healthIndicatorPayload, S>

  type healthIndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<healthIndicatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HealthIndicatorCountAggregateInputType | true
    }

  export interface healthIndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['healthIndicator'], meta: { name: 'healthIndicator' } }
    /**
     * Find zero or one HealthIndicator that matches the filter.
     * @param {healthIndicatorFindUniqueArgs} args - Arguments to find a HealthIndicator
     * @example
     * // Get one HealthIndicator
     * const healthIndicator = await prisma.healthIndicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends healthIndicatorFindUniqueArgs>(args: SelectSubset<T, healthIndicatorFindUniqueArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HealthIndicator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {healthIndicatorFindUniqueOrThrowArgs} args - Arguments to find a HealthIndicator
     * @example
     * // Get one HealthIndicator
     * const healthIndicator = await prisma.healthIndicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends healthIndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, healthIndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthIndicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {healthIndicatorFindFirstArgs} args - Arguments to find a HealthIndicator
     * @example
     * // Get one HealthIndicator
     * const healthIndicator = await prisma.healthIndicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends healthIndicatorFindFirstArgs>(args?: SelectSubset<T, healthIndicatorFindFirstArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthIndicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {healthIndicatorFindFirstOrThrowArgs} args - Arguments to find a HealthIndicator
     * @example
     * // Get one HealthIndicator
     * const healthIndicator = await prisma.healthIndicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends healthIndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, healthIndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HealthIndicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {healthIndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthIndicators
     * const healthIndicators = await prisma.healthIndicator.findMany()
     * 
     * // Get first 10 HealthIndicators
     * const healthIndicators = await prisma.healthIndicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthIndicatorWithIdOnly = await prisma.healthIndicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends healthIndicatorFindManyArgs>(args?: SelectSubset<T, healthIndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HealthIndicator.
     * @param {healthIndicatorCreateArgs} args - Arguments to create a HealthIndicator.
     * @example
     * // Create one HealthIndicator
     * const HealthIndicator = await prisma.healthIndicator.create({
     *   data: {
     *     // ... data to create a HealthIndicator
     *   }
     * })
     * 
     */
    create<T extends healthIndicatorCreateArgs>(args: SelectSubset<T, healthIndicatorCreateArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HealthIndicators.
     * @param {healthIndicatorCreateManyArgs} args - Arguments to create many HealthIndicators.
     * @example
     * // Create many HealthIndicators
     * const healthIndicator = await prisma.healthIndicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends healthIndicatorCreateManyArgs>(args?: SelectSubset<T, healthIndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthIndicators and returns the data saved in the database.
     * @param {healthIndicatorCreateManyAndReturnArgs} args - Arguments to create many HealthIndicators.
     * @example
     * // Create many HealthIndicators
     * const healthIndicator = await prisma.healthIndicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthIndicators and only return the `id`
     * const healthIndicatorWithIdOnly = await prisma.healthIndicator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends healthIndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, healthIndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HealthIndicator.
     * @param {healthIndicatorDeleteArgs} args - Arguments to delete one HealthIndicator.
     * @example
     * // Delete one HealthIndicator
     * const HealthIndicator = await prisma.healthIndicator.delete({
     *   where: {
     *     // ... filter to delete one HealthIndicator
     *   }
     * })
     * 
     */
    delete<T extends healthIndicatorDeleteArgs>(args: SelectSubset<T, healthIndicatorDeleteArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HealthIndicator.
     * @param {healthIndicatorUpdateArgs} args - Arguments to update one HealthIndicator.
     * @example
     * // Update one HealthIndicator
     * const healthIndicator = await prisma.healthIndicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends healthIndicatorUpdateArgs>(args: SelectSubset<T, healthIndicatorUpdateArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HealthIndicators.
     * @param {healthIndicatorDeleteManyArgs} args - Arguments to filter HealthIndicators to delete.
     * @example
     * // Delete a few HealthIndicators
     * const { count } = await prisma.healthIndicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends healthIndicatorDeleteManyArgs>(args?: SelectSubset<T, healthIndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {healthIndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthIndicators
     * const healthIndicator = await prisma.healthIndicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends healthIndicatorUpdateManyArgs>(args: SelectSubset<T, healthIndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthIndicators and returns the data updated in the database.
     * @param {healthIndicatorUpdateManyAndReturnArgs} args - Arguments to update many HealthIndicators.
     * @example
     * // Update many HealthIndicators
     * const healthIndicator = await prisma.healthIndicator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HealthIndicators and only return the `id`
     * const healthIndicatorWithIdOnly = await prisma.healthIndicator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends healthIndicatorUpdateManyAndReturnArgs>(args: SelectSubset<T, healthIndicatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HealthIndicator.
     * @param {healthIndicatorUpsertArgs} args - Arguments to update or create a HealthIndicator.
     * @example
     * // Update or create a HealthIndicator
     * const healthIndicator = await prisma.healthIndicator.upsert({
     *   create: {
     *     // ... data to create a HealthIndicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthIndicator we want to update
     *   }
     * })
     */
    upsert<T extends healthIndicatorUpsertArgs>(args: SelectSubset<T, healthIndicatorUpsertArgs<ExtArgs>>): Prisma__healthIndicatorClient<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HealthIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {healthIndicatorCountArgs} args - Arguments to filter HealthIndicators to count.
     * @example
     * // Count the number of HealthIndicators
     * const count = await prisma.healthIndicator.count({
     *   where: {
     *     // ... the filter for the HealthIndicators we want to count
     *   }
     * })
    **/
    count<T extends healthIndicatorCountArgs>(
      args?: Subset<T, healthIndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthIndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthIndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthIndicatorAggregateArgs>(args: Subset<T, HealthIndicatorAggregateArgs>): Prisma.PrismaPromise<GetHealthIndicatorAggregateType<T>>

    /**
     * Group by HealthIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {healthIndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends healthIndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: healthIndicatorGroupByArgs['orderBy'] }
        : { orderBy?: healthIndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, healthIndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the healthIndicator model
   */
  readonly fields: healthIndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for healthIndicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__healthIndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends healthIndicator$userArgs<ExtArgs> = {}>(args?: Subset<T, healthIndicator$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the healthIndicator model
   */
  interface healthIndicatorFieldRefs {
    readonly id: FieldRef<"healthIndicator", 'String'>
    readonly userId: FieldRef<"healthIndicator", 'String'>
    readonly recordingDate: FieldRef<"healthIndicator", 'DateTime'>
    readonly stepCount: FieldRef<"healthIndicator", 'Int'>
    readonly sleepDurationMinutes: FieldRef<"healthIndicator", 'Int'>
    readonly sleepQuality: FieldRef<"healthIndicator", 'Int'>
    readonly weight: FieldRef<"healthIndicator", 'Float'>
    readonly mood: FieldRef<"healthIndicator", 'String'>
    readonly notes: FieldRef<"healthIndicator", 'String'>
    readonly createdAt: FieldRef<"healthIndicator", 'DateTime'>
    readonly updatedAt: FieldRef<"healthIndicator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * healthIndicator findUnique
   */
  export type healthIndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which healthIndicator to fetch.
     */
    where: healthIndicatorWhereUniqueInput
  }

  /**
   * healthIndicator findUniqueOrThrow
   */
  export type healthIndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which healthIndicator to fetch.
     */
    where: healthIndicatorWhereUniqueInput
  }

  /**
   * healthIndicator findFirst
   */
  export type healthIndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which healthIndicator to fetch.
     */
    where?: healthIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of healthIndicators to fetch.
     */
    orderBy?: healthIndicatorOrderByWithRelationInput | healthIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for healthIndicators.
     */
    cursor?: healthIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` healthIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` healthIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of healthIndicators.
     */
    distinct?: HealthIndicatorScalarFieldEnum | HealthIndicatorScalarFieldEnum[]
  }

  /**
   * healthIndicator findFirstOrThrow
   */
  export type healthIndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which healthIndicator to fetch.
     */
    where?: healthIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of healthIndicators to fetch.
     */
    orderBy?: healthIndicatorOrderByWithRelationInput | healthIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for healthIndicators.
     */
    cursor?: healthIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` healthIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` healthIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of healthIndicators.
     */
    distinct?: HealthIndicatorScalarFieldEnum | HealthIndicatorScalarFieldEnum[]
  }

  /**
   * healthIndicator findMany
   */
  export type healthIndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which healthIndicators to fetch.
     */
    where?: healthIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of healthIndicators to fetch.
     */
    orderBy?: healthIndicatorOrderByWithRelationInput | healthIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing healthIndicators.
     */
    cursor?: healthIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` healthIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` healthIndicators.
     */
    skip?: number
    distinct?: HealthIndicatorScalarFieldEnum | HealthIndicatorScalarFieldEnum[]
  }

  /**
   * healthIndicator create
   */
  export type healthIndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a healthIndicator.
     */
    data: XOR<healthIndicatorCreateInput, healthIndicatorUncheckedCreateInput>
  }

  /**
   * healthIndicator createMany
   */
  export type healthIndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many healthIndicators.
     */
    data: healthIndicatorCreateManyInput | healthIndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * healthIndicator createManyAndReturn
   */
  export type healthIndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * The data used to create many healthIndicators.
     */
    data: healthIndicatorCreateManyInput | healthIndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * healthIndicator update
   */
  export type healthIndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a healthIndicator.
     */
    data: XOR<healthIndicatorUpdateInput, healthIndicatorUncheckedUpdateInput>
    /**
     * Choose, which healthIndicator to update.
     */
    where: healthIndicatorWhereUniqueInput
  }

  /**
   * healthIndicator updateMany
   */
  export type healthIndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update healthIndicators.
     */
    data: XOR<healthIndicatorUpdateManyMutationInput, healthIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which healthIndicators to update
     */
    where?: healthIndicatorWhereInput
    /**
     * Limit how many healthIndicators to update.
     */
    limit?: number
  }

  /**
   * healthIndicator updateManyAndReturn
   */
  export type healthIndicatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * The data used to update healthIndicators.
     */
    data: XOR<healthIndicatorUpdateManyMutationInput, healthIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which healthIndicators to update
     */
    where?: healthIndicatorWhereInput
    /**
     * Limit how many healthIndicators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * healthIndicator upsert
   */
  export type healthIndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the healthIndicator to update in case it exists.
     */
    where: healthIndicatorWhereUniqueInput
    /**
     * In case the healthIndicator found by the `where` argument doesn't exist, create a new healthIndicator with this data.
     */
    create: XOR<healthIndicatorCreateInput, healthIndicatorUncheckedCreateInput>
    /**
     * In case the healthIndicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<healthIndicatorUpdateInput, healthIndicatorUncheckedUpdateInput>
  }

  /**
   * healthIndicator delete
   */
  export type healthIndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    /**
     * Filter which healthIndicator to delete.
     */
    where: healthIndicatorWhereUniqueInput
  }

  /**
   * healthIndicator deleteMany
   */
  export type healthIndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which healthIndicators to delete
     */
    where?: healthIndicatorWhereInput
    /**
     * Limit how many healthIndicators to delete.
     */
    limit?: number
  }

  /**
   * healthIndicator.user
   */
  export type healthIndicator$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * healthIndicator without action
   */
  export type healthIndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
  }


  /**
   * Model helpOffer
   */

  export type AggregateHelpOffer = {
    _count: HelpOfferCountAggregateOutputType | null
    _min: HelpOfferMinAggregateOutputType | null
    _max: HelpOfferMaxAggregateOutputType | null
  }

  export type HelpOfferMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    helperId: string | null
    offerDate: Date | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpOfferMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    helperId: string | null
    offerDate: Date | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpOfferCountAggregateOutputType = {
    id: number
    requestId: number
    helperId: number
    offerDate: number
    message: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpOfferMinAggregateInputType = {
    id?: true
    requestId?: true
    helperId?: true
    offerDate?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpOfferMaxAggregateInputType = {
    id?: true
    requestId?: true
    helperId?: true
    offerDate?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpOfferCountAggregateInputType = {
    id?: true
    requestId?: true
    helperId?: true
    offerDate?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helpOffer to aggregate.
     */
    where?: helpOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpOffers to fetch.
     */
    orderBy?: helpOfferOrderByWithRelationInput | helpOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: helpOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned helpOffers
    **/
    _count?: true | HelpOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpOfferMaxAggregateInputType
  }

  export type GetHelpOfferAggregateType<T extends HelpOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpOffer[P]>
      : GetScalarType<T[P], AggregateHelpOffer[P]>
  }




  export type helpOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helpOfferWhereInput
    orderBy?: helpOfferOrderByWithAggregationInput | helpOfferOrderByWithAggregationInput[]
    by: HelpOfferScalarFieldEnum[] | HelpOfferScalarFieldEnum
    having?: helpOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpOfferCountAggregateInputType | true
    _min?: HelpOfferMinAggregateInputType
    _max?: HelpOfferMaxAggregateInputType
  }

  export type HelpOfferGroupByOutputType = {
    id: string
    requestId: string
    helperId: string
    offerDate: Date
    message: string | null
    status: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: HelpOfferCountAggregateOutputType | null
    _min: HelpOfferMinAggregateOutputType | null
    _max: HelpOfferMaxAggregateOutputType | null
  }

  type GetHelpOfferGroupByPayload<T extends helpOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpOfferGroupByOutputType[P]>
            : GetScalarType<T[P], HelpOfferGroupByOutputType[P]>
        }
      >
    >


  export type helpOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    offerDate?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpOffer"]>

  export type helpOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    offerDate?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpOffer"]>

  export type helpOfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    offerDate?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpOffer"]>

  export type helpOfferSelectScalar = {
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    offerDate?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type helpOfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "helperId" | "offerDate" | "message" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["helpOffer"]>
  export type helpOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }
  export type helpOfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }
  export type helpOfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }

  export type $helpOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "helpOffer"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      helpRequest: Prisma.$helpRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      helperId: string
      offerDate: Date
      message: string | null
      status: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["helpOffer"]>
    composites: {}
  }

  type helpOfferGetPayload<S extends boolean | null | undefined | helpOfferDefaultArgs> = $Result.GetResult<Prisma.$helpOfferPayload, S>

  type helpOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<helpOfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelpOfferCountAggregateInputType | true
    }

  export interface helpOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['helpOffer'], meta: { name: 'helpOffer' } }
    /**
     * Find zero or one HelpOffer that matches the filter.
     * @param {helpOfferFindUniqueArgs} args - Arguments to find a HelpOffer
     * @example
     * // Get one HelpOffer
     * const helpOffer = await prisma.helpOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends helpOfferFindUniqueArgs>(args: SelectSubset<T, helpOfferFindUniqueArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HelpOffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {helpOfferFindUniqueOrThrowArgs} args - Arguments to find a HelpOffer
     * @example
     * // Get one HelpOffer
     * const helpOffer = await prisma.helpOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends helpOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, helpOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpOfferFindFirstArgs} args - Arguments to find a HelpOffer
     * @example
     * // Get one HelpOffer
     * const helpOffer = await prisma.helpOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends helpOfferFindFirstArgs>(args?: SelectSubset<T, helpOfferFindFirstArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpOfferFindFirstOrThrowArgs} args - Arguments to find a HelpOffer
     * @example
     * // Get one HelpOffer
     * const helpOffer = await prisma.helpOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends helpOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, helpOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HelpOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpOffers
     * const helpOffers = await prisma.helpOffer.findMany()
     * 
     * // Get first 10 HelpOffers
     * const helpOffers = await prisma.helpOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpOfferWithIdOnly = await prisma.helpOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends helpOfferFindManyArgs>(args?: SelectSubset<T, helpOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HelpOffer.
     * @param {helpOfferCreateArgs} args - Arguments to create a HelpOffer.
     * @example
     * // Create one HelpOffer
     * const HelpOffer = await prisma.helpOffer.create({
     *   data: {
     *     // ... data to create a HelpOffer
     *   }
     * })
     * 
     */
    create<T extends helpOfferCreateArgs>(args: SelectSubset<T, helpOfferCreateArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HelpOffers.
     * @param {helpOfferCreateManyArgs} args - Arguments to create many HelpOffers.
     * @example
     * // Create many HelpOffers
     * const helpOffer = await prisma.helpOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends helpOfferCreateManyArgs>(args?: SelectSubset<T, helpOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpOffers and returns the data saved in the database.
     * @param {helpOfferCreateManyAndReturnArgs} args - Arguments to create many HelpOffers.
     * @example
     * // Create many HelpOffers
     * const helpOffer = await prisma.helpOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpOffers and only return the `id`
     * const helpOfferWithIdOnly = await prisma.helpOffer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends helpOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, helpOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HelpOffer.
     * @param {helpOfferDeleteArgs} args - Arguments to delete one HelpOffer.
     * @example
     * // Delete one HelpOffer
     * const HelpOffer = await prisma.helpOffer.delete({
     *   where: {
     *     // ... filter to delete one HelpOffer
     *   }
     * })
     * 
     */
    delete<T extends helpOfferDeleteArgs>(args: SelectSubset<T, helpOfferDeleteArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HelpOffer.
     * @param {helpOfferUpdateArgs} args - Arguments to update one HelpOffer.
     * @example
     * // Update one HelpOffer
     * const helpOffer = await prisma.helpOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends helpOfferUpdateArgs>(args: SelectSubset<T, helpOfferUpdateArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HelpOffers.
     * @param {helpOfferDeleteManyArgs} args - Arguments to filter HelpOffers to delete.
     * @example
     * // Delete a few HelpOffers
     * const { count } = await prisma.helpOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends helpOfferDeleteManyArgs>(args?: SelectSubset<T, helpOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpOffers
     * const helpOffer = await prisma.helpOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends helpOfferUpdateManyArgs>(args: SelectSubset<T, helpOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpOffers and returns the data updated in the database.
     * @param {helpOfferUpdateManyAndReturnArgs} args - Arguments to update many HelpOffers.
     * @example
     * // Update many HelpOffers
     * const helpOffer = await prisma.helpOffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HelpOffers and only return the `id`
     * const helpOfferWithIdOnly = await prisma.helpOffer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends helpOfferUpdateManyAndReturnArgs>(args: SelectSubset<T, helpOfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HelpOffer.
     * @param {helpOfferUpsertArgs} args - Arguments to update or create a HelpOffer.
     * @example
     * // Update or create a HelpOffer
     * const helpOffer = await prisma.helpOffer.upsert({
     *   create: {
     *     // ... data to create a HelpOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpOffer we want to update
     *   }
     * })
     */
    upsert<T extends helpOfferUpsertArgs>(args: SelectSubset<T, helpOfferUpsertArgs<ExtArgs>>): Prisma__helpOfferClient<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HelpOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpOfferCountArgs} args - Arguments to filter HelpOffers to count.
     * @example
     * // Count the number of HelpOffers
     * const count = await prisma.helpOffer.count({
     *   where: {
     *     // ... the filter for the HelpOffers we want to count
     *   }
     * })
    **/
    count<T extends helpOfferCountArgs>(
      args?: Subset<T, helpOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpOfferAggregateArgs>(args: Subset<T, HelpOfferAggregateArgs>): Prisma.PrismaPromise<GetHelpOfferAggregateType<T>>

    /**
     * Group by HelpOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends helpOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: helpOfferGroupByArgs['orderBy'] }
        : { orderBy?: helpOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, helpOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the helpOffer model
   */
  readonly fields: helpOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for helpOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__helpOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    helpRequest<T extends helpRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, helpRequestDefaultArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the helpOffer model
   */
  interface helpOfferFieldRefs {
    readonly id: FieldRef<"helpOffer", 'String'>
    readonly requestId: FieldRef<"helpOffer", 'String'>
    readonly helperId: FieldRef<"helpOffer", 'String'>
    readonly offerDate: FieldRef<"helpOffer", 'DateTime'>
    readonly message: FieldRef<"helpOffer", 'String'>
    readonly status: FieldRef<"helpOffer", 'String'>
    readonly createdAt: FieldRef<"helpOffer", 'DateTime'>
    readonly updatedAt: FieldRef<"helpOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * helpOffer findUnique
   */
  export type helpOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * Filter, which helpOffer to fetch.
     */
    where: helpOfferWhereUniqueInput
  }

  /**
   * helpOffer findUniqueOrThrow
   */
  export type helpOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * Filter, which helpOffer to fetch.
     */
    where: helpOfferWhereUniqueInput
  }

  /**
   * helpOffer findFirst
   */
  export type helpOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * Filter, which helpOffer to fetch.
     */
    where?: helpOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpOffers to fetch.
     */
    orderBy?: helpOfferOrderByWithRelationInput | helpOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helpOffers.
     */
    cursor?: helpOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helpOffers.
     */
    distinct?: HelpOfferScalarFieldEnum | HelpOfferScalarFieldEnum[]
  }

  /**
   * helpOffer findFirstOrThrow
   */
  export type helpOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * Filter, which helpOffer to fetch.
     */
    where?: helpOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpOffers to fetch.
     */
    orderBy?: helpOfferOrderByWithRelationInput | helpOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helpOffers.
     */
    cursor?: helpOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helpOffers.
     */
    distinct?: HelpOfferScalarFieldEnum | HelpOfferScalarFieldEnum[]
  }

  /**
   * helpOffer findMany
   */
  export type helpOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * Filter, which helpOffers to fetch.
     */
    where?: helpOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpOffers to fetch.
     */
    orderBy?: helpOfferOrderByWithRelationInput | helpOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing helpOffers.
     */
    cursor?: helpOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpOffers.
     */
    skip?: number
    distinct?: HelpOfferScalarFieldEnum | HelpOfferScalarFieldEnum[]
  }

  /**
   * helpOffer create
   */
  export type helpOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a helpOffer.
     */
    data: XOR<helpOfferCreateInput, helpOfferUncheckedCreateInput>
  }

  /**
   * helpOffer createMany
   */
  export type helpOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many helpOffers.
     */
    data: helpOfferCreateManyInput | helpOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * helpOffer createManyAndReturn
   */
  export type helpOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * The data used to create many helpOffers.
     */
    data: helpOfferCreateManyInput | helpOfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * helpOffer update
   */
  export type helpOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a helpOffer.
     */
    data: XOR<helpOfferUpdateInput, helpOfferUncheckedUpdateInput>
    /**
     * Choose, which helpOffer to update.
     */
    where: helpOfferWhereUniqueInput
  }

  /**
   * helpOffer updateMany
   */
  export type helpOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update helpOffers.
     */
    data: XOR<helpOfferUpdateManyMutationInput, helpOfferUncheckedUpdateManyInput>
    /**
     * Filter which helpOffers to update
     */
    where?: helpOfferWhereInput
    /**
     * Limit how many helpOffers to update.
     */
    limit?: number
  }

  /**
   * helpOffer updateManyAndReturn
   */
  export type helpOfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * The data used to update helpOffers.
     */
    data: XOR<helpOfferUpdateManyMutationInput, helpOfferUncheckedUpdateManyInput>
    /**
     * Filter which helpOffers to update
     */
    where?: helpOfferWhereInput
    /**
     * Limit how many helpOffers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * helpOffer upsert
   */
  export type helpOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the helpOffer to update in case it exists.
     */
    where: helpOfferWhereUniqueInput
    /**
     * In case the helpOffer found by the `where` argument doesn't exist, create a new helpOffer with this data.
     */
    create: XOR<helpOfferCreateInput, helpOfferUncheckedCreateInput>
    /**
     * In case the helpOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<helpOfferUpdateInput, helpOfferUncheckedUpdateInput>
  }

  /**
   * helpOffer delete
   */
  export type helpOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    /**
     * Filter which helpOffer to delete.
     */
    where: helpOfferWhereUniqueInput
  }

  /**
   * helpOffer deleteMany
   */
  export type helpOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helpOffers to delete
     */
    where?: helpOfferWhereInput
    /**
     * Limit how many helpOffers to delete.
     */
    limit?: number
  }

  /**
   * helpOffer without action
   */
  export type helpOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
  }


  /**
   * Model helpRequest
   */

  export type AggregateHelpRequest = {
    _count: HelpRequestCountAggregateOutputType | null
    _avg: HelpRequestAvgAggregateOutputType | null
    _sum: HelpRequestSumAggregateOutputType | null
    _min: HelpRequestMinAggregateOutputType | null
    _max: HelpRequestMaxAggregateOutputType | null
  }

  export type HelpRequestAvgAggregateOutputType = {
    estimatedDuration: number | null
    pointsOffered: number | null
  }

  export type HelpRequestSumAggregateOutputType = {
    estimatedDuration: number | null
    pointsOffered: number | null
  }

  export type HelpRequestMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    neededDate: Date | null
    estimatedDuration: number | null
    location: string | null
    gpsCoordinates: string | null
    categoryId: string | null
    recurring: boolean | null
    frequency: string | null
    status: string | null
    pointsOffered: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpRequestMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    neededDate: Date | null
    estimatedDuration: number | null
    location: string | null
    gpsCoordinates: string | null
    categoryId: string | null
    recurring: boolean | null
    frequency: string | null
    status: string | null
    pointsOffered: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpRequestCountAggregateOutputType = {
    id: number
    creatorId: number
    title: number
    description: number
    neededDate: number
    estimatedDuration: number
    location: number
    gpsCoordinates: number
    categoryId: number
    recurring: number
    frequency: number
    status: number
    pointsOffered: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpRequestAvgAggregateInputType = {
    estimatedDuration?: true
    pointsOffered?: true
  }

  export type HelpRequestSumAggregateInputType = {
    estimatedDuration?: true
    pointsOffered?: true
  }

  export type HelpRequestMinAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    neededDate?: true
    estimatedDuration?: true
    location?: true
    gpsCoordinates?: true
    categoryId?: true
    recurring?: true
    frequency?: true
    status?: true
    pointsOffered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpRequestMaxAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    neededDate?: true
    estimatedDuration?: true
    location?: true
    gpsCoordinates?: true
    categoryId?: true
    recurring?: true
    frequency?: true
    status?: true
    pointsOffered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpRequestCountAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    neededDate?: true
    estimatedDuration?: true
    location?: true
    gpsCoordinates?: true
    categoryId?: true
    recurring?: true
    frequency?: true
    status?: true
    pointsOffered?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helpRequest to aggregate.
     */
    where?: helpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpRequests to fetch.
     */
    orderBy?: helpRequestOrderByWithRelationInput | helpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: helpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned helpRequests
    **/
    _count?: true | HelpRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpRequestMaxAggregateInputType
  }

  export type GetHelpRequestAggregateType<T extends HelpRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpRequest[P]>
      : GetScalarType<T[P], AggregateHelpRequest[P]>
  }




  export type helpRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helpRequestWhereInput
    orderBy?: helpRequestOrderByWithAggregationInput | helpRequestOrderByWithAggregationInput[]
    by: HelpRequestScalarFieldEnum[] | HelpRequestScalarFieldEnum
    having?: helpRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpRequestCountAggregateInputType | true
    _avg?: HelpRequestAvgAggregateInputType
    _sum?: HelpRequestSumAggregateInputType
    _min?: HelpRequestMinAggregateInputType
    _max?: HelpRequestMaxAggregateInputType
  }

  export type HelpRequestGroupByOutputType = {
    id: string
    creatorId: string
    title: string
    description: string | null
    neededDate: Date
    estimatedDuration: number | null
    location: string | null
    gpsCoordinates: string | null
    categoryId: string
    recurring: boolean | null
    frequency: string | null
    status: string | null
    pointsOffered: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: HelpRequestCountAggregateOutputType | null
    _avg: HelpRequestAvgAggregateOutputType | null
    _sum: HelpRequestSumAggregateOutputType | null
    _min: HelpRequestMinAggregateOutputType | null
    _max: HelpRequestMaxAggregateOutputType | null
  }

  type GetHelpRequestGroupByPayload<T extends helpRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpRequestGroupByOutputType[P]>
            : GetScalarType<T[P], HelpRequestGroupByOutputType[P]>
        }
      >
    >


  export type helpRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    neededDate?: boolean
    estimatedDuration?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    status?: boolean
    pointsOffered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    helpOffer?: boolean | helpRequest$helpOfferArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    serviceCompleted?: boolean | helpRequest$serviceCompletedArgs<ExtArgs>
    helpCategory?: boolean | helpRequest$helpCategoryArgs<ExtArgs>
    _count?: boolean | HelpRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpRequest"]>

  export type helpRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    neededDate?: boolean
    estimatedDuration?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    status?: boolean
    pointsOffered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpCategory?: boolean | helpRequest$helpCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["helpRequest"]>

  export type helpRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    neededDate?: boolean
    estimatedDuration?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    status?: boolean
    pointsOffered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpCategory?: boolean | helpRequest$helpCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["helpRequest"]>

  export type helpRequestSelectScalar = {
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    neededDate?: boolean
    estimatedDuration?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    categoryId?: boolean
    recurring?: boolean
    frequency?: boolean
    status?: boolean
    pointsOffered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type helpRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorId" | "title" | "description" | "neededDate" | "estimatedDuration" | "location" | "gpsCoordinates" | "categoryId" | "recurring" | "frequency" | "status" | "pointsOffered" | "createdAt" | "updatedAt", ExtArgs["result"]["helpRequest"]>
  export type helpRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpOffer?: boolean | helpRequest$helpOfferArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    serviceCompleted?: boolean | helpRequest$serviceCompletedArgs<ExtArgs>
    helpCategory?: boolean | helpRequest$helpCategoryArgs<ExtArgs>
    _count?: boolean | HelpRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type helpRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpCategory?: boolean | helpRequest$helpCategoryArgs<ExtArgs>
  }
  export type helpRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpCategory?: boolean | helpRequest$helpCategoryArgs<ExtArgs>
  }

  export type $helpRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "helpRequest"
    objects: {
      helpOffer: Prisma.$helpOfferPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>
      serviceCompleted: Prisma.$serviceCompletedPayload<ExtArgs>[]
      helpCategory: Prisma.$helpCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      title: string
      description: string | null
      neededDate: Date
      estimatedDuration: number | null
      location: string | null
      gpsCoordinates: string | null
      categoryId: string
      recurring: boolean | null
      frequency: string | null
      status: string | null
      pointsOffered: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["helpRequest"]>
    composites: {}
  }

  type helpRequestGetPayload<S extends boolean | null | undefined | helpRequestDefaultArgs> = $Result.GetResult<Prisma.$helpRequestPayload, S>

  type helpRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<helpRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelpRequestCountAggregateInputType | true
    }

  export interface helpRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['helpRequest'], meta: { name: 'helpRequest' } }
    /**
     * Find zero or one HelpRequest that matches the filter.
     * @param {helpRequestFindUniqueArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends helpRequestFindUniqueArgs>(args: SelectSubset<T, helpRequestFindUniqueArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HelpRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {helpRequestFindUniqueOrThrowArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends helpRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, helpRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpRequestFindFirstArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends helpRequestFindFirstArgs>(args?: SelectSubset<T, helpRequestFindFirstArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpRequestFindFirstOrThrowArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends helpRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, helpRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HelpRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpRequests
     * const helpRequests = await prisma.helpRequest.findMany()
     * 
     * // Get first 10 HelpRequests
     * const helpRequests = await prisma.helpRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpRequestWithIdOnly = await prisma.helpRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends helpRequestFindManyArgs>(args?: SelectSubset<T, helpRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HelpRequest.
     * @param {helpRequestCreateArgs} args - Arguments to create a HelpRequest.
     * @example
     * // Create one HelpRequest
     * const HelpRequest = await prisma.helpRequest.create({
     *   data: {
     *     // ... data to create a HelpRequest
     *   }
     * })
     * 
     */
    create<T extends helpRequestCreateArgs>(args: SelectSubset<T, helpRequestCreateArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HelpRequests.
     * @param {helpRequestCreateManyArgs} args - Arguments to create many HelpRequests.
     * @example
     * // Create many HelpRequests
     * const helpRequest = await prisma.helpRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends helpRequestCreateManyArgs>(args?: SelectSubset<T, helpRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpRequests and returns the data saved in the database.
     * @param {helpRequestCreateManyAndReturnArgs} args - Arguments to create many HelpRequests.
     * @example
     * // Create many HelpRequests
     * const helpRequest = await prisma.helpRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpRequests and only return the `id`
     * const helpRequestWithIdOnly = await prisma.helpRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends helpRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, helpRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HelpRequest.
     * @param {helpRequestDeleteArgs} args - Arguments to delete one HelpRequest.
     * @example
     * // Delete one HelpRequest
     * const HelpRequest = await prisma.helpRequest.delete({
     *   where: {
     *     // ... filter to delete one HelpRequest
     *   }
     * })
     * 
     */
    delete<T extends helpRequestDeleteArgs>(args: SelectSubset<T, helpRequestDeleteArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HelpRequest.
     * @param {helpRequestUpdateArgs} args - Arguments to update one HelpRequest.
     * @example
     * // Update one HelpRequest
     * const helpRequest = await prisma.helpRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends helpRequestUpdateArgs>(args: SelectSubset<T, helpRequestUpdateArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HelpRequests.
     * @param {helpRequestDeleteManyArgs} args - Arguments to filter HelpRequests to delete.
     * @example
     * // Delete a few HelpRequests
     * const { count } = await prisma.helpRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends helpRequestDeleteManyArgs>(args?: SelectSubset<T, helpRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpRequests
     * const helpRequest = await prisma.helpRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends helpRequestUpdateManyArgs>(args: SelectSubset<T, helpRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpRequests and returns the data updated in the database.
     * @param {helpRequestUpdateManyAndReturnArgs} args - Arguments to update many HelpRequests.
     * @example
     * // Update many HelpRequests
     * const helpRequest = await prisma.helpRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HelpRequests and only return the `id`
     * const helpRequestWithIdOnly = await prisma.helpRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends helpRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, helpRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HelpRequest.
     * @param {helpRequestUpsertArgs} args - Arguments to update or create a HelpRequest.
     * @example
     * // Update or create a HelpRequest
     * const helpRequest = await prisma.helpRequest.upsert({
     *   create: {
     *     // ... data to create a HelpRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpRequest we want to update
     *   }
     * })
     */
    upsert<T extends helpRequestUpsertArgs>(args: SelectSubset<T, helpRequestUpsertArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HelpRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpRequestCountArgs} args - Arguments to filter HelpRequests to count.
     * @example
     * // Count the number of HelpRequests
     * const count = await prisma.helpRequest.count({
     *   where: {
     *     // ... the filter for the HelpRequests we want to count
     *   }
     * })
    **/
    count<T extends helpRequestCountArgs>(
      args?: Subset<T, helpRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpRequestAggregateArgs>(args: Subset<T, HelpRequestAggregateArgs>): Prisma.PrismaPromise<GetHelpRequestAggregateType<T>>

    /**
     * Group by HelpRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends helpRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: helpRequestGroupByArgs['orderBy'] }
        : { orderBy?: helpRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, helpRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the helpRequest model
   */
  readonly fields: helpRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for helpRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__helpRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    helpOffer<T extends helpRequest$helpOfferArgs<ExtArgs> = {}>(args?: Subset<T, helpRequest$helpOfferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceCompleted<T extends helpRequest$serviceCompletedArgs<ExtArgs> = {}>(args?: Subset<T, helpRequest$serviceCompletedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    helpCategory<T extends helpRequest$helpCategoryArgs<ExtArgs> = {}>(args?: Subset<T, helpRequest$helpCategoryArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the helpRequest model
   */
  interface helpRequestFieldRefs {
    readonly id: FieldRef<"helpRequest", 'String'>
    readonly creatorId: FieldRef<"helpRequest", 'String'>
    readonly title: FieldRef<"helpRequest", 'String'>
    readonly description: FieldRef<"helpRequest", 'String'>
    readonly neededDate: FieldRef<"helpRequest", 'DateTime'>
    readonly estimatedDuration: FieldRef<"helpRequest", 'Int'>
    readonly location: FieldRef<"helpRequest", 'String'>
    readonly gpsCoordinates: FieldRef<"helpRequest", 'String'>
    readonly categoryId: FieldRef<"helpRequest", 'String'>
    readonly recurring: FieldRef<"helpRequest", 'Boolean'>
    readonly frequency: FieldRef<"helpRequest", 'String'>
    readonly status: FieldRef<"helpRequest", 'String'>
    readonly pointsOffered: FieldRef<"helpRequest", 'Int'>
    readonly createdAt: FieldRef<"helpRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"helpRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * helpRequest findUnique
   */
  export type helpRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * Filter, which helpRequest to fetch.
     */
    where: helpRequestWhereUniqueInput
  }

  /**
   * helpRequest findUniqueOrThrow
   */
  export type helpRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * Filter, which helpRequest to fetch.
     */
    where: helpRequestWhereUniqueInput
  }

  /**
   * helpRequest findFirst
   */
  export type helpRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * Filter, which helpRequest to fetch.
     */
    where?: helpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpRequests to fetch.
     */
    orderBy?: helpRequestOrderByWithRelationInput | helpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helpRequests.
     */
    cursor?: helpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helpRequests.
     */
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * helpRequest findFirstOrThrow
   */
  export type helpRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * Filter, which helpRequest to fetch.
     */
    where?: helpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpRequests to fetch.
     */
    orderBy?: helpRequestOrderByWithRelationInput | helpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helpRequests.
     */
    cursor?: helpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helpRequests.
     */
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * helpRequest findMany
   */
  export type helpRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * Filter, which helpRequests to fetch.
     */
    where?: helpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpRequests to fetch.
     */
    orderBy?: helpRequestOrderByWithRelationInput | helpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing helpRequests.
     */
    cursor?: helpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpRequests.
     */
    skip?: number
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * helpRequest create
   */
  export type helpRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a helpRequest.
     */
    data: XOR<helpRequestCreateInput, helpRequestUncheckedCreateInput>
  }

  /**
   * helpRequest createMany
   */
  export type helpRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many helpRequests.
     */
    data: helpRequestCreateManyInput | helpRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * helpRequest createManyAndReturn
   */
  export type helpRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * The data used to create many helpRequests.
     */
    data: helpRequestCreateManyInput | helpRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * helpRequest update
   */
  export type helpRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a helpRequest.
     */
    data: XOR<helpRequestUpdateInput, helpRequestUncheckedUpdateInput>
    /**
     * Choose, which helpRequest to update.
     */
    where: helpRequestWhereUniqueInput
  }

  /**
   * helpRequest updateMany
   */
  export type helpRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update helpRequests.
     */
    data: XOR<helpRequestUpdateManyMutationInput, helpRequestUncheckedUpdateManyInput>
    /**
     * Filter which helpRequests to update
     */
    where?: helpRequestWhereInput
    /**
     * Limit how many helpRequests to update.
     */
    limit?: number
  }

  /**
   * helpRequest updateManyAndReturn
   */
  export type helpRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * The data used to update helpRequests.
     */
    data: XOR<helpRequestUpdateManyMutationInput, helpRequestUncheckedUpdateManyInput>
    /**
     * Filter which helpRequests to update
     */
    where?: helpRequestWhereInput
    /**
     * Limit how many helpRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * helpRequest upsert
   */
  export type helpRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the helpRequest to update in case it exists.
     */
    where: helpRequestWhereUniqueInput
    /**
     * In case the helpRequest found by the `where` argument doesn't exist, create a new helpRequest with this data.
     */
    create: XOR<helpRequestCreateInput, helpRequestUncheckedCreateInput>
    /**
     * In case the helpRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<helpRequestUpdateInput, helpRequestUncheckedUpdateInput>
  }

  /**
   * helpRequest delete
   */
  export type helpRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    /**
     * Filter which helpRequest to delete.
     */
    where: helpRequestWhereUniqueInput
  }

  /**
   * helpRequest deleteMany
   */
  export type helpRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helpRequests to delete
     */
    where?: helpRequestWhereInput
    /**
     * Limit how many helpRequests to delete.
     */
    limit?: number
  }

  /**
   * helpRequest.helpOffer
   */
  export type helpRequest$helpOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    where?: helpOfferWhereInput
    orderBy?: helpOfferOrderByWithRelationInput | helpOfferOrderByWithRelationInput[]
    cursor?: helpOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpOfferScalarFieldEnum | HelpOfferScalarFieldEnum[]
  }

  /**
   * helpRequest.serviceCompleted
   */
  export type helpRequest$serviceCompletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    where?: serviceCompletedWhereInput
    orderBy?: serviceCompletedOrderByWithRelationInput | serviceCompletedOrderByWithRelationInput[]
    cursor?: serviceCompletedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceCompletedScalarFieldEnum | ServiceCompletedScalarFieldEnum[]
  }

  /**
   * helpRequest.helpCategory
   */
  export type helpRequest$helpCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    where?: helpCategoryWhereInput
  }

  /**
   * helpRequest without action
   */
  export type helpRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
  }


  /**
   * Model localService
   */

  export type AggregateLocalService = {
    _count: LocalServiceCountAggregateOutputType | null
    _min: LocalServiceMinAggregateOutputType | null
    _max: LocalServiceMaxAggregateOutputType | null
  }

  export type LocalServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    address: string | null
    gpsCoordinates: string | null
    phone: string | null
    website: string | null
    description: string | null
    hours: string | null
    seniorFriendly: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    address: string | null
    gpsCoordinates: string | null
    phone: string | null
    website: string | null
    description: string | null
    hours: string | null
    seniorFriendly: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalServiceCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    address: number
    gpsCoordinates: number
    phone: number
    website: number
    description: number
    hours: number
    seniorFriendly: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocalServiceMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    address?: true
    gpsCoordinates?: true
    phone?: true
    website?: true
    description?: true
    hours?: true
    seniorFriendly?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalServiceMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    address?: true
    gpsCoordinates?: true
    phone?: true
    website?: true
    description?: true
    hours?: true
    seniorFriendly?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalServiceCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    address?: true
    gpsCoordinates?: true
    phone?: true
    website?: true
    description?: true
    hours?: true
    seniorFriendly?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocalServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localService to aggregate.
     */
    where?: localServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localServices to fetch.
     */
    orderBy?: localServiceOrderByWithRelationInput | localServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: localServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned localServices
    **/
    _count?: true | LocalServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalServiceMaxAggregateInputType
  }

  export type GetLocalServiceAggregateType<T extends LocalServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalService[P]>
      : GetScalarType<T[P], AggregateLocalService[P]>
  }




  export type localServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localServiceWhereInput
    orderBy?: localServiceOrderByWithAggregationInput | localServiceOrderByWithAggregationInput[]
    by: LocalServiceScalarFieldEnum[] | LocalServiceScalarFieldEnum
    having?: localServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalServiceCountAggregateInputType | true
    _min?: LocalServiceMinAggregateInputType
    _max?: LocalServiceMaxAggregateInputType
  }

  export type LocalServiceGroupByOutputType = {
    id: string
    name: string
    categoryId: string
    address: string | null
    gpsCoordinates: string | null
    phone: string | null
    website: string | null
    description: string | null
    hours: string | null
    seniorFriendly: boolean | null
    createdAt: Date
    updatedAt: Date | null
    _count: LocalServiceCountAggregateOutputType | null
    _min: LocalServiceMinAggregateOutputType | null
    _max: LocalServiceMaxAggregateOutputType | null
  }

  type GetLocalServiceGroupByPayload<T extends localServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalServiceGroupByOutputType[P]>
            : GetScalarType<T[P], LocalServiceGroupByOutputType[P]>
        }
      >
    >


  export type localServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    website?: boolean
    description?: boolean
    hours?: boolean
    seniorFriendly?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceCategory?: boolean | localService$serviceCategoryArgs<ExtArgs>
    serviceRating?: boolean | localService$serviceRatingArgs<ExtArgs>
    _count?: boolean | LocalServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localService"]>

  export type localServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    website?: boolean
    description?: boolean
    hours?: boolean
    seniorFriendly?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceCategory?: boolean | localService$serviceCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["localService"]>

  export type localServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    website?: boolean
    description?: boolean
    hours?: boolean
    seniorFriendly?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceCategory?: boolean | localService$serviceCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["localService"]>

  export type localServiceSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    website?: boolean
    description?: boolean
    hours?: boolean
    seniorFriendly?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type localServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "address" | "gpsCoordinates" | "phone" | "website" | "description" | "hours" | "seniorFriendly" | "createdAt" | "updatedAt", ExtArgs["result"]["localService"]>
  export type localServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceCategory?: boolean | localService$serviceCategoryArgs<ExtArgs>
    serviceRating?: boolean | localService$serviceRatingArgs<ExtArgs>
    _count?: boolean | LocalServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type localServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceCategory?: boolean | localService$serviceCategoryArgs<ExtArgs>
  }
  export type localServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceCategory?: boolean | localService$serviceCategoryArgs<ExtArgs>
  }

  export type $localServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "localService"
    objects: {
      serviceCategory: Prisma.$serviceCategoryPayload<ExtArgs> | null
      serviceRating: Prisma.$serviceRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string
      address: string | null
      gpsCoordinates: string | null
      phone: string | null
      website: string | null
      description: string | null
      hours: string | null
      seniorFriendly: boolean | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["localService"]>
    composites: {}
  }

  type localServiceGetPayload<S extends boolean | null | undefined | localServiceDefaultArgs> = $Result.GetResult<Prisma.$localServicePayload, S>

  type localServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<localServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalServiceCountAggregateInputType | true
    }

  export interface localServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['localService'], meta: { name: 'localService' } }
    /**
     * Find zero or one LocalService that matches the filter.
     * @param {localServiceFindUniqueArgs} args - Arguments to find a LocalService
     * @example
     * // Get one LocalService
     * const localService = await prisma.localService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends localServiceFindUniqueArgs>(args: SelectSubset<T, localServiceFindUniqueArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocalService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {localServiceFindUniqueOrThrowArgs} args - Arguments to find a LocalService
     * @example
     * // Get one LocalService
     * const localService = await prisma.localService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends localServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, localServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localServiceFindFirstArgs} args - Arguments to find a LocalService
     * @example
     * // Get one LocalService
     * const localService = await prisma.localService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends localServiceFindFirstArgs>(args?: SelectSubset<T, localServiceFindFirstArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localServiceFindFirstOrThrowArgs} args - Arguments to find a LocalService
     * @example
     * // Get one LocalService
     * const localService = await prisma.localService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends localServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, localServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocalServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalServices
     * const localServices = await prisma.localService.findMany()
     * 
     * // Get first 10 LocalServices
     * const localServices = await prisma.localService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localServiceWithIdOnly = await prisma.localService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends localServiceFindManyArgs>(args?: SelectSubset<T, localServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocalService.
     * @param {localServiceCreateArgs} args - Arguments to create a LocalService.
     * @example
     * // Create one LocalService
     * const LocalService = await prisma.localService.create({
     *   data: {
     *     // ... data to create a LocalService
     *   }
     * })
     * 
     */
    create<T extends localServiceCreateArgs>(args: SelectSubset<T, localServiceCreateArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocalServices.
     * @param {localServiceCreateManyArgs} args - Arguments to create many LocalServices.
     * @example
     * // Create many LocalServices
     * const localService = await prisma.localService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends localServiceCreateManyArgs>(args?: SelectSubset<T, localServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalServices and returns the data saved in the database.
     * @param {localServiceCreateManyAndReturnArgs} args - Arguments to create many LocalServices.
     * @example
     * // Create many LocalServices
     * const localService = await prisma.localService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalServices and only return the `id`
     * const localServiceWithIdOnly = await prisma.localService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends localServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, localServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocalService.
     * @param {localServiceDeleteArgs} args - Arguments to delete one LocalService.
     * @example
     * // Delete one LocalService
     * const LocalService = await prisma.localService.delete({
     *   where: {
     *     // ... filter to delete one LocalService
     *   }
     * })
     * 
     */
    delete<T extends localServiceDeleteArgs>(args: SelectSubset<T, localServiceDeleteArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocalService.
     * @param {localServiceUpdateArgs} args - Arguments to update one LocalService.
     * @example
     * // Update one LocalService
     * const localService = await prisma.localService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends localServiceUpdateArgs>(args: SelectSubset<T, localServiceUpdateArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocalServices.
     * @param {localServiceDeleteManyArgs} args - Arguments to filter LocalServices to delete.
     * @example
     * // Delete a few LocalServices
     * const { count } = await prisma.localService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends localServiceDeleteManyArgs>(args?: SelectSubset<T, localServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalServices
     * const localService = await prisma.localService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends localServiceUpdateManyArgs>(args: SelectSubset<T, localServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalServices and returns the data updated in the database.
     * @param {localServiceUpdateManyAndReturnArgs} args - Arguments to update many LocalServices.
     * @example
     * // Update many LocalServices
     * const localService = await prisma.localService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocalServices and only return the `id`
     * const localServiceWithIdOnly = await prisma.localService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends localServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, localServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocalService.
     * @param {localServiceUpsertArgs} args - Arguments to update or create a LocalService.
     * @example
     * // Update or create a LocalService
     * const localService = await prisma.localService.upsert({
     *   create: {
     *     // ... data to create a LocalService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalService we want to update
     *   }
     * })
     */
    upsert<T extends localServiceUpsertArgs>(args: SelectSubset<T, localServiceUpsertArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocalServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localServiceCountArgs} args - Arguments to filter LocalServices to count.
     * @example
     * // Count the number of LocalServices
     * const count = await prisma.localService.count({
     *   where: {
     *     // ... the filter for the LocalServices we want to count
     *   }
     * })
    **/
    count<T extends localServiceCountArgs>(
      args?: Subset<T, localServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalServiceAggregateArgs>(args: Subset<T, LocalServiceAggregateArgs>): Prisma.PrismaPromise<GetLocalServiceAggregateType<T>>

    /**
     * Group by LocalService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends localServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: localServiceGroupByArgs['orderBy'] }
        : { orderBy?: localServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, localServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the localService model
   */
  readonly fields: localServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for localService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__localServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceCategory<T extends localService$serviceCategoryArgs<ExtArgs> = {}>(args?: Subset<T, localService$serviceCategoryArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    serviceRating<T extends localService$serviceRatingArgs<ExtArgs> = {}>(args?: Subset<T, localService$serviceRatingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the localService model
   */
  interface localServiceFieldRefs {
    readonly id: FieldRef<"localService", 'String'>
    readonly name: FieldRef<"localService", 'String'>
    readonly categoryId: FieldRef<"localService", 'String'>
    readonly address: FieldRef<"localService", 'String'>
    readonly gpsCoordinates: FieldRef<"localService", 'String'>
    readonly phone: FieldRef<"localService", 'String'>
    readonly website: FieldRef<"localService", 'String'>
    readonly description: FieldRef<"localService", 'String'>
    readonly hours: FieldRef<"localService", 'String'>
    readonly seniorFriendly: FieldRef<"localService", 'Boolean'>
    readonly createdAt: FieldRef<"localService", 'DateTime'>
    readonly updatedAt: FieldRef<"localService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * localService findUnique
   */
  export type localServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * Filter, which localService to fetch.
     */
    where: localServiceWhereUniqueInput
  }

  /**
   * localService findUniqueOrThrow
   */
  export type localServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * Filter, which localService to fetch.
     */
    where: localServiceWhereUniqueInput
  }

  /**
   * localService findFirst
   */
  export type localServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * Filter, which localService to fetch.
     */
    where?: localServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localServices to fetch.
     */
    orderBy?: localServiceOrderByWithRelationInput | localServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localServices.
     */
    cursor?: localServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localServices.
     */
    distinct?: LocalServiceScalarFieldEnum | LocalServiceScalarFieldEnum[]
  }

  /**
   * localService findFirstOrThrow
   */
  export type localServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * Filter, which localService to fetch.
     */
    where?: localServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localServices to fetch.
     */
    orderBy?: localServiceOrderByWithRelationInput | localServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localServices.
     */
    cursor?: localServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localServices.
     */
    distinct?: LocalServiceScalarFieldEnum | LocalServiceScalarFieldEnum[]
  }

  /**
   * localService findMany
   */
  export type localServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * Filter, which localServices to fetch.
     */
    where?: localServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localServices to fetch.
     */
    orderBy?: localServiceOrderByWithRelationInput | localServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing localServices.
     */
    cursor?: localServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localServices.
     */
    skip?: number
    distinct?: LocalServiceScalarFieldEnum | LocalServiceScalarFieldEnum[]
  }

  /**
   * localService create
   */
  export type localServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a localService.
     */
    data: XOR<localServiceCreateInput, localServiceUncheckedCreateInput>
  }

  /**
   * localService createMany
   */
  export type localServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many localServices.
     */
    data: localServiceCreateManyInput | localServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * localService createManyAndReturn
   */
  export type localServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * The data used to create many localServices.
     */
    data: localServiceCreateManyInput | localServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * localService update
   */
  export type localServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a localService.
     */
    data: XOR<localServiceUpdateInput, localServiceUncheckedUpdateInput>
    /**
     * Choose, which localService to update.
     */
    where: localServiceWhereUniqueInput
  }

  /**
   * localService updateMany
   */
  export type localServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update localServices.
     */
    data: XOR<localServiceUpdateManyMutationInput, localServiceUncheckedUpdateManyInput>
    /**
     * Filter which localServices to update
     */
    where?: localServiceWhereInput
    /**
     * Limit how many localServices to update.
     */
    limit?: number
  }

  /**
   * localService updateManyAndReturn
   */
  export type localServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * The data used to update localServices.
     */
    data: XOR<localServiceUpdateManyMutationInput, localServiceUncheckedUpdateManyInput>
    /**
     * Filter which localServices to update
     */
    where?: localServiceWhereInput
    /**
     * Limit how many localServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * localService upsert
   */
  export type localServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the localService to update in case it exists.
     */
    where: localServiceWhereUniqueInput
    /**
     * In case the localService found by the `where` argument doesn't exist, create a new localService with this data.
     */
    create: XOR<localServiceCreateInput, localServiceUncheckedCreateInput>
    /**
     * In case the localService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<localServiceUpdateInput, localServiceUncheckedUpdateInput>
  }

  /**
   * localService delete
   */
  export type localServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    /**
     * Filter which localService to delete.
     */
    where: localServiceWhereUniqueInput
  }

  /**
   * localService deleteMany
   */
  export type localServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localServices to delete
     */
    where?: localServiceWhereInput
    /**
     * Limit how many localServices to delete.
     */
    limit?: number
  }

  /**
   * localService.serviceCategory
   */
  export type localService$serviceCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    where?: serviceCategoryWhereInput
  }

  /**
   * localService.serviceRating
   */
  export type localService$serviceRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    where?: serviceRatingWhereInput
    orderBy?: serviceRatingOrderByWithRelationInput | serviceRatingOrderByWithRelationInput[]
    cursor?: serviceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * localService without action
   */
  export type localServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
  }


  /**
   * Model medicationReminder
   */

  export type AggregateMedicationReminder = {
    _count: MedicationReminderCountAggregateOutputType | null
    _min: MedicationReminderMinAggregateOutputType | null
    _max: MedicationReminderMaxAggregateOutputType | null
  }

  export type MedicationReminderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    medicationName: string | null
    dosage: string | null
    morningReminderTime: Date | null
    noonReminderTime: Date | null
    eveningReminderTime: Date | null
    nightReminderTime: Date | null
    daysOfWeek: string | null
    instructions: string | null
    active: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationReminderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    medicationName: string | null
    dosage: string | null
    morningReminderTime: Date | null
    noonReminderTime: Date | null
    eveningReminderTime: Date | null
    nightReminderTime: Date | null
    daysOfWeek: string | null
    instructions: string | null
    active: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationReminderCountAggregateOutputType = {
    id: number
    userId: number
    medicationName: number
    dosage: number
    morningReminderTime: number
    noonReminderTime: number
    eveningReminderTime: number
    nightReminderTime: number
    daysOfWeek: number
    instructions: number
    active: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationReminderMinAggregateInputType = {
    id?: true
    userId?: true
    medicationName?: true
    dosage?: true
    morningReminderTime?: true
    noonReminderTime?: true
    eveningReminderTime?: true
    nightReminderTime?: true
    daysOfWeek?: true
    instructions?: true
    active?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationReminderMaxAggregateInputType = {
    id?: true
    userId?: true
    medicationName?: true
    dosage?: true
    morningReminderTime?: true
    noonReminderTime?: true
    eveningReminderTime?: true
    nightReminderTime?: true
    daysOfWeek?: true
    instructions?: true
    active?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationReminderCountAggregateInputType = {
    id?: true
    userId?: true
    medicationName?: true
    dosage?: true
    morningReminderTime?: true
    noonReminderTime?: true
    eveningReminderTime?: true
    nightReminderTime?: true
    daysOfWeek?: true
    instructions?: true
    active?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicationReminder to aggregate.
     */
    where?: medicationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicationReminders to fetch.
     */
    orderBy?: medicationReminderOrderByWithRelationInput | medicationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medicationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicationReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medicationReminders
    **/
    _count?: true | MedicationReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationReminderMaxAggregateInputType
  }

  export type GetMedicationReminderAggregateType<T extends MedicationReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicationReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicationReminder[P]>
      : GetScalarType<T[P], AggregateMedicationReminder[P]>
  }




  export type medicationReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicationReminderWhereInput
    orderBy?: medicationReminderOrderByWithAggregationInput | medicationReminderOrderByWithAggregationInput[]
    by: MedicationReminderScalarFieldEnum[] | MedicationReminderScalarFieldEnum
    having?: medicationReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationReminderCountAggregateInputType | true
    _min?: MedicationReminderMinAggregateInputType
    _max?: MedicationReminderMaxAggregateInputType
  }

  export type MedicationReminderGroupByOutputType = {
    id: string
    userId: string
    medicationName: string
    dosage: string | null
    morningReminderTime: Date | null
    noonReminderTime: Date | null
    eveningReminderTime: Date | null
    nightReminderTime: Date | null
    daysOfWeek: string | null
    instructions: string | null
    active: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: MedicationReminderCountAggregateOutputType | null
    _min: MedicationReminderMinAggregateOutputType | null
    _max: MedicationReminderMaxAggregateOutputType | null
  }

  type GetMedicationReminderGroupByPayload<T extends medicationReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationReminderGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationReminderGroupByOutputType[P]>
        }
      >
    >


  export type medicationReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    medicationName?: boolean
    dosage?: boolean
    morningReminderTime?: boolean
    noonReminderTime?: boolean
    eveningReminderTime?: boolean
    nightReminderTime?: boolean
    daysOfWeek?: boolean
    instructions?: boolean
    active?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationReminder"]>

  export type medicationReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    medicationName?: boolean
    dosage?: boolean
    morningReminderTime?: boolean
    noonReminderTime?: boolean
    eveningReminderTime?: boolean
    nightReminderTime?: boolean
    daysOfWeek?: boolean
    instructions?: boolean
    active?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationReminder"]>

  export type medicationReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    medicationName?: boolean
    dosage?: boolean
    morningReminderTime?: boolean
    noonReminderTime?: boolean
    eveningReminderTime?: boolean
    nightReminderTime?: boolean
    daysOfWeek?: boolean
    instructions?: boolean
    active?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationReminder"]>

  export type medicationReminderSelectScalar = {
    id?: boolean
    userId?: boolean
    medicationName?: boolean
    dosage?: boolean
    morningReminderTime?: boolean
    noonReminderTime?: boolean
    eveningReminderTime?: boolean
    nightReminderTime?: boolean
    daysOfWeek?: boolean
    instructions?: boolean
    active?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type medicationReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "medicationName" | "dosage" | "morningReminderTime" | "noonReminderTime" | "eveningReminderTime" | "nightReminderTime" | "daysOfWeek" | "instructions" | "active" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["medicationReminder"]>
  export type medicationReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type medicationReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type medicationReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $medicationReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medicationReminder"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      medicationName: string
      dosage: string | null
      morningReminderTime: Date | null
      noonReminderTime: Date | null
      eveningReminderTime: Date | null
      nightReminderTime: Date | null
      daysOfWeek: string | null
      instructions: string | null
      active: boolean | null
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["medicationReminder"]>
    composites: {}
  }

  type medicationReminderGetPayload<S extends boolean | null | undefined | medicationReminderDefaultArgs> = $Result.GetResult<Prisma.$medicationReminderPayload, S>

  type medicationReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<medicationReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationReminderCountAggregateInputType | true
    }

  export interface medicationReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medicationReminder'], meta: { name: 'medicationReminder' } }
    /**
     * Find zero or one MedicationReminder that matches the filter.
     * @param {medicationReminderFindUniqueArgs} args - Arguments to find a MedicationReminder
     * @example
     * // Get one MedicationReminder
     * const medicationReminder = await prisma.medicationReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medicationReminderFindUniqueArgs>(args: SelectSubset<T, medicationReminderFindUniqueArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicationReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {medicationReminderFindUniqueOrThrowArgs} args - Arguments to find a MedicationReminder
     * @example
     * // Get one MedicationReminder
     * const medicationReminder = await prisma.medicationReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medicationReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, medicationReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicationReminderFindFirstArgs} args - Arguments to find a MedicationReminder
     * @example
     * // Get one MedicationReminder
     * const medicationReminder = await prisma.medicationReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medicationReminderFindFirstArgs>(args?: SelectSubset<T, medicationReminderFindFirstArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicationReminderFindFirstOrThrowArgs} args - Arguments to find a MedicationReminder
     * @example
     * // Get one MedicationReminder
     * const medicationReminder = await prisma.medicationReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medicationReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, medicationReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicationReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicationReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicationReminders
     * const medicationReminders = await prisma.medicationReminder.findMany()
     * 
     * // Get first 10 MedicationReminders
     * const medicationReminders = await prisma.medicationReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationReminderWithIdOnly = await prisma.medicationReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medicationReminderFindManyArgs>(args?: SelectSubset<T, medicationReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicationReminder.
     * @param {medicationReminderCreateArgs} args - Arguments to create a MedicationReminder.
     * @example
     * // Create one MedicationReminder
     * const MedicationReminder = await prisma.medicationReminder.create({
     *   data: {
     *     // ... data to create a MedicationReminder
     *   }
     * })
     * 
     */
    create<T extends medicationReminderCreateArgs>(args: SelectSubset<T, medicationReminderCreateArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicationReminders.
     * @param {medicationReminderCreateManyArgs} args - Arguments to create many MedicationReminders.
     * @example
     * // Create many MedicationReminders
     * const medicationReminder = await prisma.medicationReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medicationReminderCreateManyArgs>(args?: SelectSubset<T, medicationReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicationReminders and returns the data saved in the database.
     * @param {medicationReminderCreateManyAndReturnArgs} args - Arguments to create many MedicationReminders.
     * @example
     * // Create many MedicationReminders
     * const medicationReminder = await prisma.medicationReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicationReminders and only return the `id`
     * const medicationReminderWithIdOnly = await prisma.medicationReminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medicationReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, medicationReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicationReminder.
     * @param {medicationReminderDeleteArgs} args - Arguments to delete one MedicationReminder.
     * @example
     * // Delete one MedicationReminder
     * const MedicationReminder = await prisma.medicationReminder.delete({
     *   where: {
     *     // ... filter to delete one MedicationReminder
     *   }
     * })
     * 
     */
    delete<T extends medicationReminderDeleteArgs>(args: SelectSubset<T, medicationReminderDeleteArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicationReminder.
     * @param {medicationReminderUpdateArgs} args - Arguments to update one MedicationReminder.
     * @example
     * // Update one MedicationReminder
     * const medicationReminder = await prisma.medicationReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medicationReminderUpdateArgs>(args: SelectSubset<T, medicationReminderUpdateArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicationReminders.
     * @param {medicationReminderDeleteManyArgs} args - Arguments to filter MedicationReminders to delete.
     * @example
     * // Delete a few MedicationReminders
     * const { count } = await prisma.medicationReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medicationReminderDeleteManyArgs>(args?: SelectSubset<T, medicationReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicationReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicationReminders
     * const medicationReminder = await prisma.medicationReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medicationReminderUpdateManyArgs>(args: SelectSubset<T, medicationReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationReminders and returns the data updated in the database.
     * @param {medicationReminderUpdateManyAndReturnArgs} args - Arguments to update many MedicationReminders.
     * @example
     * // Update many MedicationReminders
     * const medicationReminder = await prisma.medicationReminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicationReminders and only return the `id`
     * const medicationReminderWithIdOnly = await prisma.medicationReminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends medicationReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, medicationReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicationReminder.
     * @param {medicationReminderUpsertArgs} args - Arguments to update or create a MedicationReminder.
     * @example
     * // Update or create a MedicationReminder
     * const medicationReminder = await prisma.medicationReminder.upsert({
     *   create: {
     *     // ... data to create a MedicationReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicationReminder we want to update
     *   }
     * })
     */
    upsert<T extends medicationReminderUpsertArgs>(args: SelectSubset<T, medicationReminderUpsertArgs<ExtArgs>>): Prisma__medicationReminderClient<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicationReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicationReminderCountArgs} args - Arguments to filter MedicationReminders to count.
     * @example
     * // Count the number of MedicationReminders
     * const count = await prisma.medicationReminder.count({
     *   where: {
     *     // ... the filter for the MedicationReminders we want to count
     *   }
     * })
    **/
    count<T extends medicationReminderCountArgs>(
      args?: Subset<T, medicationReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicationReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationReminderAggregateArgs>(args: Subset<T, MedicationReminderAggregateArgs>): Prisma.PrismaPromise<GetMedicationReminderAggregateType<T>>

    /**
     * Group by MedicationReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicationReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medicationReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medicationReminderGroupByArgs['orderBy'] }
        : { orderBy?: medicationReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medicationReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medicationReminder model
   */
  readonly fields: medicationReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medicationReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medicationReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medicationReminder model
   */
  interface medicationReminderFieldRefs {
    readonly id: FieldRef<"medicationReminder", 'String'>
    readonly userId: FieldRef<"medicationReminder", 'String'>
    readonly medicationName: FieldRef<"medicationReminder", 'String'>
    readonly dosage: FieldRef<"medicationReminder", 'String'>
    readonly morningReminderTime: FieldRef<"medicationReminder", 'DateTime'>
    readonly noonReminderTime: FieldRef<"medicationReminder", 'DateTime'>
    readonly eveningReminderTime: FieldRef<"medicationReminder", 'DateTime'>
    readonly nightReminderTime: FieldRef<"medicationReminder", 'DateTime'>
    readonly daysOfWeek: FieldRef<"medicationReminder", 'String'>
    readonly instructions: FieldRef<"medicationReminder", 'String'>
    readonly active: FieldRef<"medicationReminder", 'Boolean'>
    readonly startDate: FieldRef<"medicationReminder", 'DateTime'>
    readonly endDate: FieldRef<"medicationReminder", 'DateTime'>
    readonly createdAt: FieldRef<"medicationReminder", 'DateTime'>
    readonly updatedAt: FieldRef<"medicationReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * medicationReminder findUnique
   */
  export type medicationReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * Filter, which medicationReminder to fetch.
     */
    where: medicationReminderWhereUniqueInput
  }

  /**
   * medicationReminder findUniqueOrThrow
   */
  export type medicationReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * Filter, which medicationReminder to fetch.
     */
    where: medicationReminderWhereUniqueInput
  }

  /**
   * medicationReminder findFirst
   */
  export type medicationReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * Filter, which medicationReminder to fetch.
     */
    where?: medicationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicationReminders to fetch.
     */
    orderBy?: medicationReminderOrderByWithRelationInput | medicationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicationReminders.
     */
    cursor?: medicationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicationReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicationReminders.
     */
    distinct?: MedicationReminderScalarFieldEnum | MedicationReminderScalarFieldEnum[]
  }

  /**
   * medicationReminder findFirstOrThrow
   */
  export type medicationReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * Filter, which medicationReminder to fetch.
     */
    where?: medicationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicationReminders to fetch.
     */
    orderBy?: medicationReminderOrderByWithRelationInput | medicationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicationReminders.
     */
    cursor?: medicationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicationReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicationReminders.
     */
    distinct?: MedicationReminderScalarFieldEnum | MedicationReminderScalarFieldEnum[]
  }

  /**
   * medicationReminder findMany
   */
  export type medicationReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * Filter, which medicationReminders to fetch.
     */
    where?: medicationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicationReminders to fetch.
     */
    orderBy?: medicationReminderOrderByWithRelationInput | medicationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medicationReminders.
     */
    cursor?: medicationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicationReminders.
     */
    skip?: number
    distinct?: MedicationReminderScalarFieldEnum | MedicationReminderScalarFieldEnum[]
  }

  /**
   * medicationReminder create
   */
  export type medicationReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a medicationReminder.
     */
    data: XOR<medicationReminderCreateInput, medicationReminderUncheckedCreateInput>
  }

  /**
   * medicationReminder createMany
   */
  export type medicationReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medicationReminders.
     */
    data: medicationReminderCreateManyInput | medicationReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicationReminder createManyAndReturn
   */
  export type medicationReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * The data used to create many medicationReminders.
     */
    data: medicationReminderCreateManyInput | medicationReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * medicationReminder update
   */
  export type medicationReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a medicationReminder.
     */
    data: XOR<medicationReminderUpdateInput, medicationReminderUncheckedUpdateInput>
    /**
     * Choose, which medicationReminder to update.
     */
    where: medicationReminderWhereUniqueInput
  }

  /**
   * medicationReminder updateMany
   */
  export type medicationReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medicationReminders.
     */
    data: XOR<medicationReminderUpdateManyMutationInput, medicationReminderUncheckedUpdateManyInput>
    /**
     * Filter which medicationReminders to update
     */
    where?: medicationReminderWhereInput
    /**
     * Limit how many medicationReminders to update.
     */
    limit?: number
  }

  /**
   * medicationReminder updateManyAndReturn
   */
  export type medicationReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * The data used to update medicationReminders.
     */
    data: XOR<medicationReminderUpdateManyMutationInput, medicationReminderUncheckedUpdateManyInput>
    /**
     * Filter which medicationReminders to update
     */
    where?: medicationReminderWhereInput
    /**
     * Limit how many medicationReminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * medicationReminder upsert
   */
  export type medicationReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the medicationReminder to update in case it exists.
     */
    where: medicationReminderWhereUniqueInput
    /**
     * In case the medicationReminder found by the `where` argument doesn't exist, create a new medicationReminder with this data.
     */
    create: XOR<medicationReminderCreateInput, medicationReminderUncheckedCreateInput>
    /**
     * In case the medicationReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medicationReminderUpdateInput, medicationReminderUncheckedUpdateInput>
  }

  /**
   * medicationReminder delete
   */
  export type medicationReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    /**
     * Filter which medicationReminder to delete.
     */
    where: medicationReminderWhereUniqueInput
  }

  /**
   * medicationReminder deleteMany
   */
  export type medicationReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicationReminders to delete
     */
    where?: medicationReminderWhereInput
    /**
     * Limit how many medicationReminders to delete.
     */
    limit?: number
  }

  /**
   * medicationReminder without action
   */
  export type medicationReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
  }


  /**
   * Model message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    sendDate: Date | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    sendDate: Date | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    sendDate: number
    type: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    sendDate?: true
    type?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    sendDate?: true
    type?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    sendDate?: true
    type?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message to aggregate.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
    orderBy?: messageOrderByWithAggregationInput | messageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string
    sendDate: Date
    type: string | null
    read: boolean | null
    createdAt: Date
    updatedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    sendDate?: boolean
    type?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | message$conversationArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    sendDate?: boolean
    type?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | message$conversationArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    sendDate?: boolean
    type?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | message$conversationArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    sendDate?: boolean
    type?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "content" | "sendDate" | "type" | "read" | "createdAt" | "updatedAt", ExtArgs["result"]["message"]>
  export type messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | message$conversationArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }
  export type messageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | message$conversationArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }
  export type messageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | message$conversationArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }

  export type $messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message"
    objects: {
      conversation: Prisma.$conversationPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string
      sendDate: Date
      type: string | null
      read: boolean | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type messageGetPayload<S extends boolean | null | undefined | messageDefaultArgs> = $Result.GetResult<Prisma.$messagePayload, S>

  type messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message'], meta: { name: 'message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {messageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messageFindUniqueArgs>(args: SelectSubset<T, messageFindUniqueArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messageFindUniqueOrThrowArgs>(args: SelectSubset<T, messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messageFindFirstArgs>(args?: SelectSubset<T, messageFindFirstArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messageFindFirstOrThrowArgs>(args?: SelectSubset<T, messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messageFindManyArgs>(args?: SelectSubset<T, messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {messageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends messageCreateArgs>(args: SelectSubset<T, messageCreateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messageCreateManyArgs>(args?: SelectSubset<T, messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messageCreateManyAndReturnArgs>(args?: SelectSubset<T, messageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {messageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends messageDeleteArgs>(args: SelectSubset<T, messageDeleteArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {messageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messageUpdateArgs>(args: SelectSubset<T, messageUpdateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messageDeleteManyArgs>(args?: SelectSubset<T, messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messageUpdateManyArgs>(args: SelectSubset<T, messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messageUpdateManyAndReturnArgs>(args: SelectSubset<T, messageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {messageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends messageUpsertArgs>(args: SelectSubset<T, messageUpsertArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messageCountArgs>(
      args?: Subset<T, messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messageGroupByArgs['orderBy'] }
        : { orderBy?: messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message model
   */
  readonly fields: messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends message$conversationArgs<ExtArgs> = {}>(args?: Subset<T, message$conversationArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends message$userArgs<ExtArgs> = {}>(args?: Subset<T, message$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message model
   */
  interface messageFieldRefs {
    readonly id: FieldRef<"message", 'String'>
    readonly conversationId: FieldRef<"message", 'String'>
    readonly senderId: FieldRef<"message", 'String'>
    readonly content: FieldRef<"message", 'String'>
    readonly sendDate: FieldRef<"message", 'DateTime'>
    readonly type: FieldRef<"message", 'String'>
    readonly read: FieldRef<"message", 'Boolean'>
    readonly createdAt: FieldRef<"message", 'DateTime'>
    readonly updatedAt: FieldRef<"message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * message findUnique
   */
  export type messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findUniqueOrThrow
   */
  export type messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findFirst
   */
  export type messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findFirstOrThrow
   */
  export type messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findMany
   */
  export type messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message create
   */
  export type messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to create a message.
     */
    data: XOR<messageCreateInput, messageUncheckedCreateInput>
  }

  /**
   * message createMany
   */
  export type messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message createManyAndReturn
   */
  export type messageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * message update
   */
  export type messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to update a message.
     */
    data: XOR<messageUpdateInput, messageUncheckedUpdateInput>
    /**
     * Choose, which message to update.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message updateMany
   */
  export type messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * message updateManyAndReturn
   */
  export type messageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * message upsert
   */
  export type messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The filter to search for the message to update in case it exists.
     */
    where: messageWhereUniqueInput
    /**
     * In case the message found by the `where` argument doesn't exist, create a new message with this data.
     */
    create: XOR<messageCreateInput, messageUncheckedCreateInput>
    /**
     * In case the message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageUpdateInput, messageUncheckedUpdateInput>
  }

  /**
   * message delete
   */
  export type messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter which message to delete.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message deleteMany
   */
  export type messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * message.conversation
   */
  export type message$conversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    where?: conversationWhereInput
  }

  /**
   * message.user
   */
  export type message$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * message without action
   */
  export type messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
  }


  /**
   * Model municipalEvent
   */

  export type AggregateMunicipalEvent = {
    _count: MunicipalEventCountAggregateOutputType | null
    _min: MunicipalEventMinAggregateOutputType | null
    _max: MunicipalEventMaxAggregateOutputType | null
  }

  export type MunicipalEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    gpsCoordinates: string | null
    organizer: string | null
    contact: string | null
    officialLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MunicipalEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    gpsCoordinates: string | null
    organizer: string | null
    contact: string | null
    officialLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MunicipalEventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    location: number
    gpsCoordinates: number
    organizer: number
    contact: number
    officialLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MunicipalEventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    gpsCoordinates?: true
    organizer?: true
    contact?: true
    officialLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MunicipalEventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    gpsCoordinates?: true
    organizer?: true
    contact?: true
    officialLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MunicipalEventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    gpsCoordinates?: true
    organizer?: true
    contact?: true
    officialLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MunicipalEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which municipalEvent to aggregate.
     */
    where?: municipalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipalEvents to fetch.
     */
    orderBy?: municipalEventOrderByWithRelationInput | municipalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: municipalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned municipalEvents
    **/
    _count?: true | MunicipalEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipalEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipalEventMaxAggregateInputType
  }

  export type GetMunicipalEventAggregateType<T extends MunicipalEventAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipalEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipalEvent[P]>
      : GetScalarType<T[P], AggregateMunicipalEvent[P]>
  }




  export type municipalEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: municipalEventWhereInput
    orderBy?: municipalEventOrderByWithAggregationInput | municipalEventOrderByWithAggregationInput[]
    by: MunicipalEventScalarFieldEnum[] | MunicipalEventScalarFieldEnum
    having?: municipalEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipalEventCountAggregateInputType | true
    _min?: MunicipalEventMinAggregateInputType
    _max?: MunicipalEventMaxAggregateInputType
  }

  export type MunicipalEventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startDate: Date
    endDate: Date
    location: string
    gpsCoordinates: string | null
    organizer: string | null
    contact: string | null
    officialLink: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: MunicipalEventCountAggregateOutputType | null
    _min: MunicipalEventMinAggregateOutputType | null
    _max: MunicipalEventMaxAggregateOutputType | null
  }

  type GetMunicipalEventGroupByPayload<T extends municipalEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipalEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipalEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipalEventGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipalEventGroupByOutputType[P]>
        }
      >
    >


  export type municipalEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    organizer?: boolean
    contact?: boolean
    officialLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["municipalEvent"]>

  export type municipalEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    organizer?: boolean
    contact?: boolean
    officialLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["municipalEvent"]>

  export type municipalEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    organizer?: boolean
    contact?: boolean
    officialLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["municipalEvent"]>

  export type municipalEventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    gpsCoordinates?: boolean
    organizer?: boolean
    contact?: boolean
    officialLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type municipalEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startDate" | "endDate" | "location" | "gpsCoordinates" | "organizer" | "contact" | "officialLink" | "createdAt" | "updatedAt", ExtArgs["result"]["municipalEvent"]>

  export type $municipalEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "municipalEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startDate: Date
      endDate: Date
      location: string
      gpsCoordinates: string | null
      organizer: string | null
      contact: string | null
      officialLink: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["municipalEvent"]>
    composites: {}
  }

  type municipalEventGetPayload<S extends boolean | null | undefined | municipalEventDefaultArgs> = $Result.GetResult<Prisma.$municipalEventPayload, S>

  type municipalEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<municipalEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MunicipalEventCountAggregateInputType | true
    }

  export interface municipalEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['municipalEvent'], meta: { name: 'municipalEvent' } }
    /**
     * Find zero or one MunicipalEvent that matches the filter.
     * @param {municipalEventFindUniqueArgs} args - Arguments to find a MunicipalEvent
     * @example
     * // Get one MunicipalEvent
     * const municipalEvent = await prisma.municipalEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends municipalEventFindUniqueArgs>(args: SelectSubset<T, municipalEventFindUniqueArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MunicipalEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {municipalEventFindUniqueOrThrowArgs} args - Arguments to find a MunicipalEvent
     * @example
     * // Get one MunicipalEvent
     * const municipalEvent = await prisma.municipalEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends municipalEventFindUniqueOrThrowArgs>(args: SelectSubset<T, municipalEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MunicipalEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipalEventFindFirstArgs} args - Arguments to find a MunicipalEvent
     * @example
     * // Get one MunicipalEvent
     * const municipalEvent = await prisma.municipalEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends municipalEventFindFirstArgs>(args?: SelectSubset<T, municipalEventFindFirstArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MunicipalEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipalEventFindFirstOrThrowArgs} args - Arguments to find a MunicipalEvent
     * @example
     * // Get one MunicipalEvent
     * const municipalEvent = await prisma.municipalEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends municipalEventFindFirstOrThrowArgs>(args?: SelectSubset<T, municipalEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MunicipalEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipalEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MunicipalEvents
     * const municipalEvents = await prisma.municipalEvent.findMany()
     * 
     * // Get first 10 MunicipalEvents
     * const municipalEvents = await prisma.municipalEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const municipalEventWithIdOnly = await prisma.municipalEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends municipalEventFindManyArgs>(args?: SelectSubset<T, municipalEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MunicipalEvent.
     * @param {municipalEventCreateArgs} args - Arguments to create a MunicipalEvent.
     * @example
     * // Create one MunicipalEvent
     * const MunicipalEvent = await prisma.municipalEvent.create({
     *   data: {
     *     // ... data to create a MunicipalEvent
     *   }
     * })
     * 
     */
    create<T extends municipalEventCreateArgs>(args: SelectSubset<T, municipalEventCreateArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MunicipalEvents.
     * @param {municipalEventCreateManyArgs} args - Arguments to create many MunicipalEvents.
     * @example
     * // Create many MunicipalEvents
     * const municipalEvent = await prisma.municipalEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends municipalEventCreateManyArgs>(args?: SelectSubset<T, municipalEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MunicipalEvents and returns the data saved in the database.
     * @param {municipalEventCreateManyAndReturnArgs} args - Arguments to create many MunicipalEvents.
     * @example
     * // Create many MunicipalEvents
     * const municipalEvent = await prisma.municipalEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MunicipalEvents and only return the `id`
     * const municipalEventWithIdOnly = await prisma.municipalEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends municipalEventCreateManyAndReturnArgs>(args?: SelectSubset<T, municipalEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MunicipalEvent.
     * @param {municipalEventDeleteArgs} args - Arguments to delete one MunicipalEvent.
     * @example
     * // Delete one MunicipalEvent
     * const MunicipalEvent = await prisma.municipalEvent.delete({
     *   where: {
     *     // ... filter to delete one MunicipalEvent
     *   }
     * })
     * 
     */
    delete<T extends municipalEventDeleteArgs>(args: SelectSubset<T, municipalEventDeleteArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MunicipalEvent.
     * @param {municipalEventUpdateArgs} args - Arguments to update one MunicipalEvent.
     * @example
     * // Update one MunicipalEvent
     * const municipalEvent = await prisma.municipalEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends municipalEventUpdateArgs>(args: SelectSubset<T, municipalEventUpdateArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MunicipalEvents.
     * @param {municipalEventDeleteManyArgs} args - Arguments to filter MunicipalEvents to delete.
     * @example
     * // Delete a few MunicipalEvents
     * const { count } = await prisma.municipalEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends municipalEventDeleteManyArgs>(args?: SelectSubset<T, municipalEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MunicipalEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipalEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MunicipalEvents
     * const municipalEvent = await prisma.municipalEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends municipalEventUpdateManyArgs>(args: SelectSubset<T, municipalEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MunicipalEvents and returns the data updated in the database.
     * @param {municipalEventUpdateManyAndReturnArgs} args - Arguments to update many MunicipalEvents.
     * @example
     * // Update many MunicipalEvents
     * const municipalEvent = await prisma.municipalEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MunicipalEvents and only return the `id`
     * const municipalEventWithIdOnly = await prisma.municipalEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends municipalEventUpdateManyAndReturnArgs>(args: SelectSubset<T, municipalEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MunicipalEvent.
     * @param {municipalEventUpsertArgs} args - Arguments to update or create a MunicipalEvent.
     * @example
     * // Update or create a MunicipalEvent
     * const municipalEvent = await prisma.municipalEvent.upsert({
     *   create: {
     *     // ... data to create a MunicipalEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MunicipalEvent we want to update
     *   }
     * })
     */
    upsert<T extends municipalEventUpsertArgs>(args: SelectSubset<T, municipalEventUpsertArgs<ExtArgs>>): Prisma__municipalEventClient<$Result.GetResult<Prisma.$municipalEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MunicipalEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipalEventCountArgs} args - Arguments to filter MunicipalEvents to count.
     * @example
     * // Count the number of MunicipalEvents
     * const count = await prisma.municipalEvent.count({
     *   where: {
     *     // ... the filter for the MunicipalEvents we want to count
     *   }
     * })
    **/
    count<T extends municipalEventCountArgs>(
      args?: Subset<T, municipalEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipalEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MunicipalEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipalEventAggregateArgs>(args: Subset<T, MunicipalEventAggregateArgs>): Prisma.PrismaPromise<GetMunicipalEventAggregateType<T>>

    /**
     * Group by MunicipalEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipalEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends municipalEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: municipalEventGroupByArgs['orderBy'] }
        : { orderBy?: municipalEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, municipalEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipalEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the municipalEvent model
   */
  readonly fields: municipalEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for municipalEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__municipalEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the municipalEvent model
   */
  interface municipalEventFieldRefs {
    readonly id: FieldRef<"municipalEvent", 'String'>
    readonly title: FieldRef<"municipalEvent", 'String'>
    readonly description: FieldRef<"municipalEvent", 'String'>
    readonly startDate: FieldRef<"municipalEvent", 'DateTime'>
    readonly endDate: FieldRef<"municipalEvent", 'DateTime'>
    readonly location: FieldRef<"municipalEvent", 'String'>
    readonly gpsCoordinates: FieldRef<"municipalEvent", 'String'>
    readonly organizer: FieldRef<"municipalEvent", 'String'>
    readonly contact: FieldRef<"municipalEvent", 'String'>
    readonly officialLink: FieldRef<"municipalEvent", 'String'>
    readonly createdAt: FieldRef<"municipalEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"municipalEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * municipalEvent findUnique
   */
  export type municipalEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * Filter, which municipalEvent to fetch.
     */
    where: municipalEventWhereUniqueInput
  }

  /**
   * municipalEvent findUniqueOrThrow
   */
  export type municipalEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * Filter, which municipalEvent to fetch.
     */
    where: municipalEventWhereUniqueInput
  }

  /**
   * municipalEvent findFirst
   */
  export type municipalEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * Filter, which municipalEvent to fetch.
     */
    where?: municipalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipalEvents to fetch.
     */
    orderBy?: municipalEventOrderByWithRelationInput | municipalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for municipalEvents.
     */
    cursor?: municipalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of municipalEvents.
     */
    distinct?: MunicipalEventScalarFieldEnum | MunicipalEventScalarFieldEnum[]
  }

  /**
   * municipalEvent findFirstOrThrow
   */
  export type municipalEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * Filter, which municipalEvent to fetch.
     */
    where?: municipalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipalEvents to fetch.
     */
    orderBy?: municipalEventOrderByWithRelationInput | municipalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for municipalEvents.
     */
    cursor?: municipalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of municipalEvents.
     */
    distinct?: MunicipalEventScalarFieldEnum | MunicipalEventScalarFieldEnum[]
  }

  /**
   * municipalEvent findMany
   */
  export type municipalEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * Filter, which municipalEvents to fetch.
     */
    where?: municipalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipalEvents to fetch.
     */
    orderBy?: municipalEventOrderByWithRelationInput | municipalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing municipalEvents.
     */
    cursor?: municipalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipalEvents.
     */
    skip?: number
    distinct?: MunicipalEventScalarFieldEnum | MunicipalEventScalarFieldEnum[]
  }

  /**
   * municipalEvent create
   */
  export type municipalEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * The data needed to create a municipalEvent.
     */
    data: XOR<municipalEventCreateInput, municipalEventUncheckedCreateInput>
  }

  /**
   * municipalEvent createMany
   */
  export type municipalEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many municipalEvents.
     */
    data: municipalEventCreateManyInput | municipalEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * municipalEvent createManyAndReturn
   */
  export type municipalEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * The data used to create many municipalEvents.
     */
    data: municipalEventCreateManyInput | municipalEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * municipalEvent update
   */
  export type municipalEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * The data needed to update a municipalEvent.
     */
    data: XOR<municipalEventUpdateInput, municipalEventUncheckedUpdateInput>
    /**
     * Choose, which municipalEvent to update.
     */
    where: municipalEventWhereUniqueInput
  }

  /**
   * municipalEvent updateMany
   */
  export type municipalEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update municipalEvents.
     */
    data: XOR<municipalEventUpdateManyMutationInput, municipalEventUncheckedUpdateManyInput>
    /**
     * Filter which municipalEvents to update
     */
    where?: municipalEventWhereInput
    /**
     * Limit how many municipalEvents to update.
     */
    limit?: number
  }

  /**
   * municipalEvent updateManyAndReturn
   */
  export type municipalEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * The data used to update municipalEvents.
     */
    data: XOR<municipalEventUpdateManyMutationInput, municipalEventUncheckedUpdateManyInput>
    /**
     * Filter which municipalEvents to update
     */
    where?: municipalEventWhereInput
    /**
     * Limit how many municipalEvents to update.
     */
    limit?: number
  }

  /**
   * municipalEvent upsert
   */
  export type municipalEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * The filter to search for the municipalEvent to update in case it exists.
     */
    where: municipalEventWhereUniqueInput
    /**
     * In case the municipalEvent found by the `where` argument doesn't exist, create a new municipalEvent with this data.
     */
    create: XOR<municipalEventCreateInput, municipalEventUncheckedCreateInput>
    /**
     * In case the municipalEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<municipalEventUpdateInput, municipalEventUncheckedUpdateInput>
  }

  /**
   * municipalEvent delete
   */
  export type municipalEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
    /**
     * Filter which municipalEvent to delete.
     */
    where: municipalEventWhereUniqueInput
  }

  /**
   * municipalEvent deleteMany
   */
  export type municipalEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which municipalEvents to delete
     */
    where?: municipalEventWhereInput
    /**
     * Limit how many municipalEvents to delete.
     */
    limit?: number
  }

  /**
   * municipalEvent without action
   */
  export type municipalEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipalEvent
     */
    select?: municipalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the municipalEvent
     */
    omit?: municipalEventOmit<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    content: string | null
    read: boolean | null
    actionLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    content: string | null
    read: boolean | null
    actionLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    content: number
    read: number
    actionLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    read?: true
    actionLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    read?: true
    actionLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    read?: true
    actionLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    content: string
    read: boolean | null
    actionLink: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    actionLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    actionLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    actionLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    actionLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "content" | "read" | "actionLink" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | notification$userArgs<ExtArgs>
  }
  export type notificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | notification$userArgs<ExtArgs>
  }
  export type notificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | notification$userArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      content: string
      read: boolean | null
      actionLink: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends notification$userArgs<ExtArgs> = {}>(args?: Subset<T, notification$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'String'>
    readonly userId: FieldRef<"notification", 'String'>
    readonly type: FieldRef<"notification", 'String'>
    readonly content: FieldRef<"notification", 'String'>
    readonly read: FieldRef<"notification", 'Boolean'>
    readonly actionLink: FieldRef<"notification", 'String'>
    readonly createdAt: FieldRef<"notification", 'DateTime'>
    readonly updatedAt: FieldRef<"notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification createManyAndReturn
   */
  export type notificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification updateManyAndReturn
   */
  export type notificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification.user
   */
  export type notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model notificationPreferences
   */

  export type AggregateNotificationPreferences = {
    _count: NotificationPreferencesCountAggregateOutputType | null
    _min: NotificationPreferencesMinAggregateOutputType | null
    _max: NotificationPreferencesMaxAggregateOutputType | null
  }

  export type NotificationPreferencesMinAggregateOutputType = {
    userId: string | null
    messageNotification: boolean | null
    activityNotification: boolean | null
    helpNotification: boolean | null
    forumNotification: boolean | null
    emailNotification: boolean | null
    smsNotification: boolean | null
    pushNotification: boolean | null
    quietHoursStart: Date | null
    quietHoursEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferencesMaxAggregateOutputType = {
    userId: string | null
    messageNotification: boolean | null
    activityNotification: boolean | null
    helpNotification: boolean | null
    forumNotification: boolean | null
    emailNotification: boolean | null
    smsNotification: boolean | null
    pushNotification: boolean | null
    quietHoursStart: Date | null
    quietHoursEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferencesCountAggregateOutputType = {
    userId: number
    messageNotification: number
    activityNotification: number
    helpNotification: number
    forumNotification: number
    emailNotification: number
    smsNotification: number
    pushNotification: number
    quietHoursStart: number
    quietHoursEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferencesMinAggregateInputType = {
    userId?: true
    messageNotification?: true
    activityNotification?: true
    helpNotification?: true
    forumNotification?: true
    emailNotification?: true
    smsNotification?: true
    pushNotification?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferencesMaxAggregateInputType = {
    userId?: true
    messageNotification?: true
    activityNotification?: true
    helpNotification?: true
    forumNotification?: true
    emailNotification?: true
    smsNotification?: true
    pushNotification?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferencesCountAggregateInputType = {
    userId?: true
    messageNotification?: true
    activityNotification?: true
    helpNotification?: true
    forumNotification?: true
    emailNotification?: true
    smsNotification?: true
    pushNotification?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificationPreferences to aggregate.
     */
    where?: notificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPreferences to fetch.
     */
    orderBy?: notificationPreferencesOrderByWithRelationInput | notificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notificationPreferences
    **/
    _count?: true | NotificationPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferencesMaxAggregateInputType
  }

  export type GetNotificationPreferencesAggregateType<T extends NotificationPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreferences[P]>
      : GetScalarType<T[P], AggregateNotificationPreferences[P]>
  }




  export type notificationPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationPreferencesWhereInput
    orderBy?: notificationPreferencesOrderByWithAggregationInput | notificationPreferencesOrderByWithAggregationInput[]
    by: NotificationPreferencesScalarFieldEnum[] | NotificationPreferencesScalarFieldEnum
    having?: notificationPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferencesCountAggregateInputType | true
    _min?: NotificationPreferencesMinAggregateInputType
    _max?: NotificationPreferencesMaxAggregateInputType
  }

  export type NotificationPreferencesGroupByOutputType = {
    userId: string
    messageNotification: boolean | null
    activityNotification: boolean | null
    helpNotification: boolean | null
    forumNotification: boolean | null
    emailNotification: boolean | null
    smsNotification: boolean | null
    pushNotification: boolean | null
    quietHoursStart: Date | null
    quietHoursEnd: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: NotificationPreferencesCountAggregateOutputType | null
    _min: NotificationPreferencesMinAggregateOutputType | null
    _max: NotificationPreferencesMaxAggregateOutputType | null
  }

  type GetNotificationPreferencesGroupByPayload<T extends notificationPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type notificationPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    messageNotification?: boolean
    activityNotification?: boolean
    helpNotification?: boolean
    forumNotification?: boolean
    emailNotification?: boolean
    smsNotification?: boolean
    pushNotification?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreferences"]>

  export type notificationPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    messageNotification?: boolean
    activityNotification?: boolean
    helpNotification?: boolean
    forumNotification?: boolean
    emailNotification?: boolean
    smsNotification?: boolean
    pushNotification?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreferences"]>

  export type notificationPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    messageNotification?: boolean
    activityNotification?: boolean
    helpNotification?: boolean
    forumNotification?: boolean
    emailNotification?: boolean
    smsNotification?: boolean
    pushNotification?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreferences"]>

  export type notificationPreferencesSelectScalar = {
    userId?: boolean
    messageNotification?: boolean
    activityNotification?: boolean
    helpNotification?: boolean
    forumNotification?: boolean
    emailNotification?: boolean
    smsNotification?: boolean
    pushNotification?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type notificationPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "messageNotification" | "activityNotification" | "helpNotification" | "forumNotification" | "emailNotification" | "smsNotification" | "pushNotification" | "quietHoursStart" | "quietHoursEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreferences"]>
  export type notificationPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type notificationPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type notificationPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $notificationPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notificationPreferences"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      messageNotification: boolean | null
      activityNotification: boolean | null
      helpNotification: boolean | null
      forumNotification: boolean | null
      emailNotification: boolean | null
      smsNotification: boolean | null
      pushNotification: boolean | null
      quietHoursStart: Date | null
      quietHoursEnd: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["notificationPreferences"]>
    composites: {}
  }

  type notificationPreferencesGetPayload<S extends boolean | null | undefined | notificationPreferencesDefaultArgs> = $Result.GetResult<Prisma.$notificationPreferencesPayload, S>

  type notificationPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferencesCountAggregateInputType | true
    }

  export interface notificationPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notificationPreferences'], meta: { name: 'notificationPreferences' } }
    /**
     * Find zero or one NotificationPreferences that matches the filter.
     * @param {notificationPreferencesFindUniqueArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationPreferencesFindUniqueArgs>(args: SelectSubset<T, notificationPreferencesFindUniqueArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationPreferencesFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPreferencesFindFirstArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationPreferencesFindFirstArgs>(args?: SelectSubset<T, notificationPreferencesFindFirstArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPreferencesFindFirstOrThrowArgs} args - Arguments to find a NotificationPreferences
     * @example
     * // Get one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const notificationPreferencesWithUserIdOnly = await prisma.notificationPreferences.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends notificationPreferencesFindManyArgs>(args?: SelectSubset<T, notificationPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreferences.
     * @param {notificationPreferencesCreateArgs} args - Arguments to create a NotificationPreferences.
     * @example
     * // Create one NotificationPreferences
     * const NotificationPreferences = await prisma.notificationPreferences.create({
     *   data: {
     *     // ... data to create a NotificationPreferences
     *   }
     * })
     * 
     */
    create<T extends notificationPreferencesCreateArgs>(args: SelectSubset<T, notificationPreferencesCreateArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {notificationPreferencesCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationPreferencesCreateManyArgs>(args?: SelectSubset<T, notificationPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {notificationPreferencesCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `userId`
     * const notificationPreferencesWithUserIdOnly = await prisma.notificationPreferences.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreferences.
     * @param {notificationPreferencesDeleteArgs} args - Arguments to delete one NotificationPreferences.
     * @example
     * // Delete one NotificationPreferences
     * const NotificationPreferences = await prisma.notificationPreferences.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreferences
     *   }
     * })
     * 
     */
    delete<T extends notificationPreferencesDeleteArgs>(args: SelectSubset<T, notificationPreferencesDeleteArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreferences.
     * @param {notificationPreferencesUpdateArgs} args - Arguments to update one NotificationPreferences.
     * @example
     * // Update one NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationPreferencesUpdateArgs>(args: SelectSubset<T, notificationPreferencesUpdateArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {notificationPreferencesDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationPreferencesDeleteManyArgs>(args?: SelectSubset<T, notificationPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationPreferencesUpdateManyArgs>(args: SelectSubset<T, notificationPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {notificationPreferencesUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `userId`
     * const notificationPreferencesWithUserIdOnly = await prisma.notificationPreferences.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreferences.
     * @param {notificationPreferencesUpsertArgs} args - Arguments to update or create a NotificationPreferences.
     * @example
     * // Update or create a NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreferences.upsert({
     *   create: {
     *     // ... data to create a NotificationPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to update
     *   }
     * })
     */
    upsert<T extends notificationPreferencesUpsertArgs>(args: SelectSubset<T, notificationPreferencesUpsertArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPreferencesCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreferences.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends notificationPreferencesCountArgs>(
      args?: Subset<T, notificationPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferencesAggregateArgs>(args: Subset<T, NotificationPreferencesAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferencesAggregateType<T>>

    /**
     * Group by NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: notificationPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notificationPreferences model
   */
  readonly fields: notificationPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notificationPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notificationPreferences model
   */
  interface notificationPreferencesFieldRefs {
    readonly userId: FieldRef<"notificationPreferences", 'String'>
    readonly messageNotification: FieldRef<"notificationPreferences", 'Boolean'>
    readonly activityNotification: FieldRef<"notificationPreferences", 'Boolean'>
    readonly helpNotification: FieldRef<"notificationPreferences", 'Boolean'>
    readonly forumNotification: FieldRef<"notificationPreferences", 'Boolean'>
    readonly emailNotification: FieldRef<"notificationPreferences", 'Boolean'>
    readonly smsNotification: FieldRef<"notificationPreferences", 'Boolean'>
    readonly pushNotification: FieldRef<"notificationPreferences", 'Boolean'>
    readonly quietHoursStart: FieldRef<"notificationPreferences", 'DateTime'>
    readonly quietHoursEnd: FieldRef<"notificationPreferences", 'DateTime'>
    readonly createdAt: FieldRef<"notificationPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"notificationPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notificationPreferences findUnique
   */
  export type notificationPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which notificationPreferences to fetch.
     */
    where: notificationPreferencesWhereUniqueInput
  }

  /**
   * notificationPreferences findUniqueOrThrow
   */
  export type notificationPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which notificationPreferences to fetch.
     */
    where: notificationPreferencesWhereUniqueInput
  }

  /**
   * notificationPreferences findFirst
   */
  export type notificationPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which notificationPreferences to fetch.
     */
    where?: notificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPreferences to fetch.
     */
    orderBy?: notificationPreferencesOrderByWithRelationInput | notificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificationPreferences.
     */
    cursor?: notificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificationPreferences.
     */
    distinct?: NotificationPreferencesScalarFieldEnum | NotificationPreferencesScalarFieldEnum[]
  }

  /**
   * notificationPreferences findFirstOrThrow
   */
  export type notificationPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which notificationPreferences to fetch.
     */
    where?: notificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPreferences to fetch.
     */
    orderBy?: notificationPreferencesOrderByWithRelationInput | notificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificationPreferences.
     */
    cursor?: notificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificationPreferences.
     */
    distinct?: NotificationPreferencesScalarFieldEnum | NotificationPreferencesScalarFieldEnum[]
  }

  /**
   * notificationPreferences findMany
   */
  export type notificationPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which notificationPreferences to fetch.
     */
    where?: notificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPreferences to fetch.
     */
    orderBy?: notificationPreferencesOrderByWithRelationInput | notificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notificationPreferences.
     */
    cursor?: notificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferencesScalarFieldEnum | NotificationPreferencesScalarFieldEnum[]
  }

  /**
   * notificationPreferences create
   */
  export type notificationPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a notificationPreferences.
     */
    data: XOR<notificationPreferencesCreateInput, notificationPreferencesUncheckedCreateInput>
  }

  /**
   * notificationPreferences createMany
   */
  export type notificationPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notificationPreferences.
     */
    data: notificationPreferencesCreateManyInput | notificationPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notificationPreferences createManyAndReturn
   */
  export type notificationPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many notificationPreferences.
     */
    data: notificationPreferencesCreateManyInput | notificationPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notificationPreferences update
   */
  export type notificationPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a notificationPreferences.
     */
    data: XOR<notificationPreferencesUpdateInput, notificationPreferencesUncheckedUpdateInput>
    /**
     * Choose, which notificationPreferences to update.
     */
    where: notificationPreferencesWhereUniqueInput
  }

  /**
   * notificationPreferences updateMany
   */
  export type notificationPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notificationPreferences.
     */
    data: XOR<notificationPreferencesUpdateManyMutationInput, notificationPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which notificationPreferences to update
     */
    where?: notificationPreferencesWhereInput
    /**
     * Limit how many notificationPreferences to update.
     */
    limit?: number
  }

  /**
   * notificationPreferences updateManyAndReturn
   */
  export type notificationPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update notificationPreferences.
     */
    data: XOR<notificationPreferencesUpdateManyMutationInput, notificationPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which notificationPreferences to update
     */
    where?: notificationPreferencesWhereInput
    /**
     * Limit how many notificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notificationPreferences upsert
   */
  export type notificationPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the notificationPreferences to update in case it exists.
     */
    where: notificationPreferencesWhereUniqueInput
    /**
     * In case the notificationPreferences found by the `where` argument doesn't exist, create a new notificationPreferences with this data.
     */
    create: XOR<notificationPreferencesCreateInput, notificationPreferencesUncheckedCreateInput>
    /**
     * In case the notificationPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationPreferencesUpdateInput, notificationPreferencesUncheckedUpdateInput>
  }

  /**
   * notificationPreferences delete
   */
  export type notificationPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    /**
     * Filter which notificationPreferences to delete.
     */
    where: notificationPreferencesWhereUniqueInput
  }

  /**
   * notificationPreferences deleteMany
   */
  export type notificationPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificationPreferences to delete
     */
    where?: notificationPreferencesWhereInput
    /**
     * Limit how many notificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * notificationPreferences without action
   */
  export type notificationPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model nutritionalAdvice
   */

  export type AggregateNutritionalAdvice = {
    _count: NutritionalAdviceCountAggregateOutputType | null
    _min: NutritionalAdviceMinAggregateOutputType | null
    _max: NutritionalAdviceMaxAggregateOutputType | null
  }

  export type NutritionalAdviceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    categoryId: string | null
    season: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionalAdviceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    categoryId: string | null
    season: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionalAdviceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    categoryId: number
    season: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NutritionalAdviceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    categoryId?: true
    season?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionalAdviceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    categoryId?: true
    season?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionalAdviceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    categoryId?: true
    season?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NutritionalAdviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutritionalAdvice to aggregate.
     */
    where?: nutritionalAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalAdvices to fetch.
     */
    orderBy?: nutritionalAdviceOrderByWithRelationInput | nutritionalAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: nutritionalAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalAdvices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nutritionalAdvices
    **/
    _count?: true | NutritionalAdviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionalAdviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionalAdviceMaxAggregateInputType
  }

  export type GetNutritionalAdviceAggregateType<T extends NutritionalAdviceAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionalAdvice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionalAdvice[P]>
      : GetScalarType<T[P], AggregateNutritionalAdvice[P]>
  }




  export type nutritionalAdviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: nutritionalAdviceWhereInput
    orderBy?: nutritionalAdviceOrderByWithAggregationInput | nutritionalAdviceOrderByWithAggregationInput[]
    by: NutritionalAdviceScalarFieldEnum[] | NutritionalAdviceScalarFieldEnum
    having?: nutritionalAdviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionalAdviceCountAggregateInputType | true
    _min?: NutritionalAdviceMinAggregateInputType
    _max?: NutritionalAdviceMaxAggregateInputType
  }

  export type NutritionalAdviceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    categoryId: string
    season: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: NutritionalAdviceCountAggregateOutputType | null
    _min: NutritionalAdviceMinAggregateOutputType | null
    _max: NutritionalAdviceMaxAggregateOutputType | null
  }

  type GetNutritionalAdviceGroupByPayload<T extends nutritionalAdviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionalAdviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionalAdviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionalAdviceGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionalAdviceGroupByOutputType[P]>
        }
      >
    >


  export type nutritionalAdviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    categoryId?: boolean
    season?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nutritionalCategory?: boolean | nutritionalAdvice$nutritionalCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalAdvice"]>

  export type nutritionalAdviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    categoryId?: boolean
    season?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nutritionalCategory?: boolean | nutritionalAdvice$nutritionalCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalAdvice"]>

  export type nutritionalAdviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    categoryId?: boolean
    season?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nutritionalCategory?: boolean | nutritionalAdvice$nutritionalCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalAdvice"]>

  export type nutritionalAdviceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    categoryId?: boolean
    season?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type nutritionalAdviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "categoryId" | "season" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["nutritionalAdvice"]>
  export type nutritionalAdviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionalCategory?: boolean | nutritionalAdvice$nutritionalCategoryArgs<ExtArgs>
  }
  export type nutritionalAdviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionalCategory?: boolean | nutritionalAdvice$nutritionalCategoryArgs<ExtArgs>
  }
  export type nutritionalAdviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionalCategory?: boolean | nutritionalAdvice$nutritionalCategoryArgs<ExtArgs>
  }

  export type $nutritionalAdvicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "nutritionalAdvice"
    objects: {
      nutritionalCategory: Prisma.$nutritionalCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      categoryId: string
      season: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["nutritionalAdvice"]>
    composites: {}
  }

  type nutritionalAdviceGetPayload<S extends boolean | null | undefined | nutritionalAdviceDefaultArgs> = $Result.GetResult<Prisma.$nutritionalAdvicePayload, S>

  type nutritionalAdviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<nutritionalAdviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionalAdviceCountAggregateInputType | true
    }

  export interface nutritionalAdviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['nutritionalAdvice'], meta: { name: 'nutritionalAdvice' } }
    /**
     * Find zero or one NutritionalAdvice that matches the filter.
     * @param {nutritionalAdviceFindUniqueArgs} args - Arguments to find a NutritionalAdvice
     * @example
     * // Get one NutritionalAdvice
     * const nutritionalAdvice = await prisma.nutritionalAdvice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends nutritionalAdviceFindUniqueArgs>(args: SelectSubset<T, nutritionalAdviceFindUniqueArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionalAdvice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {nutritionalAdviceFindUniqueOrThrowArgs} args - Arguments to find a NutritionalAdvice
     * @example
     * // Get one NutritionalAdvice
     * const nutritionalAdvice = await prisma.nutritionalAdvice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends nutritionalAdviceFindUniqueOrThrowArgs>(args: SelectSubset<T, nutritionalAdviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalAdvice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalAdviceFindFirstArgs} args - Arguments to find a NutritionalAdvice
     * @example
     * // Get one NutritionalAdvice
     * const nutritionalAdvice = await prisma.nutritionalAdvice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends nutritionalAdviceFindFirstArgs>(args?: SelectSubset<T, nutritionalAdviceFindFirstArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalAdvice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalAdviceFindFirstOrThrowArgs} args - Arguments to find a NutritionalAdvice
     * @example
     * // Get one NutritionalAdvice
     * const nutritionalAdvice = await prisma.nutritionalAdvice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends nutritionalAdviceFindFirstOrThrowArgs>(args?: SelectSubset<T, nutritionalAdviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionalAdvices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalAdviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionalAdvices
     * const nutritionalAdvices = await prisma.nutritionalAdvice.findMany()
     * 
     * // Get first 10 NutritionalAdvices
     * const nutritionalAdvices = await prisma.nutritionalAdvice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionalAdviceWithIdOnly = await prisma.nutritionalAdvice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends nutritionalAdviceFindManyArgs>(args?: SelectSubset<T, nutritionalAdviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionalAdvice.
     * @param {nutritionalAdviceCreateArgs} args - Arguments to create a NutritionalAdvice.
     * @example
     * // Create one NutritionalAdvice
     * const NutritionalAdvice = await prisma.nutritionalAdvice.create({
     *   data: {
     *     // ... data to create a NutritionalAdvice
     *   }
     * })
     * 
     */
    create<T extends nutritionalAdviceCreateArgs>(args: SelectSubset<T, nutritionalAdviceCreateArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionalAdvices.
     * @param {nutritionalAdviceCreateManyArgs} args - Arguments to create many NutritionalAdvices.
     * @example
     * // Create many NutritionalAdvices
     * const nutritionalAdvice = await prisma.nutritionalAdvice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends nutritionalAdviceCreateManyArgs>(args?: SelectSubset<T, nutritionalAdviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionalAdvices and returns the data saved in the database.
     * @param {nutritionalAdviceCreateManyAndReturnArgs} args - Arguments to create many NutritionalAdvices.
     * @example
     * // Create many NutritionalAdvices
     * const nutritionalAdvice = await prisma.nutritionalAdvice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionalAdvices and only return the `id`
     * const nutritionalAdviceWithIdOnly = await prisma.nutritionalAdvice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends nutritionalAdviceCreateManyAndReturnArgs>(args?: SelectSubset<T, nutritionalAdviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutritionalAdvice.
     * @param {nutritionalAdviceDeleteArgs} args - Arguments to delete one NutritionalAdvice.
     * @example
     * // Delete one NutritionalAdvice
     * const NutritionalAdvice = await prisma.nutritionalAdvice.delete({
     *   where: {
     *     // ... filter to delete one NutritionalAdvice
     *   }
     * })
     * 
     */
    delete<T extends nutritionalAdviceDeleteArgs>(args: SelectSubset<T, nutritionalAdviceDeleteArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionalAdvice.
     * @param {nutritionalAdviceUpdateArgs} args - Arguments to update one NutritionalAdvice.
     * @example
     * // Update one NutritionalAdvice
     * const nutritionalAdvice = await prisma.nutritionalAdvice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends nutritionalAdviceUpdateArgs>(args: SelectSubset<T, nutritionalAdviceUpdateArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionalAdvices.
     * @param {nutritionalAdviceDeleteManyArgs} args - Arguments to filter NutritionalAdvices to delete.
     * @example
     * // Delete a few NutritionalAdvices
     * const { count } = await prisma.nutritionalAdvice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends nutritionalAdviceDeleteManyArgs>(args?: SelectSubset<T, nutritionalAdviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalAdvices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalAdviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionalAdvices
     * const nutritionalAdvice = await prisma.nutritionalAdvice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends nutritionalAdviceUpdateManyArgs>(args: SelectSubset<T, nutritionalAdviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalAdvices and returns the data updated in the database.
     * @param {nutritionalAdviceUpdateManyAndReturnArgs} args - Arguments to update many NutritionalAdvices.
     * @example
     * // Update many NutritionalAdvices
     * const nutritionalAdvice = await prisma.nutritionalAdvice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutritionalAdvices and only return the `id`
     * const nutritionalAdviceWithIdOnly = await prisma.nutritionalAdvice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends nutritionalAdviceUpdateManyAndReturnArgs>(args: SelectSubset<T, nutritionalAdviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutritionalAdvice.
     * @param {nutritionalAdviceUpsertArgs} args - Arguments to update or create a NutritionalAdvice.
     * @example
     * // Update or create a NutritionalAdvice
     * const nutritionalAdvice = await prisma.nutritionalAdvice.upsert({
     *   create: {
     *     // ... data to create a NutritionalAdvice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionalAdvice we want to update
     *   }
     * })
     */
    upsert<T extends nutritionalAdviceUpsertArgs>(args: SelectSubset<T, nutritionalAdviceUpsertArgs<ExtArgs>>): Prisma__nutritionalAdviceClient<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionalAdvices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalAdviceCountArgs} args - Arguments to filter NutritionalAdvices to count.
     * @example
     * // Count the number of NutritionalAdvices
     * const count = await prisma.nutritionalAdvice.count({
     *   where: {
     *     // ... the filter for the NutritionalAdvices we want to count
     *   }
     * })
    **/
    count<T extends nutritionalAdviceCountArgs>(
      args?: Subset<T, nutritionalAdviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionalAdviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionalAdvice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalAdviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionalAdviceAggregateArgs>(args: Subset<T, NutritionalAdviceAggregateArgs>): Prisma.PrismaPromise<GetNutritionalAdviceAggregateType<T>>

    /**
     * Group by NutritionalAdvice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalAdviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends nutritionalAdviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: nutritionalAdviceGroupByArgs['orderBy'] }
        : { orderBy?: nutritionalAdviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, nutritionalAdviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionalAdviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the nutritionalAdvice model
   */
  readonly fields: nutritionalAdviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for nutritionalAdvice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__nutritionalAdviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nutritionalCategory<T extends nutritionalAdvice$nutritionalCategoryArgs<ExtArgs> = {}>(args?: Subset<T, nutritionalAdvice$nutritionalCategoryArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the nutritionalAdvice model
   */
  interface nutritionalAdviceFieldRefs {
    readonly id: FieldRef<"nutritionalAdvice", 'String'>
    readonly title: FieldRef<"nutritionalAdvice", 'String'>
    readonly description: FieldRef<"nutritionalAdvice", 'String'>
    readonly categoryId: FieldRef<"nutritionalAdvice", 'String'>
    readonly season: FieldRef<"nutritionalAdvice", 'String'>
    readonly image: FieldRef<"nutritionalAdvice", 'String'>
    readonly createdAt: FieldRef<"nutritionalAdvice", 'DateTime'>
    readonly updatedAt: FieldRef<"nutritionalAdvice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * nutritionalAdvice findUnique
   */
  export type nutritionalAdviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalAdvice to fetch.
     */
    where: nutritionalAdviceWhereUniqueInput
  }

  /**
   * nutritionalAdvice findUniqueOrThrow
   */
  export type nutritionalAdviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalAdvice to fetch.
     */
    where: nutritionalAdviceWhereUniqueInput
  }

  /**
   * nutritionalAdvice findFirst
   */
  export type nutritionalAdviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalAdvice to fetch.
     */
    where?: nutritionalAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalAdvices to fetch.
     */
    orderBy?: nutritionalAdviceOrderByWithRelationInput | nutritionalAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutritionalAdvices.
     */
    cursor?: nutritionalAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalAdvices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutritionalAdvices.
     */
    distinct?: NutritionalAdviceScalarFieldEnum | NutritionalAdviceScalarFieldEnum[]
  }

  /**
   * nutritionalAdvice findFirstOrThrow
   */
  export type nutritionalAdviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalAdvice to fetch.
     */
    where?: nutritionalAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalAdvices to fetch.
     */
    orderBy?: nutritionalAdviceOrderByWithRelationInput | nutritionalAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutritionalAdvices.
     */
    cursor?: nutritionalAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalAdvices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutritionalAdvices.
     */
    distinct?: NutritionalAdviceScalarFieldEnum | NutritionalAdviceScalarFieldEnum[]
  }

  /**
   * nutritionalAdvice findMany
   */
  export type nutritionalAdviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalAdvices to fetch.
     */
    where?: nutritionalAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalAdvices to fetch.
     */
    orderBy?: nutritionalAdviceOrderByWithRelationInput | nutritionalAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nutritionalAdvices.
     */
    cursor?: nutritionalAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalAdvices.
     */
    skip?: number
    distinct?: NutritionalAdviceScalarFieldEnum | NutritionalAdviceScalarFieldEnum[]
  }

  /**
   * nutritionalAdvice create
   */
  export type nutritionalAdviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * The data needed to create a nutritionalAdvice.
     */
    data: XOR<nutritionalAdviceCreateInput, nutritionalAdviceUncheckedCreateInput>
  }

  /**
   * nutritionalAdvice createMany
   */
  export type nutritionalAdviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many nutritionalAdvices.
     */
    data: nutritionalAdviceCreateManyInput | nutritionalAdviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * nutritionalAdvice createManyAndReturn
   */
  export type nutritionalAdviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * The data used to create many nutritionalAdvices.
     */
    data: nutritionalAdviceCreateManyInput | nutritionalAdviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * nutritionalAdvice update
   */
  export type nutritionalAdviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * The data needed to update a nutritionalAdvice.
     */
    data: XOR<nutritionalAdviceUpdateInput, nutritionalAdviceUncheckedUpdateInput>
    /**
     * Choose, which nutritionalAdvice to update.
     */
    where: nutritionalAdviceWhereUniqueInput
  }

  /**
   * nutritionalAdvice updateMany
   */
  export type nutritionalAdviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update nutritionalAdvices.
     */
    data: XOR<nutritionalAdviceUpdateManyMutationInput, nutritionalAdviceUncheckedUpdateManyInput>
    /**
     * Filter which nutritionalAdvices to update
     */
    where?: nutritionalAdviceWhereInput
    /**
     * Limit how many nutritionalAdvices to update.
     */
    limit?: number
  }

  /**
   * nutritionalAdvice updateManyAndReturn
   */
  export type nutritionalAdviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * The data used to update nutritionalAdvices.
     */
    data: XOR<nutritionalAdviceUpdateManyMutationInput, nutritionalAdviceUncheckedUpdateManyInput>
    /**
     * Filter which nutritionalAdvices to update
     */
    where?: nutritionalAdviceWhereInput
    /**
     * Limit how many nutritionalAdvices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * nutritionalAdvice upsert
   */
  export type nutritionalAdviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * The filter to search for the nutritionalAdvice to update in case it exists.
     */
    where: nutritionalAdviceWhereUniqueInput
    /**
     * In case the nutritionalAdvice found by the `where` argument doesn't exist, create a new nutritionalAdvice with this data.
     */
    create: XOR<nutritionalAdviceCreateInput, nutritionalAdviceUncheckedCreateInput>
    /**
     * In case the nutritionalAdvice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nutritionalAdviceUpdateInput, nutritionalAdviceUncheckedUpdateInput>
  }

  /**
   * nutritionalAdvice delete
   */
  export type nutritionalAdviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    /**
     * Filter which nutritionalAdvice to delete.
     */
    where: nutritionalAdviceWhereUniqueInput
  }

  /**
   * nutritionalAdvice deleteMany
   */
  export type nutritionalAdviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutritionalAdvices to delete
     */
    where?: nutritionalAdviceWhereInput
    /**
     * Limit how many nutritionalAdvices to delete.
     */
    limit?: number
  }

  /**
   * nutritionalAdvice.nutritionalCategory
   */
  export type nutritionalAdvice$nutritionalCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    where?: nutritionalCategoryWhereInput
  }

  /**
   * nutritionalAdvice without action
   */
  export type nutritionalAdviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
  }


  /**
   * Model projectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    projectId: string | null
    userId: string | null
    role: string | null
    joinDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    projectId: string | null
    userId: string | null
    role: string | null
    joinDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    projectId: number
    userId: number
    role: number
    joinDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    projectId?: true
    userId?: true
    role?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    projectId?: true
    userId?: true
    role?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    projectId?: true
    userId?: true
    role?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectMember to aggregate.
     */
    where?: projectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectMembers to fetch.
     */
    orderBy?: projectMemberOrderByWithRelationInput | projectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type projectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectMemberWhereInput
    orderBy?: projectMemberOrderByWithAggregationInput | projectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: projectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    projectId: string
    userId: string
    role: string
    joinDate: Date
    createdAt: Date
    updatedAt: Date | null
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends projectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type projectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaborativeProject?: boolean | collaborativeProjectDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type projectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaborativeProject?: boolean | collaborativeProjectDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type projectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaborativeProject?: boolean | collaborativeProjectDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type projectMemberSelectScalar = {
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type projectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "userId" | "role" | "joinDate" | "createdAt" | "updatedAt", ExtArgs["result"]["projectMember"]>
  export type projectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborativeProject?: boolean | collaborativeProjectDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type projectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborativeProject?: boolean | collaborativeProjectDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type projectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborativeProject?: boolean | collaborativeProjectDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $projectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projectMember"
    objects: {
      collaborativeProject: Prisma.$collaborativeProjectPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      userId: string
      role: string
      joinDate: Date
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type projectMemberGetPayload<S extends boolean | null | undefined | projectMemberDefaultArgs> = $Result.GetResult<Prisma.$projectMemberPayload, S>

  type projectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface projectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projectMember'], meta: { name: 'projectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {projectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectMemberFindUniqueArgs>(args: SelectSubset<T, projectMemberFindUniqueArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, projectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectMemberFindFirstArgs>(args?: SelectSubset<T, projectMemberFindFirstArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, projectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectMemberWithProjectIdOnly = await prisma.projectMember.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends projectMemberFindManyArgs>(args?: SelectSubset<T, projectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {projectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends projectMemberCreateArgs>(args: SelectSubset<T, projectMemberCreateArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {projectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectMemberCreateManyArgs>(args?: SelectSubset<T, projectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {projectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `projectId`
     * const projectMemberWithProjectIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, projectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {projectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends projectMemberDeleteArgs>(args: SelectSubset<T, projectMemberDeleteArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {projectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectMemberUpdateArgs>(args: SelectSubset<T, projectMemberUpdateArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {projectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectMemberDeleteManyArgs>(args?: SelectSubset<T, projectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectMemberUpdateManyArgs>(args: SelectSubset<T, projectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {projectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `projectId`
     * const projectMemberWithProjectIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { projectId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, projectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {projectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends projectMemberUpsertArgs>(args: SelectSubset<T, projectMemberUpsertArgs<ExtArgs>>): Prisma__projectMemberClient<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends projectMemberCountArgs>(
      args?: Subset<T, projectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectMemberGroupByArgs['orderBy'] }
        : { orderBy?: projectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projectMember model
   */
  readonly fields: projectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collaborativeProject<T extends collaborativeProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collaborativeProjectDefaultArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projectMember model
   */
  interface projectMemberFieldRefs {
    readonly projectId: FieldRef<"projectMember", 'String'>
    readonly userId: FieldRef<"projectMember", 'String'>
    readonly role: FieldRef<"projectMember", 'String'>
    readonly joinDate: FieldRef<"projectMember", 'DateTime'>
    readonly createdAt: FieldRef<"projectMember", 'DateTime'>
    readonly updatedAt: FieldRef<"projectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * projectMember findUnique
   */
  export type projectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * Filter, which projectMember to fetch.
     */
    where: projectMemberWhereUniqueInput
  }

  /**
   * projectMember findUniqueOrThrow
   */
  export type projectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * Filter, which projectMember to fetch.
     */
    where: projectMemberWhereUniqueInput
  }

  /**
   * projectMember findFirst
   */
  export type projectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * Filter, which projectMember to fetch.
     */
    where?: projectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectMembers to fetch.
     */
    orderBy?: projectMemberOrderByWithRelationInput | projectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectMembers.
     */
    cursor?: projectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * projectMember findFirstOrThrow
   */
  export type projectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * Filter, which projectMember to fetch.
     */
    where?: projectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectMembers to fetch.
     */
    orderBy?: projectMemberOrderByWithRelationInput | projectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectMembers.
     */
    cursor?: projectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * projectMember findMany
   */
  export type projectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * Filter, which projectMembers to fetch.
     */
    where?: projectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectMembers to fetch.
     */
    orderBy?: projectMemberOrderByWithRelationInput | projectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projectMembers.
     */
    cursor?: projectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * projectMember create
   */
  export type projectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a projectMember.
     */
    data: XOR<projectMemberCreateInput, projectMemberUncheckedCreateInput>
  }

  /**
   * projectMember createMany
   */
  export type projectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projectMembers.
     */
    data: projectMemberCreateManyInput | projectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projectMember createManyAndReturn
   */
  export type projectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many projectMembers.
     */
    data: projectMemberCreateManyInput | projectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectMember update
   */
  export type projectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a projectMember.
     */
    data: XOR<projectMemberUpdateInput, projectMemberUncheckedUpdateInput>
    /**
     * Choose, which projectMember to update.
     */
    where: projectMemberWhereUniqueInput
  }

  /**
   * projectMember updateMany
   */
  export type projectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projectMembers.
     */
    data: XOR<projectMemberUpdateManyMutationInput, projectMemberUncheckedUpdateManyInput>
    /**
     * Filter which projectMembers to update
     */
    where?: projectMemberWhereInput
    /**
     * Limit how many projectMembers to update.
     */
    limit?: number
  }

  /**
   * projectMember updateManyAndReturn
   */
  export type projectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * The data used to update projectMembers.
     */
    data: XOR<projectMemberUpdateManyMutationInput, projectMemberUncheckedUpdateManyInput>
    /**
     * Filter which projectMembers to update
     */
    where?: projectMemberWhereInput
    /**
     * Limit how many projectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectMember upsert
   */
  export type projectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the projectMember to update in case it exists.
     */
    where: projectMemberWhereUniqueInput
    /**
     * In case the projectMember found by the `where` argument doesn't exist, create a new projectMember with this data.
     */
    create: XOR<projectMemberCreateInput, projectMemberUncheckedCreateInput>
    /**
     * In case the projectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectMemberUpdateInput, projectMemberUncheckedUpdateInput>
  }

  /**
   * projectMember delete
   */
  export type projectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    /**
     * Filter which projectMember to delete.
     */
    where: projectMemberWhereUniqueInput
  }

  /**
   * projectMember deleteMany
   */
  export type projectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectMembers to delete
     */
    where?: projectMemberWhereInput
    /**
     * Limit how many projectMembers to delete.
     */
    limit?: number
  }

  /**
   * projectMember without action
   */
  export type projectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
  }


  /**
   * Model projectTask
   */

  export type AggregateProjectTask = {
    _count: ProjectTaskCountAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  export type ProjectTaskMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    creationDate: Date | null
    dueDate: Date | null
    status: string | null
    assigneeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTaskMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    creationDate: Date | null
    dueDate: Date | null
    status: string | null
    assigneeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTaskCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    creationDate: number
    dueDate: number
    status: number
    assigneeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectTaskMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    creationDate?: true
    dueDate?: true
    status?: true
    assigneeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTaskMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    creationDate?: true
    dueDate?: true
    status?: true
    assigneeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTaskCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    creationDate?: true
    dueDate?: true
    status?: true
    assigneeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectTask to aggregate.
     */
    where?: projectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectTasks to fetch.
     */
    orderBy?: projectTaskOrderByWithRelationInput | projectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projectTasks
    **/
    _count?: true | ProjectTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTaskMaxAggregateInputType
  }

  export type GetProjectTaskAggregateType<T extends ProjectTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTask[P]>
      : GetScalarType<T[P], AggregateProjectTask[P]>
  }




  export type projectTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectTaskWhereInput
    orderBy?: projectTaskOrderByWithAggregationInput | projectTaskOrderByWithAggregationInput[]
    by: ProjectTaskScalarFieldEnum[] | ProjectTaskScalarFieldEnum
    having?: projectTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTaskCountAggregateInputType | true
    _min?: ProjectTaskMinAggregateInputType
    _max?: ProjectTaskMaxAggregateInputType
  }

  export type ProjectTaskGroupByOutputType = {
    id: string
    projectId: string
    title: string
    description: string | null
    creationDate: Date
    dueDate: Date | null
    status: string | null
    assigneeId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ProjectTaskCountAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  type GetProjectTaskGroupByPayload<T extends projectTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
        }
      >
    >


  export type projectTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    creationDate?: boolean
    dueDate?: boolean
    status?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | projectTask$userArgs<ExtArgs>
    collaborativeProject?: boolean | projectTask$collaborativeProjectArgs<ExtArgs>
  }, ExtArgs["result"]["projectTask"]>

  export type projectTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    creationDate?: boolean
    dueDate?: boolean
    status?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | projectTask$userArgs<ExtArgs>
    collaborativeProject?: boolean | projectTask$collaborativeProjectArgs<ExtArgs>
  }, ExtArgs["result"]["projectTask"]>

  export type projectTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    creationDate?: boolean
    dueDate?: boolean
    status?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | projectTask$userArgs<ExtArgs>
    collaborativeProject?: boolean | projectTask$collaborativeProjectArgs<ExtArgs>
  }, ExtArgs["result"]["projectTask"]>

  export type projectTaskSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    creationDate?: boolean
    dueDate?: boolean
    status?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type projectTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "description" | "creationDate" | "dueDate" | "status" | "assigneeId" | "createdAt" | "updatedAt", ExtArgs["result"]["projectTask"]>
  export type projectTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | projectTask$userArgs<ExtArgs>
    collaborativeProject?: boolean | projectTask$collaborativeProjectArgs<ExtArgs>
  }
  export type projectTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | projectTask$userArgs<ExtArgs>
    collaborativeProject?: boolean | projectTask$collaborativeProjectArgs<ExtArgs>
  }
  export type projectTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | projectTask$userArgs<ExtArgs>
    collaborativeProject?: boolean | projectTask$collaborativeProjectArgs<ExtArgs>
  }

  export type $projectTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projectTask"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      collaborativeProject: Prisma.$collaborativeProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      description: string | null
      creationDate: Date
      dueDate: Date | null
      status: string | null
      assigneeId: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["projectTask"]>
    composites: {}
  }

  type projectTaskGetPayload<S extends boolean | null | undefined | projectTaskDefaultArgs> = $Result.GetResult<Prisma.$projectTaskPayload, S>

  type projectTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTaskCountAggregateInputType | true
    }

  export interface projectTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projectTask'], meta: { name: 'projectTask' } }
    /**
     * Find zero or one ProjectTask that matches the filter.
     * @param {projectTaskFindUniqueArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectTaskFindUniqueArgs>(args: SelectSubset<T, projectTaskFindUniqueArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectTaskFindUniqueOrThrowArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, projectTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskFindFirstArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectTaskFindFirstArgs>(args?: SelectSubset<T, projectTaskFindFirstArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskFindFirstOrThrowArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, projectTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany()
     * 
     * // Get first 10 ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTaskWithIdOnly = await prisma.projectTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projectTaskFindManyArgs>(args?: SelectSubset<T, projectTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectTask.
     * @param {projectTaskCreateArgs} args - Arguments to create a ProjectTask.
     * @example
     * // Create one ProjectTask
     * const ProjectTask = await prisma.projectTask.create({
     *   data: {
     *     // ... data to create a ProjectTask
     *   }
     * })
     * 
     */
    create<T extends projectTaskCreateArgs>(args: SelectSubset<T, projectTaskCreateArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectTasks.
     * @param {projectTaskCreateManyArgs} args - Arguments to create many ProjectTasks.
     * @example
     * // Create many ProjectTasks
     * const projectTask = await prisma.projectTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectTaskCreateManyArgs>(args?: SelectSubset<T, projectTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTasks and returns the data saved in the database.
     * @param {projectTaskCreateManyAndReturnArgs} args - Arguments to create many ProjectTasks.
     * @example
     * // Create many ProjectTasks
     * const projectTask = await prisma.projectTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTasks and only return the `id`
     * const projectTaskWithIdOnly = await prisma.projectTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, projectTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectTask.
     * @param {projectTaskDeleteArgs} args - Arguments to delete one ProjectTask.
     * @example
     * // Delete one ProjectTask
     * const ProjectTask = await prisma.projectTask.delete({
     *   where: {
     *     // ... filter to delete one ProjectTask
     *   }
     * })
     * 
     */
    delete<T extends projectTaskDeleteArgs>(args: SelectSubset<T, projectTaskDeleteArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectTask.
     * @param {projectTaskUpdateArgs} args - Arguments to update one ProjectTask.
     * @example
     * // Update one ProjectTask
     * const projectTask = await prisma.projectTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectTaskUpdateArgs>(args: SelectSubset<T, projectTaskUpdateArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectTasks.
     * @param {projectTaskDeleteManyArgs} args - Arguments to filter ProjectTasks to delete.
     * @example
     * // Delete a few ProjectTasks
     * const { count } = await prisma.projectTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectTaskDeleteManyArgs>(args?: SelectSubset<T, projectTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTasks
     * const projectTask = await prisma.projectTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectTaskUpdateManyArgs>(args: SelectSubset<T, projectTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTasks and returns the data updated in the database.
     * @param {projectTaskUpdateManyAndReturnArgs} args - Arguments to update many ProjectTasks.
     * @example
     * // Update many ProjectTasks
     * const projectTask = await prisma.projectTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectTasks and only return the `id`
     * const projectTaskWithIdOnly = await prisma.projectTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projectTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, projectTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectTask.
     * @param {projectTaskUpsertArgs} args - Arguments to update or create a ProjectTask.
     * @example
     * // Update or create a ProjectTask
     * const projectTask = await prisma.projectTask.upsert({
     *   create: {
     *     // ... data to create a ProjectTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTask we want to update
     *   }
     * })
     */
    upsert<T extends projectTaskUpsertArgs>(args: SelectSubset<T, projectTaskUpsertArgs<ExtArgs>>): Prisma__projectTaskClient<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskCountArgs} args - Arguments to filter ProjectTasks to count.
     * @example
     * // Count the number of ProjectTasks
     * const count = await prisma.projectTask.count({
     *   where: {
     *     // ... the filter for the ProjectTasks we want to count
     *   }
     * })
    **/
    count<T extends projectTaskCountArgs>(
      args?: Subset<T, projectTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTaskAggregateArgs>(args: Subset<T, ProjectTaskAggregateArgs>): Prisma.PrismaPromise<GetProjectTaskAggregateType<T>>

    /**
     * Group by ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectTaskGroupByArgs['orderBy'] }
        : { orderBy?: projectTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projectTask model
   */
  readonly fields: projectTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projectTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends projectTask$userArgs<ExtArgs> = {}>(args?: Subset<T, projectTask$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    collaborativeProject<T extends projectTask$collaborativeProjectArgs<ExtArgs> = {}>(args?: Subset<T, projectTask$collaborativeProjectArgs<ExtArgs>>): Prisma__collaborativeProjectClient<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projectTask model
   */
  interface projectTaskFieldRefs {
    readonly id: FieldRef<"projectTask", 'String'>
    readonly projectId: FieldRef<"projectTask", 'String'>
    readonly title: FieldRef<"projectTask", 'String'>
    readonly description: FieldRef<"projectTask", 'String'>
    readonly creationDate: FieldRef<"projectTask", 'DateTime'>
    readonly dueDate: FieldRef<"projectTask", 'DateTime'>
    readonly status: FieldRef<"projectTask", 'String'>
    readonly assigneeId: FieldRef<"projectTask", 'String'>
    readonly createdAt: FieldRef<"projectTask", 'DateTime'>
    readonly updatedAt: FieldRef<"projectTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * projectTask findUnique
   */
  export type projectTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * Filter, which projectTask to fetch.
     */
    where: projectTaskWhereUniqueInput
  }

  /**
   * projectTask findUniqueOrThrow
   */
  export type projectTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * Filter, which projectTask to fetch.
     */
    where: projectTaskWhereUniqueInput
  }

  /**
   * projectTask findFirst
   */
  export type projectTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * Filter, which projectTask to fetch.
     */
    where?: projectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectTasks to fetch.
     */
    orderBy?: projectTaskOrderByWithRelationInput | projectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectTasks.
     */
    cursor?: projectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectTasks.
     */
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * projectTask findFirstOrThrow
   */
  export type projectTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * Filter, which projectTask to fetch.
     */
    where?: projectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectTasks to fetch.
     */
    orderBy?: projectTaskOrderByWithRelationInput | projectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectTasks.
     */
    cursor?: projectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectTasks.
     */
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * projectTask findMany
   */
  export type projectTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * Filter, which projectTasks to fetch.
     */
    where?: projectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectTasks to fetch.
     */
    orderBy?: projectTaskOrderByWithRelationInput | projectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projectTasks.
     */
    cursor?: projectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectTasks.
     */
    skip?: number
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * projectTask create
   */
  export type projectTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a projectTask.
     */
    data: XOR<projectTaskCreateInput, projectTaskUncheckedCreateInput>
  }

  /**
   * projectTask createMany
   */
  export type projectTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projectTasks.
     */
    data: projectTaskCreateManyInput | projectTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projectTask createManyAndReturn
   */
  export type projectTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * The data used to create many projectTasks.
     */
    data: projectTaskCreateManyInput | projectTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectTask update
   */
  export type projectTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a projectTask.
     */
    data: XOR<projectTaskUpdateInput, projectTaskUncheckedUpdateInput>
    /**
     * Choose, which projectTask to update.
     */
    where: projectTaskWhereUniqueInput
  }

  /**
   * projectTask updateMany
   */
  export type projectTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projectTasks.
     */
    data: XOR<projectTaskUpdateManyMutationInput, projectTaskUncheckedUpdateManyInput>
    /**
     * Filter which projectTasks to update
     */
    where?: projectTaskWhereInput
    /**
     * Limit how many projectTasks to update.
     */
    limit?: number
  }

  /**
   * projectTask updateManyAndReturn
   */
  export type projectTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * The data used to update projectTasks.
     */
    data: XOR<projectTaskUpdateManyMutationInput, projectTaskUncheckedUpdateManyInput>
    /**
     * Filter which projectTasks to update
     */
    where?: projectTaskWhereInput
    /**
     * Limit how many projectTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectTask upsert
   */
  export type projectTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the projectTask to update in case it exists.
     */
    where: projectTaskWhereUniqueInput
    /**
     * In case the projectTask found by the `where` argument doesn't exist, create a new projectTask with this data.
     */
    create: XOR<projectTaskCreateInput, projectTaskUncheckedCreateInput>
    /**
     * In case the projectTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectTaskUpdateInput, projectTaskUncheckedUpdateInput>
  }

  /**
   * projectTask delete
   */
  export type projectTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    /**
     * Filter which projectTask to delete.
     */
    where: projectTaskWhereUniqueInput
  }

  /**
   * projectTask deleteMany
   */
  export type projectTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectTasks to delete
     */
    where?: projectTaskWhereInput
    /**
     * Limit how many projectTasks to delete.
     */
    limit?: number
  }

  /**
   * projectTask.user
   */
  export type projectTask$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * projectTask.collaborativeProject
   */
  export type projectTask$collaborativeProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    where?: collaborativeProjectWhereInput
  }

  /**
   * projectTask without action
   */
  export type projectTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
  }


  /**
   * Model resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: string | null
    categoryId: string | null
    authorId: string | null
    adminValidated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: string | null
    categoryId: string | null
    authorId: string | null
    adminValidated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    categoryId: number
    authorId: number
    adminValidated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    categoryId?: true
    authorId?: true
    adminValidated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    categoryId?: true
    authorId?: true
    adminValidated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    categoryId?: true
    authorId?: true
    adminValidated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resource to aggregate.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type resourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourceWhereInput
    orderBy?: resourceOrderByWithAggregationInput | resourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: resourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    title: string
    content: string | null
    type: string
    categoryId: string | null
    authorId: string
    adminValidated: boolean | null
    createdAt: Date
    updatedAt: Date | null
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends resourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type resourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    categoryId?: boolean
    authorId?: boolean
    adminValidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | resource$userArgs<ExtArgs>
    resourceCategory?: boolean | resource$resourceCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type resourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    categoryId?: boolean
    authorId?: boolean
    adminValidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | resource$userArgs<ExtArgs>
    resourceCategory?: boolean | resource$resourceCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type resourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    categoryId?: boolean
    authorId?: boolean
    adminValidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | resource$userArgs<ExtArgs>
    resourceCategory?: boolean | resource$resourceCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type resourceSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    categoryId?: boolean
    authorId?: boolean
    adminValidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type resourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "type" | "categoryId" | "authorId" | "adminValidated" | "createdAt" | "updatedAt", ExtArgs["result"]["resource"]>
  export type resourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | resource$userArgs<ExtArgs>
    resourceCategory?: boolean | resource$resourceCategoryArgs<ExtArgs>
  }
  export type resourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | resource$userArgs<ExtArgs>
    resourceCategory?: boolean | resource$resourceCategoryArgs<ExtArgs>
  }
  export type resourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | resource$userArgs<ExtArgs>
    resourceCategory?: boolean | resource$resourceCategoryArgs<ExtArgs>
  }

  export type $resourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "resource"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      resourceCategory: Prisma.$resourceCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string | null
      type: string
      categoryId: string | null
      authorId: string
      adminValidated: boolean | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type resourceGetPayload<S extends boolean | null | undefined | resourceDefaultArgs> = $Result.GetResult<Prisma.$resourcePayload, S>

  type resourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface resourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['resource'], meta: { name: 'resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {resourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resourceFindUniqueArgs>(args: SelectSubset<T, resourceFindUniqueArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resourceFindUniqueOrThrowArgs>(args: SelectSubset<T, resourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resourceFindFirstArgs>(args?: SelectSubset<T, resourceFindFirstArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resourceFindFirstOrThrowArgs>(args?: SelectSubset<T, resourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends resourceFindManyArgs>(args?: SelectSubset<T, resourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {resourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends resourceCreateArgs>(args: SelectSubset<T, resourceCreateArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {resourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resourceCreateManyArgs>(args?: SelectSubset<T, resourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {resourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends resourceCreateManyAndReturnArgs>(args?: SelectSubset<T, resourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {resourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends resourceDeleteArgs>(args: SelectSubset<T, resourceDeleteArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {resourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resourceUpdateArgs>(args: SelectSubset<T, resourceUpdateArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {resourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resourceDeleteManyArgs>(args?: SelectSubset<T, resourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resourceUpdateManyArgs>(args: SelectSubset<T, resourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {resourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends resourceUpdateManyAndReturnArgs>(args: SelectSubset<T, resourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {resourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends resourceUpsertArgs>(args: SelectSubset<T, resourceUpsertArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends resourceCountArgs>(
      args?: Subset<T, resourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resourceGroupByArgs['orderBy'] }
        : { orderBy?: resourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the resource model
   */
  readonly fields: resourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends resource$userArgs<ExtArgs> = {}>(args?: Subset<T, resource$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resourceCategory<T extends resource$resourceCategoryArgs<ExtArgs> = {}>(args?: Subset<T, resource$resourceCategoryArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the resource model
   */
  interface resourceFieldRefs {
    readonly id: FieldRef<"resource", 'String'>
    readonly title: FieldRef<"resource", 'String'>
    readonly content: FieldRef<"resource", 'String'>
    readonly type: FieldRef<"resource", 'String'>
    readonly categoryId: FieldRef<"resource", 'String'>
    readonly authorId: FieldRef<"resource", 'String'>
    readonly adminValidated: FieldRef<"resource", 'Boolean'>
    readonly createdAt: FieldRef<"resource", 'DateTime'>
    readonly updatedAt: FieldRef<"resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * resource findUnique
   */
  export type resourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource findUniqueOrThrow
   */
  export type resourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource findFirst
   */
  export type resourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * resource findFirstOrThrow
   */
  export type resourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * resource findMany
   */
  export type resourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing resources.
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * resource create
   */
  export type resourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * The data needed to create a resource.
     */
    data: XOR<resourceCreateInput, resourceUncheckedCreateInput>
  }

  /**
   * resource createMany
   */
  export type resourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many resources.
     */
    data: resourceCreateManyInput | resourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resource createManyAndReturn
   */
  export type resourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * The data used to create many resources.
     */
    data: resourceCreateManyInput | resourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * resource update
   */
  export type resourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * The data needed to update a resource.
     */
    data: XOR<resourceUpdateInput, resourceUncheckedUpdateInput>
    /**
     * Choose, which resource to update.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource updateMany
   */
  export type resourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update resources.
     */
    data: XOR<resourceUpdateManyMutationInput, resourceUncheckedUpdateManyInput>
    /**
     * Filter which resources to update
     */
    where?: resourceWhereInput
    /**
     * Limit how many resources to update.
     */
    limit?: number
  }

  /**
   * resource updateManyAndReturn
   */
  export type resourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * The data used to update resources.
     */
    data: XOR<resourceUpdateManyMutationInput, resourceUncheckedUpdateManyInput>
    /**
     * Filter which resources to update
     */
    where?: resourceWhereInput
    /**
     * Limit how many resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * resource upsert
   */
  export type resourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * The filter to search for the resource to update in case it exists.
     */
    where: resourceWhereUniqueInput
    /**
     * In case the resource found by the `where` argument doesn't exist, create a new resource with this data.
     */
    create: XOR<resourceCreateInput, resourceUncheckedCreateInput>
    /**
     * In case the resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resourceUpdateInput, resourceUncheckedUpdateInput>
  }

  /**
   * resource delete
   */
  export type resourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter which resource to delete.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource deleteMany
   */
  export type resourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resources to delete
     */
    where?: resourceWhereInput
    /**
     * Limit how many resources to delete.
     */
    limit?: number
  }

  /**
   * resource.user
   */
  export type resource$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * resource.resourceCategory
   */
  export type resource$resourceCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    where?: resourceCategoryWhereInput
  }

  /**
   * resource without action
   */
  export type resourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
  }


  /**
   * Model satisfactionSurvey
   */

  export type AggregateSatisfactionSurvey = {
    _count: SatisfactionSurveyCountAggregateOutputType | null
    _min: SatisfactionSurveyMinAggregateOutputType | null
    _max: SatisfactionSurveyMaxAggregateOutputType | null
  }

  export type SatisfactionSurveyMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SatisfactionSurveyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SatisfactionSurveyCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SatisfactionSurveyMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SatisfactionSurveyMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SatisfactionSurveyCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SatisfactionSurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which satisfactionSurvey to aggregate.
     */
    where?: satisfactionSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of satisfactionSurveys to fetch.
     */
    orderBy?: satisfactionSurveyOrderByWithRelationInput | satisfactionSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: satisfactionSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` satisfactionSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` satisfactionSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned satisfactionSurveys
    **/
    _count?: true | SatisfactionSurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SatisfactionSurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SatisfactionSurveyMaxAggregateInputType
  }

  export type GetSatisfactionSurveyAggregateType<T extends SatisfactionSurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateSatisfactionSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSatisfactionSurvey[P]>
      : GetScalarType<T[P], AggregateSatisfactionSurvey[P]>
  }




  export type satisfactionSurveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: satisfactionSurveyWhereInput
    orderBy?: satisfactionSurveyOrderByWithAggregationInput | satisfactionSurveyOrderByWithAggregationInput[]
    by: SatisfactionSurveyScalarFieldEnum[] | SatisfactionSurveyScalarFieldEnum
    having?: satisfactionSurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SatisfactionSurveyCountAggregateInputType | true
    _min?: SatisfactionSurveyMinAggregateInputType
    _max?: SatisfactionSurveyMaxAggregateInputType
  }

  export type SatisfactionSurveyGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date
    updatedAt: Date | null
    _count: SatisfactionSurveyCountAggregateOutputType | null
    _min: SatisfactionSurveyMinAggregateOutputType | null
    _max: SatisfactionSurveyMaxAggregateOutputType | null
  }

  type GetSatisfactionSurveyGroupByPayload<T extends satisfactionSurveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SatisfactionSurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SatisfactionSurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SatisfactionSurveyGroupByOutputType[P]>
            : GetScalarType<T[P], SatisfactionSurveyGroupByOutputType[P]>
        }
      >
    >


  export type satisfactionSurveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    surveyResponse?: boolean | satisfactionSurvey$surveyResponseArgs<ExtArgs>
    _count?: boolean | SatisfactionSurveyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["satisfactionSurvey"]>

  export type satisfactionSurveySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["satisfactionSurvey"]>

  export type satisfactionSurveySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["satisfactionSurvey"]>

  export type satisfactionSurveySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type satisfactionSurveyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startDate" | "endDate" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["satisfactionSurvey"]>
  export type satisfactionSurveyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyResponse?: boolean | satisfactionSurvey$surveyResponseArgs<ExtArgs>
    _count?: boolean | SatisfactionSurveyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type satisfactionSurveyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type satisfactionSurveyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $satisfactionSurveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "satisfactionSurvey"
    objects: {
      surveyResponse: Prisma.$surveyResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startDate: Date | null
      endDate: Date | null
      active: boolean | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["satisfactionSurvey"]>
    composites: {}
  }

  type satisfactionSurveyGetPayload<S extends boolean | null | undefined | satisfactionSurveyDefaultArgs> = $Result.GetResult<Prisma.$satisfactionSurveyPayload, S>

  type satisfactionSurveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<satisfactionSurveyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SatisfactionSurveyCountAggregateInputType | true
    }

  export interface satisfactionSurveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['satisfactionSurvey'], meta: { name: 'satisfactionSurvey' } }
    /**
     * Find zero or one SatisfactionSurvey that matches the filter.
     * @param {satisfactionSurveyFindUniqueArgs} args - Arguments to find a SatisfactionSurvey
     * @example
     * // Get one SatisfactionSurvey
     * const satisfactionSurvey = await prisma.satisfactionSurvey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends satisfactionSurveyFindUniqueArgs>(args: SelectSubset<T, satisfactionSurveyFindUniqueArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SatisfactionSurvey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {satisfactionSurveyFindUniqueOrThrowArgs} args - Arguments to find a SatisfactionSurvey
     * @example
     * // Get one SatisfactionSurvey
     * const satisfactionSurvey = await prisma.satisfactionSurvey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends satisfactionSurveyFindUniqueOrThrowArgs>(args: SelectSubset<T, satisfactionSurveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SatisfactionSurvey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {satisfactionSurveyFindFirstArgs} args - Arguments to find a SatisfactionSurvey
     * @example
     * // Get one SatisfactionSurvey
     * const satisfactionSurvey = await prisma.satisfactionSurvey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends satisfactionSurveyFindFirstArgs>(args?: SelectSubset<T, satisfactionSurveyFindFirstArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SatisfactionSurvey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {satisfactionSurveyFindFirstOrThrowArgs} args - Arguments to find a SatisfactionSurvey
     * @example
     * // Get one SatisfactionSurvey
     * const satisfactionSurvey = await prisma.satisfactionSurvey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends satisfactionSurveyFindFirstOrThrowArgs>(args?: SelectSubset<T, satisfactionSurveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SatisfactionSurveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {satisfactionSurveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SatisfactionSurveys
     * const satisfactionSurveys = await prisma.satisfactionSurvey.findMany()
     * 
     * // Get first 10 SatisfactionSurveys
     * const satisfactionSurveys = await prisma.satisfactionSurvey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const satisfactionSurveyWithIdOnly = await prisma.satisfactionSurvey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends satisfactionSurveyFindManyArgs>(args?: SelectSubset<T, satisfactionSurveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SatisfactionSurvey.
     * @param {satisfactionSurveyCreateArgs} args - Arguments to create a SatisfactionSurvey.
     * @example
     * // Create one SatisfactionSurvey
     * const SatisfactionSurvey = await prisma.satisfactionSurvey.create({
     *   data: {
     *     // ... data to create a SatisfactionSurvey
     *   }
     * })
     * 
     */
    create<T extends satisfactionSurveyCreateArgs>(args: SelectSubset<T, satisfactionSurveyCreateArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SatisfactionSurveys.
     * @param {satisfactionSurveyCreateManyArgs} args - Arguments to create many SatisfactionSurveys.
     * @example
     * // Create many SatisfactionSurveys
     * const satisfactionSurvey = await prisma.satisfactionSurvey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends satisfactionSurveyCreateManyArgs>(args?: SelectSubset<T, satisfactionSurveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SatisfactionSurveys and returns the data saved in the database.
     * @param {satisfactionSurveyCreateManyAndReturnArgs} args - Arguments to create many SatisfactionSurveys.
     * @example
     * // Create many SatisfactionSurveys
     * const satisfactionSurvey = await prisma.satisfactionSurvey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SatisfactionSurveys and only return the `id`
     * const satisfactionSurveyWithIdOnly = await prisma.satisfactionSurvey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends satisfactionSurveyCreateManyAndReturnArgs>(args?: SelectSubset<T, satisfactionSurveyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SatisfactionSurvey.
     * @param {satisfactionSurveyDeleteArgs} args - Arguments to delete one SatisfactionSurvey.
     * @example
     * // Delete one SatisfactionSurvey
     * const SatisfactionSurvey = await prisma.satisfactionSurvey.delete({
     *   where: {
     *     // ... filter to delete one SatisfactionSurvey
     *   }
     * })
     * 
     */
    delete<T extends satisfactionSurveyDeleteArgs>(args: SelectSubset<T, satisfactionSurveyDeleteArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SatisfactionSurvey.
     * @param {satisfactionSurveyUpdateArgs} args - Arguments to update one SatisfactionSurvey.
     * @example
     * // Update one SatisfactionSurvey
     * const satisfactionSurvey = await prisma.satisfactionSurvey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends satisfactionSurveyUpdateArgs>(args: SelectSubset<T, satisfactionSurveyUpdateArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SatisfactionSurveys.
     * @param {satisfactionSurveyDeleteManyArgs} args - Arguments to filter SatisfactionSurveys to delete.
     * @example
     * // Delete a few SatisfactionSurveys
     * const { count } = await prisma.satisfactionSurvey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends satisfactionSurveyDeleteManyArgs>(args?: SelectSubset<T, satisfactionSurveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SatisfactionSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {satisfactionSurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SatisfactionSurveys
     * const satisfactionSurvey = await prisma.satisfactionSurvey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends satisfactionSurveyUpdateManyArgs>(args: SelectSubset<T, satisfactionSurveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SatisfactionSurveys and returns the data updated in the database.
     * @param {satisfactionSurveyUpdateManyAndReturnArgs} args - Arguments to update many SatisfactionSurveys.
     * @example
     * // Update many SatisfactionSurveys
     * const satisfactionSurvey = await prisma.satisfactionSurvey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SatisfactionSurveys and only return the `id`
     * const satisfactionSurveyWithIdOnly = await prisma.satisfactionSurvey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends satisfactionSurveyUpdateManyAndReturnArgs>(args: SelectSubset<T, satisfactionSurveyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SatisfactionSurvey.
     * @param {satisfactionSurveyUpsertArgs} args - Arguments to update or create a SatisfactionSurvey.
     * @example
     * // Update or create a SatisfactionSurvey
     * const satisfactionSurvey = await prisma.satisfactionSurvey.upsert({
     *   create: {
     *     // ... data to create a SatisfactionSurvey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SatisfactionSurvey we want to update
     *   }
     * })
     */
    upsert<T extends satisfactionSurveyUpsertArgs>(args: SelectSubset<T, satisfactionSurveyUpsertArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SatisfactionSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {satisfactionSurveyCountArgs} args - Arguments to filter SatisfactionSurveys to count.
     * @example
     * // Count the number of SatisfactionSurveys
     * const count = await prisma.satisfactionSurvey.count({
     *   where: {
     *     // ... the filter for the SatisfactionSurveys we want to count
     *   }
     * })
    **/
    count<T extends satisfactionSurveyCountArgs>(
      args?: Subset<T, satisfactionSurveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SatisfactionSurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SatisfactionSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SatisfactionSurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SatisfactionSurveyAggregateArgs>(args: Subset<T, SatisfactionSurveyAggregateArgs>): Prisma.PrismaPromise<GetSatisfactionSurveyAggregateType<T>>

    /**
     * Group by SatisfactionSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {satisfactionSurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends satisfactionSurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: satisfactionSurveyGroupByArgs['orderBy'] }
        : { orderBy?: satisfactionSurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, satisfactionSurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSatisfactionSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the satisfactionSurvey model
   */
  readonly fields: satisfactionSurveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for satisfactionSurvey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__satisfactionSurveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyResponse<T extends satisfactionSurvey$surveyResponseArgs<ExtArgs> = {}>(args?: Subset<T, satisfactionSurvey$surveyResponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the satisfactionSurvey model
   */
  interface satisfactionSurveyFieldRefs {
    readonly id: FieldRef<"satisfactionSurvey", 'String'>
    readonly title: FieldRef<"satisfactionSurvey", 'String'>
    readonly description: FieldRef<"satisfactionSurvey", 'String'>
    readonly startDate: FieldRef<"satisfactionSurvey", 'DateTime'>
    readonly endDate: FieldRef<"satisfactionSurvey", 'DateTime'>
    readonly active: FieldRef<"satisfactionSurvey", 'Boolean'>
    readonly createdAt: FieldRef<"satisfactionSurvey", 'DateTime'>
    readonly updatedAt: FieldRef<"satisfactionSurvey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * satisfactionSurvey findUnique
   */
  export type satisfactionSurveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * Filter, which satisfactionSurvey to fetch.
     */
    where: satisfactionSurveyWhereUniqueInput
  }

  /**
   * satisfactionSurvey findUniqueOrThrow
   */
  export type satisfactionSurveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * Filter, which satisfactionSurvey to fetch.
     */
    where: satisfactionSurveyWhereUniqueInput
  }

  /**
   * satisfactionSurvey findFirst
   */
  export type satisfactionSurveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * Filter, which satisfactionSurvey to fetch.
     */
    where?: satisfactionSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of satisfactionSurveys to fetch.
     */
    orderBy?: satisfactionSurveyOrderByWithRelationInput | satisfactionSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for satisfactionSurveys.
     */
    cursor?: satisfactionSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` satisfactionSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` satisfactionSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of satisfactionSurveys.
     */
    distinct?: SatisfactionSurveyScalarFieldEnum | SatisfactionSurveyScalarFieldEnum[]
  }

  /**
   * satisfactionSurvey findFirstOrThrow
   */
  export type satisfactionSurveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * Filter, which satisfactionSurvey to fetch.
     */
    where?: satisfactionSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of satisfactionSurveys to fetch.
     */
    orderBy?: satisfactionSurveyOrderByWithRelationInput | satisfactionSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for satisfactionSurveys.
     */
    cursor?: satisfactionSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` satisfactionSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` satisfactionSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of satisfactionSurveys.
     */
    distinct?: SatisfactionSurveyScalarFieldEnum | SatisfactionSurveyScalarFieldEnum[]
  }

  /**
   * satisfactionSurvey findMany
   */
  export type satisfactionSurveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * Filter, which satisfactionSurveys to fetch.
     */
    where?: satisfactionSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of satisfactionSurveys to fetch.
     */
    orderBy?: satisfactionSurveyOrderByWithRelationInput | satisfactionSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing satisfactionSurveys.
     */
    cursor?: satisfactionSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` satisfactionSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` satisfactionSurveys.
     */
    skip?: number
    distinct?: SatisfactionSurveyScalarFieldEnum | SatisfactionSurveyScalarFieldEnum[]
  }

  /**
   * satisfactionSurvey create
   */
  export type satisfactionSurveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * The data needed to create a satisfactionSurvey.
     */
    data: XOR<satisfactionSurveyCreateInput, satisfactionSurveyUncheckedCreateInput>
  }

  /**
   * satisfactionSurvey createMany
   */
  export type satisfactionSurveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many satisfactionSurveys.
     */
    data: satisfactionSurveyCreateManyInput | satisfactionSurveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * satisfactionSurvey createManyAndReturn
   */
  export type satisfactionSurveyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * The data used to create many satisfactionSurveys.
     */
    data: satisfactionSurveyCreateManyInput | satisfactionSurveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * satisfactionSurvey update
   */
  export type satisfactionSurveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * The data needed to update a satisfactionSurvey.
     */
    data: XOR<satisfactionSurveyUpdateInput, satisfactionSurveyUncheckedUpdateInput>
    /**
     * Choose, which satisfactionSurvey to update.
     */
    where: satisfactionSurveyWhereUniqueInput
  }

  /**
   * satisfactionSurvey updateMany
   */
  export type satisfactionSurveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update satisfactionSurveys.
     */
    data: XOR<satisfactionSurveyUpdateManyMutationInput, satisfactionSurveyUncheckedUpdateManyInput>
    /**
     * Filter which satisfactionSurveys to update
     */
    where?: satisfactionSurveyWhereInput
    /**
     * Limit how many satisfactionSurveys to update.
     */
    limit?: number
  }

  /**
   * satisfactionSurvey updateManyAndReturn
   */
  export type satisfactionSurveyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * The data used to update satisfactionSurveys.
     */
    data: XOR<satisfactionSurveyUpdateManyMutationInput, satisfactionSurveyUncheckedUpdateManyInput>
    /**
     * Filter which satisfactionSurveys to update
     */
    where?: satisfactionSurveyWhereInput
    /**
     * Limit how many satisfactionSurveys to update.
     */
    limit?: number
  }

  /**
   * satisfactionSurvey upsert
   */
  export type satisfactionSurveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * The filter to search for the satisfactionSurvey to update in case it exists.
     */
    where: satisfactionSurveyWhereUniqueInput
    /**
     * In case the satisfactionSurvey found by the `where` argument doesn't exist, create a new satisfactionSurvey with this data.
     */
    create: XOR<satisfactionSurveyCreateInput, satisfactionSurveyUncheckedCreateInput>
    /**
     * In case the satisfactionSurvey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<satisfactionSurveyUpdateInput, satisfactionSurveyUncheckedUpdateInput>
  }

  /**
   * satisfactionSurvey delete
   */
  export type satisfactionSurveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
    /**
     * Filter which satisfactionSurvey to delete.
     */
    where: satisfactionSurveyWhereUniqueInput
  }

  /**
   * satisfactionSurvey deleteMany
   */
  export type satisfactionSurveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which satisfactionSurveys to delete
     */
    where?: satisfactionSurveyWhereInput
    /**
     * Limit how many satisfactionSurveys to delete.
     */
    limit?: number
  }

  /**
   * satisfactionSurvey.surveyResponse
   */
  export type satisfactionSurvey$surveyResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    where?: surveyResponseWhereInput
    orderBy?: surveyResponseOrderByWithRelationInput | surveyResponseOrderByWithRelationInput[]
    cursor?: surveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * satisfactionSurvey without action
   */
  export type satisfactionSurveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the satisfactionSurvey
     */
    select?: satisfactionSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the satisfactionSurvey
     */
    omit?: satisfactionSurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: satisfactionSurveyInclude<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    refreshToken: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    refreshToken: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    refreshToken: number
    userId: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    userAgent: number
    ipAddress: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    refreshToken: string
    userId: string
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    userAgent: string | null
    ipAddress: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectScalar = {
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "refreshToken" | "userId" | "createdAt" | "updatedAt" | "expiresAt" | "userAgent" | "ipAddress", ExtArgs["result"]["session"]>
  export type sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type sessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type sessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      refreshToken: string
      userId: string
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
      userAgent: string | null
      ipAddress: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>
    readonly refreshToken: FieldRef<"session", 'String'>
    readonly userId: FieldRef<"session", 'String'>
    readonly createdAt: FieldRef<"session", 'DateTime'>
    readonly updatedAt: FieldRef<"session", 'DateTime'>
    readonly expiresAt: FieldRef<"session", 'DateTime'>
    readonly userAgent: FieldRef<"session", 'String'>
    readonly ipAddress: FieldRef<"session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session createManyAndReturn
   */
  export type sessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session updateManyAndReturn
   */
  export type sessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
  }


  /**
   * Model serviceCompleted
   */

  export type AggregateServiceCompleted = {
    _count: ServiceCompletedCountAggregateOutputType | null
    _avg: ServiceCompletedAvgAggregateOutputType | null
    _sum: ServiceCompletedSumAggregateOutputType | null
    _min: ServiceCompletedMinAggregateOutputType | null
    _max: ServiceCompletedMaxAggregateOutputType | null
  }

  export type ServiceCompletedAvgAggregateOutputType = {
    actualDuration: number | null
    creatorRating: number | null
    helperRating: number | null
    pointsExchanged: number | null
  }

  export type ServiceCompletedSumAggregateOutputType = {
    actualDuration: number | null
    creatorRating: number | null
    helperRating: number | null
    pointsExchanged: number | null
  }

  export type ServiceCompletedMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    helperId: string | null
    completionDate: Date | null
    actualDuration: number | null
    creatorComment: string | null
    helperComment: string | null
    creatorRating: number | null
    helperRating: number | null
    pointsExchanged: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCompletedMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    helperId: string | null
    completionDate: Date | null
    actualDuration: number | null
    creatorComment: string | null
    helperComment: string | null
    creatorRating: number | null
    helperRating: number | null
    pointsExchanged: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCompletedCountAggregateOutputType = {
    id: number
    requestId: number
    helperId: number
    completionDate: number
    actualDuration: number
    creatorComment: number
    helperComment: number
    creatorRating: number
    helperRating: number
    pointsExchanged: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCompletedAvgAggregateInputType = {
    actualDuration?: true
    creatorRating?: true
    helperRating?: true
    pointsExchanged?: true
  }

  export type ServiceCompletedSumAggregateInputType = {
    actualDuration?: true
    creatorRating?: true
    helperRating?: true
    pointsExchanged?: true
  }

  export type ServiceCompletedMinAggregateInputType = {
    id?: true
    requestId?: true
    helperId?: true
    completionDate?: true
    actualDuration?: true
    creatorComment?: true
    helperComment?: true
    creatorRating?: true
    helperRating?: true
    pointsExchanged?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCompletedMaxAggregateInputType = {
    id?: true
    requestId?: true
    helperId?: true
    completionDate?: true
    actualDuration?: true
    creatorComment?: true
    helperComment?: true
    creatorRating?: true
    helperRating?: true
    pointsExchanged?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCompletedCountAggregateInputType = {
    id?: true
    requestId?: true
    helperId?: true
    completionDate?: true
    actualDuration?: true
    creatorComment?: true
    helperComment?: true
    creatorRating?: true
    helperRating?: true
    pointsExchanged?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCompletedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceCompleted to aggregate.
     */
    where?: serviceCompletedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCompleteds to fetch.
     */
    orderBy?: serviceCompletedOrderByWithRelationInput | serviceCompletedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceCompletedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCompleteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCompleteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceCompleteds
    **/
    _count?: true | ServiceCompletedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceCompletedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceCompletedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCompletedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCompletedMaxAggregateInputType
  }

  export type GetServiceCompletedAggregateType<T extends ServiceCompletedAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCompleted]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCompleted[P]>
      : GetScalarType<T[P], AggregateServiceCompleted[P]>
  }




  export type serviceCompletedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceCompletedWhereInput
    orderBy?: serviceCompletedOrderByWithAggregationInput | serviceCompletedOrderByWithAggregationInput[]
    by: ServiceCompletedScalarFieldEnum[] | ServiceCompletedScalarFieldEnum
    having?: serviceCompletedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCompletedCountAggregateInputType | true
    _avg?: ServiceCompletedAvgAggregateInputType
    _sum?: ServiceCompletedSumAggregateInputType
    _min?: ServiceCompletedMinAggregateInputType
    _max?: ServiceCompletedMaxAggregateInputType
  }

  export type ServiceCompletedGroupByOutputType = {
    id: string
    requestId: string
    helperId: string
    completionDate: Date
    actualDuration: number | null
    creatorComment: string | null
    helperComment: string | null
    creatorRating: number | null
    helperRating: number | null
    pointsExchanged: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: ServiceCompletedCountAggregateOutputType | null
    _avg: ServiceCompletedAvgAggregateOutputType | null
    _sum: ServiceCompletedSumAggregateOutputType | null
    _min: ServiceCompletedMinAggregateOutputType | null
    _max: ServiceCompletedMaxAggregateOutputType | null
  }

  type GetServiceCompletedGroupByPayload<T extends serviceCompletedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCompletedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCompletedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCompletedGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCompletedGroupByOutputType[P]>
        }
      >
    >


  export type serviceCompletedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    completionDate?: boolean
    actualDuration?: boolean
    creatorComment?: boolean
    helperComment?: boolean
    creatorRating?: boolean
    helperRating?: boolean
    pointsExchanged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCompleted"]>

  export type serviceCompletedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    completionDate?: boolean
    actualDuration?: boolean
    creatorComment?: boolean
    helperComment?: boolean
    creatorRating?: boolean
    helperRating?: boolean
    pointsExchanged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCompleted"]>

  export type serviceCompletedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    completionDate?: boolean
    actualDuration?: boolean
    creatorComment?: boolean
    helperComment?: boolean
    creatorRating?: boolean
    helperRating?: boolean
    pointsExchanged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCompleted"]>

  export type serviceCompletedSelectScalar = {
    id?: boolean
    requestId?: boolean
    helperId?: boolean
    completionDate?: boolean
    actualDuration?: boolean
    creatorComment?: boolean
    helperComment?: boolean
    creatorRating?: boolean
    helperRating?: boolean
    pointsExchanged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type serviceCompletedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "helperId" | "completionDate" | "actualDuration" | "creatorComment" | "helperComment" | "creatorRating" | "helperRating" | "pointsExchanged" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceCompleted"]>
  export type serviceCompletedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }
  export type serviceCompletedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }
  export type serviceCompletedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    helpRequest?: boolean | helpRequestDefaultArgs<ExtArgs>
  }

  export type $serviceCompletedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serviceCompleted"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      helpRequest: Prisma.$helpRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      helperId: string
      completionDate: Date
      actualDuration: number | null
      creatorComment: string | null
      helperComment: string | null
      creatorRating: number | null
      helperRating: number | null
      pointsExchanged: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["serviceCompleted"]>
    composites: {}
  }

  type serviceCompletedGetPayload<S extends boolean | null | undefined | serviceCompletedDefaultArgs> = $Result.GetResult<Prisma.$serviceCompletedPayload, S>

  type serviceCompletedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<serviceCompletedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCompletedCountAggregateInputType | true
    }

  export interface serviceCompletedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceCompleted'], meta: { name: 'serviceCompleted' } }
    /**
     * Find zero or one ServiceCompleted that matches the filter.
     * @param {serviceCompletedFindUniqueArgs} args - Arguments to find a ServiceCompleted
     * @example
     * // Get one ServiceCompleted
     * const serviceCompleted = await prisma.serviceCompleted.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceCompletedFindUniqueArgs>(args: SelectSubset<T, serviceCompletedFindUniqueArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCompleted that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {serviceCompletedFindUniqueOrThrowArgs} args - Arguments to find a ServiceCompleted
     * @example
     * // Get one ServiceCompleted
     * const serviceCompleted = await prisma.serviceCompleted.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceCompletedFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceCompletedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCompleted that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCompletedFindFirstArgs} args - Arguments to find a ServiceCompleted
     * @example
     * // Get one ServiceCompleted
     * const serviceCompleted = await prisma.serviceCompleted.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceCompletedFindFirstArgs>(args?: SelectSubset<T, serviceCompletedFindFirstArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCompleted that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCompletedFindFirstOrThrowArgs} args - Arguments to find a ServiceCompleted
     * @example
     * // Get one ServiceCompleted
     * const serviceCompleted = await prisma.serviceCompleted.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceCompletedFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceCompletedFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCompleteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCompletedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCompleteds
     * const serviceCompleteds = await prisma.serviceCompleted.findMany()
     * 
     * // Get first 10 ServiceCompleteds
     * const serviceCompleteds = await prisma.serviceCompleted.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCompletedWithIdOnly = await prisma.serviceCompleted.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serviceCompletedFindManyArgs>(args?: SelectSubset<T, serviceCompletedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCompleted.
     * @param {serviceCompletedCreateArgs} args - Arguments to create a ServiceCompleted.
     * @example
     * // Create one ServiceCompleted
     * const ServiceCompleted = await prisma.serviceCompleted.create({
     *   data: {
     *     // ... data to create a ServiceCompleted
     *   }
     * })
     * 
     */
    create<T extends serviceCompletedCreateArgs>(args: SelectSubset<T, serviceCompletedCreateArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCompleteds.
     * @param {serviceCompletedCreateManyArgs} args - Arguments to create many ServiceCompleteds.
     * @example
     * // Create many ServiceCompleteds
     * const serviceCompleted = await prisma.serviceCompleted.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceCompletedCreateManyArgs>(args?: SelectSubset<T, serviceCompletedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCompleteds and returns the data saved in the database.
     * @param {serviceCompletedCreateManyAndReturnArgs} args - Arguments to create many ServiceCompleteds.
     * @example
     * // Create many ServiceCompleteds
     * const serviceCompleted = await prisma.serviceCompleted.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCompleteds and only return the `id`
     * const serviceCompletedWithIdOnly = await prisma.serviceCompleted.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends serviceCompletedCreateManyAndReturnArgs>(args?: SelectSubset<T, serviceCompletedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCompleted.
     * @param {serviceCompletedDeleteArgs} args - Arguments to delete one ServiceCompleted.
     * @example
     * // Delete one ServiceCompleted
     * const ServiceCompleted = await prisma.serviceCompleted.delete({
     *   where: {
     *     // ... filter to delete one ServiceCompleted
     *   }
     * })
     * 
     */
    delete<T extends serviceCompletedDeleteArgs>(args: SelectSubset<T, serviceCompletedDeleteArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCompleted.
     * @param {serviceCompletedUpdateArgs} args - Arguments to update one ServiceCompleted.
     * @example
     * // Update one ServiceCompleted
     * const serviceCompleted = await prisma.serviceCompleted.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceCompletedUpdateArgs>(args: SelectSubset<T, serviceCompletedUpdateArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCompleteds.
     * @param {serviceCompletedDeleteManyArgs} args - Arguments to filter ServiceCompleteds to delete.
     * @example
     * // Delete a few ServiceCompleteds
     * const { count } = await prisma.serviceCompleted.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceCompletedDeleteManyArgs>(args?: SelectSubset<T, serviceCompletedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCompleteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCompletedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCompleteds
     * const serviceCompleted = await prisma.serviceCompleted.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceCompletedUpdateManyArgs>(args: SelectSubset<T, serviceCompletedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCompleteds and returns the data updated in the database.
     * @param {serviceCompletedUpdateManyAndReturnArgs} args - Arguments to update many ServiceCompleteds.
     * @example
     * // Update many ServiceCompleteds
     * const serviceCompleted = await prisma.serviceCompleted.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCompleteds and only return the `id`
     * const serviceCompletedWithIdOnly = await prisma.serviceCompleted.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends serviceCompletedUpdateManyAndReturnArgs>(args: SelectSubset<T, serviceCompletedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCompleted.
     * @param {serviceCompletedUpsertArgs} args - Arguments to update or create a ServiceCompleted.
     * @example
     * // Update or create a ServiceCompleted
     * const serviceCompleted = await prisma.serviceCompleted.upsert({
     *   create: {
     *     // ... data to create a ServiceCompleted
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCompleted we want to update
     *   }
     * })
     */
    upsert<T extends serviceCompletedUpsertArgs>(args: SelectSubset<T, serviceCompletedUpsertArgs<ExtArgs>>): Prisma__serviceCompletedClient<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCompleteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCompletedCountArgs} args - Arguments to filter ServiceCompleteds to count.
     * @example
     * // Count the number of ServiceCompleteds
     * const count = await prisma.serviceCompleted.count({
     *   where: {
     *     // ... the filter for the ServiceCompleteds we want to count
     *   }
     * })
    **/
    count<T extends serviceCompletedCountArgs>(
      args?: Subset<T, serviceCompletedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCompletedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCompleted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCompletedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCompletedAggregateArgs>(args: Subset<T, ServiceCompletedAggregateArgs>): Prisma.PrismaPromise<GetServiceCompletedAggregateType<T>>

    /**
     * Group by ServiceCompleted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCompletedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceCompletedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceCompletedGroupByArgs['orderBy'] }
        : { orderBy?: serviceCompletedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceCompletedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCompletedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serviceCompleted model
   */
  readonly fields: serviceCompletedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceCompleted.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceCompletedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    helpRequest<T extends helpRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, helpRequestDefaultArgs<ExtArgs>>): Prisma__helpRequestClient<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serviceCompleted model
   */
  interface serviceCompletedFieldRefs {
    readonly id: FieldRef<"serviceCompleted", 'String'>
    readonly requestId: FieldRef<"serviceCompleted", 'String'>
    readonly helperId: FieldRef<"serviceCompleted", 'String'>
    readonly completionDate: FieldRef<"serviceCompleted", 'DateTime'>
    readonly actualDuration: FieldRef<"serviceCompleted", 'Int'>
    readonly creatorComment: FieldRef<"serviceCompleted", 'String'>
    readonly helperComment: FieldRef<"serviceCompleted", 'String'>
    readonly creatorRating: FieldRef<"serviceCompleted", 'Int'>
    readonly helperRating: FieldRef<"serviceCompleted", 'Int'>
    readonly pointsExchanged: FieldRef<"serviceCompleted", 'Int'>
    readonly createdAt: FieldRef<"serviceCompleted", 'DateTime'>
    readonly updatedAt: FieldRef<"serviceCompleted", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * serviceCompleted findUnique
   */
  export type serviceCompletedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * Filter, which serviceCompleted to fetch.
     */
    where: serviceCompletedWhereUniqueInput
  }

  /**
   * serviceCompleted findUniqueOrThrow
   */
  export type serviceCompletedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * Filter, which serviceCompleted to fetch.
     */
    where: serviceCompletedWhereUniqueInput
  }

  /**
   * serviceCompleted findFirst
   */
  export type serviceCompletedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * Filter, which serviceCompleted to fetch.
     */
    where?: serviceCompletedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCompleteds to fetch.
     */
    orderBy?: serviceCompletedOrderByWithRelationInput | serviceCompletedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceCompleteds.
     */
    cursor?: serviceCompletedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCompleteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCompleteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceCompleteds.
     */
    distinct?: ServiceCompletedScalarFieldEnum | ServiceCompletedScalarFieldEnum[]
  }

  /**
   * serviceCompleted findFirstOrThrow
   */
  export type serviceCompletedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * Filter, which serviceCompleted to fetch.
     */
    where?: serviceCompletedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCompleteds to fetch.
     */
    orderBy?: serviceCompletedOrderByWithRelationInput | serviceCompletedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceCompleteds.
     */
    cursor?: serviceCompletedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCompleteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCompleteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceCompleteds.
     */
    distinct?: ServiceCompletedScalarFieldEnum | ServiceCompletedScalarFieldEnum[]
  }

  /**
   * serviceCompleted findMany
   */
  export type serviceCompletedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * Filter, which serviceCompleteds to fetch.
     */
    where?: serviceCompletedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCompleteds to fetch.
     */
    orderBy?: serviceCompletedOrderByWithRelationInput | serviceCompletedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceCompleteds.
     */
    cursor?: serviceCompletedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCompleteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCompleteds.
     */
    skip?: number
    distinct?: ServiceCompletedScalarFieldEnum | ServiceCompletedScalarFieldEnum[]
  }

  /**
   * serviceCompleted create
   */
  export type serviceCompletedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * The data needed to create a serviceCompleted.
     */
    data: XOR<serviceCompletedCreateInput, serviceCompletedUncheckedCreateInput>
  }

  /**
   * serviceCompleted createMany
   */
  export type serviceCompletedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceCompleteds.
     */
    data: serviceCompletedCreateManyInput | serviceCompletedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceCompleted createManyAndReturn
   */
  export type serviceCompletedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * The data used to create many serviceCompleteds.
     */
    data: serviceCompletedCreateManyInput | serviceCompletedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * serviceCompleted update
   */
  export type serviceCompletedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * The data needed to update a serviceCompleted.
     */
    data: XOR<serviceCompletedUpdateInput, serviceCompletedUncheckedUpdateInput>
    /**
     * Choose, which serviceCompleted to update.
     */
    where: serviceCompletedWhereUniqueInput
  }

  /**
   * serviceCompleted updateMany
   */
  export type serviceCompletedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceCompleteds.
     */
    data: XOR<serviceCompletedUpdateManyMutationInput, serviceCompletedUncheckedUpdateManyInput>
    /**
     * Filter which serviceCompleteds to update
     */
    where?: serviceCompletedWhereInput
    /**
     * Limit how many serviceCompleteds to update.
     */
    limit?: number
  }

  /**
   * serviceCompleted updateManyAndReturn
   */
  export type serviceCompletedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * The data used to update serviceCompleteds.
     */
    data: XOR<serviceCompletedUpdateManyMutationInput, serviceCompletedUncheckedUpdateManyInput>
    /**
     * Filter which serviceCompleteds to update
     */
    where?: serviceCompletedWhereInput
    /**
     * Limit how many serviceCompleteds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * serviceCompleted upsert
   */
  export type serviceCompletedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * The filter to search for the serviceCompleted to update in case it exists.
     */
    where: serviceCompletedWhereUniqueInput
    /**
     * In case the serviceCompleted found by the `where` argument doesn't exist, create a new serviceCompleted with this data.
     */
    create: XOR<serviceCompletedCreateInput, serviceCompletedUncheckedCreateInput>
    /**
     * In case the serviceCompleted was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceCompletedUpdateInput, serviceCompletedUncheckedUpdateInput>
  }

  /**
   * serviceCompleted delete
   */
  export type serviceCompletedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    /**
     * Filter which serviceCompleted to delete.
     */
    where: serviceCompletedWhereUniqueInput
  }

  /**
   * serviceCompleted deleteMany
   */
  export type serviceCompletedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceCompleteds to delete
     */
    where?: serviceCompletedWhereInput
    /**
     * Limit how many serviceCompleteds to delete.
     */
    limit?: number
  }

  /**
   * serviceCompleted without action
   */
  export type serviceCompletedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
  }


  /**
   * Model serviceRating
   */

  export type AggregateServiceRating = {
    _count: ServiceRatingCountAggregateOutputType | null
    _avg: ServiceRatingAvgAggregateOutputType | null
    _sum: ServiceRatingSumAggregateOutputType | null
    _min: ServiceRatingMinAggregateOutputType | null
    _max: ServiceRatingMaxAggregateOutputType | null
  }

  export type ServiceRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type ServiceRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type ServiceRatingMinAggregateOutputType = {
    serviceId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    ratingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRatingMaxAggregateOutputType = {
    serviceId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    ratingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRatingCountAggregateOutputType = {
    serviceId: number
    userId: number
    rating: number
    comment: number
    ratingDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceRatingAvgAggregateInputType = {
    rating?: true
  }

  export type ServiceRatingSumAggregateInputType = {
    rating?: true
  }

  export type ServiceRatingMinAggregateInputType = {
    serviceId?: true
    userId?: true
    rating?: true
    comment?: true
    ratingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRatingMaxAggregateInputType = {
    serviceId?: true
    userId?: true
    rating?: true
    comment?: true
    ratingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRatingCountAggregateInputType = {
    serviceId?: true
    userId?: true
    rating?: true
    comment?: true
    ratingDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceRating to aggregate.
     */
    where?: serviceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceRatings to fetch.
     */
    orderBy?: serviceRatingOrderByWithRelationInput | serviceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceRatings
    **/
    _count?: true | ServiceRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRatingMaxAggregateInputType
  }

  export type GetServiceRatingAggregateType<T extends ServiceRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRating[P]>
      : GetScalarType<T[P], AggregateServiceRating[P]>
  }




  export type serviceRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceRatingWhereInput
    orderBy?: serviceRatingOrderByWithAggregationInput | serviceRatingOrderByWithAggregationInput[]
    by: ServiceRatingScalarFieldEnum[] | ServiceRatingScalarFieldEnum
    having?: serviceRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRatingCountAggregateInputType | true
    _avg?: ServiceRatingAvgAggregateInputType
    _sum?: ServiceRatingSumAggregateInputType
    _min?: ServiceRatingMinAggregateInputType
    _max?: ServiceRatingMaxAggregateInputType
  }

  export type ServiceRatingGroupByOutputType = {
    serviceId: string
    userId: string
    rating: number | null
    comment: string | null
    ratingDate: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: ServiceRatingCountAggregateOutputType | null
    _avg: ServiceRatingAvgAggregateOutputType | null
    _sum: ServiceRatingSumAggregateOutputType | null
    _min: ServiceRatingMinAggregateOutputType | null
    _max: ServiceRatingMaxAggregateOutputType | null
  }

  type GetServiceRatingGroupByPayload<T extends serviceRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRatingGroupByOutputType[P]>
        }
      >
    >


  export type serviceRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    localService?: boolean | localServiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRating"]>

  export type serviceRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    localService?: boolean | localServiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRating"]>

  export type serviceRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    localService?: boolean | localServiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRating"]>

  export type serviceRatingSelectScalar = {
    serviceId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type serviceRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"serviceId" | "userId" | "rating" | "comment" | "ratingDate" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceRating"]>
  export type serviceRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localService?: boolean | localServiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type serviceRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localService?: boolean | localServiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type serviceRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localService?: boolean | localServiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $serviceRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serviceRating"
    objects: {
      localService: Prisma.$localServicePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      serviceId: string
      userId: string
      rating: number | null
      comment: string | null
      ratingDate: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["serviceRating"]>
    composites: {}
  }

  type serviceRatingGetPayload<S extends boolean | null | undefined | serviceRatingDefaultArgs> = $Result.GetResult<Prisma.$serviceRatingPayload, S>

  type serviceRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<serviceRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceRatingCountAggregateInputType | true
    }

  export interface serviceRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceRating'], meta: { name: 'serviceRating' } }
    /**
     * Find zero or one ServiceRating that matches the filter.
     * @param {serviceRatingFindUniqueArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceRatingFindUniqueArgs>(args: SelectSubset<T, serviceRatingFindUniqueArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {serviceRatingFindUniqueOrThrowArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceRatingFindFirstArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceRatingFindFirstArgs>(args?: SelectSubset<T, serviceRatingFindFirstArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceRatingFindFirstOrThrowArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRatings
     * const serviceRatings = await prisma.serviceRating.findMany()
     * 
     * // Get first 10 ServiceRatings
     * const serviceRatings = await prisma.serviceRating.findMany({ take: 10 })
     * 
     * // Only select the `serviceId`
     * const serviceRatingWithServiceIdOnly = await prisma.serviceRating.findMany({ select: { serviceId: true } })
     * 
     */
    findMany<T extends serviceRatingFindManyArgs>(args?: SelectSubset<T, serviceRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceRating.
     * @param {serviceRatingCreateArgs} args - Arguments to create a ServiceRating.
     * @example
     * // Create one ServiceRating
     * const ServiceRating = await prisma.serviceRating.create({
     *   data: {
     *     // ... data to create a ServiceRating
     *   }
     * })
     * 
     */
    create<T extends serviceRatingCreateArgs>(args: SelectSubset<T, serviceRatingCreateArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceRatings.
     * @param {serviceRatingCreateManyArgs} args - Arguments to create many ServiceRatings.
     * @example
     * // Create many ServiceRatings
     * const serviceRating = await prisma.serviceRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceRatingCreateManyArgs>(args?: SelectSubset<T, serviceRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceRatings and returns the data saved in the database.
     * @param {serviceRatingCreateManyAndReturnArgs} args - Arguments to create many ServiceRatings.
     * @example
     * // Create many ServiceRatings
     * const serviceRating = await prisma.serviceRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceRatings and only return the `serviceId`
     * const serviceRatingWithServiceIdOnly = await prisma.serviceRating.createManyAndReturn({
     *   select: { serviceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends serviceRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, serviceRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceRating.
     * @param {serviceRatingDeleteArgs} args - Arguments to delete one ServiceRating.
     * @example
     * // Delete one ServiceRating
     * const ServiceRating = await prisma.serviceRating.delete({
     *   where: {
     *     // ... filter to delete one ServiceRating
     *   }
     * })
     * 
     */
    delete<T extends serviceRatingDeleteArgs>(args: SelectSubset<T, serviceRatingDeleteArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceRating.
     * @param {serviceRatingUpdateArgs} args - Arguments to update one ServiceRating.
     * @example
     * // Update one ServiceRating
     * const serviceRating = await prisma.serviceRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceRatingUpdateArgs>(args: SelectSubset<T, serviceRatingUpdateArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceRatings.
     * @param {serviceRatingDeleteManyArgs} args - Arguments to filter ServiceRatings to delete.
     * @example
     * // Delete a few ServiceRatings
     * const { count } = await prisma.serviceRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceRatingDeleteManyArgs>(args?: SelectSubset<T, serviceRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRatings
     * const serviceRating = await prisma.serviceRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceRatingUpdateManyArgs>(args: SelectSubset<T, serviceRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRatings and returns the data updated in the database.
     * @param {serviceRatingUpdateManyAndReturnArgs} args - Arguments to update many ServiceRatings.
     * @example
     * // Update many ServiceRatings
     * const serviceRating = await prisma.serviceRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceRatings and only return the `serviceId`
     * const serviceRatingWithServiceIdOnly = await prisma.serviceRating.updateManyAndReturn({
     *   select: { serviceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends serviceRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, serviceRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceRating.
     * @param {serviceRatingUpsertArgs} args - Arguments to update or create a ServiceRating.
     * @example
     * // Update or create a ServiceRating
     * const serviceRating = await prisma.serviceRating.upsert({
     *   create: {
     *     // ... data to create a ServiceRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRating we want to update
     *   }
     * })
     */
    upsert<T extends serviceRatingUpsertArgs>(args: SelectSubset<T, serviceRatingUpsertArgs<ExtArgs>>): Prisma__serviceRatingClient<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceRatingCountArgs} args - Arguments to filter ServiceRatings to count.
     * @example
     * // Count the number of ServiceRatings
     * const count = await prisma.serviceRating.count({
     *   where: {
     *     // ... the filter for the ServiceRatings we want to count
     *   }
     * })
    **/
    count<T extends serviceRatingCountArgs>(
      args?: Subset<T, serviceRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRatingAggregateArgs>(args: Subset<T, ServiceRatingAggregateArgs>): Prisma.PrismaPromise<GetServiceRatingAggregateType<T>>

    /**
     * Group by ServiceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceRatingGroupByArgs['orderBy'] }
        : { orderBy?: serviceRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serviceRating model
   */
  readonly fields: serviceRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    localService<T extends localServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, localServiceDefaultArgs<ExtArgs>>): Prisma__localServiceClient<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serviceRating model
   */
  interface serviceRatingFieldRefs {
    readonly serviceId: FieldRef<"serviceRating", 'String'>
    readonly userId: FieldRef<"serviceRating", 'String'>
    readonly rating: FieldRef<"serviceRating", 'Int'>
    readonly comment: FieldRef<"serviceRating", 'String'>
    readonly ratingDate: FieldRef<"serviceRating", 'DateTime'>
    readonly createdAt: FieldRef<"serviceRating", 'DateTime'>
    readonly updatedAt: FieldRef<"serviceRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * serviceRating findUnique
   */
  export type serviceRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * Filter, which serviceRating to fetch.
     */
    where: serviceRatingWhereUniqueInput
  }

  /**
   * serviceRating findUniqueOrThrow
   */
  export type serviceRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * Filter, which serviceRating to fetch.
     */
    where: serviceRatingWhereUniqueInput
  }

  /**
   * serviceRating findFirst
   */
  export type serviceRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * Filter, which serviceRating to fetch.
     */
    where?: serviceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceRatings to fetch.
     */
    orderBy?: serviceRatingOrderByWithRelationInput | serviceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceRatings.
     */
    cursor?: serviceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceRatings.
     */
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * serviceRating findFirstOrThrow
   */
  export type serviceRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * Filter, which serviceRating to fetch.
     */
    where?: serviceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceRatings to fetch.
     */
    orderBy?: serviceRatingOrderByWithRelationInput | serviceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceRatings.
     */
    cursor?: serviceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceRatings.
     */
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * serviceRating findMany
   */
  export type serviceRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * Filter, which serviceRatings to fetch.
     */
    where?: serviceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceRatings to fetch.
     */
    orderBy?: serviceRatingOrderByWithRelationInput | serviceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceRatings.
     */
    cursor?: serviceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceRatings.
     */
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * serviceRating create
   */
  export type serviceRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a serviceRating.
     */
    data: XOR<serviceRatingCreateInput, serviceRatingUncheckedCreateInput>
  }

  /**
   * serviceRating createMany
   */
  export type serviceRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceRatings.
     */
    data: serviceRatingCreateManyInput | serviceRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceRating createManyAndReturn
   */
  export type serviceRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * The data used to create many serviceRatings.
     */
    data: serviceRatingCreateManyInput | serviceRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * serviceRating update
   */
  export type serviceRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a serviceRating.
     */
    data: XOR<serviceRatingUpdateInput, serviceRatingUncheckedUpdateInput>
    /**
     * Choose, which serviceRating to update.
     */
    where: serviceRatingWhereUniqueInput
  }

  /**
   * serviceRating updateMany
   */
  export type serviceRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceRatings.
     */
    data: XOR<serviceRatingUpdateManyMutationInput, serviceRatingUncheckedUpdateManyInput>
    /**
     * Filter which serviceRatings to update
     */
    where?: serviceRatingWhereInput
    /**
     * Limit how many serviceRatings to update.
     */
    limit?: number
  }

  /**
   * serviceRating updateManyAndReturn
   */
  export type serviceRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * The data used to update serviceRatings.
     */
    data: XOR<serviceRatingUpdateManyMutationInput, serviceRatingUncheckedUpdateManyInput>
    /**
     * Filter which serviceRatings to update
     */
    where?: serviceRatingWhereInput
    /**
     * Limit how many serviceRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * serviceRating upsert
   */
  export type serviceRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the serviceRating to update in case it exists.
     */
    where: serviceRatingWhereUniqueInput
    /**
     * In case the serviceRating found by the `where` argument doesn't exist, create a new serviceRating with this data.
     */
    create: XOR<serviceRatingCreateInput, serviceRatingUncheckedCreateInput>
    /**
     * In case the serviceRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceRatingUpdateInput, serviceRatingUncheckedUpdateInput>
  }

  /**
   * serviceRating delete
   */
  export type serviceRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    /**
     * Filter which serviceRating to delete.
     */
    where: serviceRatingWhereUniqueInput
  }

  /**
   * serviceRating deleteMany
   */
  export type serviceRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceRatings to delete
     */
    where?: serviceRatingWhereInput
    /**
     * Limit how many serviceRatings to delete.
     */
    limit?: number
  }

  /**
   * serviceRating without action
   */
  export type serviceRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
  }


  /**
   * Model skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    description: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skill to aggregate.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillOrderByWithRelationInput | skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type skillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillWhereInput
    orderBy?: skillOrderByWithAggregationInput | skillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: skillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    description: string | null
    categoryId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends skillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type skillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skillCategory?: boolean | skill$skillCategoryArgs<ExtArgs>
    userSkill?: boolean | skill$userSkillArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type skillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skillCategory?: boolean | skill$skillCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type skillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skillCategory?: boolean | skill$skillCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type skillSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type skillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["skill"]>
  export type skillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillCategory?: boolean | skill$skillCategoryArgs<ExtArgs>
    userSkill?: boolean | skill$userSkillArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type skillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillCategory?: boolean | skill$skillCategoryArgs<ExtArgs>
  }
  export type skillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillCategory?: boolean | skill$skillCategoryArgs<ExtArgs>
  }

  export type $skillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skill"
    objects: {
      skillCategory: Prisma.$skillCategoryPayload<ExtArgs> | null
      userSkill: Prisma.$userSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      categoryId: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type skillGetPayload<S extends boolean | null | undefined | skillDefaultArgs> = $Result.GetResult<Prisma.$skillPayload, S>

  type skillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<skillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface skillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skill'], meta: { name: 'skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {skillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skillFindUniqueArgs>(args: SelectSubset<T, skillFindUniqueArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {skillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skillFindUniqueOrThrowArgs>(args: SelectSubset<T, skillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skillFindFirstArgs>(args?: SelectSubset<T, skillFindFirstArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skillFindFirstOrThrowArgs>(args?: SelectSubset<T, skillFindFirstOrThrowArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skillFindManyArgs>(args?: SelectSubset<T, skillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {skillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends skillCreateArgs>(args: SelectSubset<T, skillCreateArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {skillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skillCreateManyArgs>(args?: SelectSubset<T, skillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {skillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends skillCreateManyAndReturnArgs>(args?: SelectSubset<T, skillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {skillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends skillDeleteArgs>(args: SelectSubset<T, skillDeleteArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {skillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skillUpdateArgs>(args: SelectSubset<T, skillUpdateArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {skillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skillDeleteManyArgs>(args?: SelectSubset<T, skillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skillUpdateManyArgs>(args: SelectSubset<T, skillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {skillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends skillUpdateManyAndReturnArgs>(args: SelectSubset<T, skillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {skillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends skillUpsertArgs>(args: SelectSubset<T, skillUpsertArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends skillCountArgs>(
      args?: Subset<T, skillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skillGroupByArgs['orderBy'] }
        : { orderBy?: skillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skill model
   */
  readonly fields: skillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skillCategory<T extends skill$skillCategoryArgs<ExtArgs> = {}>(args?: Subset<T, skill$skillCategoryArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userSkill<T extends skill$userSkillArgs<ExtArgs> = {}>(args?: Subset<T, skill$userSkillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skill model
   */
  interface skillFieldRefs {
    readonly id: FieldRef<"skill", 'String'>
    readonly name: FieldRef<"skill", 'String'>
    readonly description: FieldRef<"skill", 'String'>
    readonly categoryId: FieldRef<"skill", 'String'>
    readonly createdAt: FieldRef<"skill", 'DateTime'>
    readonly updatedAt: FieldRef<"skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * skill findUnique
   */
  export type skillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * Filter, which skill to fetch.
     */
    where: skillWhereUniqueInput
  }

  /**
   * skill findUniqueOrThrow
   */
  export type skillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * Filter, which skill to fetch.
     */
    where: skillWhereUniqueInput
  }

  /**
   * skill findFirst
   */
  export type skillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * Filter, which skill to fetch.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillOrderByWithRelationInput | skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * skill findFirstOrThrow
   */
  export type skillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * Filter, which skill to fetch.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillOrderByWithRelationInput | skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * skill findMany
   */
  export type skillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillOrderByWithRelationInput | skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skills.
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * skill create
   */
  export type skillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * The data needed to create a skill.
     */
    data: XOR<skillCreateInput, skillUncheckedCreateInput>
  }

  /**
   * skill createMany
   */
  export type skillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skills.
     */
    data: skillCreateManyInput | skillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skill createManyAndReturn
   */
  export type skillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * The data used to create many skills.
     */
    data: skillCreateManyInput | skillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * skill update
   */
  export type skillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * The data needed to update a skill.
     */
    data: XOR<skillUpdateInput, skillUncheckedUpdateInput>
    /**
     * Choose, which skill to update.
     */
    where: skillWhereUniqueInput
  }

  /**
   * skill updateMany
   */
  export type skillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skills.
     */
    data: XOR<skillUpdateManyMutationInput, skillUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
  }

  /**
   * skill updateManyAndReturn
   */
  export type skillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * The data used to update skills.
     */
    data: XOR<skillUpdateManyMutationInput, skillUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * skill upsert
   */
  export type skillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * The filter to search for the skill to update in case it exists.
     */
    where: skillWhereUniqueInput
    /**
     * In case the skill found by the `where` argument doesn't exist, create a new skill with this data.
     */
    create: XOR<skillCreateInput, skillUncheckedCreateInput>
    /**
     * In case the skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillUpdateInput, skillUncheckedUpdateInput>
  }

  /**
   * skill delete
   */
  export type skillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    /**
     * Filter which skill to delete.
     */
    where: skillWhereUniqueInput
  }

  /**
   * skill deleteMany
   */
  export type skillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to delete
     */
    where?: skillWhereInput
    /**
     * Limit how many skills to delete.
     */
    limit?: number
  }

  /**
   * skill.skillCategory
   */
  export type skill$skillCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    where?: skillCategoryWhereInput
  }

  /**
   * skill.userSkill
   */
  export type skill$userSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    where?: userSkillWhereInput
    orderBy?: userSkillOrderByWithRelationInput | userSkillOrderByWithRelationInput[]
    cursor?: userSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * skill without action
   */
  export type skillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
  }


  /**
   * Model surveyResponse
   */

  export type AggregateSurveyResponse = {
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  export type SurveyResponseMinAggregateOutputType = {
    surveyId: string | null
    userId: string | null
    response_date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyResponseMaxAggregateOutputType = {
    surveyId: string | null
    userId: string | null
    response_date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyResponseCountAggregateOutputType = {
    surveyId: number
    userId: number
    responses: number
    response_date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyResponseMinAggregateInputType = {
    surveyId?: true
    userId?: true
    response_date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyResponseMaxAggregateInputType = {
    surveyId?: true
    userId?: true
    response_date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyResponseCountAggregateInputType = {
    surveyId?: true
    userId?: true
    responses?: true
    response_date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveyResponse to aggregate.
     */
    where?: surveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyResponses to fetch.
     */
    orderBy?: surveyResponseOrderByWithRelationInput | surveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surveyResponses
    **/
    _count?: true | SurveyResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type GetSurveyResponseAggregateType<T extends SurveyResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyResponse[P]>
      : GetScalarType<T[P], AggregateSurveyResponse[P]>
  }




  export type surveyResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyResponseWhereInput
    orderBy?: surveyResponseOrderByWithAggregationInput | surveyResponseOrderByWithAggregationInput[]
    by: SurveyResponseScalarFieldEnum[] | SurveyResponseScalarFieldEnum
    having?: surveyResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyResponseCountAggregateInputType | true
    _min?: SurveyResponseMinAggregateInputType
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type SurveyResponseGroupByOutputType = {
    surveyId: string
    userId: string
    responses: JsonValue | null
    response_date: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  type GetSurveyResponseGroupByPayload<T extends surveyResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
        }
      >
    >


  export type surveyResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyId?: boolean
    userId?: boolean
    responses?: boolean
    response_date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    satisfactionSurvey?: boolean | satisfactionSurveyDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type surveyResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyId?: boolean
    userId?: boolean
    responses?: boolean
    response_date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    satisfactionSurvey?: boolean | satisfactionSurveyDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type surveyResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyId?: boolean
    userId?: boolean
    responses?: boolean
    response_date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    satisfactionSurvey?: boolean | satisfactionSurveyDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type surveyResponseSelectScalar = {
    surveyId?: boolean
    userId?: boolean
    responses?: boolean
    response_date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type surveyResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"surveyId" | "userId" | "responses" | "response_date" | "createdAt" | "updatedAt", ExtArgs["result"]["surveyResponse"]>
  export type surveyResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    satisfactionSurvey?: boolean | satisfactionSurveyDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type surveyResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    satisfactionSurvey?: boolean | satisfactionSurveyDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type surveyResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    satisfactionSurvey?: boolean | satisfactionSurveyDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $surveyResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "surveyResponse"
    objects: {
      satisfactionSurvey: Prisma.$satisfactionSurveyPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyId: string
      userId: string
      responses: Prisma.JsonValue | null
      response_date: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["surveyResponse"]>
    composites: {}
  }

  type surveyResponseGetPayload<S extends boolean | null | undefined | surveyResponseDefaultArgs> = $Result.GetResult<Prisma.$surveyResponsePayload, S>

  type surveyResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<surveyResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyResponseCountAggregateInputType | true
    }

  export interface surveyResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['surveyResponse'], meta: { name: 'surveyResponse' } }
    /**
     * Find zero or one SurveyResponse that matches the filter.
     * @param {surveyResponseFindUniqueArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends surveyResponseFindUniqueArgs>(args: SelectSubset<T, surveyResponseFindUniqueArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {surveyResponseFindUniqueOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends surveyResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, surveyResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyResponseFindFirstArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends surveyResponseFindFirstArgs>(args?: SelectSubset<T, surveyResponseFindFirstArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyResponseFindFirstOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends surveyResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, surveyResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany()
     * 
     * // Get first 10 SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany({ take: 10 })
     * 
     * // Only select the `surveyId`
     * const surveyResponseWithSurveyIdOnly = await prisma.surveyResponse.findMany({ select: { surveyId: true } })
     * 
     */
    findMany<T extends surveyResponseFindManyArgs>(args?: SelectSubset<T, surveyResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyResponse.
     * @param {surveyResponseCreateArgs} args - Arguments to create a SurveyResponse.
     * @example
     * // Create one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.create({
     *   data: {
     *     // ... data to create a SurveyResponse
     *   }
     * })
     * 
     */
    create<T extends surveyResponseCreateArgs>(args: SelectSubset<T, surveyResponseCreateArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyResponses.
     * @param {surveyResponseCreateManyArgs} args - Arguments to create many SurveyResponses.
     * @example
     * // Create many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends surveyResponseCreateManyArgs>(args?: SelectSubset<T, surveyResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyResponses and returns the data saved in the database.
     * @param {surveyResponseCreateManyAndReturnArgs} args - Arguments to create many SurveyResponses.
     * @example
     * // Create many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyResponses and only return the `surveyId`
     * const surveyResponseWithSurveyIdOnly = await prisma.surveyResponse.createManyAndReturn({
     *   select: { surveyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends surveyResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, surveyResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurveyResponse.
     * @param {surveyResponseDeleteArgs} args - Arguments to delete one SurveyResponse.
     * @example
     * // Delete one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.delete({
     *   where: {
     *     // ... filter to delete one SurveyResponse
     *   }
     * })
     * 
     */
    delete<T extends surveyResponseDeleteArgs>(args: SelectSubset<T, surveyResponseDeleteArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyResponse.
     * @param {surveyResponseUpdateArgs} args - Arguments to update one SurveyResponse.
     * @example
     * // Update one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends surveyResponseUpdateArgs>(args: SelectSubset<T, surveyResponseUpdateArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyResponses.
     * @param {surveyResponseDeleteManyArgs} args - Arguments to filter SurveyResponses to delete.
     * @example
     * // Delete a few SurveyResponses
     * const { count } = await prisma.surveyResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends surveyResponseDeleteManyArgs>(args?: SelectSubset<T, surveyResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends surveyResponseUpdateManyArgs>(args: SelectSubset<T, surveyResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponses and returns the data updated in the database.
     * @param {surveyResponseUpdateManyAndReturnArgs} args - Arguments to update many SurveyResponses.
     * @example
     * // Update many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurveyResponses and only return the `surveyId`
     * const surveyResponseWithSurveyIdOnly = await prisma.surveyResponse.updateManyAndReturn({
     *   select: { surveyId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends surveyResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, surveyResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurveyResponse.
     * @param {surveyResponseUpsertArgs} args - Arguments to update or create a SurveyResponse.
     * @example
     * // Update or create a SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.upsert({
     *   create: {
     *     // ... data to create a SurveyResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyResponse we want to update
     *   }
     * })
     */
    upsert<T extends surveyResponseUpsertArgs>(args: SelectSubset<T, surveyResponseUpsertArgs<ExtArgs>>): Prisma__surveyResponseClient<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyResponseCountArgs} args - Arguments to filter SurveyResponses to count.
     * @example
     * // Count the number of SurveyResponses
     * const count = await prisma.surveyResponse.count({
     *   where: {
     *     // ... the filter for the SurveyResponses we want to count
     *   }
     * })
    **/
    count<T extends surveyResponseCountArgs>(
      args?: Subset<T, surveyResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyResponseAggregateArgs>(args: Subset<T, SurveyResponseAggregateArgs>): Prisma.PrismaPromise<GetSurveyResponseAggregateType<T>>

    /**
     * Group by SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surveyResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surveyResponseGroupByArgs['orderBy'] }
        : { orderBy?: surveyResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surveyResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the surveyResponse model
   */
  readonly fields: surveyResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for surveyResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surveyResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    satisfactionSurvey<T extends satisfactionSurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, satisfactionSurveyDefaultArgs<ExtArgs>>): Prisma__satisfactionSurveyClient<$Result.GetResult<Prisma.$satisfactionSurveyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the surveyResponse model
   */
  interface surveyResponseFieldRefs {
    readonly surveyId: FieldRef<"surveyResponse", 'String'>
    readonly userId: FieldRef<"surveyResponse", 'String'>
    readonly responses: FieldRef<"surveyResponse", 'Json'>
    readonly response_date: FieldRef<"surveyResponse", 'DateTime'>
    readonly createdAt: FieldRef<"surveyResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"surveyResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * surveyResponse findUnique
   */
  export type surveyResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which surveyResponse to fetch.
     */
    where: surveyResponseWhereUniqueInput
  }

  /**
   * surveyResponse findUniqueOrThrow
   */
  export type surveyResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which surveyResponse to fetch.
     */
    where: surveyResponseWhereUniqueInput
  }

  /**
   * surveyResponse findFirst
   */
  export type surveyResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which surveyResponse to fetch.
     */
    where?: surveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyResponses to fetch.
     */
    orderBy?: surveyResponseOrderByWithRelationInput | surveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveyResponses.
     */
    cursor?: surveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * surveyResponse findFirstOrThrow
   */
  export type surveyResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which surveyResponse to fetch.
     */
    where?: surveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyResponses to fetch.
     */
    orderBy?: surveyResponseOrderByWithRelationInput | surveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveyResponses.
     */
    cursor?: surveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * surveyResponse findMany
   */
  export type surveyResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which surveyResponses to fetch.
     */
    where?: surveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyResponses to fetch.
     */
    orderBy?: surveyResponseOrderByWithRelationInput | surveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surveyResponses.
     */
    cursor?: surveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyResponses.
     */
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * surveyResponse create
   */
  export type surveyResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a surveyResponse.
     */
    data: XOR<surveyResponseCreateInput, surveyResponseUncheckedCreateInput>
  }

  /**
   * surveyResponse createMany
   */
  export type surveyResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surveyResponses.
     */
    data: surveyResponseCreateManyInput | surveyResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surveyResponse createManyAndReturn
   */
  export type surveyResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * The data used to create many surveyResponses.
     */
    data: surveyResponseCreateManyInput | surveyResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * surveyResponse update
   */
  export type surveyResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a surveyResponse.
     */
    data: XOR<surveyResponseUpdateInput, surveyResponseUncheckedUpdateInput>
    /**
     * Choose, which surveyResponse to update.
     */
    where: surveyResponseWhereUniqueInput
  }

  /**
   * surveyResponse updateMany
   */
  export type surveyResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surveyResponses.
     */
    data: XOR<surveyResponseUpdateManyMutationInput, surveyResponseUncheckedUpdateManyInput>
    /**
     * Filter which surveyResponses to update
     */
    where?: surveyResponseWhereInput
    /**
     * Limit how many surveyResponses to update.
     */
    limit?: number
  }

  /**
   * surveyResponse updateManyAndReturn
   */
  export type surveyResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * The data used to update surveyResponses.
     */
    data: XOR<surveyResponseUpdateManyMutationInput, surveyResponseUncheckedUpdateManyInput>
    /**
     * Filter which surveyResponses to update
     */
    where?: surveyResponseWhereInput
    /**
     * Limit how many surveyResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * surveyResponse upsert
   */
  export type surveyResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the surveyResponse to update in case it exists.
     */
    where: surveyResponseWhereUniqueInput
    /**
     * In case the surveyResponse found by the `where` argument doesn't exist, create a new surveyResponse with this data.
     */
    create: XOR<surveyResponseCreateInput, surveyResponseUncheckedCreateInput>
    /**
     * In case the surveyResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surveyResponseUpdateInput, surveyResponseUncheckedUpdateInput>
  }

  /**
   * surveyResponse delete
   */
  export type surveyResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    /**
     * Filter which surveyResponse to delete.
     */
    where: surveyResponseWhereUniqueInput
  }

  /**
   * surveyResponse deleteMany
   */
  export type surveyResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveyResponses to delete
     */
    where?: surveyResponseWhereInput
    /**
     * Limit how many surveyResponses to delete.
     */
    limit?: number
  }

  /**
   * surveyResponse without action
   */
  export type surveyResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
  }


  /**
   * Model trustCircle
   */

  export type AggregateTrustCircle = {
    _count: TrustCircleCountAggregateOutputType | null
    _min: TrustCircleMinAggregateOutputType | null
    _max: TrustCircleMaxAggregateOutputType | null
  }

  export type TrustCircleMinAggregateOutputType = {
    userId: string | null
    contactId: string | null
    dateAdded: Date | null
    accessLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrustCircleMaxAggregateOutputType = {
    userId: string | null
    contactId: string | null
    dateAdded: Date | null
    accessLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrustCircleCountAggregateOutputType = {
    userId: number
    contactId: number
    dateAdded: number
    accessLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrustCircleMinAggregateInputType = {
    userId?: true
    contactId?: true
    dateAdded?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrustCircleMaxAggregateInputType = {
    userId?: true
    contactId?: true
    dateAdded?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrustCircleCountAggregateInputType = {
    userId?: true
    contactId?: true
    dateAdded?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrustCircleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trustCircle to aggregate.
     */
    where?: trustCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustCircles to fetch.
     */
    orderBy?: trustCircleOrderByWithRelationInput | trustCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trustCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustCircles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trustCircles
    **/
    _count?: true | TrustCircleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrustCircleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrustCircleMaxAggregateInputType
  }

  export type GetTrustCircleAggregateType<T extends TrustCircleAggregateArgs> = {
        [P in keyof T & keyof AggregateTrustCircle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrustCircle[P]>
      : GetScalarType<T[P], AggregateTrustCircle[P]>
  }




  export type trustCircleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trustCircleWhereInput
    orderBy?: trustCircleOrderByWithAggregationInput | trustCircleOrderByWithAggregationInput[]
    by: TrustCircleScalarFieldEnum[] | TrustCircleScalarFieldEnum
    having?: trustCircleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrustCircleCountAggregateInputType | true
    _min?: TrustCircleMinAggregateInputType
    _max?: TrustCircleMaxAggregateInputType
  }

  export type TrustCircleGroupByOutputType = {
    userId: string
    contactId: string
    dateAdded: Date
    accessLevel: string
    createdAt: Date
    updatedAt: Date | null
    _count: TrustCircleCountAggregateOutputType | null
    _min: TrustCircleMinAggregateOutputType | null
    _max: TrustCircleMaxAggregateOutputType | null
  }

  type GetTrustCircleGroupByPayload<T extends trustCircleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrustCircleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrustCircleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrustCircleGroupByOutputType[P]>
            : GetScalarType<T[P], TrustCircleGroupByOutputType[P]>
        }
      >
    >


  export type trustCircleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    contactId?: boolean
    dateAdded?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trustCircle"]>

  export type trustCircleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    contactId?: boolean
    dateAdded?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trustCircle"]>

  export type trustCircleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    contactId?: boolean
    dateAdded?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trustCircle"]>

  export type trustCircleSelectScalar = {
    userId?: boolean
    contactId?: boolean
    dateAdded?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trustCircleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "contactId" | "dateAdded" | "accessLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["trustCircle"]>

  export type $trustCirclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trustCircle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      contactId: string
      dateAdded: Date
      accessLevel: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["trustCircle"]>
    composites: {}
  }

  type trustCircleGetPayload<S extends boolean | null | undefined | trustCircleDefaultArgs> = $Result.GetResult<Prisma.$trustCirclePayload, S>

  type trustCircleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trustCircleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrustCircleCountAggregateInputType | true
    }

  export interface trustCircleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trustCircle'], meta: { name: 'trustCircle' } }
    /**
     * Find zero or one TrustCircle that matches the filter.
     * @param {trustCircleFindUniqueArgs} args - Arguments to find a TrustCircle
     * @example
     * // Get one TrustCircle
     * const trustCircle = await prisma.trustCircle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trustCircleFindUniqueArgs>(args: SelectSubset<T, trustCircleFindUniqueArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrustCircle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trustCircleFindUniqueOrThrowArgs} args - Arguments to find a TrustCircle
     * @example
     * // Get one TrustCircle
     * const trustCircle = await prisma.trustCircle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trustCircleFindUniqueOrThrowArgs>(args: SelectSubset<T, trustCircleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustCircle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustCircleFindFirstArgs} args - Arguments to find a TrustCircle
     * @example
     * // Get one TrustCircle
     * const trustCircle = await prisma.trustCircle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trustCircleFindFirstArgs>(args?: SelectSubset<T, trustCircleFindFirstArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustCircle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustCircleFindFirstOrThrowArgs} args - Arguments to find a TrustCircle
     * @example
     * // Get one TrustCircle
     * const trustCircle = await prisma.trustCircle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trustCircleFindFirstOrThrowArgs>(args?: SelectSubset<T, trustCircleFindFirstOrThrowArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrustCircles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustCircleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrustCircles
     * const trustCircles = await prisma.trustCircle.findMany()
     * 
     * // Get first 10 TrustCircles
     * const trustCircles = await prisma.trustCircle.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const trustCircleWithUserIdOnly = await prisma.trustCircle.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends trustCircleFindManyArgs>(args?: SelectSubset<T, trustCircleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrustCircle.
     * @param {trustCircleCreateArgs} args - Arguments to create a TrustCircle.
     * @example
     * // Create one TrustCircle
     * const TrustCircle = await prisma.trustCircle.create({
     *   data: {
     *     // ... data to create a TrustCircle
     *   }
     * })
     * 
     */
    create<T extends trustCircleCreateArgs>(args: SelectSubset<T, trustCircleCreateArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrustCircles.
     * @param {trustCircleCreateManyArgs} args - Arguments to create many TrustCircles.
     * @example
     * // Create many TrustCircles
     * const trustCircle = await prisma.trustCircle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trustCircleCreateManyArgs>(args?: SelectSubset<T, trustCircleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrustCircles and returns the data saved in the database.
     * @param {trustCircleCreateManyAndReturnArgs} args - Arguments to create many TrustCircles.
     * @example
     * // Create many TrustCircles
     * const trustCircle = await prisma.trustCircle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrustCircles and only return the `userId`
     * const trustCircleWithUserIdOnly = await prisma.trustCircle.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trustCircleCreateManyAndReturnArgs>(args?: SelectSubset<T, trustCircleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrustCircle.
     * @param {trustCircleDeleteArgs} args - Arguments to delete one TrustCircle.
     * @example
     * // Delete one TrustCircle
     * const TrustCircle = await prisma.trustCircle.delete({
     *   where: {
     *     // ... filter to delete one TrustCircle
     *   }
     * })
     * 
     */
    delete<T extends trustCircleDeleteArgs>(args: SelectSubset<T, trustCircleDeleteArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrustCircle.
     * @param {trustCircleUpdateArgs} args - Arguments to update one TrustCircle.
     * @example
     * // Update one TrustCircle
     * const trustCircle = await prisma.trustCircle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trustCircleUpdateArgs>(args: SelectSubset<T, trustCircleUpdateArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrustCircles.
     * @param {trustCircleDeleteManyArgs} args - Arguments to filter TrustCircles to delete.
     * @example
     * // Delete a few TrustCircles
     * const { count } = await prisma.trustCircle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trustCircleDeleteManyArgs>(args?: SelectSubset<T, trustCircleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustCircles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustCircleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrustCircles
     * const trustCircle = await prisma.trustCircle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trustCircleUpdateManyArgs>(args: SelectSubset<T, trustCircleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustCircles and returns the data updated in the database.
     * @param {trustCircleUpdateManyAndReturnArgs} args - Arguments to update many TrustCircles.
     * @example
     * // Update many TrustCircles
     * const trustCircle = await prisma.trustCircle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrustCircles and only return the `userId`
     * const trustCircleWithUserIdOnly = await prisma.trustCircle.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trustCircleUpdateManyAndReturnArgs>(args: SelectSubset<T, trustCircleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrustCircle.
     * @param {trustCircleUpsertArgs} args - Arguments to update or create a TrustCircle.
     * @example
     * // Update or create a TrustCircle
     * const trustCircle = await prisma.trustCircle.upsert({
     *   create: {
     *     // ... data to create a TrustCircle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrustCircle we want to update
     *   }
     * })
     */
    upsert<T extends trustCircleUpsertArgs>(args: SelectSubset<T, trustCircleUpsertArgs<ExtArgs>>): Prisma__trustCircleClient<$Result.GetResult<Prisma.$trustCirclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrustCircles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustCircleCountArgs} args - Arguments to filter TrustCircles to count.
     * @example
     * // Count the number of TrustCircles
     * const count = await prisma.trustCircle.count({
     *   where: {
     *     // ... the filter for the TrustCircles we want to count
     *   }
     * })
    **/
    count<T extends trustCircleCountArgs>(
      args?: Subset<T, trustCircleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrustCircleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrustCircle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustCircleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrustCircleAggregateArgs>(args: Subset<T, TrustCircleAggregateArgs>): Prisma.PrismaPromise<GetTrustCircleAggregateType<T>>

    /**
     * Group by TrustCircle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustCircleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trustCircleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trustCircleGroupByArgs['orderBy'] }
        : { orderBy?: trustCircleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trustCircleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrustCircleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trustCircle model
   */
  readonly fields: trustCircleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trustCircle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trustCircleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trustCircle model
   */
  interface trustCircleFieldRefs {
    readonly userId: FieldRef<"trustCircle", 'String'>
    readonly contactId: FieldRef<"trustCircle", 'String'>
    readonly dateAdded: FieldRef<"trustCircle", 'DateTime'>
    readonly accessLevel: FieldRef<"trustCircle", 'String'>
    readonly createdAt: FieldRef<"trustCircle", 'DateTime'>
    readonly updatedAt: FieldRef<"trustCircle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trustCircle findUnique
   */
  export type trustCircleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * Filter, which trustCircle to fetch.
     */
    where: trustCircleWhereUniqueInput
  }

  /**
   * trustCircle findUniqueOrThrow
   */
  export type trustCircleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * Filter, which trustCircle to fetch.
     */
    where: trustCircleWhereUniqueInput
  }

  /**
   * trustCircle findFirst
   */
  export type trustCircleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * Filter, which trustCircle to fetch.
     */
    where?: trustCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustCircles to fetch.
     */
    orderBy?: trustCircleOrderByWithRelationInput | trustCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trustCircles.
     */
    cursor?: trustCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustCircles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trustCircles.
     */
    distinct?: TrustCircleScalarFieldEnum | TrustCircleScalarFieldEnum[]
  }

  /**
   * trustCircle findFirstOrThrow
   */
  export type trustCircleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * Filter, which trustCircle to fetch.
     */
    where?: trustCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustCircles to fetch.
     */
    orderBy?: trustCircleOrderByWithRelationInput | trustCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trustCircles.
     */
    cursor?: trustCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustCircles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trustCircles.
     */
    distinct?: TrustCircleScalarFieldEnum | TrustCircleScalarFieldEnum[]
  }

  /**
   * trustCircle findMany
   */
  export type trustCircleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * Filter, which trustCircles to fetch.
     */
    where?: trustCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustCircles to fetch.
     */
    orderBy?: trustCircleOrderByWithRelationInput | trustCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trustCircles.
     */
    cursor?: trustCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustCircles.
     */
    skip?: number
    distinct?: TrustCircleScalarFieldEnum | TrustCircleScalarFieldEnum[]
  }

  /**
   * trustCircle create
   */
  export type trustCircleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * The data needed to create a trustCircle.
     */
    data: XOR<trustCircleCreateInput, trustCircleUncheckedCreateInput>
  }

  /**
   * trustCircle createMany
   */
  export type trustCircleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trustCircles.
     */
    data: trustCircleCreateManyInput | trustCircleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trustCircle createManyAndReturn
   */
  export type trustCircleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * The data used to create many trustCircles.
     */
    data: trustCircleCreateManyInput | trustCircleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trustCircle update
   */
  export type trustCircleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * The data needed to update a trustCircle.
     */
    data: XOR<trustCircleUpdateInput, trustCircleUncheckedUpdateInput>
    /**
     * Choose, which trustCircle to update.
     */
    where: trustCircleWhereUniqueInput
  }

  /**
   * trustCircle updateMany
   */
  export type trustCircleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trustCircles.
     */
    data: XOR<trustCircleUpdateManyMutationInput, trustCircleUncheckedUpdateManyInput>
    /**
     * Filter which trustCircles to update
     */
    where?: trustCircleWhereInput
    /**
     * Limit how many trustCircles to update.
     */
    limit?: number
  }

  /**
   * trustCircle updateManyAndReturn
   */
  export type trustCircleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * The data used to update trustCircles.
     */
    data: XOR<trustCircleUpdateManyMutationInput, trustCircleUncheckedUpdateManyInput>
    /**
     * Filter which trustCircles to update
     */
    where?: trustCircleWhereInput
    /**
     * Limit how many trustCircles to update.
     */
    limit?: number
  }

  /**
   * trustCircle upsert
   */
  export type trustCircleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * The filter to search for the trustCircle to update in case it exists.
     */
    where: trustCircleWhereUniqueInput
    /**
     * In case the trustCircle found by the `where` argument doesn't exist, create a new trustCircle with this data.
     */
    create: XOR<trustCircleCreateInput, trustCircleUncheckedCreateInput>
    /**
     * In case the trustCircle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trustCircleUpdateInput, trustCircleUncheckedUpdateInput>
  }

  /**
   * trustCircle delete
   */
  export type trustCircleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
    /**
     * Filter which trustCircle to delete.
     */
    where: trustCircleWhereUniqueInput
  }

  /**
   * trustCircle deleteMany
   */
  export type trustCircleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trustCircles to delete
     */
    where?: trustCircleWhereInput
    /**
     * Limit how many trustCircles to delete.
     */
    limit?: number
  }

  /**
   * trustCircle without action
   */
  export type trustCircleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustCircle
     */
    select?: trustCircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustCircle
     */
    omit?: trustCircleOmit<ExtArgs> | null
  }


  /**
   * Model trustedContact
   */

  export type AggregateTrustedContact = {
    _count: TrustedContactCountAggregateOutputType | null
    _min: TrustedContactMinAggregateOutputType | null
    _max: TrustedContactMaxAggregateOutputType | null
  }

  export type TrustedContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    relationship: string | null
    shareMedications: boolean | null
    shareHealthIndicators: boolean | null
    shareWellnessActivities: boolean | null
    emergencyAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrustedContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    relationship: string | null
    shareMedications: boolean | null
    shareHealthIndicators: boolean | null
    shareWellnessActivities: boolean | null
    emergencyAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrustedContactCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    relationship: number
    shareMedications: number
    shareHealthIndicators: number
    shareWellnessActivities: number
    emergencyAlerts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrustedContactMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    relationship?: true
    shareMedications?: true
    shareHealthIndicators?: true
    shareWellnessActivities?: true
    emergencyAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrustedContactMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    relationship?: true
    shareMedications?: true
    shareHealthIndicators?: true
    shareWellnessActivities?: true
    emergencyAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrustedContactCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    relationship?: true
    shareMedications?: true
    shareHealthIndicators?: true
    shareWellnessActivities?: true
    emergencyAlerts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrustedContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trustedContact to aggregate.
     */
    where?: trustedContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustedContacts to fetch.
     */
    orderBy?: trustedContactOrderByWithRelationInput | trustedContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trustedContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustedContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustedContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trustedContacts
    **/
    _count?: true | TrustedContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrustedContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrustedContactMaxAggregateInputType
  }

  export type GetTrustedContactAggregateType<T extends TrustedContactAggregateArgs> = {
        [P in keyof T & keyof AggregateTrustedContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrustedContact[P]>
      : GetScalarType<T[P], AggregateTrustedContact[P]>
  }




  export type trustedContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trustedContactWhereInput
    orderBy?: trustedContactOrderByWithAggregationInput | trustedContactOrderByWithAggregationInput[]
    by: TrustedContactScalarFieldEnum[] | TrustedContactScalarFieldEnum
    having?: trustedContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrustedContactCountAggregateInputType | true
    _min?: TrustedContactMinAggregateInputType
    _max?: TrustedContactMaxAggregateInputType
  }

  export type TrustedContactGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    email: string | null
    phone: string
    relationship: string | null
    shareMedications: boolean
    shareHealthIndicators: boolean
    shareWellnessActivities: boolean
    emergencyAlerts: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: TrustedContactCountAggregateOutputType | null
    _min: TrustedContactMinAggregateOutputType | null
    _max: TrustedContactMaxAggregateOutputType | null
  }

  type GetTrustedContactGroupByPayload<T extends trustedContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrustedContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrustedContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrustedContactGroupByOutputType[P]>
            : GetScalarType<T[P], TrustedContactGroupByOutputType[P]>
        }
      >
    >


  export type trustedContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    relationship?: boolean
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustedContact"]>

  export type trustedContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    relationship?: boolean
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustedContact"]>

  export type trustedContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    relationship?: boolean
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustedContact"]>

  export type trustedContactSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    relationship?: boolean
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trustedContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "email" | "phone" | "relationship" | "shareMedications" | "shareHealthIndicators" | "shareWellnessActivities" | "emergencyAlerts" | "createdAt" | "updatedAt", ExtArgs["result"]["trustedContact"]>
  export type trustedContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type trustedContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type trustedContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $trustedContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trustedContact"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      email: string | null
      phone: string
      relationship: string | null
      shareMedications: boolean
      shareHealthIndicators: boolean
      shareWellnessActivities: boolean
      emergencyAlerts: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["trustedContact"]>
    composites: {}
  }

  type trustedContactGetPayload<S extends boolean | null | undefined | trustedContactDefaultArgs> = $Result.GetResult<Prisma.$trustedContactPayload, S>

  type trustedContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trustedContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrustedContactCountAggregateInputType | true
    }

  export interface trustedContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trustedContact'], meta: { name: 'trustedContact' } }
    /**
     * Find zero or one TrustedContact that matches the filter.
     * @param {trustedContactFindUniqueArgs} args - Arguments to find a TrustedContact
     * @example
     * // Get one TrustedContact
     * const trustedContact = await prisma.trustedContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trustedContactFindUniqueArgs>(args: SelectSubset<T, trustedContactFindUniqueArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrustedContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trustedContactFindUniqueOrThrowArgs} args - Arguments to find a TrustedContact
     * @example
     * // Get one TrustedContact
     * const trustedContact = await prisma.trustedContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trustedContactFindUniqueOrThrowArgs>(args: SelectSubset<T, trustedContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustedContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustedContactFindFirstArgs} args - Arguments to find a TrustedContact
     * @example
     * // Get one TrustedContact
     * const trustedContact = await prisma.trustedContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trustedContactFindFirstArgs>(args?: SelectSubset<T, trustedContactFindFirstArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustedContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustedContactFindFirstOrThrowArgs} args - Arguments to find a TrustedContact
     * @example
     * // Get one TrustedContact
     * const trustedContact = await prisma.trustedContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trustedContactFindFirstOrThrowArgs>(args?: SelectSubset<T, trustedContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrustedContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustedContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrustedContacts
     * const trustedContacts = await prisma.trustedContact.findMany()
     * 
     * // Get first 10 TrustedContacts
     * const trustedContacts = await prisma.trustedContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trustedContactWithIdOnly = await prisma.trustedContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trustedContactFindManyArgs>(args?: SelectSubset<T, trustedContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrustedContact.
     * @param {trustedContactCreateArgs} args - Arguments to create a TrustedContact.
     * @example
     * // Create one TrustedContact
     * const TrustedContact = await prisma.trustedContact.create({
     *   data: {
     *     // ... data to create a TrustedContact
     *   }
     * })
     * 
     */
    create<T extends trustedContactCreateArgs>(args: SelectSubset<T, trustedContactCreateArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrustedContacts.
     * @param {trustedContactCreateManyArgs} args - Arguments to create many TrustedContacts.
     * @example
     * // Create many TrustedContacts
     * const trustedContact = await prisma.trustedContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trustedContactCreateManyArgs>(args?: SelectSubset<T, trustedContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrustedContacts and returns the data saved in the database.
     * @param {trustedContactCreateManyAndReturnArgs} args - Arguments to create many TrustedContacts.
     * @example
     * // Create many TrustedContacts
     * const trustedContact = await prisma.trustedContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrustedContacts and only return the `id`
     * const trustedContactWithIdOnly = await prisma.trustedContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trustedContactCreateManyAndReturnArgs>(args?: SelectSubset<T, trustedContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrustedContact.
     * @param {trustedContactDeleteArgs} args - Arguments to delete one TrustedContact.
     * @example
     * // Delete one TrustedContact
     * const TrustedContact = await prisma.trustedContact.delete({
     *   where: {
     *     // ... filter to delete one TrustedContact
     *   }
     * })
     * 
     */
    delete<T extends trustedContactDeleteArgs>(args: SelectSubset<T, trustedContactDeleteArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrustedContact.
     * @param {trustedContactUpdateArgs} args - Arguments to update one TrustedContact.
     * @example
     * // Update one TrustedContact
     * const trustedContact = await prisma.trustedContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trustedContactUpdateArgs>(args: SelectSubset<T, trustedContactUpdateArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrustedContacts.
     * @param {trustedContactDeleteManyArgs} args - Arguments to filter TrustedContacts to delete.
     * @example
     * // Delete a few TrustedContacts
     * const { count } = await prisma.trustedContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trustedContactDeleteManyArgs>(args?: SelectSubset<T, trustedContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustedContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustedContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrustedContacts
     * const trustedContact = await prisma.trustedContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trustedContactUpdateManyArgs>(args: SelectSubset<T, trustedContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustedContacts and returns the data updated in the database.
     * @param {trustedContactUpdateManyAndReturnArgs} args - Arguments to update many TrustedContacts.
     * @example
     * // Update many TrustedContacts
     * const trustedContact = await prisma.trustedContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrustedContacts and only return the `id`
     * const trustedContactWithIdOnly = await prisma.trustedContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trustedContactUpdateManyAndReturnArgs>(args: SelectSubset<T, trustedContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrustedContact.
     * @param {trustedContactUpsertArgs} args - Arguments to update or create a TrustedContact.
     * @example
     * // Update or create a TrustedContact
     * const trustedContact = await prisma.trustedContact.upsert({
     *   create: {
     *     // ... data to create a TrustedContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrustedContact we want to update
     *   }
     * })
     */
    upsert<T extends trustedContactUpsertArgs>(args: SelectSubset<T, trustedContactUpsertArgs<ExtArgs>>): Prisma__trustedContactClient<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrustedContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustedContactCountArgs} args - Arguments to filter TrustedContacts to count.
     * @example
     * // Count the number of TrustedContacts
     * const count = await prisma.trustedContact.count({
     *   where: {
     *     // ... the filter for the TrustedContacts we want to count
     *   }
     * })
    **/
    count<T extends trustedContactCountArgs>(
      args?: Subset<T, trustedContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrustedContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrustedContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrustedContactAggregateArgs>(args: Subset<T, TrustedContactAggregateArgs>): Prisma.PrismaPromise<GetTrustedContactAggregateType<T>>

    /**
     * Group by TrustedContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trustedContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trustedContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trustedContactGroupByArgs['orderBy'] }
        : { orderBy?: trustedContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trustedContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrustedContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trustedContact model
   */
  readonly fields: trustedContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trustedContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trustedContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trustedContact model
   */
  interface trustedContactFieldRefs {
    readonly id: FieldRef<"trustedContact", 'String'>
    readonly userId: FieldRef<"trustedContact", 'String'>
    readonly firstName: FieldRef<"trustedContact", 'String'>
    readonly lastName: FieldRef<"trustedContact", 'String'>
    readonly email: FieldRef<"trustedContact", 'String'>
    readonly phone: FieldRef<"trustedContact", 'String'>
    readonly relationship: FieldRef<"trustedContact", 'String'>
    readonly shareMedications: FieldRef<"trustedContact", 'Boolean'>
    readonly shareHealthIndicators: FieldRef<"trustedContact", 'Boolean'>
    readonly shareWellnessActivities: FieldRef<"trustedContact", 'Boolean'>
    readonly emergencyAlerts: FieldRef<"trustedContact", 'Boolean'>
    readonly createdAt: FieldRef<"trustedContact", 'DateTime'>
    readonly updatedAt: FieldRef<"trustedContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trustedContact findUnique
   */
  export type trustedContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * Filter, which trustedContact to fetch.
     */
    where: trustedContactWhereUniqueInput
  }

  /**
   * trustedContact findUniqueOrThrow
   */
  export type trustedContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * Filter, which trustedContact to fetch.
     */
    where: trustedContactWhereUniqueInput
  }

  /**
   * trustedContact findFirst
   */
  export type trustedContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * Filter, which trustedContact to fetch.
     */
    where?: trustedContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustedContacts to fetch.
     */
    orderBy?: trustedContactOrderByWithRelationInput | trustedContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trustedContacts.
     */
    cursor?: trustedContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustedContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustedContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trustedContacts.
     */
    distinct?: TrustedContactScalarFieldEnum | TrustedContactScalarFieldEnum[]
  }

  /**
   * trustedContact findFirstOrThrow
   */
  export type trustedContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * Filter, which trustedContact to fetch.
     */
    where?: trustedContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustedContacts to fetch.
     */
    orderBy?: trustedContactOrderByWithRelationInput | trustedContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trustedContacts.
     */
    cursor?: trustedContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustedContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustedContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trustedContacts.
     */
    distinct?: TrustedContactScalarFieldEnum | TrustedContactScalarFieldEnum[]
  }

  /**
   * trustedContact findMany
   */
  export type trustedContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * Filter, which trustedContacts to fetch.
     */
    where?: trustedContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trustedContacts to fetch.
     */
    orderBy?: trustedContactOrderByWithRelationInput | trustedContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trustedContacts.
     */
    cursor?: trustedContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trustedContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trustedContacts.
     */
    skip?: number
    distinct?: TrustedContactScalarFieldEnum | TrustedContactScalarFieldEnum[]
  }

  /**
   * trustedContact create
   */
  export type trustedContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * The data needed to create a trustedContact.
     */
    data: XOR<trustedContactCreateInput, trustedContactUncheckedCreateInput>
  }

  /**
   * trustedContact createMany
   */
  export type trustedContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trustedContacts.
     */
    data: trustedContactCreateManyInput | trustedContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trustedContact createManyAndReturn
   */
  export type trustedContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * The data used to create many trustedContacts.
     */
    data: trustedContactCreateManyInput | trustedContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * trustedContact update
   */
  export type trustedContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * The data needed to update a trustedContact.
     */
    data: XOR<trustedContactUpdateInput, trustedContactUncheckedUpdateInput>
    /**
     * Choose, which trustedContact to update.
     */
    where: trustedContactWhereUniqueInput
  }

  /**
   * trustedContact updateMany
   */
  export type trustedContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trustedContacts.
     */
    data: XOR<trustedContactUpdateManyMutationInput, trustedContactUncheckedUpdateManyInput>
    /**
     * Filter which trustedContacts to update
     */
    where?: trustedContactWhereInput
    /**
     * Limit how many trustedContacts to update.
     */
    limit?: number
  }

  /**
   * trustedContact updateManyAndReturn
   */
  export type trustedContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * The data used to update trustedContacts.
     */
    data: XOR<trustedContactUpdateManyMutationInput, trustedContactUncheckedUpdateManyInput>
    /**
     * Filter which trustedContacts to update
     */
    where?: trustedContactWhereInput
    /**
     * Limit how many trustedContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * trustedContact upsert
   */
  export type trustedContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * The filter to search for the trustedContact to update in case it exists.
     */
    where: trustedContactWhereUniqueInput
    /**
     * In case the trustedContact found by the `where` argument doesn't exist, create a new trustedContact with this data.
     */
    create: XOR<trustedContactCreateInput, trustedContactUncheckedCreateInput>
    /**
     * In case the trustedContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trustedContactUpdateInput, trustedContactUncheckedUpdateInput>
  }

  /**
   * trustedContact delete
   */
  export type trustedContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    /**
     * Filter which trustedContact to delete.
     */
    where: trustedContactWhereUniqueInput
  }

  /**
   * trustedContact deleteMany
   */
  export type trustedContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trustedContacts to delete
     */
    where?: trustedContactWhereInput
    /**
     * Limit how many trustedContacts to delete.
     */
    limit?: number
  }

  /**
   * trustedContact without action
   */
  export type trustedContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
  }


  /**
   * Model urbanIssueReport
   */

  export type AggregateUrbanIssueReport = {
    _count: UrbanIssueReportCountAggregateOutputType | null
    _min: UrbanIssueReportMinAggregateOutputType | null
    _max: UrbanIssueReportMaxAggregateOutputType | null
  }

  export type UrbanIssueReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryId: string | null
    description: string | null
    address: string | null
    gpsCoordinates: string | null
    reportDate: Date | null
    status: string | null
    cityReference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UrbanIssueReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryId: string | null
    description: string | null
    address: string | null
    gpsCoordinates: string | null
    reportDate: Date | null
    status: string | null
    cityReference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UrbanIssueReportCountAggregateOutputType = {
    id: number
    userId: number
    categoryId: number
    description: number
    address: number
    gpsCoordinates: number
    reportDate: number
    status: number
    cityReference: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UrbanIssueReportMinAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    description?: true
    address?: true
    gpsCoordinates?: true
    reportDate?: true
    status?: true
    cityReference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UrbanIssueReportMaxAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    description?: true
    address?: true
    gpsCoordinates?: true
    reportDate?: true
    status?: true
    cityReference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UrbanIssueReportCountAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    description?: true
    address?: true
    gpsCoordinates?: true
    reportDate?: true
    status?: true
    cityReference?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UrbanIssueReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which urbanIssueReport to aggregate.
     */
    where?: urbanIssueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of urbanIssueReports to fetch.
     */
    orderBy?: urbanIssueReportOrderByWithRelationInput | urbanIssueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: urbanIssueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` urbanIssueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` urbanIssueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned urbanIssueReports
    **/
    _count?: true | UrbanIssueReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UrbanIssueReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UrbanIssueReportMaxAggregateInputType
  }

  export type GetUrbanIssueReportAggregateType<T extends UrbanIssueReportAggregateArgs> = {
        [P in keyof T & keyof AggregateUrbanIssueReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUrbanIssueReport[P]>
      : GetScalarType<T[P], AggregateUrbanIssueReport[P]>
  }




  export type urbanIssueReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: urbanIssueReportWhereInput
    orderBy?: urbanIssueReportOrderByWithAggregationInput | urbanIssueReportOrderByWithAggregationInput[]
    by: UrbanIssueReportScalarFieldEnum[] | UrbanIssueReportScalarFieldEnum
    having?: urbanIssueReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UrbanIssueReportCountAggregateInputType | true
    _min?: UrbanIssueReportMinAggregateInputType
    _max?: UrbanIssueReportMaxAggregateInputType
  }

  export type UrbanIssueReportGroupByOutputType = {
    id: string
    userId: string
    categoryId: string | null
    description: string
    address: string
    gpsCoordinates: string | null
    reportDate: Date
    status: string | null
    cityReference: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: UrbanIssueReportCountAggregateOutputType | null
    _min: UrbanIssueReportMinAggregateOutputType | null
    _max: UrbanIssueReportMaxAggregateOutputType | null
  }

  type GetUrbanIssueReportGroupByPayload<T extends urbanIssueReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UrbanIssueReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UrbanIssueReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UrbanIssueReportGroupByOutputType[P]>
            : GetScalarType<T[P], UrbanIssueReportGroupByOutputType[P]>
        }
      >
    >


  export type urbanIssueReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    description?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    reportDate?: boolean
    status?: boolean
    cityReference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | urbanIssueReport$userArgs<ExtArgs>
    issueCategory?: boolean | urbanIssueReport$issueCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["urbanIssueReport"]>

  export type urbanIssueReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    description?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    reportDate?: boolean
    status?: boolean
    cityReference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | urbanIssueReport$userArgs<ExtArgs>
    issueCategory?: boolean | urbanIssueReport$issueCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["urbanIssueReport"]>

  export type urbanIssueReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    description?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    reportDate?: boolean
    status?: boolean
    cityReference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | urbanIssueReport$userArgs<ExtArgs>
    issueCategory?: boolean | urbanIssueReport$issueCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["urbanIssueReport"]>

  export type urbanIssueReportSelectScalar = {
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    description?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    reportDate?: boolean
    status?: boolean
    cityReference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type urbanIssueReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "categoryId" | "description" | "address" | "gpsCoordinates" | "reportDate" | "status" | "cityReference" | "createdAt" | "updatedAt", ExtArgs["result"]["urbanIssueReport"]>
  export type urbanIssueReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | urbanIssueReport$userArgs<ExtArgs>
    issueCategory?: boolean | urbanIssueReport$issueCategoryArgs<ExtArgs>
  }
  export type urbanIssueReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | urbanIssueReport$userArgs<ExtArgs>
    issueCategory?: boolean | urbanIssueReport$issueCategoryArgs<ExtArgs>
  }
  export type urbanIssueReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | urbanIssueReport$userArgs<ExtArgs>
    issueCategory?: boolean | urbanIssueReport$issueCategoryArgs<ExtArgs>
  }

  export type $urbanIssueReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "urbanIssueReport"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      issueCategory: Prisma.$issueCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      categoryId: string | null
      description: string
      address: string
      gpsCoordinates: string | null
      reportDate: Date
      status: string | null
      cityReference: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["urbanIssueReport"]>
    composites: {}
  }

  type urbanIssueReportGetPayload<S extends boolean | null | undefined | urbanIssueReportDefaultArgs> = $Result.GetResult<Prisma.$urbanIssueReportPayload, S>

  type urbanIssueReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<urbanIssueReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UrbanIssueReportCountAggregateInputType | true
    }

  export interface urbanIssueReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['urbanIssueReport'], meta: { name: 'urbanIssueReport' } }
    /**
     * Find zero or one UrbanIssueReport that matches the filter.
     * @param {urbanIssueReportFindUniqueArgs} args - Arguments to find a UrbanIssueReport
     * @example
     * // Get one UrbanIssueReport
     * const urbanIssueReport = await prisma.urbanIssueReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends urbanIssueReportFindUniqueArgs>(args: SelectSubset<T, urbanIssueReportFindUniqueArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UrbanIssueReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {urbanIssueReportFindUniqueOrThrowArgs} args - Arguments to find a UrbanIssueReport
     * @example
     * // Get one UrbanIssueReport
     * const urbanIssueReport = await prisma.urbanIssueReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends urbanIssueReportFindUniqueOrThrowArgs>(args: SelectSubset<T, urbanIssueReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UrbanIssueReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {urbanIssueReportFindFirstArgs} args - Arguments to find a UrbanIssueReport
     * @example
     * // Get one UrbanIssueReport
     * const urbanIssueReport = await prisma.urbanIssueReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends urbanIssueReportFindFirstArgs>(args?: SelectSubset<T, urbanIssueReportFindFirstArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UrbanIssueReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {urbanIssueReportFindFirstOrThrowArgs} args - Arguments to find a UrbanIssueReport
     * @example
     * // Get one UrbanIssueReport
     * const urbanIssueReport = await prisma.urbanIssueReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends urbanIssueReportFindFirstOrThrowArgs>(args?: SelectSubset<T, urbanIssueReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UrbanIssueReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {urbanIssueReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UrbanIssueReports
     * const urbanIssueReports = await prisma.urbanIssueReport.findMany()
     * 
     * // Get first 10 UrbanIssueReports
     * const urbanIssueReports = await prisma.urbanIssueReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const urbanIssueReportWithIdOnly = await prisma.urbanIssueReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends urbanIssueReportFindManyArgs>(args?: SelectSubset<T, urbanIssueReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UrbanIssueReport.
     * @param {urbanIssueReportCreateArgs} args - Arguments to create a UrbanIssueReport.
     * @example
     * // Create one UrbanIssueReport
     * const UrbanIssueReport = await prisma.urbanIssueReport.create({
     *   data: {
     *     // ... data to create a UrbanIssueReport
     *   }
     * })
     * 
     */
    create<T extends urbanIssueReportCreateArgs>(args: SelectSubset<T, urbanIssueReportCreateArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UrbanIssueReports.
     * @param {urbanIssueReportCreateManyArgs} args - Arguments to create many UrbanIssueReports.
     * @example
     * // Create many UrbanIssueReports
     * const urbanIssueReport = await prisma.urbanIssueReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends urbanIssueReportCreateManyArgs>(args?: SelectSubset<T, urbanIssueReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UrbanIssueReports and returns the data saved in the database.
     * @param {urbanIssueReportCreateManyAndReturnArgs} args - Arguments to create many UrbanIssueReports.
     * @example
     * // Create many UrbanIssueReports
     * const urbanIssueReport = await prisma.urbanIssueReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UrbanIssueReports and only return the `id`
     * const urbanIssueReportWithIdOnly = await prisma.urbanIssueReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends urbanIssueReportCreateManyAndReturnArgs>(args?: SelectSubset<T, urbanIssueReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UrbanIssueReport.
     * @param {urbanIssueReportDeleteArgs} args - Arguments to delete one UrbanIssueReport.
     * @example
     * // Delete one UrbanIssueReport
     * const UrbanIssueReport = await prisma.urbanIssueReport.delete({
     *   where: {
     *     // ... filter to delete one UrbanIssueReport
     *   }
     * })
     * 
     */
    delete<T extends urbanIssueReportDeleteArgs>(args: SelectSubset<T, urbanIssueReportDeleteArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UrbanIssueReport.
     * @param {urbanIssueReportUpdateArgs} args - Arguments to update one UrbanIssueReport.
     * @example
     * // Update one UrbanIssueReport
     * const urbanIssueReport = await prisma.urbanIssueReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends urbanIssueReportUpdateArgs>(args: SelectSubset<T, urbanIssueReportUpdateArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UrbanIssueReports.
     * @param {urbanIssueReportDeleteManyArgs} args - Arguments to filter UrbanIssueReports to delete.
     * @example
     * // Delete a few UrbanIssueReports
     * const { count } = await prisma.urbanIssueReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends urbanIssueReportDeleteManyArgs>(args?: SelectSubset<T, urbanIssueReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UrbanIssueReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {urbanIssueReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UrbanIssueReports
     * const urbanIssueReport = await prisma.urbanIssueReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends urbanIssueReportUpdateManyArgs>(args: SelectSubset<T, urbanIssueReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UrbanIssueReports and returns the data updated in the database.
     * @param {urbanIssueReportUpdateManyAndReturnArgs} args - Arguments to update many UrbanIssueReports.
     * @example
     * // Update many UrbanIssueReports
     * const urbanIssueReport = await prisma.urbanIssueReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UrbanIssueReports and only return the `id`
     * const urbanIssueReportWithIdOnly = await prisma.urbanIssueReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends urbanIssueReportUpdateManyAndReturnArgs>(args: SelectSubset<T, urbanIssueReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UrbanIssueReport.
     * @param {urbanIssueReportUpsertArgs} args - Arguments to update or create a UrbanIssueReport.
     * @example
     * // Update or create a UrbanIssueReport
     * const urbanIssueReport = await prisma.urbanIssueReport.upsert({
     *   create: {
     *     // ... data to create a UrbanIssueReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UrbanIssueReport we want to update
     *   }
     * })
     */
    upsert<T extends urbanIssueReportUpsertArgs>(args: SelectSubset<T, urbanIssueReportUpsertArgs<ExtArgs>>): Prisma__urbanIssueReportClient<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UrbanIssueReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {urbanIssueReportCountArgs} args - Arguments to filter UrbanIssueReports to count.
     * @example
     * // Count the number of UrbanIssueReports
     * const count = await prisma.urbanIssueReport.count({
     *   where: {
     *     // ... the filter for the UrbanIssueReports we want to count
     *   }
     * })
    **/
    count<T extends urbanIssueReportCountArgs>(
      args?: Subset<T, urbanIssueReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UrbanIssueReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UrbanIssueReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrbanIssueReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UrbanIssueReportAggregateArgs>(args: Subset<T, UrbanIssueReportAggregateArgs>): Prisma.PrismaPromise<GetUrbanIssueReportAggregateType<T>>

    /**
     * Group by UrbanIssueReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {urbanIssueReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends urbanIssueReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: urbanIssueReportGroupByArgs['orderBy'] }
        : { orderBy?: urbanIssueReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, urbanIssueReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUrbanIssueReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the urbanIssueReport model
   */
  readonly fields: urbanIssueReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for urbanIssueReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__urbanIssueReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends urbanIssueReport$userArgs<ExtArgs> = {}>(args?: Subset<T, urbanIssueReport$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    issueCategory<T extends urbanIssueReport$issueCategoryArgs<ExtArgs> = {}>(args?: Subset<T, urbanIssueReport$issueCategoryArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the urbanIssueReport model
   */
  interface urbanIssueReportFieldRefs {
    readonly id: FieldRef<"urbanIssueReport", 'String'>
    readonly userId: FieldRef<"urbanIssueReport", 'String'>
    readonly categoryId: FieldRef<"urbanIssueReport", 'String'>
    readonly description: FieldRef<"urbanIssueReport", 'String'>
    readonly address: FieldRef<"urbanIssueReport", 'String'>
    readonly gpsCoordinates: FieldRef<"urbanIssueReport", 'String'>
    readonly reportDate: FieldRef<"urbanIssueReport", 'DateTime'>
    readonly status: FieldRef<"urbanIssueReport", 'String'>
    readonly cityReference: FieldRef<"urbanIssueReport", 'String'>
    readonly createdAt: FieldRef<"urbanIssueReport", 'DateTime'>
    readonly updatedAt: FieldRef<"urbanIssueReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * urbanIssueReport findUnique
   */
  export type urbanIssueReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * Filter, which urbanIssueReport to fetch.
     */
    where: urbanIssueReportWhereUniqueInput
  }

  /**
   * urbanIssueReport findUniqueOrThrow
   */
  export type urbanIssueReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * Filter, which urbanIssueReport to fetch.
     */
    where: urbanIssueReportWhereUniqueInput
  }

  /**
   * urbanIssueReport findFirst
   */
  export type urbanIssueReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * Filter, which urbanIssueReport to fetch.
     */
    where?: urbanIssueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of urbanIssueReports to fetch.
     */
    orderBy?: urbanIssueReportOrderByWithRelationInput | urbanIssueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for urbanIssueReports.
     */
    cursor?: urbanIssueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` urbanIssueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` urbanIssueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of urbanIssueReports.
     */
    distinct?: UrbanIssueReportScalarFieldEnum | UrbanIssueReportScalarFieldEnum[]
  }

  /**
   * urbanIssueReport findFirstOrThrow
   */
  export type urbanIssueReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * Filter, which urbanIssueReport to fetch.
     */
    where?: urbanIssueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of urbanIssueReports to fetch.
     */
    orderBy?: urbanIssueReportOrderByWithRelationInput | urbanIssueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for urbanIssueReports.
     */
    cursor?: urbanIssueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` urbanIssueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` urbanIssueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of urbanIssueReports.
     */
    distinct?: UrbanIssueReportScalarFieldEnum | UrbanIssueReportScalarFieldEnum[]
  }

  /**
   * urbanIssueReport findMany
   */
  export type urbanIssueReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * Filter, which urbanIssueReports to fetch.
     */
    where?: urbanIssueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of urbanIssueReports to fetch.
     */
    orderBy?: urbanIssueReportOrderByWithRelationInput | urbanIssueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing urbanIssueReports.
     */
    cursor?: urbanIssueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` urbanIssueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` urbanIssueReports.
     */
    skip?: number
    distinct?: UrbanIssueReportScalarFieldEnum | UrbanIssueReportScalarFieldEnum[]
  }

  /**
   * urbanIssueReport create
   */
  export type urbanIssueReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * The data needed to create a urbanIssueReport.
     */
    data: XOR<urbanIssueReportCreateInput, urbanIssueReportUncheckedCreateInput>
  }

  /**
   * urbanIssueReport createMany
   */
  export type urbanIssueReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many urbanIssueReports.
     */
    data: urbanIssueReportCreateManyInput | urbanIssueReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * urbanIssueReport createManyAndReturn
   */
  export type urbanIssueReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * The data used to create many urbanIssueReports.
     */
    data: urbanIssueReportCreateManyInput | urbanIssueReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * urbanIssueReport update
   */
  export type urbanIssueReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * The data needed to update a urbanIssueReport.
     */
    data: XOR<urbanIssueReportUpdateInput, urbanIssueReportUncheckedUpdateInput>
    /**
     * Choose, which urbanIssueReport to update.
     */
    where: urbanIssueReportWhereUniqueInput
  }

  /**
   * urbanIssueReport updateMany
   */
  export type urbanIssueReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update urbanIssueReports.
     */
    data: XOR<urbanIssueReportUpdateManyMutationInput, urbanIssueReportUncheckedUpdateManyInput>
    /**
     * Filter which urbanIssueReports to update
     */
    where?: urbanIssueReportWhereInput
    /**
     * Limit how many urbanIssueReports to update.
     */
    limit?: number
  }

  /**
   * urbanIssueReport updateManyAndReturn
   */
  export type urbanIssueReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * The data used to update urbanIssueReports.
     */
    data: XOR<urbanIssueReportUpdateManyMutationInput, urbanIssueReportUncheckedUpdateManyInput>
    /**
     * Filter which urbanIssueReports to update
     */
    where?: urbanIssueReportWhereInput
    /**
     * Limit how many urbanIssueReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * urbanIssueReport upsert
   */
  export type urbanIssueReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * The filter to search for the urbanIssueReport to update in case it exists.
     */
    where: urbanIssueReportWhereUniqueInput
    /**
     * In case the urbanIssueReport found by the `where` argument doesn't exist, create a new urbanIssueReport with this data.
     */
    create: XOR<urbanIssueReportCreateInput, urbanIssueReportUncheckedCreateInput>
    /**
     * In case the urbanIssueReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<urbanIssueReportUpdateInput, urbanIssueReportUncheckedUpdateInput>
  }

  /**
   * urbanIssueReport delete
   */
  export type urbanIssueReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    /**
     * Filter which urbanIssueReport to delete.
     */
    where: urbanIssueReportWhereUniqueInput
  }

  /**
   * urbanIssueReport deleteMany
   */
  export type urbanIssueReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which urbanIssueReports to delete
     */
    where?: urbanIssueReportWhereInput
    /**
     * Limit how many urbanIssueReports to delete.
     */
    limit?: number
  }

  /**
   * urbanIssueReport.user
   */
  export type urbanIssueReport$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * urbanIssueReport.issueCategory
   */
  export type urbanIssueReport$issueCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    where?: issueCategoryWhereInput
  }

  /**
   * urbanIssueReport without action
   */
  export type urbanIssueReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    helpPoints: number | null
  }

  export type UserSumAggregateOutputType = {
    helpPoints: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    address: string | null
    gpsCoordinates: string | null
    phone: string | null
    profilePicture: string | null
    registrationDate: Date | null
    accountVerified: boolean | null
    interfacePreferences: string | null
    twoFactorAuthentication: boolean | null
    helpPoints: number | null
    reducedMobility: boolean | null
    activityLevel: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    address: string | null
    gpsCoordinates: string | null
    phone: string | null
    profilePicture: string | null
    registrationDate: Date | null
    accountVerified: boolean | null
    interfacePreferences: string | null
    twoFactorAuthentication: boolean | null
    helpPoints: number | null
    reducedMobility: boolean | null
    activityLevel: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    birthDate: number
    address: number
    gpsCoordinates: number
    phone: number
    profilePicture: number
    registrationDate: number
    accountVerified: number
    interfacePreferences: number
    twoFactorAuthentication: number
    helpPoints: number
    reducedMobility: number
    activityLevel: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    helpPoints?: true
  }

  export type UserSumAggregateInputType = {
    helpPoints?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    address?: true
    gpsCoordinates?: true
    phone?: true
    profilePicture?: true
    registrationDate?: true
    accountVerified?: true
    interfacePreferences?: true
    twoFactorAuthentication?: true
    helpPoints?: true
    reducedMobility?: true
    activityLevel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    address?: true
    gpsCoordinates?: true
    phone?: true
    profilePicture?: true
    registrationDate?: true
    accountVerified?: true
    interfacePreferences?: true
    twoFactorAuthentication?: true
    helpPoints?: true
    reducedMobility?: true
    activityLevel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    address?: true
    gpsCoordinates?: true
    phone?: true
    profilePicture?: true
    registrationDate?: true
    accountVerified?: true
    interfacePreferences?: true
    twoFactorAuthentication?: true
    helpPoints?: true
    reducedMobility?: true
    activityLevel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    address: string | null
    gpsCoordinates: string | null
    phone: string | null
    profilePicture: string | null
    registrationDate: Date
    accountVerified: boolean
    interfacePreferences: string | null
    twoFactorAuthentication: boolean
    helpPoints: number | null
    reducedMobility: boolean | null
    activityLevel: string | null
    status: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    profilePicture?: boolean
    registrationDate?: boolean
    accountVerified?: boolean
    interfacePreferences?: boolean
    twoFactorAuthentication?: boolean
    helpPoints?: boolean
    reducedMobility?: boolean
    activityLevel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | user$activityArgs<ExtArgs>
    activityLog?: boolean | user$activityLogArgs<ExtArgs>
    activityRegistration?: boolean | user$activityRegistrationArgs<ExtArgs>
    collaborativeProject?: boolean | user$collaborativeProjectArgs<ExtArgs>
    conversationParticipant?: boolean | user$conversationParticipantArgs<ExtArgs>
    forumMessage?: boolean | user$forumMessageArgs<ExtArgs>
    forumTopic?: boolean | user$forumTopicArgs<ExtArgs>
    healthIndicator?: boolean | user$healthIndicatorArgs<ExtArgs>
    helpOffer?: boolean | user$helpOfferArgs<ExtArgs>
    helpRequest?: boolean | user$helpRequestArgs<ExtArgs>
    medicationReminder?: boolean | user$medicationReminderArgs<ExtArgs>
    message?: boolean | user$messageArgs<ExtArgs>
    notification?: boolean | user$notificationArgs<ExtArgs>
    notificationPreferences?: boolean | user$notificationPreferencesArgs<ExtArgs>
    projectMember?: boolean | user$projectMemberArgs<ExtArgs>
    projectTask?: boolean | user$projectTaskArgs<ExtArgs>
    resource?: boolean | user$resourceArgs<ExtArgs>
    serviceCompleted?: boolean | user$serviceCompletedArgs<ExtArgs>
    serviceRating?: boolean | user$serviceRatingArgs<ExtArgs>
    surveyResponse?: boolean | user$surveyResponseArgs<ExtArgs>
    trustedContact?: boolean | user$trustedContactArgs<ExtArgs>
    urbanIssueReport?: boolean | user$urbanIssueReportArgs<ExtArgs>
    userActivity?: boolean | user$userActivityArgs<ExtArgs>
    userBadge?: boolean | user$userBadgeArgs<ExtArgs>
    userDevice?: boolean | user$userDeviceArgs<ExtArgs>
    userSkill?: boolean | user$userSkillArgs<ExtArgs>
    userStatistics?: boolean | user$userStatisticsArgs<ExtArgs>
    videoCall?: boolean | user$videoCallArgs<ExtArgs>
    wellnessGoal?: boolean | user$wellnessGoalArgs<ExtArgs>
    session?: boolean | user$sessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    profilePicture?: boolean
    registrationDate?: boolean
    accountVerified?: boolean
    interfacePreferences?: boolean
    twoFactorAuthentication?: boolean
    helpPoints?: boolean
    reducedMobility?: boolean
    activityLevel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    profilePicture?: boolean
    registrationDate?: boolean
    accountVerified?: boolean
    interfacePreferences?: boolean
    twoFactorAuthentication?: boolean
    helpPoints?: boolean
    reducedMobility?: boolean
    activityLevel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    address?: boolean
    gpsCoordinates?: boolean
    phone?: boolean
    profilePicture?: boolean
    registrationDate?: boolean
    accountVerified?: boolean
    interfacePreferences?: boolean
    twoFactorAuthentication?: boolean
    helpPoints?: boolean
    reducedMobility?: boolean
    activityLevel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "firstName" | "lastName" | "birthDate" | "address" | "gpsCoordinates" | "phone" | "profilePicture" | "registrationDate" | "accountVerified" | "interfacePreferences" | "twoFactorAuthentication" | "helpPoints" | "reducedMobility" | "activityLevel" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | user$activityArgs<ExtArgs>
    activityLog?: boolean | user$activityLogArgs<ExtArgs>
    activityRegistration?: boolean | user$activityRegistrationArgs<ExtArgs>
    collaborativeProject?: boolean | user$collaborativeProjectArgs<ExtArgs>
    conversationParticipant?: boolean | user$conversationParticipantArgs<ExtArgs>
    forumMessage?: boolean | user$forumMessageArgs<ExtArgs>
    forumTopic?: boolean | user$forumTopicArgs<ExtArgs>
    healthIndicator?: boolean | user$healthIndicatorArgs<ExtArgs>
    helpOffer?: boolean | user$helpOfferArgs<ExtArgs>
    helpRequest?: boolean | user$helpRequestArgs<ExtArgs>
    medicationReminder?: boolean | user$medicationReminderArgs<ExtArgs>
    message?: boolean | user$messageArgs<ExtArgs>
    notification?: boolean | user$notificationArgs<ExtArgs>
    notificationPreferences?: boolean | user$notificationPreferencesArgs<ExtArgs>
    projectMember?: boolean | user$projectMemberArgs<ExtArgs>
    projectTask?: boolean | user$projectTaskArgs<ExtArgs>
    resource?: boolean | user$resourceArgs<ExtArgs>
    serviceCompleted?: boolean | user$serviceCompletedArgs<ExtArgs>
    serviceRating?: boolean | user$serviceRatingArgs<ExtArgs>
    surveyResponse?: boolean | user$surveyResponseArgs<ExtArgs>
    trustedContact?: boolean | user$trustedContactArgs<ExtArgs>
    urbanIssueReport?: boolean | user$urbanIssueReportArgs<ExtArgs>
    userActivity?: boolean | user$userActivityArgs<ExtArgs>
    userBadge?: boolean | user$userBadgeArgs<ExtArgs>
    userDevice?: boolean | user$userDeviceArgs<ExtArgs>
    userSkill?: boolean | user$userSkillArgs<ExtArgs>
    userStatistics?: boolean | user$userStatisticsArgs<ExtArgs>
    videoCall?: boolean | user$videoCallArgs<ExtArgs>
    wellnessGoal?: boolean | user$wellnessGoalArgs<ExtArgs>
    session?: boolean | user$sessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      activity: Prisma.$activityPayload<ExtArgs>[]
      activityLog: Prisma.$activityLogPayload<ExtArgs>[]
      activityRegistration: Prisma.$activityRegistrationPayload<ExtArgs>[]
      collaborativeProject: Prisma.$collaborativeProjectPayload<ExtArgs>[]
      conversationParticipant: Prisma.$conversationParticipantPayload<ExtArgs>[]
      forumMessage: Prisma.$forumMessagePayload<ExtArgs>[]
      forumTopic: Prisma.$forumTopicPayload<ExtArgs>[]
      healthIndicator: Prisma.$healthIndicatorPayload<ExtArgs>[]
      helpOffer: Prisma.$helpOfferPayload<ExtArgs>[]
      helpRequest: Prisma.$helpRequestPayload<ExtArgs>[]
      medicationReminder: Prisma.$medicationReminderPayload<ExtArgs>[]
      message: Prisma.$messagePayload<ExtArgs>[]
      notification: Prisma.$notificationPayload<ExtArgs>[]
      notificationPreferences: Prisma.$notificationPreferencesPayload<ExtArgs> | null
      projectMember: Prisma.$projectMemberPayload<ExtArgs>[]
      projectTask: Prisma.$projectTaskPayload<ExtArgs>[]
      resource: Prisma.$resourcePayload<ExtArgs>[]
      serviceCompleted: Prisma.$serviceCompletedPayload<ExtArgs>[]
      serviceRating: Prisma.$serviceRatingPayload<ExtArgs>[]
      surveyResponse: Prisma.$surveyResponsePayload<ExtArgs>[]
      trustedContact: Prisma.$trustedContactPayload<ExtArgs>[]
      urbanIssueReport: Prisma.$urbanIssueReportPayload<ExtArgs>[]
      userActivity: Prisma.$userActivityPayload<ExtArgs>[]
      userBadge: Prisma.$userBadgePayload<ExtArgs>[]
      userDevice: Prisma.$userDevicePayload<ExtArgs>[]
      userSkill: Prisma.$userSkillPayload<ExtArgs>[]
      userStatistics: Prisma.$userStatisticsPayload<ExtArgs> | null
      videoCall: Prisma.$videoCallPayload<ExtArgs>[]
      wellnessGoal: Prisma.$wellnessGoalPayload<ExtArgs>[]
      session: Prisma.$sessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string | null
      lastName: string | null
      birthDate: Date | null
      address: string | null
      gpsCoordinates: string | null
      phone: string | null
      profilePicture: string | null
      registrationDate: Date
      accountVerified: boolean
      interfacePreferences: string | null
      twoFactorAuthentication: boolean
      helpPoints: number | null
      reducedMobility: boolean | null
      activityLevel: string | null
      status: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends user$activityArgs<ExtArgs> = {}>(args?: Subset<T, user$activityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLog<T extends user$activityLogArgs<ExtArgs> = {}>(args?: Subset<T, user$activityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityRegistration<T extends user$activityRegistrationArgs<ExtArgs> = {}>(args?: Subset<T, user$activityRegistrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collaborativeProject<T extends user$collaborativeProjectArgs<ExtArgs> = {}>(args?: Subset<T, user$collaborativeProjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationParticipant<T extends user$conversationParticipantArgs<ExtArgs> = {}>(args?: Subset<T, user$conversationParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forumMessage<T extends user$forumMessageArgs<ExtArgs> = {}>(args?: Subset<T, user$forumMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forumTopic<T extends user$forumTopicArgs<ExtArgs> = {}>(args?: Subset<T, user$forumTopicArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forumTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    healthIndicator<T extends user$healthIndicatorArgs<ExtArgs> = {}>(args?: Subset<T, user$healthIndicatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$healthIndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    helpOffer<T extends user$helpOfferArgs<ExtArgs> = {}>(args?: Subset<T, user$helpOfferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    helpRequest<T extends user$helpRequestArgs<ExtArgs> = {}>(args?: Subset<T, user$helpRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicationReminder<T extends user$medicationReminderArgs<ExtArgs> = {}>(args?: Subset<T, user$medicationReminderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicationReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message<T extends user$messageArgs<ExtArgs> = {}>(args?: Subset<T, user$messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends user$notificationArgs<ExtArgs> = {}>(args?: Subset<T, user$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreferences<T extends user$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, user$notificationPreferencesArgs<ExtArgs>>): Prisma__notificationPreferencesClient<$Result.GetResult<Prisma.$notificationPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    projectMember<T extends user$projectMemberArgs<ExtArgs> = {}>(args?: Subset<T, user$projectMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectTask<T extends user$projectTaskArgs<ExtArgs> = {}>(args?: Subset<T, user$projectTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resource<T extends user$resourceArgs<ExtArgs> = {}>(args?: Subset<T, user$resourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceCompleted<T extends user$serviceCompletedArgs<ExtArgs> = {}>(args?: Subset<T, user$serviceCompletedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCompletedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceRating<T extends user$serviceRatingArgs<ExtArgs> = {}>(args?: Subset<T, user$serviceRatingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surveyResponse<T extends user$surveyResponseArgs<ExtArgs> = {}>(args?: Subset<T, user$surveyResponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trustedContact<T extends user$trustedContactArgs<ExtArgs> = {}>(args?: Subset<T, user$trustedContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trustedContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    urbanIssueReport<T extends user$urbanIssueReportArgs<ExtArgs> = {}>(args?: Subset<T, user$urbanIssueReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userActivity<T extends user$userActivityArgs<ExtArgs> = {}>(args?: Subset<T, user$userActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userBadge<T extends user$userBadgeArgs<ExtArgs> = {}>(args?: Subset<T, user$userBadgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userDevice<T extends user$userDeviceArgs<ExtArgs> = {}>(args?: Subset<T, user$userDeviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSkill<T extends user$userSkillArgs<ExtArgs> = {}>(args?: Subset<T, user$userSkillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userStatistics<T extends user$userStatisticsArgs<ExtArgs> = {}>(args?: Subset<T, user$userStatisticsArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    videoCall<T extends user$videoCallArgs<ExtArgs> = {}>(args?: Subset<T, user$videoCallArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellnessGoal<T extends user$wellnessGoalArgs<ExtArgs> = {}>(args?: Subset<T, user$wellnessGoalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session<T extends user$sessionArgs<ExtArgs> = {}>(args?: Subset<T, user$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly passwordHash: FieldRef<"user", 'String'>
    readonly firstName: FieldRef<"user", 'String'>
    readonly lastName: FieldRef<"user", 'String'>
    readonly birthDate: FieldRef<"user", 'DateTime'>
    readonly address: FieldRef<"user", 'String'>
    readonly gpsCoordinates: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly profilePicture: FieldRef<"user", 'String'>
    readonly registrationDate: FieldRef<"user", 'DateTime'>
    readonly accountVerified: FieldRef<"user", 'Boolean'>
    readonly interfacePreferences: FieldRef<"user", 'String'>
    readonly twoFactorAuthentication: FieldRef<"user", 'Boolean'>
    readonly helpPoints: FieldRef<"user", 'Int'>
    readonly reducedMobility: FieldRef<"user", 'Boolean'>
    readonly activityLevel: FieldRef<"user", 'String'>
    readonly status: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.activity
   */
  export type user$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    where?: activityWhereInput
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    cursor?: activityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * user.activityLog
   */
  export type user$activityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityLog
     */
    select?: activityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityLog
     */
    omit?: activityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityLogInclude<ExtArgs> | null
    where?: activityLogWhereInput
    orderBy?: activityLogOrderByWithRelationInput | activityLogOrderByWithRelationInput[]
    cursor?: activityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * user.activityRegistration
   */
  export type user$activityRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityRegistration
     */
    select?: activityRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityRegistration
     */
    omit?: activityRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityRegistrationInclude<ExtArgs> | null
    where?: activityRegistrationWhereInput
    orderBy?: activityRegistrationOrderByWithRelationInput | activityRegistrationOrderByWithRelationInput[]
    cursor?: activityRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityRegistrationScalarFieldEnum | ActivityRegistrationScalarFieldEnum[]
  }

  /**
   * user.collaborativeProject
   */
  export type user$collaborativeProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    where?: collaborativeProjectWhereInput
    orderBy?: collaborativeProjectOrderByWithRelationInput | collaborativeProjectOrderByWithRelationInput[]
    cursor?: collaborativeProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollaborativeProjectScalarFieldEnum | CollaborativeProjectScalarFieldEnum[]
  }

  /**
   * user.conversationParticipant
   */
  export type user$conversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversationParticipant
     */
    select?: conversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversationParticipant
     */
    omit?: conversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationParticipantInclude<ExtArgs> | null
    where?: conversationParticipantWhereInput
    orderBy?: conversationParticipantOrderByWithRelationInput | conversationParticipantOrderByWithRelationInput[]
    cursor?: conversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * user.forumMessage
   */
  export type user$forumMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumMessage
     */
    select?: forumMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumMessage
     */
    omit?: forumMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumMessageInclude<ExtArgs> | null
    where?: forumMessageWhereInput
    orderBy?: forumMessageOrderByWithRelationInput | forumMessageOrderByWithRelationInput[]
    cursor?: forumMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumMessageScalarFieldEnum | ForumMessageScalarFieldEnum[]
  }

  /**
   * user.forumTopic
   */
  export type user$forumTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forumTopic
     */
    select?: forumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the forumTopic
     */
    omit?: forumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forumTopicInclude<ExtArgs> | null
    where?: forumTopicWhereInput
    orderBy?: forumTopicOrderByWithRelationInput | forumTopicOrderByWithRelationInput[]
    cursor?: forumTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * user.healthIndicator
   */
  export type user$healthIndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the healthIndicator
     */
    select?: healthIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the healthIndicator
     */
    omit?: healthIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: healthIndicatorInclude<ExtArgs> | null
    where?: healthIndicatorWhereInput
    orderBy?: healthIndicatorOrderByWithRelationInput | healthIndicatorOrderByWithRelationInput[]
    cursor?: healthIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthIndicatorScalarFieldEnum | HealthIndicatorScalarFieldEnum[]
  }

  /**
   * user.helpOffer
   */
  export type user$helpOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpOffer
     */
    select?: helpOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpOffer
     */
    omit?: helpOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpOfferInclude<ExtArgs> | null
    where?: helpOfferWhereInput
    orderBy?: helpOfferOrderByWithRelationInput | helpOfferOrderByWithRelationInput[]
    cursor?: helpOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpOfferScalarFieldEnum | HelpOfferScalarFieldEnum[]
  }

  /**
   * user.helpRequest
   */
  export type user$helpRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    where?: helpRequestWhereInput
    orderBy?: helpRequestOrderByWithRelationInput | helpRequestOrderByWithRelationInput[]
    cursor?: helpRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * user.medicationReminder
   */
  export type user$medicationReminderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicationReminder
     */
    select?: medicationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicationReminder
     */
    omit?: medicationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicationReminderInclude<ExtArgs> | null
    where?: medicationReminderWhereInput
    orderBy?: medicationReminderOrderByWithRelationInput | medicationReminderOrderByWithRelationInput[]
    cursor?: medicationReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationReminderScalarFieldEnum | MedicationReminderScalarFieldEnum[]
  }

  /**
   * user.message
   */
  export type user$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * user.notification
   */
  export type user$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * user.notificationPreferences
   */
  export type user$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPreferences
     */
    select?: notificationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPreferences
     */
    omit?: notificationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPreferencesInclude<ExtArgs> | null
    where?: notificationPreferencesWhereInput
  }

  /**
   * user.projectMember
   */
  export type user$projectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectMember
     */
    select?: projectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectMember
     */
    omit?: projectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectMemberInclude<ExtArgs> | null
    where?: projectMemberWhereInput
    orderBy?: projectMemberOrderByWithRelationInput | projectMemberOrderByWithRelationInput[]
    cursor?: projectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * user.projectTask
   */
  export type user$projectTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectTask
     */
    select?: projectTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectTask
     */
    omit?: projectTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectTaskInclude<ExtArgs> | null
    where?: projectTaskWhereInput
    orderBy?: projectTaskOrderByWithRelationInput | projectTaskOrderByWithRelationInput[]
    cursor?: projectTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * user.resource
   */
  export type user$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    where?: resourceWhereInput
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    cursor?: resourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * user.serviceCompleted
   */
  export type user$serviceCompletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCompleted
     */
    select?: serviceCompletedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCompleted
     */
    omit?: serviceCompletedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCompletedInclude<ExtArgs> | null
    where?: serviceCompletedWhereInput
    orderBy?: serviceCompletedOrderByWithRelationInput | serviceCompletedOrderByWithRelationInput[]
    cursor?: serviceCompletedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceCompletedScalarFieldEnum | ServiceCompletedScalarFieldEnum[]
  }

  /**
   * user.serviceRating
   */
  export type user$serviceRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceRating
     */
    select?: serviceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceRating
     */
    omit?: serviceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceRatingInclude<ExtArgs> | null
    where?: serviceRatingWhereInput
    orderBy?: serviceRatingOrderByWithRelationInput | serviceRatingOrderByWithRelationInput[]
    cursor?: serviceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * user.surveyResponse
   */
  export type user$surveyResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyResponse
     */
    select?: surveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyResponse
     */
    omit?: surveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyResponseInclude<ExtArgs> | null
    where?: surveyResponseWhereInput
    orderBy?: surveyResponseOrderByWithRelationInput | surveyResponseOrderByWithRelationInput[]
    cursor?: surveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * user.trustedContact
   */
  export type user$trustedContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trustedContact
     */
    select?: trustedContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trustedContact
     */
    omit?: trustedContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trustedContactInclude<ExtArgs> | null
    where?: trustedContactWhereInput
    orderBy?: trustedContactOrderByWithRelationInput | trustedContactOrderByWithRelationInput[]
    cursor?: trustedContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrustedContactScalarFieldEnum | TrustedContactScalarFieldEnum[]
  }

  /**
   * user.urbanIssueReport
   */
  export type user$urbanIssueReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    where?: urbanIssueReportWhereInput
    orderBy?: urbanIssueReportOrderByWithRelationInput | urbanIssueReportOrderByWithRelationInput[]
    cursor?: urbanIssueReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UrbanIssueReportScalarFieldEnum | UrbanIssueReportScalarFieldEnum[]
  }

  /**
   * user.userActivity
   */
  export type user$userActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    where?: userActivityWhereInput
    orderBy?: userActivityOrderByWithRelationInput | userActivityOrderByWithRelationInput[]
    cursor?: userActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * user.userBadge
   */
  export type user$userBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    where?: userBadgeWhereInput
    orderBy?: userBadgeOrderByWithRelationInput | userBadgeOrderByWithRelationInput[]
    cursor?: userBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * user.userDevice
   */
  export type user$userDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    where?: userDeviceWhereInput
    orderBy?: userDeviceOrderByWithRelationInput | userDeviceOrderByWithRelationInput[]
    cursor?: userDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * user.userSkill
   */
  export type user$userSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    where?: userSkillWhereInput
    orderBy?: userSkillOrderByWithRelationInput | userSkillOrderByWithRelationInput[]
    cursor?: userSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * user.userStatistics
   */
  export type user$userStatisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    where?: userStatisticsWhereInput
  }

  /**
   * user.videoCall
   */
  export type user$videoCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    where?: videoCallWhereInput
    orderBy?: videoCallOrderByWithRelationInput | videoCallOrderByWithRelationInput[]
    cursor?: videoCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * user.wellnessGoal
   */
  export type user$wellnessGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    where?: wellnessGoalWhereInput
    orderBy?: wellnessGoalOrderByWithRelationInput | wellnessGoalOrderByWithRelationInput[]
    cursor?: wellnessGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellnessGoalScalarFieldEnum | WellnessGoalScalarFieldEnum[]
  }

  /**
   * user.session
   */
  export type user$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    cursor?: sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model userActivity
   */

  export type AggregateUserActivity = {
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  export type UserActivityAvgAggregateOutputType = {
    durationMinutes: number | null
    perceivedDifficultyLevel: number | null
    enjoymentLevel: number | null
  }

  export type UserActivitySumAggregateOutputType = {
    durationMinutes: number | null
    perceivedDifficultyLevel: number | null
    enjoymentLevel: number | null
  }

  export type UserActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    completionDate: Date | null
    exerciseProgramId: string | null
    cognitiveExerciseId: string | null
    durationMinutes: number | null
    perceivedDifficultyLevel: number | null
    enjoymentLevel: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    completionDate: Date | null
    exerciseProgramId: string | null
    cognitiveExerciseId: string | null
    durationMinutes: number | null
    perceivedDifficultyLevel: number | null
    enjoymentLevel: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserActivityCountAggregateOutputType = {
    id: number
    userId: number
    completionDate: number
    exerciseProgramId: number
    cognitiveExerciseId: number
    durationMinutes: number
    perceivedDifficultyLevel: number
    enjoymentLevel: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserActivityAvgAggregateInputType = {
    durationMinutes?: true
    perceivedDifficultyLevel?: true
    enjoymentLevel?: true
  }

  export type UserActivitySumAggregateInputType = {
    durationMinutes?: true
    perceivedDifficultyLevel?: true
    enjoymentLevel?: true
  }

  export type UserActivityMinAggregateInputType = {
    id?: true
    userId?: true
    completionDate?: true
    exerciseProgramId?: true
    cognitiveExerciseId?: true
    durationMinutes?: true
    perceivedDifficultyLevel?: true
    enjoymentLevel?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    completionDate?: true
    exerciseProgramId?: true
    cognitiveExerciseId?: true
    durationMinutes?: true
    perceivedDifficultyLevel?: true
    enjoymentLevel?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserActivityCountAggregateInputType = {
    id?: true
    userId?: true
    completionDate?: true
    exerciseProgramId?: true
    cognitiveExerciseId?: true
    durationMinutes?: true
    perceivedDifficultyLevel?: true
    enjoymentLevel?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userActivity to aggregate.
     */
    where?: userActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivities to fetch.
     */
    orderBy?: userActivityOrderByWithRelationInput | userActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userActivities
    **/
    _count?: true | UserActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityMaxAggregateInputType
  }

  export type GetUserActivityAggregateType<T extends UserActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivity[P]>
      : GetScalarType<T[P], AggregateUserActivity[P]>
  }




  export type userActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userActivityWhereInput
    orderBy?: userActivityOrderByWithAggregationInput | userActivityOrderByWithAggregationInput[]
    by: UserActivityScalarFieldEnum[] | UserActivityScalarFieldEnum
    having?: userActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityCountAggregateInputType | true
    _avg?: UserActivityAvgAggregateInputType
    _sum?: UserActivitySumAggregateInputType
    _min?: UserActivityMinAggregateInputType
    _max?: UserActivityMaxAggregateInputType
  }

  export type UserActivityGroupByOutputType = {
    id: string
    userId: string
    completionDate: Date
    exerciseProgramId: string | null
    cognitiveExerciseId: string | null
    durationMinutes: number | null
    perceivedDifficultyLevel: number | null
    enjoymentLevel: number | null
    comment: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  type GetUserActivityGroupByPayload<T extends userActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
        }
      >
    >


  export type userActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completionDate?: boolean
    exerciseProgramId?: boolean
    cognitiveExerciseId?: boolean
    durationMinutes?: boolean
    perceivedDifficultyLevel?: boolean
    enjoymentLevel?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cognitiveExercise?: boolean | userActivity$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | userActivity$exerciseProgramArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type userActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completionDate?: boolean
    exerciseProgramId?: boolean
    cognitiveExerciseId?: boolean
    durationMinutes?: boolean
    perceivedDifficultyLevel?: boolean
    enjoymentLevel?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cognitiveExercise?: boolean | userActivity$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | userActivity$exerciseProgramArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type userActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completionDate?: boolean
    exerciseProgramId?: boolean
    cognitiveExerciseId?: boolean
    durationMinutes?: boolean
    perceivedDifficultyLevel?: boolean
    enjoymentLevel?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cognitiveExercise?: boolean | userActivity$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | userActivity$exerciseProgramArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type userActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    completionDate?: boolean
    exerciseProgramId?: boolean
    cognitiveExerciseId?: boolean
    durationMinutes?: boolean
    perceivedDifficultyLevel?: boolean
    enjoymentLevel?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "completionDate" | "exerciseProgramId" | "cognitiveExerciseId" | "durationMinutes" | "perceivedDifficultyLevel" | "enjoymentLevel" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["userActivity"]>
  export type userActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveExercise?: boolean | userActivity$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | userActivity$exerciseProgramArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveExercise?: boolean | userActivity$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | userActivity$exerciseProgramArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveExercise?: boolean | userActivity$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | userActivity$exerciseProgramArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userActivity"
    objects: {
      cognitiveExercise: Prisma.$cognitiveExercisePayload<ExtArgs> | null
      exerciseProgram: Prisma.$exerciseProgramPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      completionDate: Date
      exerciseProgramId: string | null
      cognitiveExerciseId: string | null
      durationMinutes: number | null
      perceivedDifficultyLevel: number | null
      enjoymentLevel: number | null
      comment: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userActivity"]>
    composites: {}
  }

  type userActivityGetPayload<S extends boolean | null | undefined | userActivityDefaultArgs> = $Result.GetResult<Prisma.$userActivityPayload, S>

  type userActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserActivityCountAggregateInputType | true
    }

  export interface userActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userActivity'], meta: { name: 'userActivity' } }
    /**
     * Find zero or one UserActivity that matches the filter.
     * @param {userActivityFindUniqueArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userActivityFindUniqueArgs>(args: SelectSubset<T, userActivityFindUniqueArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userActivityFindUniqueOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, userActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivityFindFirstArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userActivityFindFirstArgs>(args?: SelectSubset<T, userActivityFindFirstArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivityFindFirstOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, userActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivities
     * const userActivities = await prisma.userActivity.findMany()
     * 
     * // Get first 10 UserActivities
     * const userActivities = await prisma.userActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userActivityFindManyArgs>(args?: SelectSubset<T, userActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserActivity.
     * @param {userActivityCreateArgs} args - Arguments to create a UserActivity.
     * @example
     * // Create one UserActivity
     * const UserActivity = await prisma.userActivity.create({
     *   data: {
     *     // ... data to create a UserActivity
     *   }
     * })
     * 
     */
    create<T extends userActivityCreateArgs>(args: SelectSubset<T, userActivityCreateArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserActivities.
     * @param {userActivityCreateManyArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userActivityCreateManyArgs>(args?: SelectSubset<T, userActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActivities and returns the data saved in the database.
     * @param {userActivityCreateManyAndReturnArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActivities and only return the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, userActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserActivity.
     * @param {userActivityDeleteArgs} args - Arguments to delete one UserActivity.
     * @example
     * // Delete one UserActivity
     * const UserActivity = await prisma.userActivity.delete({
     *   where: {
     *     // ... filter to delete one UserActivity
     *   }
     * })
     * 
     */
    delete<T extends userActivityDeleteArgs>(args: SelectSubset<T, userActivityDeleteArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserActivity.
     * @param {userActivityUpdateArgs} args - Arguments to update one UserActivity.
     * @example
     * // Update one UserActivity
     * const userActivity = await prisma.userActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userActivityUpdateArgs>(args: SelectSubset<T, userActivityUpdateArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserActivities.
     * @param {userActivityDeleteManyArgs} args - Arguments to filter UserActivities to delete.
     * @example
     * // Delete a few UserActivities
     * const { count } = await prisma.userActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userActivityDeleteManyArgs>(args?: SelectSubset<T, userActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userActivityUpdateManyArgs>(args: SelectSubset<T, userActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities and returns the data updated in the database.
     * @param {userActivityUpdateManyAndReturnArgs} args - Arguments to update many UserActivities.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserActivities and only return the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, userActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserActivity.
     * @param {userActivityUpsertArgs} args - Arguments to update or create a UserActivity.
     * @example
     * // Update or create a UserActivity
     * const userActivity = await prisma.userActivity.upsert({
     *   create: {
     *     // ... data to create a UserActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivity we want to update
     *   }
     * })
     */
    upsert<T extends userActivityUpsertArgs>(args: SelectSubset<T, userActivityUpsertArgs<ExtArgs>>): Prisma__userActivityClient<$Result.GetResult<Prisma.$userActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivityCountArgs} args - Arguments to filter UserActivities to count.
     * @example
     * // Count the number of UserActivities
     * const count = await prisma.userActivity.count({
     *   where: {
     *     // ... the filter for the UserActivities we want to count
     *   }
     * })
    **/
    count<T extends userActivityCountArgs>(
      args?: Subset<T, userActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityAggregateArgs>(args: Subset<T, UserActivityAggregateArgs>): Prisma.PrismaPromise<GetUserActivityAggregateType<T>>

    /**
     * Group by UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userActivityGroupByArgs['orderBy'] }
        : { orderBy?: userActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userActivity model
   */
  readonly fields: userActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cognitiveExercise<T extends userActivity$cognitiveExerciseArgs<ExtArgs> = {}>(args?: Subset<T, userActivity$cognitiveExerciseArgs<ExtArgs>>): Prisma__cognitiveExerciseClient<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    exerciseProgram<T extends userActivity$exerciseProgramArgs<ExtArgs> = {}>(args?: Subset<T, userActivity$exerciseProgramArgs<ExtArgs>>): Prisma__exerciseProgramClient<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userActivity model
   */
  interface userActivityFieldRefs {
    readonly id: FieldRef<"userActivity", 'String'>
    readonly userId: FieldRef<"userActivity", 'String'>
    readonly completionDate: FieldRef<"userActivity", 'DateTime'>
    readonly exerciseProgramId: FieldRef<"userActivity", 'String'>
    readonly cognitiveExerciseId: FieldRef<"userActivity", 'String'>
    readonly durationMinutes: FieldRef<"userActivity", 'Int'>
    readonly perceivedDifficultyLevel: FieldRef<"userActivity", 'Int'>
    readonly enjoymentLevel: FieldRef<"userActivity", 'Int'>
    readonly comment: FieldRef<"userActivity", 'String'>
    readonly createdAt: FieldRef<"userActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"userActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userActivity findUnique
   */
  export type userActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * Filter, which userActivity to fetch.
     */
    where: userActivityWhereUniqueInput
  }

  /**
   * userActivity findUniqueOrThrow
   */
  export type userActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * Filter, which userActivity to fetch.
     */
    where: userActivityWhereUniqueInput
  }

  /**
   * userActivity findFirst
   */
  export type userActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * Filter, which userActivity to fetch.
     */
    where?: userActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivities to fetch.
     */
    orderBy?: userActivityOrderByWithRelationInput | userActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userActivities.
     */
    cursor?: userActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * userActivity findFirstOrThrow
   */
  export type userActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * Filter, which userActivity to fetch.
     */
    where?: userActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivities to fetch.
     */
    orderBy?: userActivityOrderByWithRelationInput | userActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userActivities.
     */
    cursor?: userActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * userActivity findMany
   */
  export type userActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * Filter, which userActivities to fetch.
     */
    where?: userActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivities to fetch.
     */
    orderBy?: userActivityOrderByWithRelationInput | userActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userActivities.
     */
    cursor?: userActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivities.
     */
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * userActivity create
   */
  export type userActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a userActivity.
     */
    data: XOR<userActivityCreateInput, userActivityUncheckedCreateInput>
  }

  /**
   * userActivity createMany
   */
  export type userActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userActivities.
     */
    data: userActivityCreateManyInput | userActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userActivity createManyAndReturn
   */
  export type userActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * The data used to create many userActivities.
     */
    data: userActivityCreateManyInput | userActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userActivity update
   */
  export type userActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a userActivity.
     */
    data: XOR<userActivityUpdateInput, userActivityUncheckedUpdateInput>
    /**
     * Choose, which userActivity to update.
     */
    where: userActivityWhereUniqueInput
  }

  /**
   * userActivity updateMany
   */
  export type userActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userActivities.
     */
    data: XOR<userActivityUpdateManyMutationInput, userActivityUncheckedUpdateManyInput>
    /**
     * Filter which userActivities to update
     */
    where?: userActivityWhereInput
    /**
     * Limit how many userActivities to update.
     */
    limit?: number
  }

  /**
   * userActivity updateManyAndReturn
   */
  export type userActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * The data used to update userActivities.
     */
    data: XOR<userActivityUpdateManyMutationInput, userActivityUncheckedUpdateManyInput>
    /**
     * Filter which userActivities to update
     */
    where?: userActivityWhereInput
    /**
     * Limit how many userActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userActivity upsert
   */
  export type userActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the userActivity to update in case it exists.
     */
    where: userActivityWhereUniqueInput
    /**
     * In case the userActivity found by the `where` argument doesn't exist, create a new userActivity with this data.
     */
    create: XOR<userActivityCreateInput, userActivityUncheckedCreateInput>
    /**
     * In case the userActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userActivityUpdateInput, userActivityUncheckedUpdateInput>
  }

  /**
   * userActivity delete
   */
  export type userActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
    /**
     * Filter which userActivity to delete.
     */
    where: userActivityWhereUniqueInput
  }

  /**
   * userActivity deleteMany
   */
  export type userActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userActivities to delete
     */
    where?: userActivityWhereInput
    /**
     * Limit how many userActivities to delete.
     */
    limit?: number
  }

  /**
   * userActivity.cognitiveExercise
   */
  export type userActivity$cognitiveExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    where?: cognitiveExerciseWhereInput
  }

  /**
   * userActivity.exerciseProgram
   */
  export type userActivity$exerciseProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    where?: exerciseProgramWhereInput
  }

  /**
   * userActivity without action
   */
  export type userActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivity
     */
    select?: userActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivity
     */
    omit?: userActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivityInclude<ExtArgs> | null
  }


  /**
   * Model userBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeMinAggregateOutputType = {
    userId: string | null
    badgeId: string | null
    achievementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    userId: string | null
    badgeId: string | null
    achievementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    userId: number
    badgeId: number
    achievementDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBadgeMinAggregateInputType = {
    userId?: true
    badgeId?: true
    achievementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    userId?: true
    badgeId?: true
    achievementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    userId?: true
    badgeId?: true
    achievementDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userBadge to aggregate.
     */
    where?: userBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userBadges to fetch.
     */
    orderBy?: userBadgeOrderByWithRelationInput | userBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type userBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userBadgeWhereInput
    orderBy?: userBadgeOrderByWithAggregationInput | userBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: userBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    userId: string
    badgeId: string
    achievementDate: Date
    createdAt: Date
    updatedAt: Date | null
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends userBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type userBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    badgeId?: boolean
    achievementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type userBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    badgeId?: boolean
    achievementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type userBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    badgeId?: boolean
    achievementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type userBadgeSelectScalar = {
    userId?: boolean
    badgeId?: boolean
    achievementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "badgeId" | "achievementDate" | "createdAt" | "updatedAt", ExtArgs["result"]["userBadge"]>
  export type userBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userBadge"
    objects: {
      badge: Prisma.$badgePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      badgeId: string
      achievementDate: Date
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type userBadgeGetPayload<S extends boolean | null | undefined | userBadgeDefaultArgs> = $Result.GetResult<Prisma.$userBadgePayload, S>

  type userBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface userBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userBadge'], meta: { name: 'userBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {userBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userBadgeFindUniqueArgs>(args: SelectSubset<T, userBadgeFindUniqueArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, userBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userBadgeFindFirstArgs>(args?: SelectSubset<T, userBadgeFindFirstArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, userBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userBadgeWithUserIdOnly = await prisma.userBadge.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends userBadgeFindManyArgs>(args?: SelectSubset<T, userBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBadge.
     * @param {userBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends userBadgeCreateArgs>(args: SelectSubset<T, userBadgeCreateArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBadges.
     * @param {userBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userBadgeCreateManyArgs>(args?: SelectSubset<T, userBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {userBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `userId`
     * const userBadgeWithUserIdOnly = await prisma.userBadge.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, userBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBadge.
     * @param {userBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends userBadgeDeleteArgs>(args: SelectSubset<T, userBadgeDeleteArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBadge.
     * @param {userBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userBadgeUpdateArgs>(args: SelectSubset<T, userBadgeUpdateArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBadges.
     * @param {userBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userBadgeDeleteManyArgs>(args?: SelectSubset<T, userBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userBadgeUpdateManyArgs>(args: SelectSubset<T, userBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges and returns the data updated in the database.
     * @param {userBadgeUpdateManyAndReturnArgs} args - Arguments to update many UserBadges.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBadges and only return the `userId`
     * const userBadgeWithUserIdOnly = await prisma.userBadge.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, userBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBadge.
     * @param {userBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends userBadgeUpsertArgs>(args: SelectSubset<T, userBadgeUpsertArgs<ExtArgs>>): Prisma__userBadgeClient<$Result.GetResult<Prisma.$userBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends userBadgeCountArgs>(
      args?: Subset<T, userBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userBadgeGroupByArgs['orderBy'] }
        : { orderBy?: userBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userBadge model
   */
  readonly fields: userBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends badgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, badgeDefaultArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userBadge model
   */
  interface userBadgeFieldRefs {
    readonly userId: FieldRef<"userBadge", 'String'>
    readonly badgeId: FieldRef<"userBadge", 'String'>
    readonly achievementDate: FieldRef<"userBadge", 'DateTime'>
    readonly createdAt: FieldRef<"userBadge", 'DateTime'>
    readonly updatedAt: FieldRef<"userBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userBadge findUnique
   */
  export type userBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * Filter, which userBadge to fetch.
     */
    where: userBadgeWhereUniqueInput
  }

  /**
   * userBadge findUniqueOrThrow
   */
  export type userBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * Filter, which userBadge to fetch.
     */
    where: userBadgeWhereUniqueInput
  }

  /**
   * userBadge findFirst
   */
  export type userBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * Filter, which userBadge to fetch.
     */
    where?: userBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userBadges to fetch.
     */
    orderBy?: userBadgeOrderByWithRelationInput | userBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userBadges.
     */
    cursor?: userBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * userBadge findFirstOrThrow
   */
  export type userBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * Filter, which userBadge to fetch.
     */
    where?: userBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userBadges to fetch.
     */
    orderBy?: userBadgeOrderByWithRelationInput | userBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userBadges.
     */
    cursor?: userBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * userBadge findMany
   */
  export type userBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * Filter, which userBadges to fetch.
     */
    where?: userBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userBadges to fetch.
     */
    orderBy?: userBadgeOrderByWithRelationInput | userBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userBadges.
     */
    cursor?: userBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * userBadge create
   */
  export type userBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a userBadge.
     */
    data: XOR<userBadgeCreateInput, userBadgeUncheckedCreateInput>
  }

  /**
   * userBadge createMany
   */
  export type userBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userBadges.
     */
    data: userBadgeCreateManyInput | userBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userBadge createManyAndReturn
   */
  export type userBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many userBadges.
     */
    data: userBadgeCreateManyInput | userBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userBadge update
   */
  export type userBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a userBadge.
     */
    data: XOR<userBadgeUpdateInput, userBadgeUncheckedUpdateInput>
    /**
     * Choose, which userBadge to update.
     */
    where: userBadgeWhereUniqueInput
  }

  /**
   * userBadge updateMany
   */
  export type userBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userBadges.
     */
    data: XOR<userBadgeUpdateManyMutationInput, userBadgeUncheckedUpdateManyInput>
    /**
     * Filter which userBadges to update
     */
    where?: userBadgeWhereInput
    /**
     * Limit how many userBadges to update.
     */
    limit?: number
  }

  /**
   * userBadge updateManyAndReturn
   */
  export type userBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * The data used to update userBadges.
     */
    data: XOR<userBadgeUpdateManyMutationInput, userBadgeUncheckedUpdateManyInput>
    /**
     * Filter which userBadges to update
     */
    where?: userBadgeWhereInput
    /**
     * Limit how many userBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userBadge upsert
   */
  export type userBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the userBadge to update in case it exists.
     */
    where: userBadgeWhereUniqueInput
    /**
     * In case the userBadge found by the `where` argument doesn't exist, create a new userBadge with this data.
     */
    create: XOR<userBadgeCreateInput, userBadgeUncheckedCreateInput>
    /**
     * In case the userBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userBadgeUpdateInput, userBadgeUncheckedUpdateInput>
  }

  /**
   * userBadge delete
   */
  export type userBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
    /**
     * Filter which userBadge to delete.
     */
    where: userBadgeWhereUniqueInput
  }

  /**
   * userBadge deleteMany
   */
  export type userBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userBadges to delete
     */
    where?: userBadgeWhereInput
    /**
     * Limit how many userBadges to delete.
     */
    limit?: number
  }

  /**
   * userBadge without action
   */
  export type userBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userBadge
     */
    select?: userBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userBadge
     */
    omit?: userBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userBadgeInclude<ExtArgs> | null
  }


  /**
   * Model userDevice
   */

  export type AggregateUserDevice = {
    _count: UserDeviceCountAggregateOutputType | null
    _min: UserDeviceMinAggregateOutputType | null
    _max: UserDeviceMaxAggregateOutputType | null
  }

  export type UserDeviceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: string | null
    deviceName: string | null
    operatingSystem: string | null
    notificationToken: string | null
    lastConnection: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDeviceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: string | null
    deviceName: string | null
    operatingSystem: string | null
    notificationToken: string | null
    lastConnection: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDeviceCountAggregateOutputType = {
    id: number
    userId: number
    deviceType: number
    deviceName: number
    operatingSystem: number
    notificationToken: number
    lastConnection: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserDeviceMinAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceName?: true
    operatingSystem?: true
    notificationToken?: true
    lastConnection?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDeviceMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceName?: true
    operatingSystem?: true
    notificationToken?: true
    lastConnection?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDeviceCountAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceName?: true
    operatingSystem?: true
    notificationToken?: true
    lastConnection?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userDevice to aggregate.
     */
    where?: userDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userDevices to fetch.
     */
    orderBy?: userDeviceOrderByWithRelationInput | userDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userDevices
    **/
    _count?: true | UserDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDeviceMaxAggregateInputType
  }

  export type GetUserDeviceAggregateType<T extends UserDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDevice[P]>
      : GetScalarType<T[P], AggregateUserDevice[P]>
  }




  export type userDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userDeviceWhereInput
    orderBy?: userDeviceOrderByWithAggregationInput | userDeviceOrderByWithAggregationInput[]
    by: UserDeviceScalarFieldEnum[] | UserDeviceScalarFieldEnum
    having?: userDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDeviceCountAggregateInputType | true
    _min?: UserDeviceMinAggregateInputType
    _max?: UserDeviceMaxAggregateInputType
  }

  export type UserDeviceGroupByOutputType = {
    id: string
    userId: string
    deviceType: string
    deviceName: string | null
    operatingSystem: string | null
    notificationToken: string
    lastConnection: Date
    createdAt: Date
    updatedAt: Date | null
    _count: UserDeviceCountAggregateOutputType | null
    _min: UserDeviceMinAggregateOutputType | null
    _max: UserDeviceMaxAggregateOutputType | null
  }

  type GetUserDeviceGroupByPayload<T extends userDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], UserDeviceGroupByOutputType[P]>
        }
      >
    >


  export type userDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    operatingSystem?: boolean
    notificationToken?: boolean
    lastConnection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDevice$userArgs<ExtArgs>
  }, ExtArgs["result"]["userDevice"]>

  export type userDeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    operatingSystem?: boolean
    notificationToken?: boolean
    lastConnection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDevice$userArgs<ExtArgs>
  }, ExtArgs["result"]["userDevice"]>

  export type userDeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    operatingSystem?: boolean
    notificationToken?: boolean
    lastConnection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDevice$userArgs<ExtArgs>
  }, ExtArgs["result"]["userDevice"]>

  export type userDeviceSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    operatingSystem?: boolean
    notificationToken?: boolean
    lastConnection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceType" | "deviceName" | "operatingSystem" | "notificationToken" | "lastConnection" | "createdAt" | "updatedAt", ExtArgs["result"]["userDevice"]>
  export type userDeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDevice$userArgs<ExtArgs>
  }
  export type userDeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDevice$userArgs<ExtArgs>
  }
  export type userDeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDevice$userArgs<ExtArgs>
  }

  export type $userDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userDevice"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceType: string
      deviceName: string | null
      operatingSystem: string | null
      notificationToken: string
      lastConnection: Date
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userDevice"]>
    composites: {}
  }

  type userDeviceGetPayload<S extends boolean | null | undefined | userDeviceDefaultArgs> = $Result.GetResult<Prisma.$userDevicePayload, S>

  type userDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDeviceCountAggregateInputType | true
    }

  export interface userDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userDevice'], meta: { name: 'userDevice' } }
    /**
     * Find zero or one UserDevice that matches the filter.
     * @param {userDeviceFindUniqueArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userDeviceFindUniqueArgs>(args: SelectSubset<T, userDeviceFindUniqueArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userDeviceFindUniqueOrThrowArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, userDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userDeviceFindFirstArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userDeviceFindFirstArgs>(args?: SelectSubset<T, userDeviceFindFirstArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userDeviceFindFirstOrThrowArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, userDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDevices
     * const userDevices = await prisma.userDevice.findMany()
     * 
     * // Get first 10 UserDevices
     * const userDevices = await prisma.userDevice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDeviceWithIdOnly = await prisma.userDevice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userDeviceFindManyArgs>(args?: SelectSubset<T, userDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserDevice.
     * @param {userDeviceCreateArgs} args - Arguments to create a UserDevice.
     * @example
     * // Create one UserDevice
     * const UserDevice = await prisma.userDevice.create({
     *   data: {
     *     // ... data to create a UserDevice
     *   }
     * })
     * 
     */
    create<T extends userDeviceCreateArgs>(args: SelectSubset<T, userDeviceCreateArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserDevices.
     * @param {userDeviceCreateManyArgs} args - Arguments to create many UserDevices.
     * @example
     * // Create many UserDevices
     * const userDevice = await prisma.userDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userDeviceCreateManyArgs>(args?: SelectSubset<T, userDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDevices and returns the data saved in the database.
     * @param {userDeviceCreateManyAndReturnArgs} args - Arguments to create many UserDevices.
     * @example
     * // Create many UserDevices
     * const userDevice = await prisma.userDevice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDevices and only return the `id`
     * const userDeviceWithIdOnly = await prisma.userDevice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userDeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, userDeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserDevice.
     * @param {userDeviceDeleteArgs} args - Arguments to delete one UserDevice.
     * @example
     * // Delete one UserDevice
     * const UserDevice = await prisma.userDevice.delete({
     *   where: {
     *     // ... filter to delete one UserDevice
     *   }
     * })
     * 
     */
    delete<T extends userDeviceDeleteArgs>(args: SelectSubset<T, userDeviceDeleteArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserDevice.
     * @param {userDeviceUpdateArgs} args - Arguments to update one UserDevice.
     * @example
     * // Update one UserDevice
     * const userDevice = await prisma.userDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userDeviceUpdateArgs>(args: SelectSubset<T, userDeviceUpdateArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserDevices.
     * @param {userDeviceDeleteManyArgs} args - Arguments to filter UserDevices to delete.
     * @example
     * // Delete a few UserDevices
     * const { count } = await prisma.userDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeviceDeleteManyArgs>(args?: SelectSubset<T, userDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDevices
     * const userDevice = await prisma.userDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userDeviceUpdateManyArgs>(args: SelectSubset<T, userDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDevices and returns the data updated in the database.
     * @param {userDeviceUpdateManyAndReturnArgs} args - Arguments to update many UserDevices.
     * @example
     * // Update many UserDevices
     * const userDevice = await prisma.userDevice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDevices and only return the `id`
     * const userDeviceWithIdOnly = await prisma.userDevice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userDeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, userDeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserDevice.
     * @param {userDeviceUpsertArgs} args - Arguments to update or create a UserDevice.
     * @example
     * // Update or create a UserDevice
     * const userDevice = await prisma.userDevice.upsert({
     *   create: {
     *     // ... data to create a UserDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDevice we want to update
     *   }
     * })
     */
    upsert<T extends userDeviceUpsertArgs>(args: SelectSubset<T, userDeviceUpsertArgs<ExtArgs>>): Prisma__userDeviceClient<$Result.GetResult<Prisma.$userDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userDeviceCountArgs} args - Arguments to filter UserDevices to count.
     * @example
     * // Count the number of UserDevices
     * const count = await prisma.userDevice.count({
     *   where: {
     *     // ... the filter for the UserDevices we want to count
     *   }
     * })
    **/
    count<T extends userDeviceCountArgs>(
      args?: Subset<T, userDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDeviceAggregateArgs>(args: Subset<T, UserDeviceAggregateArgs>): Prisma.PrismaPromise<GetUserDeviceAggregateType<T>>

    /**
     * Group by UserDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userDeviceGroupByArgs['orderBy'] }
        : { orderBy?: userDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userDevice model
   */
  readonly fields: userDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDevice$userArgs<ExtArgs> = {}>(args?: Subset<T, userDevice$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userDevice model
   */
  interface userDeviceFieldRefs {
    readonly id: FieldRef<"userDevice", 'String'>
    readonly userId: FieldRef<"userDevice", 'String'>
    readonly deviceType: FieldRef<"userDevice", 'String'>
    readonly deviceName: FieldRef<"userDevice", 'String'>
    readonly operatingSystem: FieldRef<"userDevice", 'String'>
    readonly notificationToken: FieldRef<"userDevice", 'String'>
    readonly lastConnection: FieldRef<"userDevice", 'DateTime'>
    readonly createdAt: FieldRef<"userDevice", 'DateTime'>
    readonly updatedAt: FieldRef<"userDevice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userDevice findUnique
   */
  export type userDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * Filter, which userDevice to fetch.
     */
    where: userDeviceWhereUniqueInput
  }

  /**
   * userDevice findUniqueOrThrow
   */
  export type userDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * Filter, which userDevice to fetch.
     */
    where: userDeviceWhereUniqueInput
  }

  /**
   * userDevice findFirst
   */
  export type userDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * Filter, which userDevice to fetch.
     */
    where?: userDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userDevices to fetch.
     */
    orderBy?: userDeviceOrderByWithRelationInput | userDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userDevices.
     */
    cursor?: userDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userDevices.
     */
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * userDevice findFirstOrThrow
   */
  export type userDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * Filter, which userDevice to fetch.
     */
    where?: userDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userDevices to fetch.
     */
    orderBy?: userDeviceOrderByWithRelationInput | userDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userDevices.
     */
    cursor?: userDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userDevices.
     */
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * userDevice findMany
   */
  export type userDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * Filter, which userDevices to fetch.
     */
    where?: userDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userDevices to fetch.
     */
    orderBy?: userDeviceOrderByWithRelationInput | userDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userDevices.
     */
    cursor?: userDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userDevices.
     */
    skip?: number
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * userDevice create
   */
  export type userDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a userDevice.
     */
    data: XOR<userDeviceCreateInput, userDeviceUncheckedCreateInput>
  }

  /**
   * userDevice createMany
   */
  export type userDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userDevices.
     */
    data: userDeviceCreateManyInput | userDeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userDevice createManyAndReturn
   */
  export type userDeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * The data used to create many userDevices.
     */
    data: userDeviceCreateManyInput | userDeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userDevice update
   */
  export type userDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a userDevice.
     */
    data: XOR<userDeviceUpdateInput, userDeviceUncheckedUpdateInput>
    /**
     * Choose, which userDevice to update.
     */
    where: userDeviceWhereUniqueInput
  }

  /**
   * userDevice updateMany
   */
  export type userDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userDevices.
     */
    data: XOR<userDeviceUpdateManyMutationInput, userDeviceUncheckedUpdateManyInput>
    /**
     * Filter which userDevices to update
     */
    where?: userDeviceWhereInput
    /**
     * Limit how many userDevices to update.
     */
    limit?: number
  }

  /**
   * userDevice updateManyAndReturn
   */
  export type userDeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * The data used to update userDevices.
     */
    data: XOR<userDeviceUpdateManyMutationInput, userDeviceUncheckedUpdateManyInput>
    /**
     * Filter which userDevices to update
     */
    where?: userDeviceWhereInput
    /**
     * Limit how many userDevices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userDevice upsert
   */
  export type userDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the userDevice to update in case it exists.
     */
    where: userDeviceWhereUniqueInput
    /**
     * In case the userDevice found by the `where` argument doesn't exist, create a new userDevice with this data.
     */
    create: XOR<userDeviceCreateInput, userDeviceUncheckedCreateInput>
    /**
     * In case the userDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userDeviceUpdateInput, userDeviceUncheckedUpdateInput>
  }

  /**
   * userDevice delete
   */
  export type userDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
    /**
     * Filter which userDevice to delete.
     */
    where: userDeviceWhereUniqueInput
  }

  /**
   * userDevice deleteMany
   */
  export type userDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userDevices to delete
     */
    where?: userDeviceWhereInput
    /**
     * Limit how many userDevices to delete.
     */
    limit?: number
  }

  /**
   * userDevice.user
   */
  export type userDevice$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * userDevice without action
   */
  export type userDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userDevice
     */
    select?: userDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userDevice
     */
    omit?: userDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userDeviceInclude<ExtArgs> | null
  }


  /**
   * Model userSkill
   */

  export type AggregateUserSkill = {
    _count: UserSkillCountAggregateOutputType | null
    _avg: UserSkillAvgAggregateOutputType | null
    _sum: UserSkillSumAggregateOutputType | null
    _min: UserSkillMinAggregateOutputType | null
    _max: UserSkillMaxAggregateOutputType | null
  }

  export type UserSkillAvgAggregateOutputType = {
    level: number | null
  }

  export type UserSkillSumAggregateOutputType = {
    level: number | null
  }

  export type UserSkillMinAggregateOutputType = {
    userId: string | null
    skillId: string | null
    level: number | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type UserSkillMaxAggregateOutputType = {
    userId: string | null
    skillId: string | null
    level: number | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type UserSkillCountAggregateOutputType = {
    userId: number
    skillId: number
    level: number
    created_at: number
    updatedAt: number
    _all: number
  }


  export type UserSkillAvgAggregateInputType = {
    level?: true
  }

  export type UserSkillSumAggregateInputType = {
    level?: true
  }

  export type UserSkillMinAggregateInputType = {
    userId?: true
    skillId?: true
    level?: true
    created_at?: true
    updatedAt?: true
  }

  export type UserSkillMaxAggregateInputType = {
    userId?: true
    skillId?: true
    level?: true
    created_at?: true
    updatedAt?: true
  }

  export type UserSkillCountAggregateInputType = {
    userId?: true
    skillId?: true
    level?: true
    created_at?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userSkill to aggregate.
     */
    where?: userSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSkills to fetch.
     */
    orderBy?: userSkillOrderByWithRelationInput | userSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userSkills
    **/
    _count?: true | UserSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkillMaxAggregateInputType
  }

  export type GetUserSkillAggregateType<T extends UserSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkill[P]>
      : GetScalarType<T[P], AggregateUserSkill[P]>
  }




  export type userSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userSkillWhereInput
    orderBy?: userSkillOrderByWithAggregationInput | userSkillOrderByWithAggregationInput[]
    by: UserSkillScalarFieldEnum[] | UserSkillScalarFieldEnum
    having?: userSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkillCountAggregateInputType | true
    _avg?: UserSkillAvgAggregateInputType
    _sum?: UserSkillSumAggregateInputType
    _min?: UserSkillMinAggregateInputType
    _max?: UserSkillMaxAggregateInputType
  }

  export type UserSkillGroupByOutputType = {
    userId: string
    skillId: string
    level: number | null
    created_at: Date
    updatedAt: Date | null
    _count: UserSkillCountAggregateOutputType | null
    _avg: UserSkillAvgAggregateOutputType | null
    _sum: UserSkillSumAggregateOutputType | null
    _min: UserSkillMinAggregateOutputType | null
    _max: UserSkillMaxAggregateOutputType | null
  }

  type GetUserSkillGroupByPayload<T extends userSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkillGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkillGroupByOutputType[P]>
        }
      >
    >


  export type userSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    skillId?: boolean
    level?: boolean
    created_at?: boolean
    updatedAt?: boolean
    skill?: boolean | skillDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type userSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    skillId?: boolean
    level?: boolean
    created_at?: boolean
    updatedAt?: boolean
    skill?: boolean | skillDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type userSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    skillId?: boolean
    level?: boolean
    created_at?: boolean
    updatedAt?: boolean
    skill?: boolean | skillDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type userSkillSelectScalar = {
    userId?: boolean
    skillId?: boolean
    level?: boolean
    created_at?: boolean
    updatedAt?: boolean
  }

  export type userSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "skillId" | "level" | "created_at" | "updatedAt", ExtArgs["result"]["userSkill"]>
  export type userSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | skillDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | skillDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | skillDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userSkill"
    objects: {
      skill: Prisma.$skillPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      skillId: string
      level: number | null
      created_at: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userSkill"]>
    composites: {}
  }

  type userSkillGetPayload<S extends boolean | null | undefined | userSkillDefaultArgs> = $Result.GetResult<Prisma.$userSkillPayload, S>

  type userSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSkillCountAggregateInputType | true
    }

  export interface userSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userSkill'], meta: { name: 'userSkill' } }
    /**
     * Find zero or one UserSkill that matches the filter.
     * @param {userSkillFindUniqueArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userSkillFindUniqueArgs>(args: SelectSubset<T, userSkillFindUniqueArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userSkillFindUniqueOrThrowArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, userSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSkillFindFirstArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userSkillFindFirstArgs>(args?: SelectSubset<T, userSkillFindFirstArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSkillFindFirstOrThrowArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, userSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkills
     * const userSkills = await prisma.userSkill.findMany()
     * 
     * // Get first 10 UserSkills
     * const userSkills = await prisma.userSkill.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSkillWithUserIdOnly = await prisma.userSkill.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends userSkillFindManyArgs>(args?: SelectSubset<T, userSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSkill.
     * @param {userSkillCreateArgs} args - Arguments to create a UserSkill.
     * @example
     * // Create one UserSkill
     * const UserSkill = await prisma.userSkill.create({
     *   data: {
     *     // ... data to create a UserSkill
     *   }
     * })
     * 
     */
    create<T extends userSkillCreateArgs>(args: SelectSubset<T, userSkillCreateArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSkills.
     * @param {userSkillCreateManyArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkill = await prisma.userSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userSkillCreateManyArgs>(args?: SelectSubset<T, userSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSkills and returns the data saved in the database.
     * @param {userSkillCreateManyAndReturnArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkill = await prisma.userSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSkills and only return the `userId`
     * const userSkillWithUserIdOnly = await prisma.userSkill.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, userSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSkill.
     * @param {userSkillDeleteArgs} args - Arguments to delete one UserSkill.
     * @example
     * // Delete one UserSkill
     * const UserSkill = await prisma.userSkill.delete({
     *   where: {
     *     // ... filter to delete one UserSkill
     *   }
     * })
     * 
     */
    delete<T extends userSkillDeleteArgs>(args: SelectSubset<T, userSkillDeleteArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSkill.
     * @param {userSkillUpdateArgs} args - Arguments to update one UserSkill.
     * @example
     * // Update one UserSkill
     * const userSkill = await prisma.userSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userSkillUpdateArgs>(args: SelectSubset<T, userSkillUpdateArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSkills.
     * @param {userSkillDeleteManyArgs} args - Arguments to filter UserSkills to delete.
     * @example
     * // Delete a few UserSkills
     * const { count } = await prisma.userSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userSkillDeleteManyArgs>(args?: SelectSubset<T, userSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkills
     * const userSkill = await prisma.userSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userSkillUpdateManyArgs>(args: SelectSubset<T, userSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills and returns the data updated in the database.
     * @param {userSkillUpdateManyAndReturnArgs} args - Arguments to update many UserSkills.
     * @example
     * // Update many UserSkills
     * const userSkill = await prisma.userSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSkills and only return the `userId`
     * const userSkillWithUserIdOnly = await prisma.userSkill.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, userSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSkill.
     * @param {userSkillUpsertArgs} args - Arguments to update or create a UserSkill.
     * @example
     * // Update or create a UserSkill
     * const userSkill = await prisma.userSkill.upsert({
     *   create: {
     *     // ... data to create a UserSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkill we want to update
     *   }
     * })
     */
    upsert<T extends userSkillUpsertArgs>(args: SelectSubset<T, userSkillUpsertArgs<ExtArgs>>): Prisma__userSkillClient<$Result.GetResult<Prisma.$userSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSkillCountArgs} args - Arguments to filter UserSkills to count.
     * @example
     * // Count the number of UserSkills
     * const count = await prisma.userSkill.count({
     *   where: {
     *     // ... the filter for the UserSkills we want to count
     *   }
     * })
    **/
    count<T extends userSkillCountArgs>(
      args?: Subset<T, userSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkillAggregateArgs>(args: Subset<T, UserSkillAggregateArgs>): Prisma.PrismaPromise<GetUserSkillAggregateType<T>>

    /**
     * Group by UserSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userSkillGroupByArgs['orderBy'] }
        : { orderBy?: userSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userSkill model
   */
  readonly fields: userSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill<T extends skillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, skillDefaultArgs<ExtArgs>>): Prisma__skillClient<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userSkill model
   */
  interface userSkillFieldRefs {
    readonly userId: FieldRef<"userSkill", 'String'>
    readonly skillId: FieldRef<"userSkill", 'String'>
    readonly level: FieldRef<"userSkill", 'Int'>
    readonly created_at: FieldRef<"userSkill", 'DateTime'>
    readonly updatedAt: FieldRef<"userSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userSkill findUnique
   */
  export type userSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * Filter, which userSkill to fetch.
     */
    where: userSkillWhereUniqueInput
  }

  /**
   * userSkill findUniqueOrThrow
   */
  export type userSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * Filter, which userSkill to fetch.
     */
    where: userSkillWhereUniqueInput
  }

  /**
   * userSkill findFirst
   */
  export type userSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * Filter, which userSkill to fetch.
     */
    where?: userSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSkills to fetch.
     */
    orderBy?: userSkillOrderByWithRelationInput | userSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userSkills.
     */
    cursor?: userSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userSkills.
     */
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * userSkill findFirstOrThrow
   */
  export type userSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * Filter, which userSkill to fetch.
     */
    where?: userSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSkills to fetch.
     */
    orderBy?: userSkillOrderByWithRelationInput | userSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userSkills.
     */
    cursor?: userSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userSkills.
     */
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * userSkill findMany
   */
  export type userSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * Filter, which userSkills to fetch.
     */
    where?: userSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSkills to fetch.
     */
    orderBy?: userSkillOrderByWithRelationInput | userSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userSkills.
     */
    cursor?: userSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSkills.
     */
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * userSkill create
   */
  export type userSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a userSkill.
     */
    data: XOR<userSkillCreateInput, userSkillUncheckedCreateInput>
  }

  /**
   * userSkill createMany
   */
  export type userSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userSkills.
     */
    data: userSkillCreateManyInput | userSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userSkill createManyAndReturn
   */
  export type userSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * The data used to create many userSkills.
     */
    data: userSkillCreateManyInput | userSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userSkill update
   */
  export type userSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a userSkill.
     */
    data: XOR<userSkillUpdateInput, userSkillUncheckedUpdateInput>
    /**
     * Choose, which userSkill to update.
     */
    where: userSkillWhereUniqueInput
  }

  /**
   * userSkill updateMany
   */
  export type userSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userSkills.
     */
    data: XOR<userSkillUpdateManyMutationInput, userSkillUncheckedUpdateManyInput>
    /**
     * Filter which userSkills to update
     */
    where?: userSkillWhereInput
    /**
     * Limit how many userSkills to update.
     */
    limit?: number
  }

  /**
   * userSkill updateManyAndReturn
   */
  export type userSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * The data used to update userSkills.
     */
    data: XOR<userSkillUpdateManyMutationInput, userSkillUncheckedUpdateManyInput>
    /**
     * Filter which userSkills to update
     */
    where?: userSkillWhereInput
    /**
     * Limit how many userSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userSkill upsert
   */
  export type userSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the userSkill to update in case it exists.
     */
    where: userSkillWhereUniqueInput
    /**
     * In case the userSkill found by the `where` argument doesn't exist, create a new userSkill with this data.
     */
    create: XOR<userSkillCreateInput, userSkillUncheckedCreateInput>
    /**
     * In case the userSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userSkillUpdateInput, userSkillUncheckedUpdateInput>
  }

  /**
   * userSkill delete
   */
  export type userSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
    /**
     * Filter which userSkill to delete.
     */
    where: userSkillWhereUniqueInput
  }

  /**
   * userSkill deleteMany
   */
  export type userSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userSkills to delete
     */
    where?: userSkillWhereInput
    /**
     * Limit how many userSkills to delete.
     */
    limit?: number
  }

  /**
   * userSkill without action
   */
  export type userSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSkill
     */
    select?: userSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userSkill
     */
    omit?: userSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userSkillInclude<ExtArgs> | null
  }


  /**
   * Model userStatistics
   */

  export type AggregateUserStatistics = {
    _count: UserStatisticsCountAggregateOutputType | null
    _avg: UserStatisticsAvgAggregateOutputType | null
    _sum: UserStatisticsSumAggregateOutputType | null
    _min: UserStatisticsMinAggregateOutputType | null
    _max: UserStatisticsMaxAggregateOutputType | null
  }

  export type UserStatisticsAvgAggregateOutputType = {
    servicesProvided: number | null
    servicesReceived: number | null
    activitiesParticipated: number | null
    activitiesOrganized: number | null
    forumMessages: number | null
    totalHelpPoints: number | null
    networkSize: number | null
  }

  export type UserStatisticsSumAggregateOutputType = {
    servicesProvided: number | null
    servicesReceived: number | null
    activitiesParticipated: number | null
    activitiesOrganized: number | null
    forumMessages: number | null
    totalHelpPoints: number | null
    networkSize: number | null
  }

  export type UserStatisticsMinAggregateOutputType = {
    userId: string | null
    servicesProvided: number | null
    servicesReceived: number | null
    activitiesParticipated: number | null
    activitiesOrganized: number | null
    forumMessages: number | null
    totalHelpPoints: number | null
    networkSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStatisticsMaxAggregateOutputType = {
    userId: string | null
    servicesProvided: number | null
    servicesReceived: number | null
    activitiesParticipated: number | null
    activitiesOrganized: number | null
    forumMessages: number | null
    totalHelpPoints: number | null
    networkSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStatisticsCountAggregateOutputType = {
    userId: number
    servicesProvided: number
    servicesReceived: number
    activitiesParticipated: number
    activitiesOrganized: number
    forumMessages: number
    totalHelpPoints: number
    networkSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserStatisticsAvgAggregateInputType = {
    servicesProvided?: true
    servicesReceived?: true
    activitiesParticipated?: true
    activitiesOrganized?: true
    forumMessages?: true
    totalHelpPoints?: true
    networkSize?: true
  }

  export type UserStatisticsSumAggregateInputType = {
    servicesProvided?: true
    servicesReceived?: true
    activitiesParticipated?: true
    activitiesOrganized?: true
    forumMessages?: true
    totalHelpPoints?: true
    networkSize?: true
  }

  export type UserStatisticsMinAggregateInputType = {
    userId?: true
    servicesProvided?: true
    servicesReceived?: true
    activitiesParticipated?: true
    activitiesOrganized?: true
    forumMessages?: true
    totalHelpPoints?: true
    networkSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStatisticsMaxAggregateInputType = {
    userId?: true
    servicesProvided?: true
    servicesReceived?: true
    activitiesParticipated?: true
    activitiesOrganized?: true
    forumMessages?: true
    totalHelpPoints?: true
    networkSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStatisticsCountAggregateInputType = {
    userId?: true
    servicesProvided?: true
    servicesReceived?: true
    activitiesParticipated?: true
    activitiesOrganized?: true
    forumMessages?: true
    totalHelpPoints?: true
    networkSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userStatistics to aggregate.
     */
    where?: userStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userStatistics to fetch.
     */
    orderBy?: userStatisticsOrderByWithRelationInput | userStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userStatistics
    **/
    _count?: true | UserStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatisticsMaxAggregateInputType
  }

  export type GetUserStatisticsAggregateType<T extends UserStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStatistics[P]>
      : GetScalarType<T[P], AggregateUserStatistics[P]>
  }




  export type userStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userStatisticsWhereInput
    orderBy?: userStatisticsOrderByWithAggregationInput | userStatisticsOrderByWithAggregationInput[]
    by: UserStatisticsScalarFieldEnum[] | UserStatisticsScalarFieldEnum
    having?: userStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatisticsCountAggregateInputType | true
    _avg?: UserStatisticsAvgAggregateInputType
    _sum?: UserStatisticsSumAggregateInputType
    _min?: UserStatisticsMinAggregateInputType
    _max?: UserStatisticsMaxAggregateInputType
  }

  export type UserStatisticsGroupByOutputType = {
    userId: string
    servicesProvided: number | null
    servicesReceived: number | null
    activitiesParticipated: number | null
    activitiesOrganized: number | null
    forumMessages: number | null
    totalHelpPoints: number | null
    networkSize: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserStatisticsCountAggregateOutputType | null
    _avg: UserStatisticsAvgAggregateOutputType | null
    _sum: UserStatisticsSumAggregateOutputType | null
    _min: UserStatisticsMinAggregateOutputType | null
    _max: UserStatisticsMaxAggregateOutputType | null
  }

  type GetUserStatisticsGroupByPayload<T extends userStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type userStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    servicesProvided?: boolean
    servicesReceived?: boolean
    activitiesParticipated?: boolean
    activitiesOrganized?: boolean
    forumMessages?: boolean
    totalHelpPoints?: boolean
    networkSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStatistics"]>

  export type userStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    servicesProvided?: boolean
    servicesReceived?: boolean
    activitiesParticipated?: boolean
    activitiesOrganized?: boolean
    forumMessages?: boolean
    totalHelpPoints?: boolean
    networkSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStatistics"]>

  export type userStatisticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    servicesProvided?: boolean
    servicesReceived?: boolean
    activitiesParticipated?: boolean
    activitiesOrganized?: boolean
    forumMessages?: boolean
    totalHelpPoints?: boolean
    networkSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStatistics"]>

  export type userStatisticsSelectScalar = {
    userId?: boolean
    servicesProvided?: boolean
    servicesReceived?: boolean
    activitiesParticipated?: boolean
    activitiesOrganized?: boolean
    forumMessages?: boolean
    totalHelpPoints?: boolean
    networkSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "servicesProvided" | "servicesReceived" | "activitiesParticipated" | "activitiesOrganized" | "forumMessages" | "totalHelpPoints" | "networkSize" | "createdAt" | "updatedAt", ExtArgs["result"]["userStatistics"]>
  export type userStatisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userStatisticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userStatisticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userStatistics"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      servicesProvided: number | null
      servicesReceived: number | null
      activitiesParticipated: number | null
      activitiesOrganized: number | null
      forumMessages: number | null
      totalHelpPoints: number | null
      networkSize: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userStatistics"]>
    composites: {}
  }

  type userStatisticsGetPayload<S extends boolean | null | undefined | userStatisticsDefaultArgs> = $Result.GetResult<Prisma.$userStatisticsPayload, S>

  type userStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStatisticsCountAggregateInputType | true
    }

  export interface userStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userStatistics'], meta: { name: 'userStatistics' } }
    /**
     * Find zero or one UserStatistics that matches the filter.
     * @param {userStatisticsFindUniqueArgs} args - Arguments to find a UserStatistics
     * @example
     * // Get one UserStatistics
     * const userStatistics = await prisma.userStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userStatisticsFindUniqueArgs>(args: SelectSubset<T, userStatisticsFindUniqueArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userStatisticsFindUniqueOrThrowArgs} args - Arguments to find a UserStatistics
     * @example
     * // Get one UserStatistics
     * const userStatistics = await prisma.userStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, userStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userStatisticsFindFirstArgs} args - Arguments to find a UserStatistics
     * @example
     * // Get one UserStatistics
     * const userStatistics = await prisma.userStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userStatisticsFindFirstArgs>(args?: SelectSubset<T, userStatisticsFindFirstArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userStatisticsFindFirstOrThrowArgs} args - Arguments to find a UserStatistics
     * @example
     * // Get one UserStatistics
     * const userStatistics = await prisma.userStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, userStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStatistics
     * const userStatistics = await prisma.userStatistics.findMany()
     * 
     * // Get first 10 UserStatistics
     * const userStatistics = await prisma.userStatistics.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userStatisticsWithUserIdOnly = await prisma.userStatistics.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends userStatisticsFindManyArgs>(args?: SelectSubset<T, userStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStatistics.
     * @param {userStatisticsCreateArgs} args - Arguments to create a UserStatistics.
     * @example
     * // Create one UserStatistics
     * const UserStatistics = await prisma.userStatistics.create({
     *   data: {
     *     // ... data to create a UserStatistics
     *   }
     * })
     * 
     */
    create<T extends userStatisticsCreateArgs>(args: SelectSubset<T, userStatisticsCreateArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStatistics.
     * @param {userStatisticsCreateManyArgs} args - Arguments to create many UserStatistics.
     * @example
     * // Create many UserStatistics
     * const userStatistics = await prisma.userStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userStatisticsCreateManyArgs>(args?: SelectSubset<T, userStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStatistics and returns the data saved in the database.
     * @param {userStatisticsCreateManyAndReturnArgs} args - Arguments to create many UserStatistics.
     * @example
     * // Create many UserStatistics
     * const userStatistics = await prisma.userStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStatistics and only return the `userId`
     * const userStatisticsWithUserIdOnly = await prisma.userStatistics.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, userStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStatistics.
     * @param {userStatisticsDeleteArgs} args - Arguments to delete one UserStatistics.
     * @example
     * // Delete one UserStatistics
     * const UserStatistics = await prisma.userStatistics.delete({
     *   where: {
     *     // ... filter to delete one UserStatistics
     *   }
     * })
     * 
     */
    delete<T extends userStatisticsDeleteArgs>(args: SelectSubset<T, userStatisticsDeleteArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStatistics.
     * @param {userStatisticsUpdateArgs} args - Arguments to update one UserStatistics.
     * @example
     * // Update one UserStatistics
     * const userStatistics = await prisma.userStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userStatisticsUpdateArgs>(args: SelectSubset<T, userStatisticsUpdateArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStatistics.
     * @param {userStatisticsDeleteManyArgs} args - Arguments to filter UserStatistics to delete.
     * @example
     * // Delete a few UserStatistics
     * const { count } = await prisma.userStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userStatisticsDeleteManyArgs>(args?: SelectSubset<T, userStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStatistics
     * const userStatistics = await prisma.userStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userStatisticsUpdateManyArgs>(args: SelectSubset<T, userStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStatistics and returns the data updated in the database.
     * @param {userStatisticsUpdateManyAndReturnArgs} args - Arguments to update many UserStatistics.
     * @example
     * // Update many UserStatistics
     * const userStatistics = await prisma.userStatistics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStatistics and only return the `userId`
     * const userStatisticsWithUserIdOnly = await prisma.userStatistics.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userStatisticsUpdateManyAndReturnArgs>(args: SelectSubset<T, userStatisticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStatistics.
     * @param {userStatisticsUpsertArgs} args - Arguments to update or create a UserStatistics.
     * @example
     * // Update or create a UserStatistics
     * const userStatistics = await prisma.userStatistics.upsert({
     *   create: {
     *     // ... data to create a UserStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStatistics we want to update
     *   }
     * })
     */
    upsert<T extends userStatisticsUpsertArgs>(args: SelectSubset<T, userStatisticsUpsertArgs<ExtArgs>>): Prisma__userStatisticsClient<$Result.GetResult<Prisma.$userStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userStatisticsCountArgs} args - Arguments to filter UserStatistics to count.
     * @example
     * // Count the number of UserStatistics
     * const count = await prisma.userStatistics.count({
     *   where: {
     *     // ... the filter for the UserStatistics we want to count
     *   }
     * })
    **/
    count<T extends userStatisticsCountArgs>(
      args?: Subset<T, userStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatisticsAggregateArgs>(args: Subset<T, UserStatisticsAggregateArgs>): Prisma.PrismaPromise<GetUserStatisticsAggregateType<T>>

    /**
     * Group by UserStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: userStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userStatistics model
   */
  readonly fields: userStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userStatistics model
   */
  interface userStatisticsFieldRefs {
    readonly userId: FieldRef<"userStatistics", 'String'>
    readonly servicesProvided: FieldRef<"userStatistics", 'Int'>
    readonly servicesReceived: FieldRef<"userStatistics", 'Int'>
    readonly activitiesParticipated: FieldRef<"userStatistics", 'Int'>
    readonly activitiesOrganized: FieldRef<"userStatistics", 'Int'>
    readonly forumMessages: FieldRef<"userStatistics", 'Int'>
    readonly totalHelpPoints: FieldRef<"userStatistics", 'Int'>
    readonly networkSize: FieldRef<"userStatistics", 'Int'>
    readonly createdAt: FieldRef<"userStatistics", 'DateTime'>
    readonly updatedAt: FieldRef<"userStatistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userStatistics findUnique
   */
  export type userStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which userStatistics to fetch.
     */
    where: userStatisticsWhereUniqueInput
  }

  /**
   * userStatistics findUniqueOrThrow
   */
  export type userStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which userStatistics to fetch.
     */
    where: userStatisticsWhereUniqueInput
  }

  /**
   * userStatistics findFirst
   */
  export type userStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which userStatistics to fetch.
     */
    where?: userStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userStatistics to fetch.
     */
    orderBy?: userStatisticsOrderByWithRelationInput | userStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userStatistics.
     */
    cursor?: userStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userStatistics.
     */
    distinct?: UserStatisticsScalarFieldEnum | UserStatisticsScalarFieldEnum[]
  }

  /**
   * userStatistics findFirstOrThrow
   */
  export type userStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which userStatistics to fetch.
     */
    where?: userStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userStatistics to fetch.
     */
    orderBy?: userStatisticsOrderByWithRelationInput | userStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userStatistics.
     */
    cursor?: userStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userStatistics.
     */
    distinct?: UserStatisticsScalarFieldEnum | UserStatisticsScalarFieldEnum[]
  }

  /**
   * userStatistics findMany
   */
  export type userStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which userStatistics to fetch.
     */
    where?: userStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userStatistics to fetch.
     */
    orderBy?: userStatisticsOrderByWithRelationInput | userStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userStatistics.
     */
    cursor?: userStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userStatistics.
     */
    skip?: number
    distinct?: UserStatisticsScalarFieldEnum | UserStatisticsScalarFieldEnum[]
  }

  /**
   * userStatistics create
   */
  export type userStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a userStatistics.
     */
    data: XOR<userStatisticsCreateInput, userStatisticsUncheckedCreateInput>
  }

  /**
   * userStatistics createMany
   */
  export type userStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userStatistics.
     */
    data: userStatisticsCreateManyInput | userStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userStatistics createManyAndReturn
   */
  export type userStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * The data used to create many userStatistics.
     */
    data: userStatisticsCreateManyInput | userStatisticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userStatistics update
   */
  export type userStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a userStatistics.
     */
    data: XOR<userStatisticsUpdateInput, userStatisticsUncheckedUpdateInput>
    /**
     * Choose, which userStatistics to update.
     */
    where: userStatisticsWhereUniqueInput
  }

  /**
   * userStatistics updateMany
   */
  export type userStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userStatistics.
     */
    data: XOR<userStatisticsUpdateManyMutationInput, userStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which userStatistics to update
     */
    where?: userStatisticsWhereInput
    /**
     * Limit how many userStatistics to update.
     */
    limit?: number
  }

  /**
   * userStatistics updateManyAndReturn
   */
  export type userStatisticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * The data used to update userStatistics.
     */
    data: XOR<userStatisticsUpdateManyMutationInput, userStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which userStatistics to update
     */
    where?: userStatisticsWhereInput
    /**
     * Limit how many userStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userStatistics upsert
   */
  export type userStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the userStatistics to update in case it exists.
     */
    where: userStatisticsWhereUniqueInput
    /**
     * In case the userStatistics found by the `where` argument doesn't exist, create a new userStatistics with this data.
     */
    create: XOR<userStatisticsCreateInput, userStatisticsUncheckedCreateInput>
    /**
     * In case the userStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userStatisticsUpdateInput, userStatisticsUncheckedUpdateInput>
  }

  /**
   * userStatistics delete
   */
  export type userStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
    /**
     * Filter which userStatistics to delete.
     */
    where: userStatisticsWhereUniqueInput
  }

  /**
   * userStatistics deleteMany
   */
  export type userStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userStatistics to delete
     */
    where?: userStatisticsWhereInput
    /**
     * Limit how many userStatistics to delete.
     */
    limit?: number
  }

  /**
   * userStatistics without action
   */
  export type userStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userStatistics
     */
    select?: userStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userStatistics
     */
    omit?: userStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userStatisticsInclude<ExtArgs> | null
  }


  /**
   * Model videoCall
   */

  export type AggregateVideoCall = {
    _count: VideoCallCountAggregateOutputType | null
    _min: VideoCallMinAggregateOutputType | null
    _max: VideoCallMaxAggregateOutputType | null
  }

  export type VideoCallMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    initiatorId: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCallMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    initiatorId: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCallCountAggregateOutputType = {
    id: number
    conversationId: number
    initiatorId: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoCallMinAggregateInputType = {
    id?: true
    conversationId?: true
    initiatorId?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCallMaxAggregateInputType = {
    id?: true
    conversationId?: true
    initiatorId?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCallCountAggregateInputType = {
    id?: true
    conversationId?: true
    initiatorId?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videoCall to aggregate.
     */
    where?: videoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videoCalls to fetch.
     */
    orderBy?: videoCallOrderByWithRelationInput | videoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videoCalls
    **/
    _count?: true | VideoCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoCallMaxAggregateInputType
  }

  export type GetVideoCallAggregateType<T extends VideoCallAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoCall[P]>
      : GetScalarType<T[P], AggregateVideoCall[P]>
  }




  export type videoCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videoCallWhereInput
    orderBy?: videoCallOrderByWithAggregationInput | videoCallOrderByWithAggregationInput[]
    by: VideoCallScalarFieldEnum[] | VideoCallScalarFieldEnum
    having?: videoCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCallCountAggregateInputType | true
    _min?: VideoCallMinAggregateInputType
    _max?: VideoCallMaxAggregateInputType
  }

  export type VideoCallGroupByOutputType = {
    id: string
    conversationId: string
    initiatorId: string
    startDate: Date
    endDate: Date
    status: string
    createdAt: Date
    updatedAt: Date | null
    _count: VideoCallCountAggregateOutputType | null
    _min: VideoCallMinAggregateOutputType | null
    _max: VideoCallMaxAggregateOutputType | null
  }

  type GetVideoCallGroupByPayload<T extends videoCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoCallGroupByOutputType[P]>
            : GetScalarType<T[P], VideoCallGroupByOutputType[P]>
        }
      >
    >


  export type videoCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    initiatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | videoCall$conversationArgs<ExtArgs>
    user?: boolean | videoCall$userArgs<ExtArgs>
  }, ExtArgs["result"]["videoCall"]>

  export type videoCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    initiatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | videoCall$conversationArgs<ExtArgs>
    user?: boolean | videoCall$userArgs<ExtArgs>
  }, ExtArgs["result"]["videoCall"]>

  export type videoCallSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    initiatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | videoCall$conversationArgs<ExtArgs>
    user?: boolean | videoCall$userArgs<ExtArgs>
  }, ExtArgs["result"]["videoCall"]>

  export type videoCallSelectScalar = {
    id?: boolean
    conversationId?: boolean
    initiatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type videoCallOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "initiatorId" | "startDate" | "endDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["videoCall"]>
  export type videoCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | videoCall$conversationArgs<ExtArgs>
    user?: boolean | videoCall$userArgs<ExtArgs>
  }
  export type videoCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | videoCall$conversationArgs<ExtArgs>
    user?: boolean | videoCall$userArgs<ExtArgs>
  }
  export type videoCallIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | videoCall$conversationArgs<ExtArgs>
    user?: boolean | videoCall$userArgs<ExtArgs>
  }

  export type $videoCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videoCall"
    objects: {
      conversation: Prisma.$conversationPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      initiatorId: string
      startDate: Date
      endDate: Date
      status: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["videoCall"]>
    composites: {}
  }

  type videoCallGetPayload<S extends boolean | null | undefined | videoCallDefaultArgs> = $Result.GetResult<Prisma.$videoCallPayload, S>

  type videoCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videoCallFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCallCountAggregateInputType | true
    }

  export interface videoCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videoCall'], meta: { name: 'videoCall' } }
    /**
     * Find zero or one VideoCall that matches the filter.
     * @param {videoCallFindUniqueArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videoCallFindUniqueArgs>(args: SelectSubset<T, videoCallFindUniqueArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoCall that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videoCallFindUniqueOrThrowArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videoCallFindUniqueOrThrowArgs>(args: SelectSubset<T, videoCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoCallFindFirstArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videoCallFindFirstArgs>(args?: SelectSubset<T, videoCallFindFirstArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoCallFindFirstOrThrowArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videoCallFindFirstOrThrowArgs>(args?: SelectSubset<T, videoCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoCalls
     * const videoCalls = await prisma.videoCall.findMany()
     * 
     * // Get first 10 VideoCalls
     * const videoCalls = await prisma.videoCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoCallWithIdOnly = await prisma.videoCall.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends videoCallFindManyArgs>(args?: SelectSubset<T, videoCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoCall.
     * @param {videoCallCreateArgs} args - Arguments to create a VideoCall.
     * @example
     * // Create one VideoCall
     * const VideoCall = await prisma.videoCall.create({
     *   data: {
     *     // ... data to create a VideoCall
     *   }
     * })
     * 
     */
    create<T extends videoCallCreateArgs>(args: SelectSubset<T, videoCallCreateArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoCalls.
     * @param {videoCallCreateManyArgs} args - Arguments to create many VideoCalls.
     * @example
     * // Create many VideoCalls
     * const videoCall = await prisma.videoCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videoCallCreateManyArgs>(args?: SelectSubset<T, videoCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoCalls and returns the data saved in the database.
     * @param {videoCallCreateManyAndReturnArgs} args - Arguments to create many VideoCalls.
     * @example
     * // Create many VideoCalls
     * const videoCall = await prisma.videoCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoCalls and only return the `id`
     * const videoCallWithIdOnly = await prisma.videoCall.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends videoCallCreateManyAndReturnArgs>(args?: SelectSubset<T, videoCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoCall.
     * @param {videoCallDeleteArgs} args - Arguments to delete one VideoCall.
     * @example
     * // Delete one VideoCall
     * const VideoCall = await prisma.videoCall.delete({
     *   where: {
     *     // ... filter to delete one VideoCall
     *   }
     * })
     * 
     */
    delete<T extends videoCallDeleteArgs>(args: SelectSubset<T, videoCallDeleteArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoCall.
     * @param {videoCallUpdateArgs} args - Arguments to update one VideoCall.
     * @example
     * // Update one VideoCall
     * const videoCall = await prisma.videoCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videoCallUpdateArgs>(args: SelectSubset<T, videoCallUpdateArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoCalls.
     * @param {videoCallDeleteManyArgs} args - Arguments to filter VideoCalls to delete.
     * @example
     * // Delete a few VideoCalls
     * const { count } = await prisma.videoCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videoCallDeleteManyArgs>(args?: SelectSubset<T, videoCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoCalls
     * const videoCall = await prisma.videoCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videoCallUpdateManyArgs>(args: SelectSubset<T, videoCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoCalls and returns the data updated in the database.
     * @param {videoCallUpdateManyAndReturnArgs} args - Arguments to update many VideoCalls.
     * @example
     * // Update many VideoCalls
     * const videoCall = await prisma.videoCall.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoCalls and only return the `id`
     * const videoCallWithIdOnly = await prisma.videoCall.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends videoCallUpdateManyAndReturnArgs>(args: SelectSubset<T, videoCallUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoCall.
     * @param {videoCallUpsertArgs} args - Arguments to update or create a VideoCall.
     * @example
     * // Update or create a VideoCall
     * const videoCall = await prisma.videoCall.upsert({
     *   create: {
     *     // ... data to create a VideoCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoCall we want to update
     *   }
     * })
     */
    upsert<T extends videoCallUpsertArgs>(args: SelectSubset<T, videoCallUpsertArgs<ExtArgs>>): Prisma__videoCallClient<$Result.GetResult<Prisma.$videoCallPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoCallCountArgs} args - Arguments to filter VideoCalls to count.
     * @example
     * // Count the number of VideoCalls
     * const count = await prisma.videoCall.count({
     *   where: {
     *     // ... the filter for the VideoCalls we want to count
     *   }
     * })
    **/
    count<T extends videoCallCountArgs>(
      args?: Subset<T, videoCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoCallAggregateArgs>(args: Subset<T, VideoCallAggregateArgs>): Prisma.PrismaPromise<GetVideoCallAggregateType<T>>

    /**
     * Group by VideoCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videoCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videoCallGroupByArgs['orderBy'] }
        : { orderBy?: videoCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videoCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videoCall model
   */
  readonly fields: videoCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videoCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videoCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends videoCall$conversationArgs<ExtArgs> = {}>(args?: Subset<T, videoCall$conversationArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends videoCall$userArgs<ExtArgs> = {}>(args?: Subset<T, videoCall$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videoCall model
   */
  interface videoCallFieldRefs {
    readonly id: FieldRef<"videoCall", 'String'>
    readonly conversationId: FieldRef<"videoCall", 'String'>
    readonly initiatorId: FieldRef<"videoCall", 'String'>
    readonly startDate: FieldRef<"videoCall", 'DateTime'>
    readonly endDate: FieldRef<"videoCall", 'DateTime'>
    readonly status: FieldRef<"videoCall", 'String'>
    readonly createdAt: FieldRef<"videoCall", 'DateTime'>
    readonly updatedAt: FieldRef<"videoCall", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * videoCall findUnique
   */
  export type videoCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * Filter, which videoCall to fetch.
     */
    where: videoCallWhereUniqueInput
  }

  /**
   * videoCall findUniqueOrThrow
   */
  export type videoCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * Filter, which videoCall to fetch.
     */
    where: videoCallWhereUniqueInput
  }

  /**
   * videoCall findFirst
   */
  export type videoCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * Filter, which videoCall to fetch.
     */
    where?: videoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videoCalls to fetch.
     */
    orderBy?: videoCallOrderByWithRelationInput | videoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videoCalls.
     */
    cursor?: videoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videoCalls.
     */
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * videoCall findFirstOrThrow
   */
  export type videoCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * Filter, which videoCall to fetch.
     */
    where?: videoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videoCalls to fetch.
     */
    orderBy?: videoCallOrderByWithRelationInput | videoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videoCalls.
     */
    cursor?: videoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videoCalls.
     */
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * videoCall findMany
   */
  export type videoCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * Filter, which videoCalls to fetch.
     */
    where?: videoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videoCalls to fetch.
     */
    orderBy?: videoCallOrderByWithRelationInput | videoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videoCalls.
     */
    cursor?: videoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videoCalls.
     */
    skip?: number
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * videoCall create
   */
  export type videoCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * The data needed to create a videoCall.
     */
    data: XOR<videoCallCreateInput, videoCallUncheckedCreateInput>
  }

  /**
   * videoCall createMany
   */
  export type videoCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videoCalls.
     */
    data: videoCallCreateManyInput | videoCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videoCall createManyAndReturn
   */
  export type videoCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * The data used to create many videoCalls.
     */
    data: videoCallCreateManyInput | videoCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * videoCall update
   */
  export type videoCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * The data needed to update a videoCall.
     */
    data: XOR<videoCallUpdateInput, videoCallUncheckedUpdateInput>
    /**
     * Choose, which videoCall to update.
     */
    where: videoCallWhereUniqueInput
  }

  /**
   * videoCall updateMany
   */
  export type videoCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videoCalls.
     */
    data: XOR<videoCallUpdateManyMutationInput, videoCallUncheckedUpdateManyInput>
    /**
     * Filter which videoCalls to update
     */
    where?: videoCallWhereInput
    /**
     * Limit how many videoCalls to update.
     */
    limit?: number
  }

  /**
   * videoCall updateManyAndReturn
   */
  export type videoCallUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * The data used to update videoCalls.
     */
    data: XOR<videoCallUpdateManyMutationInput, videoCallUncheckedUpdateManyInput>
    /**
     * Filter which videoCalls to update
     */
    where?: videoCallWhereInput
    /**
     * Limit how many videoCalls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * videoCall upsert
   */
  export type videoCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * The filter to search for the videoCall to update in case it exists.
     */
    where: videoCallWhereUniqueInput
    /**
     * In case the videoCall found by the `where` argument doesn't exist, create a new videoCall with this data.
     */
    create: XOR<videoCallCreateInput, videoCallUncheckedCreateInput>
    /**
     * In case the videoCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videoCallUpdateInput, videoCallUncheckedUpdateInput>
  }

  /**
   * videoCall delete
   */
  export type videoCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
    /**
     * Filter which videoCall to delete.
     */
    where: videoCallWhereUniqueInput
  }

  /**
   * videoCall deleteMany
   */
  export type videoCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videoCalls to delete
     */
    where?: videoCallWhereInput
    /**
     * Limit how many videoCalls to delete.
     */
    limit?: number
  }

  /**
   * videoCall.conversation
   */
  export type videoCall$conversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    where?: conversationWhereInput
  }

  /**
   * videoCall.user
   */
  export type videoCall$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * videoCall without action
   */
  export type videoCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videoCall
     */
    select?: videoCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videoCall
     */
    omit?: videoCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoCallInclude<ExtArgs> | null
  }


  /**
   * Model wellnessBadge
   */

  export type AggregateWellnessBadge = {
    _count: WellnessBadgeCountAggregateOutputType | null
    _avg: WellnessBadgeAvgAggregateOutputType | null
    _sum: WellnessBadgeSumAggregateOutputType | null
    _min: WellnessBadgeMinAggregateOutputType | null
    _max: WellnessBadgeMaxAggregateOutputType | null
  }

  export type WellnessBadgeAvgAggregateOutputType = {
    level: number | null
  }

  export type WellnessBadgeSumAggregateOutputType = {
    level: number | null
  }

  export type WellnessBadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    image: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessBadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    image: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessBadgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    categoryId: number
    image: number
    level: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellnessBadgeAvgAggregateInputType = {
    level?: true
  }

  export type WellnessBadgeSumAggregateInputType = {
    level?: true
  }

  export type WellnessBadgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    categoryId?: true
    image?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessBadgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    categoryId?: true
    image?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessBadgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    categoryId?: true
    image?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellnessBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessBadge to aggregate.
     */
    where?: wellnessBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessBadges to fetch.
     */
    orderBy?: wellnessBadgeOrderByWithRelationInput | wellnessBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wellnessBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wellnessBadges
    **/
    _count?: true | WellnessBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellnessBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellnessBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessBadgeMaxAggregateInputType
  }

  export type GetWellnessBadgeAggregateType<T extends WellnessBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessBadge[P]>
      : GetScalarType<T[P], AggregateWellnessBadge[P]>
  }




  export type wellnessBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessBadgeWhereInput
    orderBy?: wellnessBadgeOrderByWithAggregationInput | wellnessBadgeOrderByWithAggregationInput[]
    by: WellnessBadgeScalarFieldEnum[] | WellnessBadgeScalarFieldEnum
    having?: wellnessBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessBadgeCountAggregateInputType | true
    _avg?: WellnessBadgeAvgAggregateInputType
    _sum?: WellnessBadgeSumAggregateInputType
    _min?: WellnessBadgeMinAggregateInputType
    _max?: WellnessBadgeMaxAggregateInputType
  }

  export type WellnessBadgeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    categoryId: string | null
    image: string | null
    level: number
    createdAt: Date
    updatedAt: Date | null
    _count: WellnessBadgeCountAggregateOutputType | null
    _avg: WellnessBadgeAvgAggregateOutputType | null
    _sum: WellnessBadgeSumAggregateOutputType | null
    _min: WellnessBadgeMinAggregateOutputType | null
    _max: WellnessBadgeMaxAggregateOutputType | null
  }

  type GetWellnessBadgeGroupByPayload<T extends wellnessBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessBadgeGroupByOutputType[P]>
        }
      >
    >


  export type wellnessBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    image?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessCategory?: boolean | wellnessBadge$wellnessCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessBadge"]>

  export type wellnessBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    image?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessCategory?: boolean | wellnessBadge$wellnessCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessBadge"]>

  export type wellnessBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    image?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessCategory?: boolean | wellnessBadge$wellnessCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessBadge"]>

  export type wellnessBadgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    image?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type wellnessBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "categoryId" | "image" | "level" | "createdAt" | "updatedAt", ExtArgs["result"]["wellnessBadge"]>
  export type wellnessBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessCategory?: boolean | wellnessBadge$wellnessCategoryArgs<ExtArgs>
  }
  export type wellnessBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessCategory?: boolean | wellnessBadge$wellnessCategoryArgs<ExtArgs>
  }
  export type wellnessBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessCategory?: boolean | wellnessBadge$wellnessCategoryArgs<ExtArgs>
  }

  export type $wellnessBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wellnessBadge"
    objects: {
      wellnessCategory: Prisma.$wellnessCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      categoryId: string | null
      image: string | null
      level: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["wellnessBadge"]>
    composites: {}
  }

  type wellnessBadgeGetPayload<S extends boolean | null | undefined | wellnessBadgeDefaultArgs> = $Result.GetResult<Prisma.$wellnessBadgePayload, S>

  type wellnessBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wellnessBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellnessBadgeCountAggregateInputType | true
    }

  export interface wellnessBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wellnessBadge'], meta: { name: 'wellnessBadge' } }
    /**
     * Find zero or one WellnessBadge that matches the filter.
     * @param {wellnessBadgeFindUniqueArgs} args - Arguments to find a WellnessBadge
     * @example
     * // Get one WellnessBadge
     * const wellnessBadge = await prisma.wellnessBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wellnessBadgeFindUniqueArgs>(args: SelectSubset<T, wellnessBadgeFindUniqueArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellnessBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wellnessBadgeFindUniqueOrThrowArgs} args - Arguments to find a WellnessBadge
     * @example
     * // Get one WellnessBadge
     * const wellnessBadge = await prisma.wellnessBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wellnessBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, wellnessBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessBadgeFindFirstArgs} args - Arguments to find a WellnessBadge
     * @example
     * // Get one WellnessBadge
     * const wellnessBadge = await prisma.wellnessBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wellnessBadgeFindFirstArgs>(args?: SelectSubset<T, wellnessBadgeFindFirstArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessBadgeFindFirstOrThrowArgs} args - Arguments to find a WellnessBadge
     * @example
     * // Get one WellnessBadge
     * const wellnessBadge = await prisma.wellnessBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wellnessBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, wellnessBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellnessBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessBadges
     * const wellnessBadges = await prisma.wellnessBadge.findMany()
     * 
     * // Get first 10 WellnessBadges
     * const wellnessBadges = await prisma.wellnessBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessBadgeWithIdOnly = await prisma.wellnessBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wellnessBadgeFindManyArgs>(args?: SelectSubset<T, wellnessBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellnessBadge.
     * @param {wellnessBadgeCreateArgs} args - Arguments to create a WellnessBadge.
     * @example
     * // Create one WellnessBadge
     * const WellnessBadge = await prisma.wellnessBadge.create({
     *   data: {
     *     // ... data to create a WellnessBadge
     *   }
     * })
     * 
     */
    create<T extends wellnessBadgeCreateArgs>(args: SelectSubset<T, wellnessBadgeCreateArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellnessBadges.
     * @param {wellnessBadgeCreateManyArgs} args - Arguments to create many WellnessBadges.
     * @example
     * // Create many WellnessBadges
     * const wellnessBadge = await prisma.wellnessBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wellnessBadgeCreateManyArgs>(args?: SelectSubset<T, wellnessBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessBadges and returns the data saved in the database.
     * @param {wellnessBadgeCreateManyAndReturnArgs} args - Arguments to create many WellnessBadges.
     * @example
     * // Create many WellnessBadges
     * const wellnessBadge = await prisma.wellnessBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessBadges and only return the `id`
     * const wellnessBadgeWithIdOnly = await prisma.wellnessBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wellnessBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, wellnessBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellnessBadge.
     * @param {wellnessBadgeDeleteArgs} args - Arguments to delete one WellnessBadge.
     * @example
     * // Delete one WellnessBadge
     * const WellnessBadge = await prisma.wellnessBadge.delete({
     *   where: {
     *     // ... filter to delete one WellnessBadge
     *   }
     * })
     * 
     */
    delete<T extends wellnessBadgeDeleteArgs>(args: SelectSubset<T, wellnessBadgeDeleteArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellnessBadge.
     * @param {wellnessBadgeUpdateArgs} args - Arguments to update one WellnessBadge.
     * @example
     * // Update one WellnessBadge
     * const wellnessBadge = await prisma.wellnessBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wellnessBadgeUpdateArgs>(args: SelectSubset<T, wellnessBadgeUpdateArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellnessBadges.
     * @param {wellnessBadgeDeleteManyArgs} args - Arguments to filter WellnessBadges to delete.
     * @example
     * // Delete a few WellnessBadges
     * const { count } = await prisma.wellnessBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wellnessBadgeDeleteManyArgs>(args?: SelectSubset<T, wellnessBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessBadges
     * const wellnessBadge = await prisma.wellnessBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wellnessBadgeUpdateManyArgs>(args: SelectSubset<T, wellnessBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessBadges and returns the data updated in the database.
     * @param {wellnessBadgeUpdateManyAndReturnArgs} args - Arguments to update many WellnessBadges.
     * @example
     * // Update many WellnessBadges
     * const wellnessBadge = await prisma.wellnessBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellnessBadges and only return the `id`
     * const wellnessBadgeWithIdOnly = await prisma.wellnessBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends wellnessBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, wellnessBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellnessBadge.
     * @param {wellnessBadgeUpsertArgs} args - Arguments to update or create a WellnessBadge.
     * @example
     * // Update or create a WellnessBadge
     * const wellnessBadge = await prisma.wellnessBadge.upsert({
     *   create: {
     *     // ... data to create a WellnessBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessBadge we want to update
     *   }
     * })
     */
    upsert<T extends wellnessBadgeUpsertArgs>(args: SelectSubset<T, wellnessBadgeUpsertArgs<ExtArgs>>): Prisma__wellnessBadgeClient<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellnessBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessBadgeCountArgs} args - Arguments to filter WellnessBadges to count.
     * @example
     * // Count the number of WellnessBadges
     * const count = await prisma.wellnessBadge.count({
     *   where: {
     *     // ... the filter for the WellnessBadges we want to count
     *   }
     * })
    **/
    count<T extends wellnessBadgeCountArgs>(
      args?: Subset<T, wellnessBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessBadgeAggregateArgs>(args: Subset<T, WellnessBadgeAggregateArgs>): Prisma.PrismaPromise<GetWellnessBadgeAggregateType<T>>

    /**
     * Group by WellnessBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wellnessBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wellnessBadgeGroupByArgs['orderBy'] }
        : { orderBy?: wellnessBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wellnessBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wellnessBadge model
   */
  readonly fields: wellnessBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wellnessBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wellnessBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wellnessCategory<T extends wellnessBadge$wellnessCategoryArgs<ExtArgs> = {}>(args?: Subset<T, wellnessBadge$wellnessCategoryArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wellnessBadge model
   */
  interface wellnessBadgeFieldRefs {
    readonly id: FieldRef<"wellnessBadge", 'String'>
    readonly name: FieldRef<"wellnessBadge", 'String'>
    readonly description: FieldRef<"wellnessBadge", 'String'>
    readonly categoryId: FieldRef<"wellnessBadge", 'String'>
    readonly image: FieldRef<"wellnessBadge", 'String'>
    readonly level: FieldRef<"wellnessBadge", 'Int'>
    readonly createdAt: FieldRef<"wellnessBadge", 'DateTime'>
    readonly updatedAt: FieldRef<"wellnessBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wellnessBadge findUnique
   */
  export type wellnessBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * Filter, which wellnessBadge to fetch.
     */
    where: wellnessBadgeWhereUniqueInput
  }

  /**
   * wellnessBadge findUniqueOrThrow
   */
  export type wellnessBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * Filter, which wellnessBadge to fetch.
     */
    where: wellnessBadgeWhereUniqueInput
  }

  /**
   * wellnessBadge findFirst
   */
  export type wellnessBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * Filter, which wellnessBadge to fetch.
     */
    where?: wellnessBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessBadges to fetch.
     */
    orderBy?: wellnessBadgeOrderByWithRelationInput | wellnessBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessBadges.
     */
    cursor?: wellnessBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessBadges.
     */
    distinct?: WellnessBadgeScalarFieldEnum | WellnessBadgeScalarFieldEnum[]
  }

  /**
   * wellnessBadge findFirstOrThrow
   */
  export type wellnessBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * Filter, which wellnessBadge to fetch.
     */
    where?: wellnessBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessBadges to fetch.
     */
    orderBy?: wellnessBadgeOrderByWithRelationInput | wellnessBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessBadges.
     */
    cursor?: wellnessBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessBadges.
     */
    distinct?: WellnessBadgeScalarFieldEnum | WellnessBadgeScalarFieldEnum[]
  }

  /**
   * wellnessBadge findMany
   */
  export type wellnessBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * Filter, which wellnessBadges to fetch.
     */
    where?: wellnessBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessBadges to fetch.
     */
    orderBy?: wellnessBadgeOrderByWithRelationInput | wellnessBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wellnessBadges.
     */
    cursor?: wellnessBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessBadges.
     */
    skip?: number
    distinct?: WellnessBadgeScalarFieldEnum | WellnessBadgeScalarFieldEnum[]
  }

  /**
   * wellnessBadge create
   */
  export type wellnessBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a wellnessBadge.
     */
    data: XOR<wellnessBadgeCreateInput, wellnessBadgeUncheckedCreateInput>
  }

  /**
   * wellnessBadge createMany
   */
  export type wellnessBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wellnessBadges.
     */
    data: wellnessBadgeCreateManyInput | wellnessBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wellnessBadge createManyAndReturn
   */
  export type wellnessBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many wellnessBadges.
     */
    data: wellnessBadgeCreateManyInput | wellnessBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wellnessBadge update
   */
  export type wellnessBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a wellnessBadge.
     */
    data: XOR<wellnessBadgeUpdateInput, wellnessBadgeUncheckedUpdateInput>
    /**
     * Choose, which wellnessBadge to update.
     */
    where: wellnessBadgeWhereUniqueInput
  }

  /**
   * wellnessBadge updateMany
   */
  export type wellnessBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wellnessBadges.
     */
    data: XOR<wellnessBadgeUpdateManyMutationInput, wellnessBadgeUncheckedUpdateManyInput>
    /**
     * Filter which wellnessBadges to update
     */
    where?: wellnessBadgeWhereInput
    /**
     * Limit how many wellnessBadges to update.
     */
    limit?: number
  }

  /**
   * wellnessBadge updateManyAndReturn
   */
  export type wellnessBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * The data used to update wellnessBadges.
     */
    data: XOR<wellnessBadgeUpdateManyMutationInput, wellnessBadgeUncheckedUpdateManyInput>
    /**
     * Filter which wellnessBadges to update
     */
    where?: wellnessBadgeWhereInput
    /**
     * Limit how many wellnessBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * wellnessBadge upsert
   */
  export type wellnessBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the wellnessBadge to update in case it exists.
     */
    where: wellnessBadgeWhereUniqueInput
    /**
     * In case the wellnessBadge found by the `where` argument doesn't exist, create a new wellnessBadge with this data.
     */
    create: XOR<wellnessBadgeCreateInput, wellnessBadgeUncheckedCreateInput>
    /**
     * In case the wellnessBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wellnessBadgeUpdateInput, wellnessBadgeUncheckedUpdateInput>
  }

  /**
   * wellnessBadge delete
   */
  export type wellnessBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    /**
     * Filter which wellnessBadge to delete.
     */
    where: wellnessBadgeWhereUniqueInput
  }

  /**
   * wellnessBadge deleteMany
   */
  export type wellnessBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessBadges to delete
     */
    where?: wellnessBadgeWhereInput
    /**
     * Limit how many wellnessBadges to delete.
     */
    limit?: number
  }

  /**
   * wellnessBadge.wellnessCategory
   */
  export type wellnessBadge$wellnessCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    where?: wellnessCategoryWhereInput
  }

  /**
   * wellnessBadge without action
   */
  export type wellnessBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
  }


  /**
   * Model wellnessGoal
   */

  export type AggregateWellnessGoal = {
    _count: WellnessGoalCountAggregateOutputType | null
    _avg: WellnessGoalAvgAggregateOutputType | null
    _sum: WellnessGoalSumAggregateOutputType | null
    _min: WellnessGoalMinAggregateOutputType | null
    _max: WellnessGoalMaxAggregateOutputType | null
  }

  export type WellnessGoalAvgAggregateOutputType = {
    targetValue: number | null
  }

  export type WellnessGoalSumAggregateOutputType = {
    targetValue: number | null
  }

  export type WellnessGoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    categoryId: string | null
    targetValue: number | null
    unit: string | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessGoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    categoryId: string | null
    targetValue: number | null
    unit: string | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessGoalCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    categoryId: number
    targetValue: number
    unit: number
    frequency: number
    startDate: number
    endDate: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellnessGoalAvgAggregateInputType = {
    targetValue?: true
  }

  export type WellnessGoalSumAggregateInputType = {
    targetValue?: true
  }

  export type WellnessGoalMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    categoryId?: true
    targetValue?: true
    unit?: true
    frequency?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessGoalMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    categoryId?: true
    targetValue?: true
    unit?: true
    frequency?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessGoalCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    categoryId?: true
    targetValue?: true
    unit?: true
    frequency?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellnessGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessGoal to aggregate.
     */
    where?: wellnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoals to fetch.
     */
    orderBy?: wellnessGoalOrderByWithRelationInput | wellnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wellnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wellnessGoals
    **/
    _count?: true | WellnessGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellnessGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellnessGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessGoalMaxAggregateInputType
  }

  export type GetWellnessGoalAggregateType<T extends WellnessGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessGoal[P]>
      : GetScalarType<T[P], AggregateWellnessGoal[P]>
  }




  export type wellnessGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessGoalWhereInput
    orderBy?: wellnessGoalOrderByWithAggregationInput | wellnessGoalOrderByWithAggregationInput[]
    by: WellnessGoalScalarFieldEnum[] | WellnessGoalScalarFieldEnum
    having?: wellnessGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessGoalCountAggregateInputType | true
    _avg?: WellnessGoalAvgAggregateInputType
    _sum?: WellnessGoalSumAggregateInputType
    _min?: WellnessGoalMinAggregateInputType
    _max?: WellnessGoalMaxAggregateInputType
  }

  export type WellnessGoalGroupByOutputType = {
    id: string
    userId: string
    title: string
    categoryId: string | null
    targetValue: number
    unit: string
    frequency: string
    startDate: Date
    endDate: Date
    active: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: WellnessGoalCountAggregateOutputType | null
    _avg: WellnessGoalAvgAggregateOutputType | null
    _sum: WellnessGoalSumAggregateOutputType | null
    _min: WellnessGoalMinAggregateOutputType | null
    _max: WellnessGoalMaxAggregateOutputType | null
  }

  type GetWellnessGoalGroupByPayload<T extends wellnessGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessGoalGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessGoalGroupByOutputType[P]>
        }
      >
    >


  export type wellnessGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    categoryId?: boolean
    targetValue?: boolean
    unit?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessGoalProgress?: boolean | wellnessGoal$wellnessGoalProgressArgs<ExtArgs>
    user?: boolean | wellnessGoal$userArgs<ExtArgs>
    wellnessCategory?: boolean | wellnessGoal$wellnessCategoryArgs<ExtArgs>
    _count?: boolean | WellnessGoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessGoal"]>

  export type wellnessGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    categoryId?: boolean
    targetValue?: boolean
    unit?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | wellnessGoal$userArgs<ExtArgs>
    wellnessCategory?: boolean | wellnessGoal$wellnessCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessGoal"]>

  export type wellnessGoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    categoryId?: boolean
    targetValue?: boolean
    unit?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | wellnessGoal$userArgs<ExtArgs>
    wellnessCategory?: boolean | wellnessGoal$wellnessCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessGoal"]>

  export type wellnessGoalSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    categoryId?: boolean
    targetValue?: boolean
    unit?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type wellnessGoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "categoryId" | "targetValue" | "unit" | "frequency" | "startDate" | "endDate" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["wellnessGoal"]>
  export type wellnessGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessGoalProgress?: boolean | wellnessGoal$wellnessGoalProgressArgs<ExtArgs>
    user?: boolean | wellnessGoal$userArgs<ExtArgs>
    wellnessCategory?: boolean | wellnessGoal$wellnessCategoryArgs<ExtArgs>
    _count?: boolean | WellnessGoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type wellnessGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | wellnessGoal$userArgs<ExtArgs>
    wellnessCategory?: boolean | wellnessGoal$wellnessCategoryArgs<ExtArgs>
  }
  export type wellnessGoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | wellnessGoal$userArgs<ExtArgs>
    wellnessCategory?: boolean | wellnessGoal$wellnessCategoryArgs<ExtArgs>
  }

  export type $wellnessGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wellnessGoal"
    objects: {
      wellnessGoalProgress: Prisma.$wellnessGoalProgressPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs> | null
      wellnessCategory: Prisma.$wellnessCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      categoryId: string | null
      targetValue: number
      unit: string
      frequency: string
      startDate: Date
      endDate: Date
      active: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["wellnessGoal"]>
    composites: {}
  }

  type wellnessGoalGetPayload<S extends boolean | null | undefined | wellnessGoalDefaultArgs> = $Result.GetResult<Prisma.$wellnessGoalPayload, S>

  type wellnessGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wellnessGoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellnessGoalCountAggregateInputType | true
    }

  export interface wellnessGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wellnessGoal'], meta: { name: 'wellnessGoal' } }
    /**
     * Find zero or one WellnessGoal that matches the filter.
     * @param {wellnessGoalFindUniqueArgs} args - Arguments to find a WellnessGoal
     * @example
     * // Get one WellnessGoal
     * const wellnessGoal = await prisma.wellnessGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wellnessGoalFindUniqueArgs>(args: SelectSubset<T, wellnessGoalFindUniqueArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellnessGoal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wellnessGoalFindUniqueOrThrowArgs} args - Arguments to find a WellnessGoal
     * @example
     * // Get one WellnessGoal
     * const wellnessGoal = await prisma.wellnessGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wellnessGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, wellnessGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalFindFirstArgs} args - Arguments to find a WellnessGoal
     * @example
     * // Get one WellnessGoal
     * const wellnessGoal = await prisma.wellnessGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wellnessGoalFindFirstArgs>(args?: SelectSubset<T, wellnessGoalFindFirstArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalFindFirstOrThrowArgs} args - Arguments to find a WellnessGoal
     * @example
     * // Get one WellnessGoal
     * const wellnessGoal = await prisma.wellnessGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wellnessGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, wellnessGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellnessGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessGoals
     * const wellnessGoals = await prisma.wellnessGoal.findMany()
     * 
     * // Get first 10 WellnessGoals
     * const wellnessGoals = await prisma.wellnessGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessGoalWithIdOnly = await prisma.wellnessGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wellnessGoalFindManyArgs>(args?: SelectSubset<T, wellnessGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellnessGoal.
     * @param {wellnessGoalCreateArgs} args - Arguments to create a WellnessGoal.
     * @example
     * // Create one WellnessGoal
     * const WellnessGoal = await prisma.wellnessGoal.create({
     *   data: {
     *     // ... data to create a WellnessGoal
     *   }
     * })
     * 
     */
    create<T extends wellnessGoalCreateArgs>(args: SelectSubset<T, wellnessGoalCreateArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellnessGoals.
     * @param {wellnessGoalCreateManyArgs} args - Arguments to create many WellnessGoals.
     * @example
     * // Create many WellnessGoals
     * const wellnessGoal = await prisma.wellnessGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wellnessGoalCreateManyArgs>(args?: SelectSubset<T, wellnessGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessGoals and returns the data saved in the database.
     * @param {wellnessGoalCreateManyAndReturnArgs} args - Arguments to create many WellnessGoals.
     * @example
     * // Create many WellnessGoals
     * const wellnessGoal = await prisma.wellnessGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessGoals and only return the `id`
     * const wellnessGoalWithIdOnly = await prisma.wellnessGoal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wellnessGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, wellnessGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellnessGoal.
     * @param {wellnessGoalDeleteArgs} args - Arguments to delete one WellnessGoal.
     * @example
     * // Delete one WellnessGoal
     * const WellnessGoal = await prisma.wellnessGoal.delete({
     *   where: {
     *     // ... filter to delete one WellnessGoal
     *   }
     * })
     * 
     */
    delete<T extends wellnessGoalDeleteArgs>(args: SelectSubset<T, wellnessGoalDeleteArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellnessGoal.
     * @param {wellnessGoalUpdateArgs} args - Arguments to update one WellnessGoal.
     * @example
     * // Update one WellnessGoal
     * const wellnessGoal = await prisma.wellnessGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wellnessGoalUpdateArgs>(args: SelectSubset<T, wellnessGoalUpdateArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellnessGoals.
     * @param {wellnessGoalDeleteManyArgs} args - Arguments to filter WellnessGoals to delete.
     * @example
     * // Delete a few WellnessGoals
     * const { count } = await prisma.wellnessGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wellnessGoalDeleteManyArgs>(args?: SelectSubset<T, wellnessGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessGoals
     * const wellnessGoal = await prisma.wellnessGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wellnessGoalUpdateManyArgs>(args: SelectSubset<T, wellnessGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessGoals and returns the data updated in the database.
     * @param {wellnessGoalUpdateManyAndReturnArgs} args - Arguments to update many WellnessGoals.
     * @example
     * // Update many WellnessGoals
     * const wellnessGoal = await prisma.wellnessGoal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellnessGoals and only return the `id`
     * const wellnessGoalWithIdOnly = await prisma.wellnessGoal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends wellnessGoalUpdateManyAndReturnArgs>(args: SelectSubset<T, wellnessGoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellnessGoal.
     * @param {wellnessGoalUpsertArgs} args - Arguments to update or create a WellnessGoal.
     * @example
     * // Update or create a WellnessGoal
     * const wellnessGoal = await prisma.wellnessGoal.upsert({
     *   create: {
     *     // ... data to create a WellnessGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessGoal we want to update
     *   }
     * })
     */
    upsert<T extends wellnessGoalUpsertArgs>(args: SelectSubset<T, wellnessGoalUpsertArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellnessGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalCountArgs} args - Arguments to filter WellnessGoals to count.
     * @example
     * // Count the number of WellnessGoals
     * const count = await prisma.wellnessGoal.count({
     *   where: {
     *     // ... the filter for the WellnessGoals we want to count
     *   }
     * })
    **/
    count<T extends wellnessGoalCountArgs>(
      args?: Subset<T, wellnessGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessGoalAggregateArgs>(args: Subset<T, WellnessGoalAggregateArgs>): Prisma.PrismaPromise<GetWellnessGoalAggregateType<T>>

    /**
     * Group by WellnessGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wellnessGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wellnessGoalGroupByArgs['orderBy'] }
        : { orderBy?: wellnessGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wellnessGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wellnessGoal model
   */
  readonly fields: wellnessGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wellnessGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wellnessGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wellnessGoalProgress<T extends wellnessGoal$wellnessGoalProgressArgs<ExtArgs> = {}>(args?: Subset<T, wellnessGoal$wellnessGoalProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends wellnessGoal$userArgs<ExtArgs> = {}>(args?: Subset<T, wellnessGoal$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wellnessCategory<T extends wellnessGoal$wellnessCategoryArgs<ExtArgs> = {}>(args?: Subset<T, wellnessGoal$wellnessCategoryArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wellnessGoal model
   */
  interface wellnessGoalFieldRefs {
    readonly id: FieldRef<"wellnessGoal", 'String'>
    readonly userId: FieldRef<"wellnessGoal", 'String'>
    readonly title: FieldRef<"wellnessGoal", 'String'>
    readonly categoryId: FieldRef<"wellnessGoal", 'String'>
    readonly targetValue: FieldRef<"wellnessGoal", 'Int'>
    readonly unit: FieldRef<"wellnessGoal", 'String'>
    readonly frequency: FieldRef<"wellnessGoal", 'String'>
    readonly startDate: FieldRef<"wellnessGoal", 'DateTime'>
    readonly endDate: FieldRef<"wellnessGoal", 'DateTime'>
    readonly active: FieldRef<"wellnessGoal", 'Boolean'>
    readonly createdAt: FieldRef<"wellnessGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"wellnessGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wellnessGoal findUnique
   */
  export type wellnessGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoal to fetch.
     */
    where: wellnessGoalWhereUniqueInput
  }

  /**
   * wellnessGoal findUniqueOrThrow
   */
  export type wellnessGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoal to fetch.
     */
    where: wellnessGoalWhereUniqueInput
  }

  /**
   * wellnessGoal findFirst
   */
  export type wellnessGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoal to fetch.
     */
    where?: wellnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoals to fetch.
     */
    orderBy?: wellnessGoalOrderByWithRelationInput | wellnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessGoals.
     */
    cursor?: wellnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessGoals.
     */
    distinct?: WellnessGoalScalarFieldEnum | WellnessGoalScalarFieldEnum[]
  }

  /**
   * wellnessGoal findFirstOrThrow
   */
  export type wellnessGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoal to fetch.
     */
    where?: wellnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoals to fetch.
     */
    orderBy?: wellnessGoalOrderByWithRelationInput | wellnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessGoals.
     */
    cursor?: wellnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessGoals.
     */
    distinct?: WellnessGoalScalarFieldEnum | WellnessGoalScalarFieldEnum[]
  }

  /**
   * wellnessGoal findMany
   */
  export type wellnessGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoals to fetch.
     */
    where?: wellnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoals to fetch.
     */
    orderBy?: wellnessGoalOrderByWithRelationInput | wellnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wellnessGoals.
     */
    cursor?: wellnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoals.
     */
    skip?: number
    distinct?: WellnessGoalScalarFieldEnum | WellnessGoalScalarFieldEnum[]
  }

  /**
   * wellnessGoal create
   */
  export type wellnessGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a wellnessGoal.
     */
    data: XOR<wellnessGoalCreateInput, wellnessGoalUncheckedCreateInput>
  }

  /**
   * wellnessGoal createMany
   */
  export type wellnessGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wellnessGoals.
     */
    data: wellnessGoalCreateManyInput | wellnessGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wellnessGoal createManyAndReturn
   */
  export type wellnessGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * The data used to create many wellnessGoals.
     */
    data: wellnessGoalCreateManyInput | wellnessGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wellnessGoal update
   */
  export type wellnessGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a wellnessGoal.
     */
    data: XOR<wellnessGoalUpdateInput, wellnessGoalUncheckedUpdateInput>
    /**
     * Choose, which wellnessGoal to update.
     */
    where: wellnessGoalWhereUniqueInput
  }

  /**
   * wellnessGoal updateMany
   */
  export type wellnessGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wellnessGoals.
     */
    data: XOR<wellnessGoalUpdateManyMutationInput, wellnessGoalUncheckedUpdateManyInput>
    /**
     * Filter which wellnessGoals to update
     */
    where?: wellnessGoalWhereInput
    /**
     * Limit how many wellnessGoals to update.
     */
    limit?: number
  }

  /**
   * wellnessGoal updateManyAndReturn
   */
  export type wellnessGoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * The data used to update wellnessGoals.
     */
    data: XOR<wellnessGoalUpdateManyMutationInput, wellnessGoalUncheckedUpdateManyInput>
    /**
     * Filter which wellnessGoals to update
     */
    where?: wellnessGoalWhereInput
    /**
     * Limit how many wellnessGoals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * wellnessGoal upsert
   */
  export type wellnessGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the wellnessGoal to update in case it exists.
     */
    where: wellnessGoalWhereUniqueInput
    /**
     * In case the wellnessGoal found by the `where` argument doesn't exist, create a new wellnessGoal with this data.
     */
    create: XOR<wellnessGoalCreateInput, wellnessGoalUncheckedCreateInput>
    /**
     * In case the wellnessGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wellnessGoalUpdateInput, wellnessGoalUncheckedUpdateInput>
  }

  /**
   * wellnessGoal delete
   */
  export type wellnessGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    /**
     * Filter which wellnessGoal to delete.
     */
    where: wellnessGoalWhereUniqueInput
  }

  /**
   * wellnessGoal deleteMany
   */
  export type wellnessGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessGoals to delete
     */
    where?: wellnessGoalWhereInput
    /**
     * Limit how many wellnessGoals to delete.
     */
    limit?: number
  }

  /**
   * wellnessGoal.wellnessGoalProgress
   */
  export type wellnessGoal$wellnessGoalProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    where?: wellnessGoalProgressWhereInput
    orderBy?: wellnessGoalProgressOrderByWithRelationInput | wellnessGoalProgressOrderByWithRelationInput[]
    cursor?: wellnessGoalProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellnessGoalProgressScalarFieldEnum | WellnessGoalProgressScalarFieldEnum[]
  }

  /**
   * wellnessGoal.user
   */
  export type wellnessGoal$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * wellnessGoal.wellnessCategory
   */
  export type wellnessGoal$wellnessCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    where?: wellnessCategoryWhereInput
  }

  /**
   * wellnessGoal without action
   */
  export type wellnessGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
  }


  /**
   * Model wellnessGoalProgress
   */

  export type AggregateWellnessGoalProgress = {
    _count: WellnessGoalProgressCountAggregateOutputType | null
    _avg: WellnessGoalProgressAvgAggregateOutputType | null
    _sum: WellnessGoalProgressSumAggregateOutputType | null
    _min: WellnessGoalProgressMinAggregateOutputType | null
    _max: WellnessGoalProgressMaxAggregateOutputType | null
  }

  export type WellnessGoalProgressAvgAggregateOutputType = {
    achievedValue: number | null
  }

  export type WellnessGoalProgressSumAggregateOutputType = {
    achievedValue: number | null
  }

  export type WellnessGoalProgressMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    recordingDate: Date | null
    achievedValue: number | null
    goalAchieved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessGoalProgressMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    recordingDate: Date | null
    achievedValue: number | null
    goalAchieved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessGoalProgressCountAggregateOutputType = {
    id: number
    goalId: number
    recordingDate: number
    achievedValue: number
    goalAchieved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellnessGoalProgressAvgAggregateInputType = {
    achievedValue?: true
  }

  export type WellnessGoalProgressSumAggregateInputType = {
    achievedValue?: true
  }

  export type WellnessGoalProgressMinAggregateInputType = {
    id?: true
    goalId?: true
    recordingDate?: true
    achievedValue?: true
    goalAchieved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessGoalProgressMaxAggregateInputType = {
    id?: true
    goalId?: true
    recordingDate?: true
    achievedValue?: true
    goalAchieved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessGoalProgressCountAggregateInputType = {
    id?: true
    goalId?: true
    recordingDate?: true
    achievedValue?: true
    goalAchieved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellnessGoalProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessGoalProgress to aggregate.
     */
    where?: wellnessGoalProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoalProgresses to fetch.
     */
    orderBy?: wellnessGoalProgressOrderByWithRelationInput | wellnessGoalProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wellnessGoalProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoalProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoalProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wellnessGoalProgresses
    **/
    _count?: true | WellnessGoalProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellnessGoalProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellnessGoalProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessGoalProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessGoalProgressMaxAggregateInputType
  }

  export type GetWellnessGoalProgressAggregateType<T extends WellnessGoalProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessGoalProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessGoalProgress[P]>
      : GetScalarType<T[P], AggregateWellnessGoalProgress[P]>
  }




  export type wellnessGoalProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessGoalProgressWhereInput
    orderBy?: wellnessGoalProgressOrderByWithAggregationInput | wellnessGoalProgressOrderByWithAggregationInput[]
    by: WellnessGoalProgressScalarFieldEnum[] | WellnessGoalProgressScalarFieldEnum
    having?: wellnessGoalProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessGoalProgressCountAggregateInputType | true
    _avg?: WellnessGoalProgressAvgAggregateInputType
    _sum?: WellnessGoalProgressSumAggregateInputType
    _min?: WellnessGoalProgressMinAggregateInputType
    _max?: WellnessGoalProgressMaxAggregateInputType
  }

  export type WellnessGoalProgressGroupByOutputType = {
    id: string
    goalId: string
    recordingDate: Date
    achievedValue: number
    goalAchieved: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: WellnessGoalProgressCountAggregateOutputType | null
    _avg: WellnessGoalProgressAvgAggregateOutputType | null
    _sum: WellnessGoalProgressSumAggregateOutputType | null
    _min: WellnessGoalProgressMinAggregateOutputType | null
    _max: WellnessGoalProgressMaxAggregateOutputType | null
  }

  type GetWellnessGoalProgressGroupByPayload<T extends wellnessGoalProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessGoalProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessGoalProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessGoalProgressGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessGoalProgressGroupByOutputType[P]>
        }
      >
    >


  export type wellnessGoalProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    recordingDate?: boolean
    achievedValue?: boolean
    goalAchieved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessGoal?: boolean | wellnessGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessGoalProgress"]>

  export type wellnessGoalProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    recordingDate?: boolean
    achievedValue?: boolean
    goalAchieved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessGoal?: boolean | wellnessGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessGoalProgress"]>

  export type wellnessGoalProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    recordingDate?: boolean
    achievedValue?: boolean
    goalAchieved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessGoal?: boolean | wellnessGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessGoalProgress"]>

  export type wellnessGoalProgressSelectScalar = {
    id?: boolean
    goalId?: boolean
    recordingDate?: boolean
    achievedValue?: boolean
    goalAchieved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type wellnessGoalProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goalId" | "recordingDate" | "achievedValue" | "goalAchieved" | "createdAt" | "updatedAt", ExtArgs["result"]["wellnessGoalProgress"]>
  export type wellnessGoalProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessGoal?: boolean | wellnessGoalDefaultArgs<ExtArgs>
  }
  export type wellnessGoalProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessGoal?: boolean | wellnessGoalDefaultArgs<ExtArgs>
  }
  export type wellnessGoalProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessGoal?: boolean | wellnessGoalDefaultArgs<ExtArgs>
  }

  export type $wellnessGoalProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wellnessGoalProgress"
    objects: {
      wellnessGoal: Prisma.$wellnessGoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      recordingDate: Date
      achievedValue: number
      goalAchieved: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["wellnessGoalProgress"]>
    composites: {}
  }

  type wellnessGoalProgressGetPayload<S extends boolean | null | undefined | wellnessGoalProgressDefaultArgs> = $Result.GetResult<Prisma.$wellnessGoalProgressPayload, S>

  type wellnessGoalProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wellnessGoalProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellnessGoalProgressCountAggregateInputType | true
    }

  export interface wellnessGoalProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wellnessGoalProgress'], meta: { name: 'wellnessGoalProgress' } }
    /**
     * Find zero or one WellnessGoalProgress that matches the filter.
     * @param {wellnessGoalProgressFindUniqueArgs} args - Arguments to find a WellnessGoalProgress
     * @example
     * // Get one WellnessGoalProgress
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wellnessGoalProgressFindUniqueArgs>(args: SelectSubset<T, wellnessGoalProgressFindUniqueArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellnessGoalProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wellnessGoalProgressFindUniqueOrThrowArgs} args - Arguments to find a WellnessGoalProgress
     * @example
     * // Get one WellnessGoalProgress
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wellnessGoalProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, wellnessGoalProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessGoalProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalProgressFindFirstArgs} args - Arguments to find a WellnessGoalProgress
     * @example
     * // Get one WellnessGoalProgress
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wellnessGoalProgressFindFirstArgs>(args?: SelectSubset<T, wellnessGoalProgressFindFirstArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessGoalProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalProgressFindFirstOrThrowArgs} args - Arguments to find a WellnessGoalProgress
     * @example
     * // Get one WellnessGoalProgress
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wellnessGoalProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, wellnessGoalProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellnessGoalProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessGoalProgresses
     * const wellnessGoalProgresses = await prisma.wellnessGoalProgress.findMany()
     * 
     * // Get first 10 WellnessGoalProgresses
     * const wellnessGoalProgresses = await prisma.wellnessGoalProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessGoalProgressWithIdOnly = await prisma.wellnessGoalProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wellnessGoalProgressFindManyArgs>(args?: SelectSubset<T, wellnessGoalProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellnessGoalProgress.
     * @param {wellnessGoalProgressCreateArgs} args - Arguments to create a WellnessGoalProgress.
     * @example
     * // Create one WellnessGoalProgress
     * const WellnessGoalProgress = await prisma.wellnessGoalProgress.create({
     *   data: {
     *     // ... data to create a WellnessGoalProgress
     *   }
     * })
     * 
     */
    create<T extends wellnessGoalProgressCreateArgs>(args: SelectSubset<T, wellnessGoalProgressCreateArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellnessGoalProgresses.
     * @param {wellnessGoalProgressCreateManyArgs} args - Arguments to create many WellnessGoalProgresses.
     * @example
     * // Create many WellnessGoalProgresses
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wellnessGoalProgressCreateManyArgs>(args?: SelectSubset<T, wellnessGoalProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessGoalProgresses and returns the data saved in the database.
     * @param {wellnessGoalProgressCreateManyAndReturnArgs} args - Arguments to create many WellnessGoalProgresses.
     * @example
     * // Create many WellnessGoalProgresses
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessGoalProgresses and only return the `id`
     * const wellnessGoalProgressWithIdOnly = await prisma.wellnessGoalProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wellnessGoalProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, wellnessGoalProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellnessGoalProgress.
     * @param {wellnessGoalProgressDeleteArgs} args - Arguments to delete one WellnessGoalProgress.
     * @example
     * // Delete one WellnessGoalProgress
     * const WellnessGoalProgress = await prisma.wellnessGoalProgress.delete({
     *   where: {
     *     // ... filter to delete one WellnessGoalProgress
     *   }
     * })
     * 
     */
    delete<T extends wellnessGoalProgressDeleteArgs>(args: SelectSubset<T, wellnessGoalProgressDeleteArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellnessGoalProgress.
     * @param {wellnessGoalProgressUpdateArgs} args - Arguments to update one WellnessGoalProgress.
     * @example
     * // Update one WellnessGoalProgress
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wellnessGoalProgressUpdateArgs>(args: SelectSubset<T, wellnessGoalProgressUpdateArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellnessGoalProgresses.
     * @param {wellnessGoalProgressDeleteManyArgs} args - Arguments to filter WellnessGoalProgresses to delete.
     * @example
     * // Delete a few WellnessGoalProgresses
     * const { count } = await prisma.wellnessGoalProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wellnessGoalProgressDeleteManyArgs>(args?: SelectSubset<T, wellnessGoalProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessGoalProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessGoalProgresses
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wellnessGoalProgressUpdateManyArgs>(args: SelectSubset<T, wellnessGoalProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessGoalProgresses and returns the data updated in the database.
     * @param {wellnessGoalProgressUpdateManyAndReturnArgs} args - Arguments to update many WellnessGoalProgresses.
     * @example
     * // Update many WellnessGoalProgresses
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellnessGoalProgresses and only return the `id`
     * const wellnessGoalProgressWithIdOnly = await prisma.wellnessGoalProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends wellnessGoalProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, wellnessGoalProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellnessGoalProgress.
     * @param {wellnessGoalProgressUpsertArgs} args - Arguments to update or create a WellnessGoalProgress.
     * @example
     * // Update or create a WellnessGoalProgress
     * const wellnessGoalProgress = await prisma.wellnessGoalProgress.upsert({
     *   create: {
     *     // ... data to create a WellnessGoalProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessGoalProgress we want to update
     *   }
     * })
     */
    upsert<T extends wellnessGoalProgressUpsertArgs>(args: SelectSubset<T, wellnessGoalProgressUpsertArgs<ExtArgs>>): Prisma__wellnessGoalProgressClient<$Result.GetResult<Prisma.$wellnessGoalProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellnessGoalProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalProgressCountArgs} args - Arguments to filter WellnessGoalProgresses to count.
     * @example
     * // Count the number of WellnessGoalProgresses
     * const count = await prisma.wellnessGoalProgress.count({
     *   where: {
     *     // ... the filter for the WellnessGoalProgresses we want to count
     *   }
     * })
    **/
    count<T extends wellnessGoalProgressCountArgs>(
      args?: Subset<T, wellnessGoalProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessGoalProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessGoalProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGoalProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessGoalProgressAggregateArgs>(args: Subset<T, WellnessGoalProgressAggregateArgs>): Prisma.PrismaPromise<GetWellnessGoalProgressAggregateType<T>>

    /**
     * Group by WellnessGoalProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessGoalProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wellnessGoalProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wellnessGoalProgressGroupByArgs['orderBy'] }
        : { orderBy?: wellnessGoalProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wellnessGoalProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessGoalProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wellnessGoalProgress model
   */
  readonly fields: wellnessGoalProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wellnessGoalProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wellnessGoalProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wellnessGoal<T extends wellnessGoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, wellnessGoalDefaultArgs<ExtArgs>>): Prisma__wellnessGoalClient<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wellnessGoalProgress model
   */
  interface wellnessGoalProgressFieldRefs {
    readonly id: FieldRef<"wellnessGoalProgress", 'String'>
    readonly goalId: FieldRef<"wellnessGoalProgress", 'String'>
    readonly recordingDate: FieldRef<"wellnessGoalProgress", 'DateTime'>
    readonly achievedValue: FieldRef<"wellnessGoalProgress", 'Int'>
    readonly goalAchieved: FieldRef<"wellnessGoalProgress", 'Boolean'>
    readonly createdAt: FieldRef<"wellnessGoalProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"wellnessGoalProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wellnessGoalProgress findUnique
   */
  export type wellnessGoalProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoalProgress to fetch.
     */
    where: wellnessGoalProgressWhereUniqueInput
  }

  /**
   * wellnessGoalProgress findUniqueOrThrow
   */
  export type wellnessGoalProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoalProgress to fetch.
     */
    where: wellnessGoalProgressWhereUniqueInput
  }

  /**
   * wellnessGoalProgress findFirst
   */
  export type wellnessGoalProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoalProgress to fetch.
     */
    where?: wellnessGoalProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoalProgresses to fetch.
     */
    orderBy?: wellnessGoalProgressOrderByWithRelationInput | wellnessGoalProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessGoalProgresses.
     */
    cursor?: wellnessGoalProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoalProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoalProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessGoalProgresses.
     */
    distinct?: WellnessGoalProgressScalarFieldEnum | WellnessGoalProgressScalarFieldEnum[]
  }

  /**
   * wellnessGoalProgress findFirstOrThrow
   */
  export type wellnessGoalProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoalProgress to fetch.
     */
    where?: wellnessGoalProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoalProgresses to fetch.
     */
    orderBy?: wellnessGoalProgressOrderByWithRelationInput | wellnessGoalProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessGoalProgresses.
     */
    cursor?: wellnessGoalProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoalProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoalProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessGoalProgresses.
     */
    distinct?: WellnessGoalProgressScalarFieldEnum | WellnessGoalProgressScalarFieldEnum[]
  }

  /**
   * wellnessGoalProgress findMany
   */
  export type wellnessGoalProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * Filter, which wellnessGoalProgresses to fetch.
     */
    where?: wellnessGoalProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessGoalProgresses to fetch.
     */
    orderBy?: wellnessGoalProgressOrderByWithRelationInput | wellnessGoalProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wellnessGoalProgresses.
     */
    cursor?: wellnessGoalProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessGoalProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessGoalProgresses.
     */
    skip?: number
    distinct?: WellnessGoalProgressScalarFieldEnum | WellnessGoalProgressScalarFieldEnum[]
  }

  /**
   * wellnessGoalProgress create
   */
  export type wellnessGoalProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a wellnessGoalProgress.
     */
    data: XOR<wellnessGoalProgressCreateInput, wellnessGoalProgressUncheckedCreateInput>
  }

  /**
   * wellnessGoalProgress createMany
   */
  export type wellnessGoalProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wellnessGoalProgresses.
     */
    data: wellnessGoalProgressCreateManyInput | wellnessGoalProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wellnessGoalProgress createManyAndReturn
   */
  export type wellnessGoalProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * The data used to create many wellnessGoalProgresses.
     */
    data: wellnessGoalProgressCreateManyInput | wellnessGoalProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wellnessGoalProgress update
   */
  export type wellnessGoalProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a wellnessGoalProgress.
     */
    data: XOR<wellnessGoalProgressUpdateInput, wellnessGoalProgressUncheckedUpdateInput>
    /**
     * Choose, which wellnessGoalProgress to update.
     */
    where: wellnessGoalProgressWhereUniqueInput
  }

  /**
   * wellnessGoalProgress updateMany
   */
  export type wellnessGoalProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wellnessGoalProgresses.
     */
    data: XOR<wellnessGoalProgressUpdateManyMutationInput, wellnessGoalProgressUncheckedUpdateManyInput>
    /**
     * Filter which wellnessGoalProgresses to update
     */
    where?: wellnessGoalProgressWhereInput
    /**
     * Limit how many wellnessGoalProgresses to update.
     */
    limit?: number
  }

  /**
   * wellnessGoalProgress updateManyAndReturn
   */
  export type wellnessGoalProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * The data used to update wellnessGoalProgresses.
     */
    data: XOR<wellnessGoalProgressUpdateManyMutationInput, wellnessGoalProgressUncheckedUpdateManyInput>
    /**
     * Filter which wellnessGoalProgresses to update
     */
    where?: wellnessGoalProgressWhereInput
    /**
     * Limit how many wellnessGoalProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * wellnessGoalProgress upsert
   */
  export type wellnessGoalProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the wellnessGoalProgress to update in case it exists.
     */
    where: wellnessGoalProgressWhereUniqueInput
    /**
     * In case the wellnessGoalProgress found by the `where` argument doesn't exist, create a new wellnessGoalProgress with this data.
     */
    create: XOR<wellnessGoalProgressCreateInput, wellnessGoalProgressUncheckedCreateInput>
    /**
     * In case the wellnessGoalProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wellnessGoalProgressUpdateInput, wellnessGoalProgressUncheckedUpdateInput>
  }

  /**
   * wellnessGoalProgress delete
   */
  export type wellnessGoalProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
    /**
     * Filter which wellnessGoalProgress to delete.
     */
    where: wellnessGoalProgressWhereUniqueInput
  }

  /**
   * wellnessGoalProgress deleteMany
   */
  export type wellnessGoalProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessGoalProgresses to delete
     */
    where?: wellnessGoalProgressWhereInput
    /**
     * Limit how many wellnessGoalProgresses to delete.
     */
    limit?: number
  }

  /**
   * wellnessGoalProgress without action
   */
  export type wellnessGoalProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoalProgress
     */
    select?: wellnessGoalProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoalProgress
     */
    omit?: wellnessGoalProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalProgressInclude<ExtArgs> | null
  }


  /**
   * Model activityCategory
   */

  export type AggregateActivityCategory = {
    _count: ActivityCategoryCountAggregateOutputType | null
    _min: ActivityCategoryMinAggregateOutputType | null
    _max: ActivityCategoryMaxAggregateOutputType | null
  }

  export type ActivityCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activityCategory to aggregate.
     */
    where?: activityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityCategories to fetch.
     */
    orderBy?: activityCategoryOrderByWithRelationInput | activityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activityCategories
    **/
    _count?: true | ActivityCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityCategoryMaxAggregateInputType
  }

  export type GetActivityCategoryAggregateType<T extends ActivityCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityCategory[P]>
      : GetScalarType<T[P], AggregateActivityCategory[P]>
  }




  export type activityCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityCategoryWhereInput
    orderBy?: activityCategoryOrderByWithAggregationInput | activityCategoryOrderByWithAggregationInput[]
    by: ActivityCategoryScalarFieldEnum[] | ActivityCategoryScalarFieldEnum
    having?: activityCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCategoryCountAggregateInputType | true
    _min?: ActivityCategoryMinAggregateInputType
    _max?: ActivityCategoryMaxAggregateInputType
  }

  export type ActivityCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ActivityCategoryCountAggregateOutputType | null
    _min: ActivityCategoryMinAggregateOutputType | null
    _max: ActivityCategoryMaxAggregateOutputType | null
  }

  type GetActivityCategoryGroupByPayload<T extends activityCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityCategoryGroupByOutputType[P]>
        }
      >
    >


  export type activityCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | activityCategory$activityArgs<ExtArgs>
    _count?: boolean | ActivityCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityCategory"]>

  export type activityCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["activityCategory"]>

  export type activityCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["activityCategory"]>

  export type activityCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type activityCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["activityCategory"]>
  export type activityCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | activityCategory$activityArgs<ExtArgs>
    _count?: boolean | ActivityCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type activityCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type activityCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $activityCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activityCategory"
    objects: {
      activity: Prisma.$activityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["activityCategory"]>
    composites: {}
  }

  type activityCategoryGetPayload<S extends boolean | null | undefined | activityCategoryDefaultArgs> = $Result.GetResult<Prisma.$activityCategoryPayload, S>

  type activityCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activityCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCategoryCountAggregateInputType | true
    }

  export interface activityCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activityCategory'], meta: { name: 'activityCategory' } }
    /**
     * Find zero or one ActivityCategory that matches the filter.
     * @param {activityCategoryFindUniqueArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activityCategoryFindUniqueArgs>(args: SelectSubset<T, activityCategoryFindUniqueArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activityCategoryFindUniqueOrThrowArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activityCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, activityCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCategoryFindFirstArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activityCategoryFindFirstArgs>(args?: SelectSubset<T, activityCategoryFindFirstArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCategoryFindFirstOrThrowArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activityCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, activityCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityCategories
     * const activityCategories = await prisma.activityCategory.findMany()
     * 
     * // Get first 10 ActivityCategories
     * const activityCategories = await prisma.activityCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activityCategoryFindManyArgs>(args?: SelectSubset<T, activityCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityCategory.
     * @param {activityCategoryCreateArgs} args - Arguments to create a ActivityCategory.
     * @example
     * // Create one ActivityCategory
     * const ActivityCategory = await prisma.activityCategory.create({
     *   data: {
     *     // ... data to create a ActivityCategory
     *   }
     * })
     * 
     */
    create<T extends activityCategoryCreateArgs>(args: SelectSubset<T, activityCategoryCreateArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityCategories.
     * @param {activityCategoryCreateManyArgs} args - Arguments to create many ActivityCategories.
     * @example
     * // Create many ActivityCategories
     * const activityCategory = await prisma.activityCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activityCategoryCreateManyArgs>(args?: SelectSubset<T, activityCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityCategories and returns the data saved in the database.
     * @param {activityCategoryCreateManyAndReturnArgs} args - Arguments to create many ActivityCategories.
     * @example
     * // Create many ActivityCategories
     * const activityCategory = await prisma.activityCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityCategories and only return the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activityCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, activityCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityCategory.
     * @param {activityCategoryDeleteArgs} args - Arguments to delete one ActivityCategory.
     * @example
     * // Delete one ActivityCategory
     * const ActivityCategory = await prisma.activityCategory.delete({
     *   where: {
     *     // ... filter to delete one ActivityCategory
     *   }
     * })
     * 
     */
    delete<T extends activityCategoryDeleteArgs>(args: SelectSubset<T, activityCategoryDeleteArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityCategory.
     * @param {activityCategoryUpdateArgs} args - Arguments to update one ActivityCategory.
     * @example
     * // Update one ActivityCategory
     * const activityCategory = await prisma.activityCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activityCategoryUpdateArgs>(args: SelectSubset<T, activityCategoryUpdateArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityCategories.
     * @param {activityCategoryDeleteManyArgs} args - Arguments to filter ActivityCategories to delete.
     * @example
     * // Delete a few ActivityCategories
     * const { count } = await prisma.activityCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activityCategoryDeleteManyArgs>(args?: SelectSubset<T, activityCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityCategories
     * const activityCategory = await prisma.activityCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activityCategoryUpdateManyArgs>(args: SelectSubset<T, activityCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityCategories and returns the data updated in the database.
     * @param {activityCategoryUpdateManyAndReturnArgs} args - Arguments to update many ActivityCategories.
     * @example
     * // Update many ActivityCategories
     * const activityCategory = await prisma.activityCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityCategories and only return the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends activityCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, activityCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityCategory.
     * @param {activityCategoryUpsertArgs} args - Arguments to update or create a ActivityCategory.
     * @example
     * // Update or create a ActivityCategory
     * const activityCategory = await prisma.activityCategory.upsert({
     *   create: {
     *     // ... data to create a ActivityCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityCategory we want to update
     *   }
     * })
     */
    upsert<T extends activityCategoryUpsertArgs>(args: SelectSubset<T, activityCategoryUpsertArgs<ExtArgs>>): Prisma__activityCategoryClient<$Result.GetResult<Prisma.$activityCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCategoryCountArgs} args - Arguments to filter ActivityCategories to count.
     * @example
     * // Count the number of ActivityCategories
     * const count = await prisma.activityCategory.count({
     *   where: {
     *     // ... the filter for the ActivityCategories we want to count
     *   }
     * })
    **/
    count<T extends activityCategoryCountArgs>(
      args?: Subset<T, activityCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityCategoryAggregateArgs>(args: Subset<T, ActivityCategoryAggregateArgs>): Prisma.PrismaPromise<GetActivityCategoryAggregateType<T>>

    /**
     * Group by ActivityCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activityCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activityCategoryGroupByArgs['orderBy'] }
        : { orderBy?: activityCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activityCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activityCategory model
   */
  readonly fields: activityCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activityCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activityCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends activityCategory$activityArgs<ExtArgs> = {}>(args?: Subset<T, activityCategory$activityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activityCategory model
   */
  interface activityCategoryFieldRefs {
    readonly id: FieldRef<"activityCategory", 'String'>
    readonly name: FieldRef<"activityCategory", 'String'>
    readonly description: FieldRef<"activityCategory", 'String'>
    readonly createdAt: FieldRef<"activityCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"activityCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activityCategory findUnique
   */
  export type activityCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which activityCategory to fetch.
     */
    where: activityCategoryWhereUniqueInput
  }

  /**
   * activityCategory findUniqueOrThrow
   */
  export type activityCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which activityCategory to fetch.
     */
    where: activityCategoryWhereUniqueInput
  }

  /**
   * activityCategory findFirst
   */
  export type activityCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which activityCategory to fetch.
     */
    where?: activityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityCategories to fetch.
     */
    orderBy?: activityCategoryOrderByWithRelationInput | activityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activityCategories.
     */
    cursor?: activityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activityCategories.
     */
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * activityCategory findFirstOrThrow
   */
  export type activityCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which activityCategory to fetch.
     */
    where?: activityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityCategories to fetch.
     */
    orderBy?: activityCategoryOrderByWithRelationInput | activityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activityCategories.
     */
    cursor?: activityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activityCategories.
     */
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * activityCategory findMany
   */
  export type activityCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which activityCategories to fetch.
     */
    where?: activityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activityCategories to fetch.
     */
    orderBy?: activityCategoryOrderByWithRelationInput | activityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activityCategories.
     */
    cursor?: activityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activityCategories.
     */
    skip?: number
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * activityCategory create
   */
  export type activityCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a activityCategory.
     */
    data: XOR<activityCategoryCreateInput, activityCategoryUncheckedCreateInput>
  }

  /**
   * activityCategory createMany
   */
  export type activityCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activityCategories.
     */
    data: activityCategoryCreateManyInput | activityCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activityCategory createManyAndReturn
   */
  export type activityCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many activityCategories.
     */
    data: activityCategoryCreateManyInput | activityCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activityCategory update
   */
  export type activityCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a activityCategory.
     */
    data: XOR<activityCategoryUpdateInput, activityCategoryUncheckedUpdateInput>
    /**
     * Choose, which activityCategory to update.
     */
    where: activityCategoryWhereUniqueInput
  }

  /**
   * activityCategory updateMany
   */
  export type activityCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activityCategories.
     */
    data: XOR<activityCategoryUpdateManyMutationInput, activityCategoryUncheckedUpdateManyInput>
    /**
     * Filter which activityCategories to update
     */
    where?: activityCategoryWhereInput
    /**
     * Limit how many activityCategories to update.
     */
    limit?: number
  }

  /**
   * activityCategory updateManyAndReturn
   */
  export type activityCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * The data used to update activityCategories.
     */
    data: XOR<activityCategoryUpdateManyMutationInput, activityCategoryUncheckedUpdateManyInput>
    /**
     * Filter which activityCategories to update
     */
    where?: activityCategoryWhereInput
    /**
     * Limit how many activityCategories to update.
     */
    limit?: number
  }

  /**
   * activityCategory upsert
   */
  export type activityCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the activityCategory to update in case it exists.
     */
    where: activityCategoryWhereUniqueInput
    /**
     * In case the activityCategory found by the `where` argument doesn't exist, create a new activityCategory with this data.
     */
    create: XOR<activityCategoryCreateInput, activityCategoryUncheckedCreateInput>
    /**
     * In case the activityCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activityCategoryUpdateInput, activityCategoryUncheckedUpdateInput>
  }

  /**
   * activityCategory delete
   */
  export type activityCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
    /**
     * Filter which activityCategory to delete.
     */
    where: activityCategoryWhereUniqueInput
  }

  /**
   * activityCategory deleteMany
   */
  export type activityCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activityCategories to delete
     */
    where?: activityCategoryWhereInput
    /**
     * Limit how many activityCategories to delete.
     */
    limit?: number
  }

  /**
   * activityCategory.activity
   */
  export type activityCategory$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    where?: activityWhereInput
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    cursor?: activityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * activityCategory without action
   */
  export type activityCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activityCategory
     */
    select?: activityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activityCategory
     */
    omit?: activityCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityCategoryInclude<ExtArgs> | null
  }


  /**
   * Model badgeCategory
   */

  export type AggregateBadgeCategory = {
    _count: BadgeCategoryCountAggregateOutputType | null
    _min: BadgeCategoryMinAggregateOutputType | null
    _max: BadgeCategoryMaxAggregateOutputType | null
  }

  export type BadgeCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badgeCategory to aggregate.
     */
    where?: badgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badgeCategories to fetch.
     */
    orderBy?: badgeCategoryOrderByWithRelationInput | badgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: badgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned badgeCategories
    **/
    _count?: true | BadgeCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeCategoryMaxAggregateInputType
  }

  export type GetBadgeCategoryAggregateType<T extends BadgeCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBadgeCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadgeCategory[P]>
      : GetScalarType<T[P], AggregateBadgeCategory[P]>
  }




  export type badgeCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgeCategoryWhereInput
    orderBy?: badgeCategoryOrderByWithAggregationInput | badgeCategoryOrderByWithAggregationInput[]
    by: BadgeCategoryScalarFieldEnum[] | BadgeCategoryScalarFieldEnum
    having?: badgeCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCategoryCountAggregateInputType | true
    _min?: BadgeCategoryMinAggregateInputType
    _max?: BadgeCategoryMaxAggregateInputType
  }

  export type BadgeCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: BadgeCategoryCountAggregateOutputType | null
    _min: BadgeCategoryMinAggregateOutputType | null
    _max: BadgeCategoryMaxAggregateOutputType | null
  }

  type GetBadgeCategoryGroupByPayload<T extends badgeCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeCategoryGroupByOutputType[P]>
        }
      >
    >


  export type badgeCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badge?: boolean | badgeCategory$badgeArgs<ExtArgs>
    _count?: boolean | BadgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badgeCategory"]>

  export type badgeCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badgeCategory"]>

  export type badgeCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badgeCategory"]>

  export type badgeCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type badgeCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["badgeCategory"]>
  export type badgeCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | badgeCategory$badgeArgs<ExtArgs>
    _count?: boolean | BadgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type badgeCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type badgeCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $badgeCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "badgeCategory"
    objects: {
      badge: Prisma.$badgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["badgeCategory"]>
    composites: {}
  }

  type badgeCategoryGetPayload<S extends boolean | null | undefined | badgeCategoryDefaultArgs> = $Result.GetResult<Prisma.$badgeCategoryPayload, S>

  type badgeCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<badgeCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCategoryCountAggregateInputType | true
    }

  export interface badgeCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['badgeCategory'], meta: { name: 'badgeCategory' } }
    /**
     * Find zero or one BadgeCategory that matches the filter.
     * @param {badgeCategoryFindUniqueArgs} args - Arguments to find a BadgeCategory
     * @example
     * // Get one BadgeCategory
     * const badgeCategory = await prisma.badgeCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends badgeCategoryFindUniqueArgs>(args: SelectSubset<T, badgeCategoryFindUniqueArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BadgeCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {badgeCategoryFindUniqueOrThrowArgs} args - Arguments to find a BadgeCategory
     * @example
     * // Get one BadgeCategory
     * const badgeCategory = await prisma.badgeCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends badgeCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, badgeCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCategoryFindFirstArgs} args - Arguments to find a BadgeCategory
     * @example
     * // Get one BadgeCategory
     * const badgeCategory = await prisma.badgeCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends badgeCategoryFindFirstArgs>(args?: SelectSubset<T, badgeCategoryFindFirstArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCategoryFindFirstOrThrowArgs} args - Arguments to find a BadgeCategory
     * @example
     * // Get one BadgeCategory
     * const badgeCategory = await prisma.badgeCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends badgeCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, badgeCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BadgeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BadgeCategories
     * const badgeCategories = await prisma.badgeCategory.findMany()
     * 
     * // Get first 10 BadgeCategories
     * const badgeCategories = await prisma.badgeCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeCategoryWithIdOnly = await prisma.badgeCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends badgeCategoryFindManyArgs>(args?: SelectSubset<T, badgeCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BadgeCategory.
     * @param {badgeCategoryCreateArgs} args - Arguments to create a BadgeCategory.
     * @example
     * // Create one BadgeCategory
     * const BadgeCategory = await prisma.badgeCategory.create({
     *   data: {
     *     // ... data to create a BadgeCategory
     *   }
     * })
     * 
     */
    create<T extends badgeCategoryCreateArgs>(args: SelectSubset<T, badgeCategoryCreateArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BadgeCategories.
     * @param {badgeCategoryCreateManyArgs} args - Arguments to create many BadgeCategories.
     * @example
     * // Create many BadgeCategories
     * const badgeCategory = await prisma.badgeCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends badgeCategoryCreateManyArgs>(args?: SelectSubset<T, badgeCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BadgeCategories and returns the data saved in the database.
     * @param {badgeCategoryCreateManyAndReturnArgs} args - Arguments to create many BadgeCategories.
     * @example
     * // Create many BadgeCategories
     * const badgeCategory = await prisma.badgeCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BadgeCategories and only return the `id`
     * const badgeCategoryWithIdOnly = await prisma.badgeCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends badgeCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, badgeCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BadgeCategory.
     * @param {badgeCategoryDeleteArgs} args - Arguments to delete one BadgeCategory.
     * @example
     * // Delete one BadgeCategory
     * const BadgeCategory = await prisma.badgeCategory.delete({
     *   where: {
     *     // ... filter to delete one BadgeCategory
     *   }
     * })
     * 
     */
    delete<T extends badgeCategoryDeleteArgs>(args: SelectSubset<T, badgeCategoryDeleteArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BadgeCategory.
     * @param {badgeCategoryUpdateArgs} args - Arguments to update one BadgeCategory.
     * @example
     * // Update one BadgeCategory
     * const badgeCategory = await prisma.badgeCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends badgeCategoryUpdateArgs>(args: SelectSubset<T, badgeCategoryUpdateArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BadgeCategories.
     * @param {badgeCategoryDeleteManyArgs} args - Arguments to filter BadgeCategories to delete.
     * @example
     * // Delete a few BadgeCategories
     * const { count } = await prisma.badgeCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends badgeCategoryDeleteManyArgs>(args?: SelectSubset<T, badgeCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BadgeCategories
     * const badgeCategory = await prisma.badgeCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends badgeCategoryUpdateManyArgs>(args: SelectSubset<T, badgeCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeCategories and returns the data updated in the database.
     * @param {badgeCategoryUpdateManyAndReturnArgs} args - Arguments to update many BadgeCategories.
     * @example
     * // Update many BadgeCategories
     * const badgeCategory = await prisma.badgeCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BadgeCategories and only return the `id`
     * const badgeCategoryWithIdOnly = await prisma.badgeCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends badgeCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, badgeCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BadgeCategory.
     * @param {badgeCategoryUpsertArgs} args - Arguments to update or create a BadgeCategory.
     * @example
     * // Update or create a BadgeCategory
     * const badgeCategory = await prisma.badgeCategory.upsert({
     *   create: {
     *     // ... data to create a BadgeCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BadgeCategory we want to update
     *   }
     * })
     */
    upsert<T extends badgeCategoryUpsertArgs>(args: SelectSubset<T, badgeCategoryUpsertArgs<ExtArgs>>): Prisma__badgeCategoryClient<$Result.GetResult<Prisma.$badgeCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BadgeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCategoryCountArgs} args - Arguments to filter BadgeCategories to count.
     * @example
     * // Count the number of BadgeCategories
     * const count = await prisma.badgeCategory.count({
     *   where: {
     *     // ... the filter for the BadgeCategories we want to count
     *   }
     * })
    **/
    count<T extends badgeCategoryCountArgs>(
      args?: Subset<T, badgeCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BadgeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeCategoryAggregateArgs>(args: Subset<T, BadgeCategoryAggregateArgs>): Prisma.PrismaPromise<GetBadgeCategoryAggregateType<T>>

    /**
     * Group by BadgeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends badgeCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: badgeCategoryGroupByArgs['orderBy'] }
        : { orderBy?: badgeCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, badgeCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the badgeCategory model
   */
  readonly fields: badgeCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for badgeCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__badgeCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends badgeCategory$badgeArgs<ExtArgs> = {}>(args?: Subset<T, badgeCategory$badgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the badgeCategory model
   */
  interface badgeCategoryFieldRefs {
    readonly id: FieldRef<"badgeCategory", 'String'>
    readonly name: FieldRef<"badgeCategory", 'String'>
    readonly description: FieldRef<"badgeCategory", 'String'>
    readonly createdAt: FieldRef<"badgeCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"badgeCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * badgeCategory findUnique
   */
  export type badgeCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which badgeCategory to fetch.
     */
    where: badgeCategoryWhereUniqueInput
  }

  /**
   * badgeCategory findUniqueOrThrow
   */
  export type badgeCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which badgeCategory to fetch.
     */
    where: badgeCategoryWhereUniqueInput
  }

  /**
   * badgeCategory findFirst
   */
  export type badgeCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which badgeCategory to fetch.
     */
    where?: badgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badgeCategories to fetch.
     */
    orderBy?: badgeCategoryOrderByWithRelationInput | badgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badgeCategories.
     */
    cursor?: badgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badgeCategories.
     */
    distinct?: BadgeCategoryScalarFieldEnum | BadgeCategoryScalarFieldEnum[]
  }

  /**
   * badgeCategory findFirstOrThrow
   */
  export type badgeCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which badgeCategory to fetch.
     */
    where?: badgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badgeCategories to fetch.
     */
    orderBy?: badgeCategoryOrderByWithRelationInput | badgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badgeCategories.
     */
    cursor?: badgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badgeCategories.
     */
    distinct?: BadgeCategoryScalarFieldEnum | BadgeCategoryScalarFieldEnum[]
  }

  /**
   * badgeCategory findMany
   */
  export type badgeCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which badgeCategories to fetch.
     */
    where?: badgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badgeCategories to fetch.
     */
    orderBy?: badgeCategoryOrderByWithRelationInput | badgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing badgeCategories.
     */
    cursor?: badgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badgeCategories.
     */
    skip?: number
    distinct?: BadgeCategoryScalarFieldEnum | BadgeCategoryScalarFieldEnum[]
  }

  /**
   * badgeCategory create
   */
  export type badgeCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a badgeCategory.
     */
    data: XOR<badgeCategoryCreateInput, badgeCategoryUncheckedCreateInput>
  }

  /**
   * badgeCategory createMany
   */
  export type badgeCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many badgeCategories.
     */
    data: badgeCategoryCreateManyInput | badgeCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badgeCategory createManyAndReturn
   */
  export type badgeCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many badgeCategories.
     */
    data: badgeCategoryCreateManyInput | badgeCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badgeCategory update
   */
  export type badgeCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a badgeCategory.
     */
    data: XOR<badgeCategoryUpdateInput, badgeCategoryUncheckedUpdateInput>
    /**
     * Choose, which badgeCategory to update.
     */
    where: badgeCategoryWhereUniqueInput
  }

  /**
   * badgeCategory updateMany
   */
  export type badgeCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update badgeCategories.
     */
    data: XOR<badgeCategoryUpdateManyMutationInput, badgeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which badgeCategories to update
     */
    where?: badgeCategoryWhereInput
    /**
     * Limit how many badgeCategories to update.
     */
    limit?: number
  }

  /**
   * badgeCategory updateManyAndReturn
   */
  export type badgeCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * The data used to update badgeCategories.
     */
    data: XOR<badgeCategoryUpdateManyMutationInput, badgeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which badgeCategories to update
     */
    where?: badgeCategoryWhereInput
    /**
     * Limit how many badgeCategories to update.
     */
    limit?: number
  }

  /**
   * badgeCategory upsert
   */
  export type badgeCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the badgeCategory to update in case it exists.
     */
    where: badgeCategoryWhereUniqueInput
    /**
     * In case the badgeCategory found by the `where` argument doesn't exist, create a new badgeCategory with this data.
     */
    create: XOR<badgeCategoryCreateInput, badgeCategoryUncheckedCreateInput>
    /**
     * In case the badgeCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<badgeCategoryUpdateInput, badgeCategoryUncheckedUpdateInput>
  }

  /**
   * badgeCategory delete
   */
  export type badgeCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
    /**
     * Filter which badgeCategory to delete.
     */
    where: badgeCategoryWhereUniqueInput
  }

  /**
   * badgeCategory deleteMany
   */
  export type badgeCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badgeCategories to delete
     */
    where?: badgeCategoryWhereInput
    /**
     * Limit how many badgeCategories to delete.
     */
    limit?: number
  }

  /**
   * badgeCategory.badge
   */
  export type badgeCategory$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    where?: badgeWhereInput
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    cursor?: badgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * badgeCategory without action
   */
  export type badgeCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badgeCategory
     */
    select?: badgeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the badgeCategory
     */
    omit?: badgeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeCategoryInclude<ExtArgs> | null
  }


  /**
   * Model cognitiveCategory
   */

  export type AggregateCognitiveCategory = {
    _count: CognitiveCategoryCountAggregateOutputType | null
    _min: CognitiveCategoryMinAggregateOutputType | null
    _max: CognitiveCategoryMaxAggregateOutputType | null
  }

  export type CognitiveCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CognitiveCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CognitiveCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CognitiveCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CognitiveCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CognitiveCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CognitiveCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cognitiveCategory to aggregate.
     */
    where?: cognitiveCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveCategories to fetch.
     */
    orderBy?: cognitiveCategoryOrderByWithRelationInput | cognitiveCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cognitiveCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cognitiveCategories
    **/
    _count?: true | CognitiveCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CognitiveCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CognitiveCategoryMaxAggregateInputType
  }

  export type GetCognitiveCategoryAggregateType<T extends CognitiveCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCognitiveCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCognitiveCategory[P]>
      : GetScalarType<T[P], AggregateCognitiveCategory[P]>
  }




  export type cognitiveCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cognitiveCategoryWhereInput
    orderBy?: cognitiveCategoryOrderByWithAggregationInput | cognitiveCategoryOrderByWithAggregationInput[]
    by: CognitiveCategoryScalarFieldEnum[] | CognitiveCategoryScalarFieldEnum
    having?: cognitiveCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CognitiveCategoryCountAggregateInputType | true
    _min?: CognitiveCategoryMinAggregateInputType
    _max?: CognitiveCategoryMaxAggregateInputType
  }

  export type CognitiveCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: CognitiveCategoryCountAggregateOutputType | null
    _min: CognitiveCategoryMinAggregateOutputType | null
    _max: CognitiveCategoryMaxAggregateOutputType | null
  }

  type GetCognitiveCategoryGroupByPayload<T extends cognitiveCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CognitiveCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CognitiveCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CognitiveCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CognitiveCategoryGroupByOutputType[P]>
        }
      >
    >


  export type cognitiveCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cognitiveExercise?: boolean | cognitiveCategory$cognitiveExerciseArgs<ExtArgs>
    _count?: boolean | CognitiveCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cognitiveCategory"]>

  export type cognitiveCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cognitiveCategory"]>

  export type cognitiveCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cognitiveCategory"]>

  export type cognitiveCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type cognitiveCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["cognitiveCategory"]>
  export type cognitiveCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveExercise?: boolean | cognitiveCategory$cognitiveExerciseArgs<ExtArgs>
    _count?: boolean | CognitiveCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cognitiveCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type cognitiveCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $cognitiveCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cognitiveCategory"
    objects: {
      cognitiveExercise: Prisma.$cognitiveExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["cognitiveCategory"]>
    composites: {}
  }

  type cognitiveCategoryGetPayload<S extends boolean | null | undefined | cognitiveCategoryDefaultArgs> = $Result.GetResult<Prisma.$cognitiveCategoryPayload, S>

  type cognitiveCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cognitiveCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CognitiveCategoryCountAggregateInputType | true
    }

  export interface cognitiveCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cognitiveCategory'], meta: { name: 'cognitiveCategory' } }
    /**
     * Find zero or one CognitiveCategory that matches the filter.
     * @param {cognitiveCategoryFindUniqueArgs} args - Arguments to find a CognitiveCategory
     * @example
     * // Get one CognitiveCategory
     * const cognitiveCategory = await prisma.cognitiveCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cognitiveCategoryFindUniqueArgs>(args: SelectSubset<T, cognitiveCategoryFindUniqueArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CognitiveCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cognitiveCategoryFindUniqueOrThrowArgs} args - Arguments to find a CognitiveCategory
     * @example
     * // Get one CognitiveCategory
     * const cognitiveCategory = await prisma.cognitiveCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cognitiveCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, cognitiveCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CognitiveCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveCategoryFindFirstArgs} args - Arguments to find a CognitiveCategory
     * @example
     * // Get one CognitiveCategory
     * const cognitiveCategory = await prisma.cognitiveCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cognitiveCategoryFindFirstArgs>(args?: SelectSubset<T, cognitiveCategoryFindFirstArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CognitiveCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveCategoryFindFirstOrThrowArgs} args - Arguments to find a CognitiveCategory
     * @example
     * // Get one CognitiveCategory
     * const cognitiveCategory = await prisma.cognitiveCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cognitiveCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, cognitiveCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CognitiveCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CognitiveCategories
     * const cognitiveCategories = await prisma.cognitiveCategory.findMany()
     * 
     * // Get first 10 CognitiveCategories
     * const cognitiveCategories = await prisma.cognitiveCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cognitiveCategoryWithIdOnly = await prisma.cognitiveCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cognitiveCategoryFindManyArgs>(args?: SelectSubset<T, cognitiveCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CognitiveCategory.
     * @param {cognitiveCategoryCreateArgs} args - Arguments to create a CognitiveCategory.
     * @example
     * // Create one CognitiveCategory
     * const CognitiveCategory = await prisma.cognitiveCategory.create({
     *   data: {
     *     // ... data to create a CognitiveCategory
     *   }
     * })
     * 
     */
    create<T extends cognitiveCategoryCreateArgs>(args: SelectSubset<T, cognitiveCategoryCreateArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CognitiveCategories.
     * @param {cognitiveCategoryCreateManyArgs} args - Arguments to create many CognitiveCategories.
     * @example
     * // Create many CognitiveCategories
     * const cognitiveCategory = await prisma.cognitiveCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cognitiveCategoryCreateManyArgs>(args?: SelectSubset<T, cognitiveCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CognitiveCategories and returns the data saved in the database.
     * @param {cognitiveCategoryCreateManyAndReturnArgs} args - Arguments to create many CognitiveCategories.
     * @example
     * // Create many CognitiveCategories
     * const cognitiveCategory = await prisma.cognitiveCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CognitiveCategories and only return the `id`
     * const cognitiveCategoryWithIdOnly = await prisma.cognitiveCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cognitiveCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, cognitiveCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CognitiveCategory.
     * @param {cognitiveCategoryDeleteArgs} args - Arguments to delete one CognitiveCategory.
     * @example
     * // Delete one CognitiveCategory
     * const CognitiveCategory = await prisma.cognitiveCategory.delete({
     *   where: {
     *     // ... filter to delete one CognitiveCategory
     *   }
     * })
     * 
     */
    delete<T extends cognitiveCategoryDeleteArgs>(args: SelectSubset<T, cognitiveCategoryDeleteArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CognitiveCategory.
     * @param {cognitiveCategoryUpdateArgs} args - Arguments to update one CognitiveCategory.
     * @example
     * // Update one CognitiveCategory
     * const cognitiveCategory = await prisma.cognitiveCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cognitiveCategoryUpdateArgs>(args: SelectSubset<T, cognitiveCategoryUpdateArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CognitiveCategories.
     * @param {cognitiveCategoryDeleteManyArgs} args - Arguments to filter CognitiveCategories to delete.
     * @example
     * // Delete a few CognitiveCategories
     * const { count } = await prisma.cognitiveCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cognitiveCategoryDeleteManyArgs>(args?: SelectSubset<T, cognitiveCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CognitiveCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CognitiveCategories
     * const cognitiveCategory = await prisma.cognitiveCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cognitiveCategoryUpdateManyArgs>(args: SelectSubset<T, cognitiveCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CognitiveCategories and returns the data updated in the database.
     * @param {cognitiveCategoryUpdateManyAndReturnArgs} args - Arguments to update many CognitiveCategories.
     * @example
     * // Update many CognitiveCategories
     * const cognitiveCategory = await prisma.cognitiveCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CognitiveCategories and only return the `id`
     * const cognitiveCategoryWithIdOnly = await prisma.cognitiveCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cognitiveCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, cognitiveCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CognitiveCategory.
     * @param {cognitiveCategoryUpsertArgs} args - Arguments to update or create a CognitiveCategory.
     * @example
     * // Update or create a CognitiveCategory
     * const cognitiveCategory = await prisma.cognitiveCategory.upsert({
     *   create: {
     *     // ... data to create a CognitiveCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CognitiveCategory we want to update
     *   }
     * })
     */
    upsert<T extends cognitiveCategoryUpsertArgs>(args: SelectSubset<T, cognitiveCategoryUpsertArgs<ExtArgs>>): Prisma__cognitiveCategoryClient<$Result.GetResult<Prisma.$cognitiveCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CognitiveCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveCategoryCountArgs} args - Arguments to filter CognitiveCategories to count.
     * @example
     * // Count the number of CognitiveCategories
     * const count = await prisma.cognitiveCategory.count({
     *   where: {
     *     // ... the filter for the CognitiveCategories we want to count
     *   }
     * })
    **/
    count<T extends cognitiveCategoryCountArgs>(
      args?: Subset<T, cognitiveCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CognitiveCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CognitiveCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CognitiveCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CognitiveCategoryAggregateArgs>(args: Subset<T, CognitiveCategoryAggregateArgs>): Prisma.PrismaPromise<GetCognitiveCategoryAggregateType<T>>

    /**
     * Group by CognitiveCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cognitiveCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cognitiveCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cognitiveCategoryGroupByArgs['orderBy'] }
        : { orderBy?: cognitiveCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cognitiveCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCognitiveCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cognitiveCategory model
   */
  readonly fields: cognitiveCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cognitiveCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cognitiveCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cognitiveExercise<T extends cognitiveCategory$cognitiveExerciseArgs<ExtArgs> = {}>(args?: Subset<T, cognitiveCategory$cognitiveExerciseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cognitiveCategory model
   */
  interface cognitiveCategoryFieldRefs {
    readonly id: FieldRef<"cognitiveCategory", 'String'>
    readonly name: FieldRef<"cognitiveCategory", 'String'>
    readonly description: FieldRef<"cognitiveCategory", 'String'>
    readonly createdAt: FieldRef<"cognitiveCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"cognitiveCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cognitiveCategory findUnique
   */
  export type cognitiveCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveCategory to fetch.
     */
    where: cognitiveCategoryWhereUniqueInput
  }

  /**
   * cognitiveCategory findUniqueOrThrow
   */
  export type cognitiveCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveCategory to fetch.
     */
    where: cognitiveCategoryWhereUniqueInput
  }

  /**
   * cognitiveCategory findFirst
   */
  export type cognitiveCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveCategory to fetch.
     */
    where?: cognitiveCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveCategories to fetch.
     */
    orderBy?: cognitiveCategoryOrderByWithRelationInput | cognitiveCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cognitiveCategories.
     */
    cursor?: cognitiveCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cognitiveCategories.
     */
    distinct?: CognitiveCategoryScalarFieldEnum | CognitiveCategoryScalarFieldEnum[]
  }

  /**
   * cognitiveCategory findFirstOrThrow
   */
  export type cognitiveCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveCategory to fetch.
     */
    where?: cognitiveCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveCategories to fetch.
     */
    orderBy?: cognitiveCategoryOrderByWithRelationInput | cognitiveCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cognitiveCategories.
     */
    cursor?: cognitiveCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cognitiveCategories.
     */
    distinct?: CognitiveCategoryScalarFieldEnum | CognitiveCategoryScalarFieldEnum[]
  }

  /**
   * cognitiveCategory findMany
   */
  export type cognitiveCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * Filter, which cognitiveCategories to fetch.
     */
    where?: cognitiveCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cognitiveCategories to fetch.
     */
    orderBy?: cognitiveCategoryOrderByWithRelationInput | cognitiveCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cognitiveCategories.
     */
    cursor?: cognitiveCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cognitiveCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cognitiveCategories.
     */
    skip?: number
    distinct?: CognitiveCategoryScalarFieldEnum | CognitiveCategoryScalarFieldEnum[]
  }

  /**
   * cognitiveCategory create
   */
  export type cognitiveCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a cognitiveCategory.
     */
    data: XOR<cognitiveCategoryCreateInput, cognitiveCategoryUncheckedCreateInput>
  }

  /**
   * cognitiveCategory createMany
   */
  export type cognitiveCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cognitiveCategories.
     */
    data: cognitiveCategoryCreateManyInput | cognitiveCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cognitiveCategory createManyAndReturn
   */
  export type cognitiveCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many cognitiveCategories.
     */
    data: cognitiveCategoryCreateManyInput | cognitiveCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cognitiveCategory update
   */
  export type cognitiveCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a cognitiveCategory.
     */
    data: XOR<cognitiveCategoryUpdateInput, cognitiveCategoryUncheckedUpdateInput>
    /**
     * Choose, which cognitiveCategory to update.
     */
    where: cognitiveCategoryWhereUniqueInput
  }

  /**
   * cognitiveCategory updateMany
   */
  export type cognitiveCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cognitiveCategories.
     */
    data: XOR<cognitiveCategoryUpdateManyMutationInput, cognitiveCategoryUncheckedUpdateManyInput>
    /**
     * Filter which cognitiveCategories to update
     */
    where?: cognitiveCategoryWhereInput
    /**
     * Limit how many cognitiveCategories to update.
     */
    limit?: number
  }

  /**
   * cognitiveCategory updateManyAndReturn
   */
  export type cognitiveCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * The data used to update cognitiveCategories.
     */
    data: XOR<cognitiveCategoryUpdateManyMutationInput, cognitiveCategoryUncheckedUpdateManyInput>
    /**
     * Filter which cognitiveCategories to update
     */
    where?: cognitiveCategoryWhereInput
    /**
     * Limit how many cognitiveCategories to update.
     */
    limit?: number
  }

  /**
   * cognitiveCategory upsert
   */
  export type cognitiveCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the cognitiveCategory to update in case it exists.
     */
    where: cognitiveCategoryWhereUniqueInput
    /**
     * In case the cognitiveCategory found by the `where` argument doesn't exist, create a new cognitiveCategory with this data.
     */
    create: XOR<cognitiveCategoryCreateInput, cognitiveCategoryUncheckedCreateInput>
    /**
     * In case the cognitiveCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cognitiveCategoryUpdateInput, cognitiveCategoryUncheckedUpdateInput>
  }

  /**
   * cognitiveCategory delete
   */
  export type cognitiveCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
    /**
     * Filter which cognitiveCategory to delete.
     */
    where: cognitiveCategoryWhereUniqueInput
  }

  /**
   * cognitiveCategory deleteMany
   */
  export type cognitiveCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cognitiveCategories to delete
     */
    where?: cognitiveCategoryWhereInput
    /**
     * Limit how many cognitiveCategories to delete.
     */
    limit?: number
  }

  /**
   * cognitiveCategory.cognitiveExercise
   */
  export type cognitiveCategory$cognitiveExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    where?: cognitiveExerciseWhereInput
    orderBy?: cognitiveExerciseOrderByWithRelationInput | cognitiveExerciseOrderByWithRelationInput[]
    cursor?: cognitiveExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CognitiveExerciseScalarFieldEnum | CognitiveExerciseScalarFieldEnum[]
  }

  /**
   * cognitiveCategory without action
   */
  export type cognitiveCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveCategory
     */
    select?: cognitiveCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveCategory
     */
    omit?: cognitiveCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveCategoryInclude<ExtArgs> | null
  }


  /**
   * Model helpCategory
   */

  export type AggregateHelpCategory = {
    _count: HelpCategoryCountAggregateOutputType | null
    _min: HelpCategoryMinAggregateOutputType | null
    _max: HelpCategoryMaxAggregateOutputType | null
  }

  export type HelpCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helpCategory to aggregate.
     */
    where?: helpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpCategories to fetch.
     */
    orderBy?: helpCategoryOrderByWithRelationInput | helpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: helpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned helpCategories
    **/
    _count?: true | HelpCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpCategoryMaxAggregateInputType
  }

  export type GetHelpCategoryAggregateType<T extends HelpCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpCategory[P]>
      : GetScalarType<T[P], AggregateHelpCategory[P]>
  }




  export type helpCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helpCategoryWhereInput
    orderBy?: helpCategoryOrderByWithAggregationInput | helpCategoryOrderByWithAggregationInput[]
    by: HelpCategoryScalarFieldEnum[] | HelpCategoryScalarFieldEnum
    having?: helpCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCategoryCountAggregateInputType | true
    _min?: HelpCategoryMinAggregateInputType
    _max?: HelpCategoryMaxAggregateInputType
  }

  export type HelpCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: HelpCategoryCountAggregateOutputType | null
    _min: HelpCategoryMinAggregateOutputType | null
    _max: HelpCategoryMaxAggregateOutputType | null
  }

  type GetHelpCategoryGroupByPayload<T extends helpCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], HelpCategoryGroupByOutputType[P]>
        }
      >
    >


  export type helpCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    helpRequest?: boolean | helpCategory$helpRequestArgs<ExtArgs>
    _count?: boolean | HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCategory"]>

  export type helpCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["helpCategory"]>

  export type helpCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["helpCategory"]>

  export type helpCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type helpCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["helpCategory"]>
  export type helpCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpRequest?: boolean | helpCategory$helpRequestArgs<ExtArgs>
    _count?: boolean | HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type helpCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type helpCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $helpCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "helpCategory"
    objects: {
      helpRequest: Prisma.$helpRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["helpCategory"]>
    composites: {}
  }

  type helpCategoryGetPayload<S extends boolean | null | undefined | helpCategoryDefaultArgs> = $Result.GetResult<Prisma.$helpCategoryPayload, S>

  type helpCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<helpCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelpCategoryCountAggregateInputType | true
    }

  export interface helpCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['helpCategory'], meta: { name: 'helpCategory' } }
    /**
     * Find zero or one HelpCategory that matches the filter.
     * @param {helpCategoryFindUniqueArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends helpCategoryFindUniqueArgs>(args: SelectSubset<T, helpCategoryFindUniqueArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HelpCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {helpCategoryFindUniqueOrThrowArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends helpCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, helpCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpCategoryFindFirstArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends helpCategoryFindFirstArgs>(args?: SelectSubset<T, helpCategoryFindFirstArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpCategoryFindFirstOrThrowArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends helpCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, helpCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HelpCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpCategories
     * const helpCategories = await prisma.helpCategory.findMany()
     * 
     * // Get first 10 HelpCategories
     * const helpCategories = await prisma.helpCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpCategoryWithIdOnly = await prisma.helpCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends helpCategoryFindManyArgs>(args?: SelectSubset<T, helpCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HelpCategory.
     * @param {helpCategoryCreateArgs} args - Arguments to create a HelpCategory.
     * @example
     * // Create one HelpCategory
     * const HelpCategory = await prisma.helpCategory.create({
     *   data: {
     *     // ... data to create a HelpCategory
     *   }
     * })
     * 
     */
    create<T extends helpCategoryCreateArgs>(args: SelectSubset<T, helpCategoryCreateArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HelpCategories.
     * @param {helpCategoryCreateManyArgs} args - Arguments to create many HelpCategories.
     * @example
     * // Create many HelpCategories
     * const helpCategory = await prisma.helpCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends helpCategoryCreateManyArgs>(args?: SelectSubset<T, helpCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpCategories and returns the data saved in the database.
     * @param {helpCategoryCreateManyAndReturnArgs} args - Arguments to create many HelpCategories.
     * @example
     * // Create many HelpCategories
     * const helpCategory = await prisma.helpCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpCategories and only return the `id`
     * const helpCategoryWithIdOnly = await prisma.helpCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends helpCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, helpCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HelpCategory.
     * @param {helpCategoryDeleteArgs} args - Arguments to delete one HelpCategory.
     * @example
     * // Delete one HelpCategory
     * const HelpCategory = await prisma.helpCategory.delete({
     *   where: {
     *     // ... filter to delete one HelpCategory
     *   }
     * })
     * 
     */
    delete<T extends helpCategoryDeleteArgs>(args: SelectSubset<T, helpCategoryDeleteArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HelpCategory.
     * @param {helpCategoryUpdateArgs} args - Arguments to update one HelpCategory.
     * @example
     * // Update one HelpCategory
     * const helpCategory = await prisma.helpCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends helpCategoryUpdateArgs>(args: SelectSubset<T, helpCategoryUpdateArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HelpCategories.
     * @param {helpCategoryDeleteManyArgs} args - Arguments to filter HelpCategories to delete.
     * @example
     * // Delete a few HelpCategories
     * const { count } = await prisma.helpCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends helpCategoryDeleteManyArgs>(args?: SelectSubset<T, helpCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpCategories
     * const helpCategory = await prisma.helpCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends helpCategoryUpdateManyArgs>(args: SelectSubset<T, helpCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpCategories and returns the data updated in the database.
     * @param {helpCategoryUpdateManyAndReturnArgs} args - Arguments to update many HelpCategories.
     * @example
     * // Update many HelpCategories
     * const helpCategory = await prisma.helpCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HelpCategories and only return the `id`
     * const helpCategoryWithIdOnly = await prisma.helpCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends helpCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, helpCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HelpCategory.
     * @param {helpCategoryUpsertArgs} args - Arguments to update or create a HelpCategory.
     * @example
     * // Update or create a HelpCategory
     * const helpCategory = await prisma.helpCategory.upsert({
     *   create: {
     *     // ... data to create a HelpCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpCategory we want to update
     *   }
     * })
     */
    upsert<T extends helpCategoryUpsertArgs>(args: SelectSubset<T, helpCategoryUpsertArgs<ExtArgs>>): Prisma__helpCategoryClient<$Result.GetResult<Prisma.$helpCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HelpCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpCategoryCountArgs} args - Arguments to filter HelpCategories to count.
     * @example
     * // Count the number of HelpCategories
     * const count = await prisma.helpCategory.count({
     *   where: {
     *     // ... the filter for the HelpCategories we want to count
     *   }
     * })
    **/
    count<T extends helpCategoryCountArgs>(
      args?: Subset<T, helpCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpCategoryAggregateArgs>(args: Subset<T, HelpCategoryAggregateArgs>): Prisma.PrismaPromise<GetHelpCategoryAggregateType<T>>

    /**
     * Group by HelpCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helpCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends helpCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: helpCategoryGroupByArgs['orderBy'] }
        : { orderBy?: helpCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, helpCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the helpCategory model
   */
  readonly fields: helpCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for helpCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__helpCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    helpRequest<T extends helpCategory$helpRequestArgs<ExtArgs> = {}>(args?: Subset<T, helpCategory$helpRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helpRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the helpCategory model
   */
  interface helpCategoryFieldRefs {
    readonly id: FieldRef<"helpCategory", 'String'>
    readonly name: FieldRef<"helpCategory", 'String'>
    readonly description: FieldRef<"helpCategory", 'String'>
    readonly createdAt: FieldRef<"helpCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"helpCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * helpCategory findUnique
   */
  export type helpCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which helpCategory to fetch.
     */
    where: helpCategoryWhereUniqueInput
  }

  /**
   * helpCategory findUniqueOrThrow
   */
  export type helpCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which helpCategory to fetch.
     */
    where: helpCategoryWhereUniqueInput
  }

  /**
   * helpCategory findFirst
   */
  export type helpCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which helpCategory to fetch.
     */
    where?: helpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpCategories to fetch.
     */
    orderBy?: helpCategoryOrderByWithRelationInput | helpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helpCategories.
     */
    cursor?: helpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helpCategories.
     */
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * helpCategory findFirstOrThrow
   */
  export type helpCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which helpCategory to fetch.
     */
    where?: helpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpCategories to fetch.
     */
    orderBy?: helpCategoryOrderByWithRelationInput | helpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helpCategories.
     */
    cursor?: helpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helpCategories.
     */
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * helpCategory findMany
   */
  export type helpCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which helpCategories to fetch.
     */
    where?: helpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helpCategories to fetch.
     */
    orderBy?: helpCategoryOrderByWithRelationInput | helpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing helpCategories.
     */
    cursor?: helpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helpCategories.
     */
    skip?: number
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * helpCategory create
   */
  export type helpCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a helpCategory.
     */
    data: XOR<helpCategoryCreateInput, helpCategoryUncheckedCreateInput>
  }

  /**
   * helpCategory createMany
   */
  export type helpCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many helpCategories.
     */
    data: helpCategoryCreateManyInput | helpCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * helpCategory createManyAndReturn
   */
  export type helpCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many helpCategories.
     */
    data: helpCategoryCreateManyInput | helpCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * helpCategory update
   */
  export type helpCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a helpCategory.
     */
    data: XOR<helpCategoryUpdateInput, helpCategoryUncheckedUpdateInput>
    /**
     * Choose, which helpCategory to update.
     */
    where: helpCategoryWhereUniqueInput
  }

  /**
   * helpCategory updateMany
   */
  export type helpCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update helpCategories.
     */
    data: XOR<helpCategoryUpdateManyMutationInput, helpCategoryUncheckedUpdateManyInput>
    /**
     * Filter which helpCategories to update
     */
    where?: helpCategoryWhereInput
    /**
     * Limit how many helpCategories to update.
     */
    limit?: number
  }

  /**
   * helpCategory updateManyAndReturn
   */
  export type helpCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * The data used to update helpCategories.
     */
    data: XOR<helpCategoryUpdateManyMutationInput, helpCategoryUncheckedUpdateManyInput>
    /**
     * Filter which helpCategories to update
     */
    where?: helpCategoryWhereInput
    /**
     * Limit how many helpCategories to update.
     */
    limit?: number
  }

  /**
   * helpCategory upsert
   */
  export type helpCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the helpCategory to update in case it exists.
     */
    where: helpCategoryWhereUniqueInput
    /**
     * In case the helpCategory found by the `where` argument doesn't exist, create a new helpCategory with this data.
     */
    create: XOR<helpCategoryCreateInput, helpCategoryUncheckedCreateInput>
    /**
     * In case the helpCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<helpCategoryUpdateInput, helpCategoryUncheckedUpdateInput>
  }

  /**
   * helpCategory delete
   */
  export type helpCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
    /**
     * Filter which helpCategory to delete.
     */
    where: helpCategoryWhereUniqueInput
  }

  /**
   * helpCategory deleteMany
   */
  export type helpCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helpCategories to delete
     */
    where?: helpCategoryWhereInput
    /**
     * Limit how many helpCategories to delete.
     */
    limit?: number
  }

  /**
   * helpCategory.helpRequest
   */
  export type helpCategory$helpRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpRequest
     */
    select?: helpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpRequest
     */
    omit?: helpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpRequestInclude<ExtArgs> | null
    where?: helpRequestWhereInput
    orderBy?: helpRequestOrderByWithRelationInput | helpRequestOrderByWithRelationInput[]
    cursor?: helpRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * helpCategory without action
   */
  export type helpCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helpCategory
     */
    select?: helpCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the helpCategory
     */
    omit?: helpCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helpCategoryInclude<ExtArgs> | null
  }


  /**
   * Model issueCategory
   */

  export type AggregateIssueCategory = {
    _count: IssueCategoryCountAggregateOutputType | null
    _min: IssueCategoryMinAggregateOutputType | null
    _max: IssueCategoryMaxAggregateOutputType | null
  }

  export type IssueCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssueCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssueCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IssueCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssueCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssueCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IssueCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which issueCategory to aggregate.
     */
    where?: issueCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issueCategories to fetch.
     */
    orderBy?: issueCategoryOrderByWithRelationInput | issueCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: issueCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issueCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issueCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned issueCategories
    **/
    _count?: true | IssueCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueCategoryMaxAggregateInputType
  }

  export type GetIssueCategoryAggregateType<T extends IssueCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateIssueCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssueCategory[P]>
      : GetScalarType<T[P], AggregateIssueCategory[P]>
  }




  export type issueCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: issueCategoryWhereInput
    orderBy?: issueCategoryOrderByWithAggregationInput | issueCategoryOrderByWithAggregationInput[]
    by: IssueCategoryScalarFieldEnum[] | IssueCategoryScalarFieldEnum
    having?: issueCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueCategoryCountAggregateInputType | true
    _min?: IssueCategoryMinAggregateInputType
    _max?: IssueCategoryMaxAggregateInputType
  }

  export type IssueCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: IssueCategoryCountAggregateOutputType | null
    _min: IssueCategoryMinAggregateOutputType | null
    _max: IssueCategoryMaxAggregateOutputType | null
  }

  type GetIssueCategoryGroupByPayload<T extends issueCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], IssueCategoryGroupByOutputType[P]>
        }
      >
    >


  export type issueCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    urbanIssueReport?: boolean | issueCategory$urbanIssueReportArgs<ExtArgs>
    _count?: boolean | IssueCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issueCategory"]>

  export type issueCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["issueCategory"]>

  export type issueCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["issueCategory"]>

  export type issueCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type issueCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["issueCategory"]>
  export type issueCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    urbanIssueReport?: boolean | issueCategory$urbanIssueReportArgs<ExtArgs>
    _count?: boolean | IssueCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type issueCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type issueCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $issueCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "issueCategory"
    objects: {
      urbanIssueReport: Prisma.$urbanIssueReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["issueCategory"]>
    composites: {}
  }

  type issueCategoryGetPayload<S extends boolean | null | undefined | issueCategoryDefaultArgs> = $Result.GetResult<Prisma.$issueCategoryPayload, S>

  type issueCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<issueCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IssueCategoryCountAggregateInputType | true
    }

  export interface issueCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['issueCategory'], meta: { name: 'issueCategory' } }
    /**
     * Find zero or one IssueCategory that matches the filter.
     * @param {issueCategoryFindUniqueArgs} args - Arguments to find a IssueCategory
     * @example
     * // Get one IssueCategory
     * const issueCategory = await prisma.issueCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends issueCategoryFindUniqueArgs>(args: SelectSubset<T, issueCategoryFindUniqueArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IssueCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {issueCategoryFindUniqueOrThrowArgs} args - Arguments to find a IssueCategory
     * @example
     * // Get one IssueCategory
     * const issueCategory = await prisma.issueCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends issueCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, issueCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IssueCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueCategoryFindFirstArgs} args - Arguments to find a IssueCategory
     * @example
     * // Get one IssueCategory
     * const issueCategory = await prisma.issueCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends issueCategoryFindFirstArgs>(args?: SelectSubset<T, issueCategoryFindFirstArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IssueCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueCategoryFindFirstOrThrowArgs} args - Arguments to find a IssueCategory
     * @example
     * // Get one IssueCategory
     * const issueCategory = await prisma.issueCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends issueCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, issueCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IssueCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IssueCategories
     * const issueCategories = await prisma.issueCategory.findMany()
     * 
     * // Get first 10 IssueCategories
     * const issueCategories = await prisma.issueCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueCategoryWithIdOnly = await prisma.issueCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends issueCategoryFindManyArgs>(args?: SelectSubset<T, issueCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IssueCategory.
     * @param {issueCategoryCreateArgs} args - Arguments to create a IssueCategory.
     * @example
     * // Create one IssueCategory
     * const IssueCategory = await prisma.issueCategory.create({
     *   data: {
     *     // ... data to create a IssueCategory
     *   }
     * })
     * 
     */
    create<T extends issueCategoryCreateArgs>(args: SelectSubset<T, issueCategoryCreateArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IssueCategories.
     * @param {issueCategoryCreateManyArgs} args - Arguments to create many IssueCategories.
     * @example
     * // Create many IssueCategories
     * const issueCategory = await prisma.issueCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends issueCategoryCreateManyArgs>(args?: SelectSubset<T, issueCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IssueCategories and returns the data saved in the database.
     * @param {issueCategoryCreateManyAndReturnArgs} args - Arguments to create many IssueCategories.
     * @example
     * // Create many IssueCategories
     * const issueCategory = await prisma.issueCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IssueCategories and only return the `id`
     * const issueCategoryWithIdOnly = await prisma.issueCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends issueCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, issueCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IssueCategory.
     * @param {issueCategoryDeleteArgs} args - Arguments to delete one IssueCategory.
     * @example
     * // Delete one IssueCategory
     * const IssueCategory = await prisma.issueCategory.delete({
     *   where: {
     *     // ... filter to delete one IssueCategory
     *   }
     * })
     * 
     */
    delete<T extends issueCategoryDeleteArgs>(args: SelectSubset<T, issueCategoryDeleteArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IssueCategory.
     * @param {issueCategoryUpdateArgs} args - Arguments to update one IssueCategory.
     * @example
     * // Update one IssueCategory
     * const issueCategory = await prisma.issueCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends issueCategoryUpdateArgs>(args: SelectSubset<T, issueCategoryUpdateArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IssueCategories.
     * @param {issueCategoryDeleteManyArgs} args - Arguments to filter IssueCategories to delete.
     * @example
     * // Delete a few IssueCategories
     * const { count } = await prisma.issueCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends issueCategoryDeleteManyArgs>(args?: SelectSubset<T, issueCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IssueCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IssueCategories
     * const issueCategory = await prisma.issueCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends issueCategoryUpdateManyArgs>(args: SelectSubset<T, issueCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IssueCategories and returns the data updated in the database.
     * @param {issueCategoryUpdateManyAndReturnArgs} args - Arguments to update many IssueCategories.
     * @example
     * // Update many IssueCategories
     * const issueCategory = await prisma.issueCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IssueCategories and only return the `id`
     * const issueCategoryWithIdOnly = await prisma.issueCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends issueCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, issueCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IssueCategory.
     * @param {issueCategoryUpsertArgs} args - Arguments to update or create a IssueCategory.
     * @example
     * // Update or create a IssueCategory
     * const issueCategory = await prisma.issueCategory.upsert({
     *   create: {
     *     // ... data to create a IssueCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IssueCategory we want to update
     *   }
     * })
     */
    upsert<T extends issueCategoryUpsertArgs>(args: SelectSubset<T, issueCategoryUpsertArgs<ExtArgs>>): Prisma__issueCategoryClient<$Result.GetResult<Prisma.$issueCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IssueCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueCategoryCountArgs} args - Arguments to filter IssueCategories to count.
     * @example
     * // Count the number of IssueCategories
     * const count = await prisma.issueCategory.count({
     *   where: {
     *     // ... the filter for the IssueCategories we want to count
     *   }
     * })
    **/
    count<T extends issueCategoryCountArgs>(
      args?: Subset<T, issueCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IssueCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueCategoryAggregateArgs>(args: Subset<T, IssueCategoryAggregateArgs>): Prisma.PrismaPromise<GetIssueCategoryAggregateType<T>>

    /**
     * Group by IssueCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends issueCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: issueCategoryGroupByArgs['orderBy'] }
        : { orderBy?: issueCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, issueCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the issueCategory model
   */
  readonly fields: issueCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for issueCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__issueCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    urbanIssueReport<T extends issueCategory$urbanIssueReportArgs<ExtArgs> = {}>(args?: Subset<T, issueCategory$urbanIssueReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$urbanIssueReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the issueCategory model
   */
  interface issueCategoryFieldRefs {
    readonly id: FieldRef<"issueCategory", 'String'>
    readonly name: FieldRef<"issueCategory", 'String'>
    readonly description: FieldRef<"issueCategory", 'String'>
    readonly createdAt: FieldRef<"issueCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"issueCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * issueCategory findUnique
   */
  export type issueCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * Filter, which issueCategory to fetch.
     */
    where: issueCategoryWhereUniqueInput
  }

  /**
   * issueCategory findUniqueOrThrow
   */
  export type issueCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * Filter, which issueCategory to fetch.
     */
    where: issueCategoryWhereUniqueInput
  }

  /**
   * issueCategory findFirst
   */
  export type issueCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * Filter, which issueCategory to fetch.
     */
    where?: issueCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issueCategories to fetch.
     */
    orderBy?: issueCategoryOrderByWithRelationInput | issueCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issueCategories.
     */
    cursor?: issueCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issueCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issueCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issueCategories.
     */
    distinct?: IssueCategoryScalarFieldEnum | IssueCategoryScalarFieldEnum[]
  }

  /**
   * issueCategory findFirstOrThrow
   */
  export type issueCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * Filter, which issueCategory to fetch.
     */
    where?: issueCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issueCategories to fetch.
     */
    orderBy?: issueCategoryOrderByWithRelationInput | issueCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issueCategories.
     */
    cursor?: issueCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issueCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issueCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issueCategories.
     */
    distinct?: IssueCategoryScalarFieldEnum | IssueCategoryScalarFieldEnum[]
  }

  /**
   * issueCategory findMany
   */
  export type issueCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * Filter, which issueCategories to fetch.
     */
    where?: issueCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issueCategories to fetch.
     */
    orderBy?: issueCategoryOrderByWithRelationInput | issueCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing issueCategories.
     */
    cursor?: issueCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issueCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issueCategories.
     */
    skip?: number
    distinct?: IssueCategoryScalarFieldEnum | IssueCategoryScalarFieldEnum[]
  }

  /**
   * issueCategory create
   */
  export type issueCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a issueCategory.
     */
    data: XOR<issueCategoryCreateInput, issueCategoryUncheckedCreateInput>
  }

  /**
   * issueCategory createMany
   */
  export type issueCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many issueCategories.
     */
    data: issueCategoryCreateManyInput | issueCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * issueCategory createManyAndReturn
   */
  export type issueCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many issueCategories.
     */
    data: issueCategoryCreateManyInput | issueCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * issueCategory update
   */
  export type issueCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a issueCategory.
     */
    data: XOR<issueCategoryUpdateInput, issueCategoryUncheckedUpdateInput>
    /**
     * Choose, which issueCategory to update.
     */
    where: issueCategoryWhereUniqueInput
  }

  /**
   * issueCategory updateMany
   */
  export type issueCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update issueCategories.
     */
    data: XOR<issueCategoryUpdateManyMutationInput, issueCategoryUncheckedUpdateManyInput>
    /**
     * Filter which issueCategories to update
     */
    where?: issueCategoryWhereInput
    /**
     * Limit how many issueCategories to update.
     */
    limit?: number
  }

  /**
   * issueCategory updateManyAndReturn
   */
  export type issueCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * The data used to update issueCategories.
     */
    data: XOR<issueCategoryUpdateManyMutationInput, issueCategoryUncheckedUpdateManyInput>
    /**
     * Filter which issueCategories to update
     */
    where?: issueCategoryWhereInput
    /**
     * Limit how many issueCategories to update.
     */
    limit?: number
  }

  /**
   * issueCategory upsert
   */
  export type issueCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the issueCategory to update in case it exists.
     */
    where: issueCategoryWhereUniqueInput
    /**
     * In case the issueCategory found by the `where` argument doesn't exist, create a new issueCategory with this data.
     */
    create: XOR<issueCategoryCreateInput, issueCategoryUncheckedCreateInput>
    /**
     * In case the issueCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<issueCategoryUpdateInput, issueCategoryUncheckedUpdateInput>
  }

  /**
   * issueCategory delete
   */
  export type issueCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
    /**
     * Filter which issueCategory to delete.
     */
    where: issueCategoryWhereUniqueInput
  }

  /**
   * issueCategory deleteMany
   */
  export type issueCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which issueCategories to delete
     */
    where?: issueCategoryWhereInput
    /**
     * Limit how many issueCategories to delete.
     */
    limit?: number
  }

  /**
   * issueCategory.urbanIssueReport
   */
  export type issueCategory$urbanIssueReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the urbanIssueReport
     */
    select?: urbanIssueReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the urbanIssueReport
     */
    omit?: urbanIssueReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: urbanIssueReportInclude<ExtArgs> | null
    where?: urbanIssueReportWhereInput
    orderBy?: urbanIssueReportOrderByWithRelationInput | urbanIssueReportOrderByWithRelationInput[]
    cursor?: urbanIssueReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UrbanIssueReportScalarFieldEnum | UrbanIssueReportScalarFieldEnum[]
  }

  /**
   * issueCategory without action
   */
  export type issueCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issueCategory
     */
    select?: issueCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the issueCategory
     */
    omit?: issueCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issueCategoryInclude<ExtArgs> | null
  }


  /**
   * Model nutritionalCategory
   */

  export type AggregateNutritionalCategory = {
    _count: NutritionalCategoryCountAggregateOutputType | null
    _min: NutritionalCategoryMinAggregateOutputType | null
    _max: NutritionalCategoryMaxAggregateOutputType | null
  }

  export type NutritionalCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionalCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionalCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NutritionalCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionalCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionalCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NutritionalCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutritionalCategory to aggregate.
     */
    where?: nutritionalCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalCategories to fetch.
     */
    orderBy?: nutritionalCategoryOrderByWithRelationInput | nutritionalCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: nutritionalCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nutritionalCategories
    **/
    _count?: true | NutritionalCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionalCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionalCategoryMaxAggregateInputType
  }

  export type GetNutritionalCategoryAggregateType<T extends NutritionalCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionalCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionalCategory[P]>
      : GetScalarType<T[P], AggregateNutritionalCategory[P]>
  }




  export type nutritionalCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: nutritionalCategoryWhereInput
    orderBy?: nutritionalCategoryOrderByWithAggregationInput | nutritionalCategoryOrderByWithAggregationInput[]
    by: NutritionalCategoryScalarFieldEnum[] | NutritionalCategoryScalarFieldEnum
    having?: nutritionalCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionalCategoryCountAggregateInputType | true
    _min?: NutritionalCategoryMinAggregateInputType
    _max?: NutritionalCategoryMaxAggregateInputType
  }

  export type NutritionalCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: NutritionalCategoryCountAggregateOutputType | null
    _min: NutritionalCategoryMinAggregateOutputType | null
    _max: NutritionalCategoryMaxAggregateOutputType | null
  }

  type GetNutritionalCategoryGroupByPayload<T extends nutritionalCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionalCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionalCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionalCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionalCategoryGroupByOutputType[P]>
        }
      >
    >


  export type nutritionalCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nutritionalAdvice?: boolean | nutritionalCategory$nutritionalAdviceArgs<ExtArgs>
    _count?: boolean | NutritionalCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalCategory"]>

  export type nutritionalCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nutritionalCategory"]>

  export type nutritionalCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nutritionalCategory"]>

  export type nutritionalCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type nutritionalCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["nutritionalCategory"]>
  export type nutritionalCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionalAdvice?: boolean | nutritionalCategory$nutritionalAdviceArgs<ExtArgs>
    _count?: boolean | NutritionalCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type nutritionalCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type nutritionalCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $nutritionalCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "nutritionalCategory"
    objects: {
      nutritionalAdvice: Prisma.$nutritionalAdvicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["nutritionalCategory"]>
    composites: {}
  }

  type nutritionalCategoryGetPayload<S extends boolean | null | undefined | nutritionalCategoryDefaultArgs> = $Result.GetResult<Prisma.$nutritionalCategoryPayload, S>

  type nutritionalCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<nutritionalCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionalCategoryCountAggregateInputType | true
    }

  export interface nutritionalCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['nutritionalCategory'], meta: { name: 'nutritionalCategory' } }
    /**
     * Find zero or one NutritionalCategory that matches the filter.
     * @param {nutritionalCategoryFindUniqueArgs} args - Arguments to find a NutritionalCategory
     * @example
     * // Get one NutritionalCategory
     * const nutritionalCategory = await prisma.nutritionalCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends nutritionalCategoryFindUniqueArgs>(args: SelectSubset<T, nutritionalCategoryFindUniqueArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionalCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {nutritionalCategoryFindUniqueOrThrowArgs} args - Arguments to find a NutritionalCategory
     * @example
     * // Get one NutritionalCategory
     * const nutritionalCategory = await prisma.nutritionalCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends nutritionalCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, nutritionalCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalCategoryFindFirstArgs} args - Arguments to find a NutritionalCategory
     * @example
     * // Get one NutritionalCategory
     * const nutritionalCategory = await prisma.nutritionalCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends nutritionalCategoryFindFirstArgs>(args?: SelectSubset<T, nutritionalCategoryFindFirstArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalCategoryFindFirstOrThrowArgs} args - Arguments to find a NutritionalCategory
     * @example
     * // Get one NutritionalCategory
     * const nutritionalCategory = await prisma.nutritionalCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends nutritionalCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, nutritionalCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionalCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionalCategories
     * const nutritionalCategories = await prisma.nutritionalCategory.findMany()
     * 
     * // Get first 10 NutritionalCategories
     * const nutritionalCategories = await prisma.nutritionalCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionalCategoryWithIdOnly = await prisma.nutritionalCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends nutritionalCategoryFindManyArgs>(args?: SelectSubset<T, nutritionalCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionalCategory.
     * @param {nutritionalCategoryCreateArgs} args - Arguments to create a NutritionalCategory.
     * @example
     * // Create one NutritionalCategory
     * const NutritionalCategory = await prisma.nutritionalCategory.create({
     *   data: {
     *     // ... data to create a NutritionalCategory
     *   }
     * })
     * 
     */
    create<T extends nutritionalCategoryCreateArgs>(args: SelectSubset<T, nutritionalCategoryCreateArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionalCategories.
     * @param {nutritionalCategoryCreateManyArgs} args - Arguments to create many NutritionalCategories.
     * @example
     * // Create many NutritionalCategories
     * const nutritionalCategory = await prisma.nutritionalCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends nutritionalCategoryCreateManyArgs>(args?: SelectSubset<T, nutritionalCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionalCategories and returns the data saved in the database.
     * @param {nutritionalCategoryCreateManyAndReturnArgs} args - Arguments to create many NutritionalCategories.
     * @example
     * // Create many NutritionalCategories
     * const nutritionalCategory = await prisma.nutritionalCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionalCategories and only return the `id`
     * const nutritionalCategoryWithIdOnly = await prisma.nutritionalCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends nutritionalCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, nutritionalCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutritionalCategory.
     * @param {nutritionalCategoryDeleteArgs} args - Arguments to delete one NutritionalCategory.
     * @example
     * // Delete one NutritionalCategory
     * const NutritionalCategory = await prisma.nutritionalCategory.delete({
     *   where: {
     *     // ... filter to delete one NutritionalCategory
     *   }
     * })
     * 
     */
    delete<T extends nutritionalCategoryDeleteArgs>(args: SelectSubset<T, nutritionalCategoryDeleteArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionalCategory.
     * @param {nutritionalCategoryUpdateArgs} args - Arguments to update one NutritionalCategory.
     * @example
     * // Update one NutritionalCategory
     * const nutritionalCategory = await prisma.nutritionalCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends nutritionalCategoryUpdateArgs>(args: SelectSubset<T, nutritionalCategoryUpdateArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionalCategories.
     * @param {nutritionalCategoryDeleteManyArgs} args - Arguments to filter NutritionalCategories to delete.
     * @example
     * // Delete a few NutritionalCategories
     * const { count } = await prisma.nutritionalCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends nutritionalCategoryDeleteManyArgs>(args?: SelectSubset<T, nutritionalCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionalCategories
     * const nutritionalCategory = await prisma.nutritionalCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends nutritionalCategoryUpdateManyArgs>(args: SelectSubset<T, nutritionalCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalCategories and returns the data updated in the database.
     * @param {nutritionalCategoryUpdateManyAndReturnArgs} args - Arguments to update many NutritionalCategories.
     * @example
     * // Update many NutritionalCategories
     * const nutritionalCategory = await prisma.nutritionalCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutritionalCategories and only return the `id`
     * const nutritionalCategoryWithIdOnly = await prisma.nutritionalCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends nutritionalCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, nutritionalCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutritionalCategory.
     * @param {nutritionalCategoryUpsertArgs} args - Arguments to update or create a NutritionalCategory.
     * @example
     * // Update or create a NutritionalCategory
     * const nutritionalCategory = await prisma.nutritionalCategory.upsert({
     *   create: {
     *     // ... data to create a NutritionalCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionalCategory we want to update
     *   }
     * })
     */
    upsert<T extends nutritionalCategoryUpsertArgs>(args: SelectSubset<T, nutritionalCategoryUpsertArgs<ExtArgs>>): Prisma__nutritionalCategoryClient<$Result.GetResult<Prisma.$nutritionalCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionalCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalCategoryCountArgs} args - Arguments to filter NutritionalCategories to count.
     * @example
     * // Count the number of NutritionalCategories
     * const count = await prisma.nutritionalCategory.count({
     *   where: {
     *     // ... the filter for the NutritionalCategories we want to count
     *   }
     * })
    **/
    count<T extends nutritionalCategoryCountArgs>(
      args?: Subset<T, nutritionalCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionalCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionalCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionalCategoryAggregateArgs>(args: Subset<T, NutritionalCategoryAggregateArgs>): Prisma.PrismaPromise<GetNutritionalCategoryAggregateType<T>>

    /**
     * Group by NutritionalCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutritionalCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends nutritionalCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: nutritionalCategoryGroupByArgs['orderBy'] }
        : { orderBy?: nutritionalCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, nutritionalCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionalCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the nutritionalCategory model
   */
  readonly fields: nutritionalCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for nutritionalCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__nutritionalCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nutritionalAdvice<T extends nutritionalCategory$nutritionalAdviceArgs<ExtArgs> = {}>(args?: Subset<T, nutritionalCategory$nutritionalAdviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nutritionalAdvicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the nutritionalCategory model
   */
  interface nutritionalCategoryFieldRefs {
    readonly id: FieldRef<"nutritionalCategory", 'String'>
    readonly name: FieldRef<"nutritionalCategory", 'String'>
    readonly description: FieldRef<"nutritionalCategory", 'String'>
    readonly createdAt: FieldRef<"nutritionalCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"nutritionalCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * nutritionalCategory findUnique
   */
  export type nutritionalCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalCategory to fetch.
     */
    where: nutritionalCategoryWhereUniqueInput
  }

  /**
   * nutritionalCategory findUniqueOrThrow
   */
  export type nutritionalCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalCategory to fetch.
     */
    where: nutritionalCategoryWhereUniqueInput
  }

  /**
   * nutritionalCategory findFirst
   */
  export type nutritionalCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalCategory to fetch.
     */
    where?: nutritionalCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalCategories to fetch.
     */
    orderBy?: nutritionalCategoryOrderByWithRelationInput | nutritionalCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutritionalCategories.
     */
    cursor?: nutritionalCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutritionalCategories.
     */
    distinct?: NutritionalCategoryScalarFieldEnum | NutritionalCategoryScalarFieldEnum[]
  }

  /**
   * nutritionalCategory findFirstOrThrow
   */
  export type nutritionalCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalCategory to fetch.
     */
    where?: nutritionalCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalCategories to fetch.
     */
    orderBy?: nutritionalCategoryOrderByWithRelationInput | nutritionalCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutritionalCategories.
     */
    cursor?: nutritionalCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutritionalCategories.
     */
    distinct?: NutritionalCategoryScalarFieldEnum | NutritionalCategoryScalarFieldEnum[]
  }

  /**
   * nutritionalCategory findMany
   */
  export type nutritionalCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * Filter, which nutritionalCategories to fetch.
     */
    where?: nutritionalCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutritionalCategories to fetch.
     */
    orderBy?: nutritionalCategoryOrderByWithRelationInput | nutritionalCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nutritionalCategories.
     */
    cursor?: nutritionalCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutritionalCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutritionalCategories.
     */
    skip?: number
    distinct?: NutritionalCategoryScalarFieldEnum | NutritionalCategoryScalarFieldEnum[]
  }

  /**
   * nutritionalCategory create
   */
  export type nutritionalCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a nutritionalCategory.
     */
    data: XOR<nutritionalCategoryCreateInput, nutritionalCategoryUncheckedCreateInput>
  }

  /**
   * nutritionalCategory createMany
   */
  export type nutritionalCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many nutritionalCategories.
     */
    data: nutritionalCategoryCreateManyInput | nutritionalCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * nutritionalCategory createManyAndReturn
   */
  export type nutritionalCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many nutritionalCategories.
     */
    data: nutritionalCategoryCreateManyInput | nutritionalCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * nutritionalCategory update
   */
  export type nutritionalCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a nutritionalCategory.
     */
    data: XOR<nutritionalCategoryUpdateInput, nutritionalCategoryUncheckedUpdateInput>
    /**
     * Choose, which nutritionalCategory to update.
     */
    where: nutritionalCategoryWhereUniqueInput
  }

  /**
   * nutritionalCategory updateMany
   */
  export type nutritionalCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update nutritionalCategories.
     */
    data: XOR<nutritionalCategoryUpdateManyMutationInput, nutritionalCategoryUncheckedUpdateManyInput>
    /**
     * Filter which nutritionalCategories to update
     */
    where?: nutritionalCategoryWhereInput
    /**
     * Limit how many nutritionalCategories to update.
     */
    limit?: number
  }

  /**
   * nutritionalCategory updateManyAndReturn
   */
  export type nutritionalCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * The data used to update nutritionalCategories.
     */
    data: XOR<nutritionalCategoryUpdateManyMutationInput, nutritionalCategoryUncheckedUpdateManyInput>
    /**
     * Filter which nutritionalCategories to update
     */
    where?: nutritionalCategoryWhereInput
    /**
     * Limit how many nutritionalCategories to update.
     */
    limit?: number
  }

  /**
   * nutritionalCategory upsert
   */
  export type nutritionalCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the nutritionalCategory to update in case it exists.
     */
    where: nutritionalCategoryWhereUniqueInput
    /**
     * In case the nutritionalCategory found by the `where` argument doesn't exist, create a new nutritionalCategory with this data.
     */
    create: XOR<nutritionalCategoryCreateInput, nutritionalCategoryUncheckedCreateInput>
    /**
     * In case the nutritionalCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nutritionalCategoryUpdateInput, nutritionalCategoryUncheckedUpdateInput>
  }

  /**
   * nutritionalCategory delete
   */
  export type nutritionalCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
    /**
     * Filter which nutritionalCategory to delete.
     */
    where: nutritionalCategoryWhereUniqueInput
  }

  /**
   * nutritionalCategory deleteMany
   */
  export type nutritionalCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutritionalCategories to delete
     */
    where?: nutritionalCategoryWhereInput
    /**
     * Limit how many nutritionalCategories to delete.
     */
    limit?: number
  }

  /**
   * nutritionalCategory.nutritionalAdvice
   */
  export type nutritionalCategory$nutritionalAdviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalAdvice
     */
    select?: nutritionalAdviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalAdvice
     */
    omit?: nutritionalAdviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalAdviceInclude<ExtArgs> | null
    where?: nutritionalAdviceWhereInput
    orderBy?: nutritionalAdviceOrderByWithRelationInput | nutritionalAdviceOrderByWithRelationInput[]
    cursor?: nutritionalAdviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NutritionalAdviceScalarFieldEnum | NutritionalAdviceScalarFieldEnum[]
  }

  /**
   * nutritionalCategory without action
   */
  export type nutritionalCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutritionalCategory
     */
    select?: nutritionalCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the nutritionalCategory
     */
    omit?: nutritionalCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nutritionalCategoryInclude<ExtArgs> | null
  }


  /**
   * Model programCategory
   */

  export type AggregateProgramCategory = {
    _count: ProgramCategoryCountAggregateOutputType | null
    _min: ProgramCategoryMinAggregateOutputType | null
    _max: ProgramCategoryMaxAggregateOutputType | null
  }

  export type ProgramCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which programCategory to aggregate.
     */
    where?: programCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of programCategories to fetch.
     */
    orderBy?: programCategoryOrderByWithRelationInput | programCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: programCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` programCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` programCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned programCategories
    **/
    _count?: true | ProgramCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramCategoryMaxAggregateInputType
  }

  export type GetProgramCategoryAggregateType<T extends ProgramCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramCategory[P]>
      : GetScalarType<T[P], AggregateProgramCategory[P]>
  }




  export type programCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: programCategoryWhereInput
    orderBy?: programCategoryOrderByWithAggregationInput | programCategoryOrderByWithAggregationInput[]
    by: ProgramCategoryScalarFieldEnum[] | ProgramCategoryScalarFieldEnum
    having?: programCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCategoryCountAggregateInputType | true
    _min?: ProgramCategoryMinAggregateInputType
    _max?: ProgramCategoryMaxAggregateInputType
  }

  export type ProgramCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ProgramCategoryCountAggregateOutputType | null
    _min: ProgramCategoryMinAggregateOutputType | null
    _max: ProgramCategoryMaxAggregateOutputType | null
  }

  type GetProgramCategoryGroupByPayload<T extends programCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramCategoryGroupByOutputType[P]>
        }
      >
    >


  export type programCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cognitiveExercise?: boolean | programCategory$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | programCategory$exerciseProgramArgs<ExtArgs>
    _count?: boolean | ProgramCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programCategory"]>

  export type programCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programCategory"]>

  export type programCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programCategory"]>

  export type programCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type programCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["programCategory"]>
  export type programCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cognitiveExercise?: boolean | programCategory$cognitiveExerciseArgs<ExtArgs>
    exerciseProgram?: boolean | programCategory$exerciseProgramArgs<ExtArgs>
    _count?: boolean | ProgramCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type programCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type programCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $programCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "programCategory"
    objects: {
      cognitiveExercise: Prisma.$cognitiveExercisePayload<ExtArgs>[]
      exerciseProgram: Prisma.$exerciseProgramPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["programCategory"]>
    composites: {}
  }

  type programCategoryGetPayload<S extends boolean | null | undefined | programCategoryDefaultArgs> = $Result.GetResult<Prisma.$programCategoryPayload, S>

  type programCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<programCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCategoryCountAggregateInputType | true
    }

  export interface programCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['programCategory'], meta: { name: 'programCategory' } }
    /**
     * Find zero or one ProgramCategory that matches the filter.
     * @param {programCategoryFindUniqueArgs} args - Arguments to find a ProgramCategory
     * @example
     * // Get one ProgramCategory
     * const programCategory = await prisma.programCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends programCategoryFindUniqueArgs>(args: SelectSubset<T, programCategoryFindUniqueArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {programCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProgramCategory
     * @example
     * // Get one ProgramCategory
     * const programCategory = await prisma.programCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends programCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, programCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {programCategoryFindFirstArgs} args - Arguments to find a ProgramCategory
     * @example
     * // Get one ProgramCategory
     * const programCategory = await prisma.programCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends programCategoryFindFirstArgs>(args?: SelectSubset<T, programCategoryFindFirstArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {programCategoryFindFirstOrThrowArgs} args - Arguments to find a ProgramCategory
     * @example
     * // Get one ProgramCategory
     * const programCategory = await prisma.programCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends programCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, programCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {programCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramCategories
     * const programCategories = await prisma.programCategory.findMany()
     * 
     * // Get first 10 ProgramCategories
     * const programCategories = await prisma.programCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programCategoryWithIdOnly = await prisma.programCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends programCategoryFindManyArgs>(args?: SelectSubset<T, programCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramCategory.
     * @param {programCategoryCreateArgs} args - Arguments to create a ProgramCategory.
     * @example
     * // Create one ProgramCategory
     * const ProgramCategory = await prisma.programCategory.create({
     *   data: {
     *     // ... data to create a ProgramCategory
     *   }
     * })
     * 
     */
    create<T extends programCategoryCreateArgs>(args: SelectSubset<T, programCategoryCreateArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramCategories.
     * @param {programCategoryCreateManyArgs} args - Arguments to create many ProgramCategories.
     * @example
     * // Create many ProgramCategories
     * const programCategory = await prisma.programCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends programCategoryCreateManyArgs>(args?: SelectSubset<T, programCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramCategories and returns the data saved in the database.
     * @param {programCategoryCreateManyAndReturnArgs} args - Arguments to create many ProgramCategories.
     * @example
     * // Create many ProgramCategories
     * const programCategory = await prisma.programCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramCategories and only return the `id`
     * const programCategoryWithIdOnly = await prisma.programCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends programCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, programCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramCategory.
     * @param {programCategoryDeleteArgs} args - Arguments to delete one ProgramCategory.
     * @example
     * // Delete one ProgramCategory
     * const ProgramCategory = await prisma.programCategory.delete({
     *   where: {
     *     // ... filter to delete one ProgramCategory
     *   }
     * })
     * 
     */
    delete<T extends programCategoryDeleteArgs>(args: SelectSubset<T, programCategoryDeleteArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramCategory.
     * @param {programCategoryUpdateArgs} args - Arguments to update one ProgramCategory.
     * @example
     * // Update one ProgramCategory
     * const programCategory = await prisma.programCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends programCategoryUpdateArgs>(args: SelectSubset<T, programCategoryUpdateArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramCategories.
     * @param {programCategoryDeleteManyArgs} args - Arguments to filter ProgramCategories to delete.
     * @example
     * // Delete a few ProgramCategories
     * const { count } = await prisma.programCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends programCategoryDeleteManyArgs>(args?: SelectSubset<T, programCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {programCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramCategories
     * const programCategory = await prisma.programCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends programCategoryUpdateManyArgs>(args: SelectSubset<T, programCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramCategories and returns the data updated in the database.
     * @param {programCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProgramCategories.
     * @example
     * // Update many ProgramCategories
     * const programCategory = await prisma.programCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramCategories and only return the `id`
     * const programCategoryWithIdOnly = await prisma.programCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends programCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, programCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramCategory.
     * @param {programCategoryUpsertArgs} args - Arguments to update or create a ProgramCategory.
     * @example
     * // Update or create a ProgramCategory
     * const programCategory = await prisma.programCategory.upsert({
     *   create: {
     *     // ... data to create a ProgramCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramCategory we want to update
     *   }
     * })
     */
    upsert<T extends programCategoryUpsertArgs>(args: SelectSubset<T, programCategoryUpsertArgs<ExtArgs>>): Prisma__programCategoryClient<$Result.GetResult<Prisma.$programCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {programCategoryCountArgs} args - Arguments to filter ProgramCategories to count.
     * @example
     * // Count the number of ProgramCategories
     * const count = await prisma.programCategory.count({
     *   where: {
     *     // ... the filter for the ProgramCategories we want to count
     *   }
     * })
    **/
    count<T extends programCategoryCountArgs>(
      args?: Subset<T, programCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramCategoryAggregateArgs>(args: Subset<T, ProgramCategoryAggregateArgs>): Prisma.PrismaPromise<GetProgramCategoryAggregateType<T>>

    /**
     * Group by ProgramCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {programCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends programCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: programCategoryGroupByArgs['orderBy'] }
        : { orderBy?: programCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, programCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the programCategory model
   */
  readonly fields: programCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for programCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__programCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cognitiveExercise<T extends programCategory$cognitiveExerciseArgs<ExtArgs> = {}>(args?: Subset<T, programCategory$cognitiveExerciseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cognitiveExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exerciseProgram<T extends programCategory$exerciseProgramArgs<ExtArgs> = {}>(args?: Subset<T, programCategory$exerciseProgramArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exerciseProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the programCategory model
   */
  interface programCategoryFieldRefs {
    readonly id: FieldRef<"programCategory", 'String'>
    readonly name: FieldRef<"programCategory", 'String'>
    readonly description: FieldRef<"programCategory", 'String'>
    readonly createdAt: FieldRef<"programCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"programCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * programCategory findUnique
   */
  export type programCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * Filter, which programCategory to fetch.
     */
    where: programCategoryWhereUniqueInput
  }

  /**
   * programCategory findUniqueOrThrow
   */
  export type programCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * Filter, which programCategory to fetch.
     */
    where: programCategoryWhereUniqueInput
  }

  /**
   * programCategory findFirst
   */
  export type programCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * Filter, which programCategory to fetch.
     */
    where?: programCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of programCategories to fetch.
     */
    orderBy?: programCategoryOrderByWithRelationInput | programCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for programCategories.
     */
    cursor?: programCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` programCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` programCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of programCategories.
     */
    distinct?: ProgramCategoryScalarFieldEnum | ProgramCategoryScalarFieldEnum[]
  }

  /**
   * programCategory findFirstOrThrow
   */
  export type programCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * Filter, which programCategory to fetch.
     */
    where?: programCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of programCategories to fetch.
     */
    orderBy?: programCategoryOrderByWithRelationInput | programCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for programCategories.
     */
    cursor?: programCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` programCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` programCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of programCategories.
     */
    distinct?: ProgramCategoryScalarFieldEnum | ProgramCategoryScalarFieldEnum[]
  }

  /**
   * programCategory findMany
   */
  export type programCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * Filter, which programCategories to fetch.
     */
    where?: programCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of programCategories to fetch.
     */
    orderBy?: programCategoryOrderByWithRelationInput | programCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing programCategories.
     */
    cursor?: programCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` programCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` programCategories.
     */
    skip?: number
    distinct?: ProgramCategoryScalarFieldEnum | ProgramCategoryScalarFieldEnum[]
  }

  /**
   * programCategory create
   */
  export type programCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a programCategory.
     */
    data: XOR<programCategoryCreateInput, programCategoryUncheckedCreateInput>
  }

  /**
   * programCategory createMany
   */
  export type programCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many programCategories.
     */
    data: programCategoryCreateManyInput | programCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * programCategory createManyAndReturn
   */
  export type programCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many programCategories.
     */
    data: programCategoryCreateManyInput | programCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * programCategory update
   */
  export type programCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a programCategory.
     */
    data: XOR<programCategoryUpdateInput, programCategoryUncheckedUpdateInput>
    /**
     * Choose, which programCategory to update.
     */
    where: programCategoryWhereUniqueInput
  }

  /**
   * programCategory updateMany
   */
  export type programCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update programCategories.
     */
    data: XOR<programCategoryUpdateManyMutationInput, programCategoryUncheckedUpdateManyInput>
    /**
     * Filter which programCategories to update
     */
    where?: programCategoryWhereInput
    /**
     * Limit how many programCategories to update.
     */
    limit?: number
  }

  /**
   * programCategory updateManyAndReturn
   */
  export type programCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * The data used to update programCategories.
     */
    data: XOR<programCategoryUpdateManyMutationInput, programCategoryUncheckedUpdateManyInput>
    /**
     * Filter which programCategories to update
     */
    where?: programCategoryWhereInput
    /**
     * Limit how many programCategories to update.
     */
    limit?: number
  }

  /**
   * programCategory upsert
   */
  export type programCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the programCategory to update in case it exists.
     */
    where: programCategoryWhereUniqueInput
    /**
     * In case the programCategory found by the `where` argument doesn't exist, create a new programCategory with this data.
     */
    create: XOR<programCategoryCreateInput, programCategoryUncheckedCreateInput>
    /**
     * In case the programCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<programCategoryUpdateInput, programCategoryUncheckedUpdateInput>
  }

  /**
   * programCategory delete
   */
  export type programCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
    /**
     * Filter which programCategory to delete.
     */
    where: programCategoryWhereUniqueInput
  }

  /**
   * programCategory deleteMany
   */
  export type programCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which programCategories to delete
     */
    where?: programCategoryWhereInput
    /**
     * Limit how many programCategories to delete.
     */
    limit?: number
  }

  /**
   * programCategory.cognitiveExercise
   */
  export type programCategory$cognitiveExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cognitiveExercise
     */
    select?: cognitiveExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cognitiveExercise
     */
    omit?: cognitiveExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cognitiveExerciseInclude<ExtArgs> | null
    where?: cognitiveExerciseWhereInput
    orderBy?: cognitiveExerciseOrderByWithRelationInput | cognitiveExerciseOrderByWithRelationInput[]
    cursor?: cognitiveExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CognitiveExerciseScalarFieldEnum | CognitiveExerciseScalarFieldEnum[]
  }

  /**
   * programCategory.exerciseProgram
   */
  export type programCategory$exerciseProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exerciseProgram
     */
    select?: exerciseProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exerciseProgram
     */
    omit?: exerciseProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exerciseProgramInclude<ExtArgs> | null
    where?: exerciseProgramWhereInput
    orderBy?: exerciseProgramOrderByWithRelationInput | exerciseProgramOrderByWithRelationInput[]
    cursor?: exerciseProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseProgramScalarFieldEnum | ExerciseProgramScalarFieldEnum[]
  }

  /**
   * programCategory without action
   */
  export type programCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the programCategory
     */
    select?: programCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the programCategory
     */
    omit?: programCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: programCategoryInclude<ExtArgs> | null
  }


  /**
   * Model projectCategory
   */

  export type AggregateProjectCategory = {
    _count: ProjectCategoryCountAggregateOutputType | null
    _min: ProjectCategoryMinAggregateOutputType | null
    _max: ProjectCategoryMaxAggregateOutputType | null
  }

  export type ProjectCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectCategory to aggregate.
     */
    where?: projectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectCategories to fetch.
     */
    orderBy?: projectCategoryOrderByWithRelationInput | projectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projectCategories
    **/
    _count?: true | ProjectCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectCategoryMaxAggregateInputType
  }

  export type GetProjectCategoryAggregateType<T extends ProjectCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectCategory[P]>
      : GetScalarType<T[P], AggregateProjectCategory[P]>
  }




  export type projectCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectCategoryWhereInput
    orderBy?: projectCategoryOrderByWithAggregationInput | projectCategoryOrderByWithAggregationInput[]
    by: ProjectCategoryScalarFieldEnum[] | ProjectCategoryScalarFieldEnum
    having?: projectCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCategoryCountAggregateInputType | true
    _min?: ProjectCategoryMinAggregateInputType
    _max?: ProjectCategoryMaxAggregateInputType
  }

  export type ProjectCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ProjectCategoryCountAggregateOutputType | null
    _min: ProjectCategoryMinAggregateOutputType | null
    _max: ProjectCategoryMaxAggregateOutputType | null
  }

  type GetProjectCategoryGroupByPayload<T extends projectCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectCategoryGroupByOutputType[P]>
        }
      >
    >


  export type projectCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaborativeProject?: boolean | projectCategory$collaborativeProjectArgs<ExtArgs>
    _count?: boolean | ProjectCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCategory"]>

  export type projectCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["projectCategory"]>

  export type projectCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["projectCategory"]>

  export type projectCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type projectCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["projectCategory"]>
  export type projectCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborativeProject?: boolean | projectCategory$collaborativeProjectArgs<ExtArgs>
    _count?: boolean | ProjectCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type projectCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type projectCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $projectCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projectCategory"
    objects: {
      collaborativeProject: Prisma.$collaborativeProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["projectCategory"]>
    composites: {}
  }

  type projectCategoryGetPayload<S extends boolean | null | undefined | projectCategoryDefaultArgs> = $Result.GetResult<Prisma.$projectCategoryPayload, S>

  type projectCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCategoryCountAggregateInputType | true
    }

  export interface projectCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projectCategory'], meta: { name: 'projectCategory' } }
    /**
     * Find zero or one ProjectCategory that matches the filter.
     * @param {projectCategoryFindUniqueArgs} args - Arguments to find a ProjectCategory
     * @example
     * // Get one ProjectCategory
     * const projectCategory = await prisma.projectCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectCategoryFindUniqueArgs>(args: SelectSubset<T, projectCategoryFindUniqueArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProjectCategory
     * @example
     * // Get one ProjectCategory
     * const projectCategory = await prisma.projectCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, projectCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCategoryFindFirstArgs} args - Arguments to find a ProjectCategory
     * @example
     * // Get one ProjectCategory
     * const projectCategory = await prisma.projectCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectCategoryFindFirstArgs>(args?: SelectSubset<T, projectCategoryFindFirstArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCategoryFindFirstOrThrowArgs} args - Arguments to find a ProjectCategory
     * @example
     * // Get one ProjectCategory
     * const projectCategory = await prisma.projectCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, projectCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectCategories
     * const projectCategories = await prisma.projectCategory.findMany()
     * 
     * // Get first 10 ProjectCategories
     * const projectCategories = await prisma.projectCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectCategoryWithIdOnly = await prisma.projectCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projectCategoryFindManyArgs>(args?: SelectSubset<T, projectCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectCategory.
     * @param {projectCategoryCreateArgs} args - Arguments to create a ProjectCategory.
     * @example
     * // Create one ProjectCategory
     * const ProjectCategory = await prisma.projectCategory.create({
     *   data: {
     *     // ... data to create a ProjectCategory
     *   }
     * })
     * 
     */
    create<T extends projectCategoryCreateArgs>(args: SelectSubset<T, projectCategoryCreateArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectCategories.
     * @param {projectCategoryCreateManyArgs} args - Arguments to create many ProjectCategories.
     * @example
     * // Create many ProjectCategories
     * const projectCategory = await prisma.projectCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectCategoryCreateManyArgs>(args?: SelectSubset<T, projectCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectCategories and returns the data saved in the database.
     * @param {projectCategoryCreateManyAndReturnArgs} args - Arguments to create many ProjectCategories.
     * @example
     * // Create many ProjectCategories
     * const projectCategory = await prisma.projectCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectCategories and only return the `id`
     * const projectCategoryWithIdOnly = await prisma.projectCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, projectCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectCategory.
     * @param {projectCategoryDeleteArgs} args - Arguments to delete one ProjectCategory.
     * @example
     * // Delete one ProjectCategory
     * const ProjectCategory = await prisma.projectCategory.delete({
     *   where: {
     *     // ... filter to delete one ProjectCategory
     *   }
     * })
     * 
     */
    delete<T extends projectCategoryDeleteArgs>(args: SelectSubset<T, projectCategoryDeleteArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectCategory.
     * @param {projectCategoryUpdateArgs} args - Arguments to update one ProjectCategory.
     * @example
     * // Update one ProjectCategory
     * const projectCategory = await prisma.projectCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectCategoryUpdateArgs>(args: SelectSubset<T, projectCategoryUpdateArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectCategories.
     * @param {projectCategoryDeleteManyArgs} args - Arguments to filter ProjectCategories to delete.
     * @example
     * // Delete a few ProjectCategories
     * const { count } = await prisma.projectCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectCategoryDeleteManyArgs>(args?: SelectSubset<T, projectCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectCategories
     * const projectCategory = await prisma.projectCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectCategoryUpdateManyArgs>(args: SelectSubset<T, projectCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectCategories and returns the data updated in the database.
     * @param {projectCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProjectCategories.
     * @example
     * // Update many ProjectCategories
     * const projectCategory = await prisma.projectCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectCategories and only return the `id`
     * const projectCategoryWithIdOnly = await prisma.projectCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projectCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, projectCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectCategory.
     * @param {projectCategoryUpsertArgs} args - Arguments to update or create a ProjectCategory.
     * @example
     * // Update or create a ProjectCategory
     * const projectCategory = await prisma.projectCategory.upsert({
     *   create: {
     *     // ... data to create a ProjectCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectCategory we want to update
     *   }
     * })
     */
    upsert<T extends projectCategoryUpsertArgs>(args: SelectSubset<T, projectCategoryUpsertArgs<ExtArgs>>): Prisma__projectCategoryClient<$Result.GetResult<Prisma.$projectCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCategoryCountArgs} args - Arguments to filter ProjectCategories to count.
     * @example
     * // Count the number of ProjectCategories
     * const count = await prisma.projectCategory.count({
     *   where: {
     *     // ... the filter for the ProjectCategories we want to count
     *   }
     * })
    **/
    count<T extends projectCategoryCountArgs>(
      args?: Subset<T, projectCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectCategoryAggregateArgs>(args: Subset<T, ProjectCategoryAggregateArgs>): Prisma.PrismaPromise<GetProjectCategoryAggregateType<T>>

    /**
     * Group by ProjectCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectCategoryGroupByArgs['orderBy'] }
        : { orderBy?: projectCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projectCategory model
   */
  readonly fields: projectCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projectCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collaborativeProject<T extends projectCategory$collaborativeProjectArgs<ExtArgs> = {}>(args?: Subset<T, projectCategory$collaborativeProjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collaborativeProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projectCategory model
   */
  interface projectCategoryFieldRefs {
    readonly id: FieldRef<"projectCategory", 'String'>
    readonly name: FieldRef<"projectCategory", 'String'>
    readonly description: FieldRef<"projectCategory", 'String'>
    readonly createdAt: FieldRef<"projectCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"projectCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * projectCategory findUnique
   */
  export type projectCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which projectCategory to fetch.
     */
    where: projectCategoryWhereUniqueInput
  }

  /**
   * projectCategory findUniqueOrThrow
   */
  export type projectCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which projectCategory to fetch.
     */
    where: projectCategoryWhereUniqueInput
  }

  /**
   * projectCategory findFirst
   */
  export type projectCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which projectCategory to fetch.
     */
    where?: projectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectCategories to fetch.
     */
    orderBy?: projectCategoryOrderByWithRelationInput | projectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectCategories.
     */
    cursor?: projectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectCategories.
     */
    distinct?: ProjectCategoryScalarFieldEnum | ProjectCategoryScalarFieldEnum[]
  }

  /**
   * projectCategory findFirstOrThrow
   */
  export type projectCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which projectCategory to fetch.
     */
    where?: projectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectCategories to fetch.
     */
    orderBy?: projectCategoryOrderByWithRelationInput | projectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectCategories.
     */
    cursor?: projectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectCategories.
     */
    distinct?: ProjectCategoryScalarFieldEnum | ProjectCategoryScalarFieldEnum[]
  }

  /**
   * projectCategory findMany
   */
  export type projectCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which projectCategories to fetch.
     */
    where?: projectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectCategories to fetch.
     */
    orderBy?: projectCategoryOrderByWithRelationInput | projectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projectCategories.
     */
    cursor?: projectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectCategories.
     */
    skip?: number
    distinct?: ProjectCategoryScalarFieldEnum | ProjectCategoryScalarFieldEnum[]
  }

  /**
   * projectCategory create
   */
  export type projectCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a projectCategory.
     */
    data: XOR<projectCategoryCreateInput, projectCategoryUncheckedCreateInput>
  }

  /**
   * projectCategory createMany
   */
  export type projectCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projectCategories.
     */
    data: projectCategoryCreateManyInput | projectCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projectCategory createManyAndReturn
   */
  export type projectCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many projectCategories.
     */
    data: projectCategoryCreateManyInput | projectCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projectCategory update
   */
  export type projectCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a projectCategory.
     */
    data: XOR<projectCategoryUpdateInput, projectCategoryUncheckedUpdateInput>
    /**
     * Choose, which projectCategory to update.
     */
    where: projectCategoryWhereUniqueInput
  }

  /**
   * projectCategory updateMany
   */
  export type projectCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projectCategories.
     */
    data: XOR<projectCategoryUpdateManyMutationInput, projectCategoryUncheckedUpdateManyInput>
    /**
     * Filter which projectCategories to update
     */
    where?: projectCategoryWhereInput
    /**
     * Limit how many projectCategories to update.
     */
    limit?: number
  }

  /**
   * projectCategory updateManyAndReturn
   */
  export type projectCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * The data used to update projectCategories.
     */
    data: XOR<projectCategoryUpdateManyMutationInput, projectCategoryUncheckedUpdateManyInput>
    /**
     * Filter which projectCategories to update
     */
    where?: projectCategoryWhereInput
    /**
     * Limit how many projectCategories to update.
     */
    limit?: number
  }

  /**
   * projectCategory upsert
   */
  export type projectCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the projectCategory to update in case it exists.
     */
    where: projectCategoryWhereUniqueInput
    /**
     * In case the projectCategory found by the `where` argument doesn't exist, create a new projectCategory with this data.
     */
    create: XOR<projectCategoryCreateInput, projectCategoryUncheckedCreateInput>
    /**
     * In case the projectCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectCategoryUpdateInput, projectCategoryUncheckedUpdateInput>
  }

  /**
   * projectCategory delete
   */
  export type projectCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
    /**
     * Filter which projectCategory to delete.
     */
    where: projectCategoryWhereUniqueInput
  }

  /**
   * projectCategory deleteMany
   */
  export type projectCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectCategories to delete
     */
    where?: projectCategoryWhereInput
    /**
     * Limit how many projectCategories to delete.
     */
    limit?: number
  }

  /**
   * projectCategory.collaborativeProject
   */
  export type projectCategory$collaborativeProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collaborativeProject
     */
    select?: collaborativeProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collaborativeProject
     */
    omit?: collaborativeProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collaborativeProjectInclude<ExtArgs> | null
    where?: collaborativeProjectWhereInput
    orderBy?: collaborativeProjectOrderByWithRelationInput | collaborativeProjectOrderByWithRelationInput[]
    cursor?: collaborativeProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollaborativeProjectScalarFieldEnum | CollaborativeProjectScalarFieldEnum[]
  }

  /**
   * projectCategory without action
   */
  export type projectCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectCategory
     */
    select?: projectCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectCategory
     */
    omit?: projectCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectCategoryInclude<ExtArgs> | null
  }


  /**
   * Model resourceCategory
   */

  export type AggregateResourceCategory = {
    _count: ResourceCategoryCountAggregateOutputType | null
    _min: ResourceCategoryMinAggregateOutputType | null
    _max: ResourceCategoryMaxAggregateOutputType | null
  }

  export type ResourceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resourceCategory to aggregate.
     */
    where?: resourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resourceCategories to fetch.
     */
    orderBy?: resourceCategoryOrderByWithRelationInput | resourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resourceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned resourceCategories
    **/
    _count?: true | ResourceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceCategoryMaxAggregateInputType
  }

  export type GetResourceCategoryAggregateType<T extends ResourceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceCategory[P]>
      : GetScalarType<T[P], AggregateResourceCategory[P]>
  }




  export type resourceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourceCategoryWhereInput
    orderBy?: resourceCategoryOrderByWithAggregationInput | resourceCategoryOrderByWithAggregationInput[]
    by: ResourceCategoryScalarFieldEnum[] | ResourceCategoryScalarFieldEnum
    having?: resourceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCategoryCountAggregateInputType | true
    _min?: ResourceCategoryMinAggregateInputType
    _max?: ResourceCategoryMaxAggregateInputType
  }

  export type ResourceCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ResourceCategoryCountAggregateOutputType | null
    _min: ResourceCategoryMinAggregateOutputType | null
    _max: ResourceCategoryMaxAggregateOutputType | null
  }

  type GetResourceCategoryGroupByPayload<T extends resourceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type resourceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resource?: boolean | resourceCategory$resourceArgs<ExtArgs>
    _count?: boolean | ResourceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceCategory"]>

  export type resourceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["resourceCategory"]>

  export type resourceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["resourceCategory"]>

  export type resourceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type resourceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["resourceCategory"]>
  export type resourceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | resourceCategory$resourceArgs<ExtArgs>
    _count?: boolean | ResourceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type resourceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type resourceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $resourceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "resourceCategory"
    objects: {
      resource: Prisma.$resourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["resourceCategory"]>
    composites: {}
  }

  type resourceCategoryGetPayload<S extends boolean | null | undefined | resourceCategoryDefaultArgs> = $Result.GetResult<Prisma.$resourceCategoryPayload, S>

  type resourceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resourceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCategoryCountAggregateInputType | true
    }

  export interface resourceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['resourceCategory'], meta: { name: 'resourceCategory' } }
    /**
     * Find zero or one ResourceCategory that matches the filter.
     * @param {resourceCategoryFindUniqueArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resourceCategoryFindUniqueArgs>(args: SelectSubset<T, resourceCategoryFindUniqueArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resourceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resourceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, resourceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCategoryFindFirstArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resourceCategoryFindFirstArgs>(args?: SelectSubset<T, resourceCategoryFindFirstArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCategoryFindFirstOrThrowArgs} args - Arguments to find a ResourceCategory
     * @example
     * // Get one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resourceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, resourceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceCategories
     * const resourceCategories = await prisma.resourceCategory.findMany()
     * 
     * // Get first 10 ResourceCategories
     * const resourceCategories = await prisma.resourceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceCategoryWithIdOnly = await prisma.resourceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends resourceCategoryFindManyArgs>(args?: SelectSubset<T, resourceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceCategory.
     * @param {resourceCategoryCreateArgs} args - Arguments to create a ResourceCategory.
     * @example
     * // Create one ResourceCategory
     * const ResourceCategory = await prisma.resourceCategory.create({
     *   data: {
     *     // ... data to create a ResourceCategory
     *   }
     * })
     * 
     */
    create<T extends resourceCategoryCreateArgs>(args: SelectSubset<T, resourceCategoryCreateArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceCategories.
     * @param {resourceCategoryCreateManyArgs} args - Arguments to create many ResourceCategories.
     * @example
     * // Create many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resourceCategoryCreateManyArgs>(args?: SelectSubset<T, resourceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceCategories and returns the data saved in the database.
     * @param {resourceCategoryCreateManyAndReturnArgs} args - Arguments to create many ResourceCategories.
     * @example
     * // Create many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceCategories and only return the `id`
     * const resourceCategoryWithIdOnly = await prisma.resourceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends resourceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, resourceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceCategory.
     * @param {resourceCategoryDeleteArgs} args - Arguments to delete one ResourceCategory.
     * @example
     * // Delete one ResourceCategory
     * const ResourceCategory = await prisma.resourceCategory.delete({
     *   where: {
     *     // ... filter to delete one ResourceCategory
     *   }
     * })
     * 
     */
    delete<T extends resourceCategoryDeleteArgs>(args: SelectSubset<T, resourceCategoryDeleteArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceCategory.
     * @param {resourceCategoryUpdateArgs} args - Arguments to update one ResourceCategory.
     * @example
     * // Update one ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resourceCategoryUpdateArgs>(args: SelectSubset<T, resourceCategoryUpdateArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceCategories.
     * @param {resourceCategoryDeleteManyArgs} args - Arguments to filter ResourceCategories to delete.
     * @example
     * // Delete a few ResourceCategories
     * const { count } = await prisma.resourceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resourceCategoryDeleteManyArgs>(args?: SelectSubset<T, resourceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resourceCategoryUpdateManyArgs>(args: SelectSubset<T, resourceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceCategories and returns the data updated in the database.
     * @param {resourceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ResourceCategories.
     * @example
     * // Update many ResourceCategories
     * const resourceCategory = await prisma.resourceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceCategories and only return the `id`
     * const resourceCategoryWithIdOnly = await prisma.resourceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends resourceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, resourceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceCategory.
     * @param {resourceCategoryUpsertArgs} args - Arguments to update or create a ResourceCategory.
     * @example
     * // Update or create a ResourceCategory
     * const resourceCategory = await prisma.resourceCategory.upsert({
     *   create: {
     *     // ... data to create a ResourceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceCategory we want to update
     *   }
     * })
     */
    upsert<T extends resourceCategoryUpsertArgs>(args: SelectSubset<T, resourceCategoryUpsertArgs<ExtArgs>>): Prisma__resourceCategoryClient<$Result.GetResult<Prisma.$resourceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCategoryCountArgs} args - Arguments to filter ResourceCategories to count.
     * @example
     * // Count the number of ResourceCategories
     * const count = await prisma.resourceCategory.count({
     *   where: {
     *     // ... the filter for the ResourceCategories we want to count
     *   }
     * })
    **/
    count<T extends resourceCategoryCountArgs>(
      args?: Subset<T, resourceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceCategoryAggregateArgs>(args: Subset<T, ResourceCategoryAggregateArgs>): Prisma.PrismaPromise<GetResourceCategoryAggregateType<T>>

    /**
     * Group by ResourceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resourceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resourceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: resourceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resourceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the resourceCategory model
   */
  readonly fields: resourceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for resourceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resourceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends resourceCategory$resourceArgs<ExtArgs> = {}>(args?: Subset<T, resourceCategory$resourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the resourceCategory model
   */
  interface resourceCategoryFieldRefs {
    readonly id: FieldRef<"resourceCategory", 'String'>
    readonly name: FieldRef<"resourceCategory", 'String'>
    readonly description: FieldRef<"resourceCategory", 'String'>
    readonly createdAt: FieldRef<"resourceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"resourceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * resourceCategory findUnique
   */
  export type resourceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which resourceCategory to fetch.
     */
    where: resourceCategoryWhereUniqueInput
  }

  /**
   * resourceCategory findUniqueOrThrow
   */
  export type resourceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which resourceCategory to fetch.
     */
    where: resourceCategoryWhereUniqueInput
  }

  /**
   * resourceCategory findFirst
   */
  export type resourceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which resourceCategory to fetch.
     */
    where?: resourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resourceCategories to fetch.
     */
    orderBy?: resourceCategoryOrderByWithRelationInput | resourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resourceCategories.
     */
    cursor?: resourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resourceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resourceCategories.
     */
    distinct?: ResourceCategoryScalarFieldEnum | ResourceCategoryScalarFieldEnum[]
  }

  /**
   * resourceCategory findFirstOrThrow
   */
  export type resourceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which resourceCategory to fetch.
     */
    where?: resourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resourceCategories to fetch.
     */
    orderBy?: resourceCategoryOrderByWithRelationInput | resourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resourceCategories.
     */
    cursor?: resourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resourceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resourceCategories.
     */
    distinct?: ResourceCategoryScalarFieldEnum | ResourceCategoryScalarFieldEnum[]
  }

  /**
   * resourceCategory findMany
   */
  export type resourceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which resourceCategories to fetch.
     */
    where?: resourceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resourceCategories to fetch.
     */
    orderBy?: resourceCategoryOrderByWithRelationInput | resourceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing resourceCategories.
     */
    cursor?: resourceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resourceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resourceCategories.
     */
    skip?: number
    distinct?: ResourceCategoryScalarFieldEnum | ResourceCategoryScalarFieldEnum[]
  }

  /**
   * resourceCategory create
   */
  export type resourceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a resourceCategory.
     */
    data: XOR<resourceCategoryCreateInput, resourceCategoryUncheckedCreateInput>
  }

  /**
   * resourceCategory createMany
   */
  export type resourceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many resourceCategories.
     */
    data: resourceCategoryCreateManyInput | resourceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resourceCategory createManyAndReturn
   */
  export type resourceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many resourceCategories.
     */
    data: resourceCategoryCreateManyInput | resourceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resourceCategory update
   */
  export type resourceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a resourceCategory.
     */
    data: XOR<resourceCategoryUpdateInput, resourceCategoryUncheckedUpdateInput>
    /**
     * Choose, which resourceCategory to update.
     */
    where: resourceCategoryWhereUniqueInput
  }

  /**
   * resourceCategory updateMany
   */
  export type resourceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update resourceCategories.
     */
    data: XOR<resourceCategoryUpdateManyMutationInput, resourceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which resourceCategories to update
     */
    where?: resourceCategoryWhereInput
    /**
     * Limit how many resourceCategories to update.
     */
    limit?: number
  }

  /**
   * resourceCategory updateManyAndReturn
   */
  export type resourceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update resourceCategories.
     */
    data: XOR<resourceCategoryUpdateManyMutationInput, resourceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which resourceCategories to update
     */
    where?: resourceCategoryWhereInput
    /**
     * Limit how many resourceCategories to update.
     */
    limit?: number
  }

  /**
   * resourceCategory upsert
   */
  export type resourceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the resourceCategory to update in case it exists.
     */
    where: resourceCategoryWhereUniqueInput
    /**
     * In case the resourceCategory found by the `where` argument doesn't exist, create a new resourceCategory with this data.
     */
    create: XOR<resourceCategoryCreateInput, resourceCategoryUncheckedCreateInput>
    /**
     * In case the resourceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resourceCategoryUpdateInput, resourceCategoryUncheckedUpdateInput>
  }

  /**
   * resourceCategory delete
   */
  export type resourceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
    /**
     * Filter which resourceCategory to delete.
     */
    where: resourceCategoryWhereUniqueInput
  }

  /**
   * resourceCategory deleteMany
   */
  export type resourceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resourceCategories to delete
     */
    where?: resourceCategoryWhereInput
    /**
     * Limit how many resourceCategories to delete.
     */
    limit?: number
  }

  /**
   * resourceCategory.resource
   */
  export type resourceCategory$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    where?: resourceWhereInput
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    cursor?: resourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * resourceCategory without action
   */
  export type resourceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resourceCategory
     */
    select?: resourceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the resourceCategory
     */
    omit?: resourceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model serviceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceCategory to aggregate.
     */
    where?: serviceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCategories to fetch.
     */
    orderBy?: serviceCategoryOrderByWithRelationInput | serviceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type serviceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceCategoryWhereInput
    orderBy?: serviceCategoryOrderByWithAggregationInput | serviceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: serviceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends serviceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type serviceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    localService?: boolean | serviceCategory$localServiceArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type serviceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type serviceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type serviceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type serviceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceCategory"]>
  export type serviceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localService?: boolean | serviceCategory$localServiceArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type serviceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type serviceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $serviceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serviceCategory"
    objects: {
      localService: Prisma.$localServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type serviceCategoryGetPayload<S extends boolean | null | undefined | serviceCategoryDefaultArgs> = $Result.GetResult<Prisma.$serviceCategoryPayload, S>

  type serviceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<serviceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface serviceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceCategory'], meta: { name: 'serviceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {serviceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceCategoryFindUniqueArgs>(args: SelectSubset<T, serviceCategoryFindUniqueArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {serviceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceCategoryFindFirstArgs>(args?: SelectSubset<T, serviceCategoryFindFirstArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serviceCategoryFindManyArgs>(args?: SelectSubset<T, serviceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {serviceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends serviceCategoryCreateArgs>(args: SelectSubset<T, serviceCategoryCreateArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {serviceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceCategoryCreateManyArgs>(args?: SelectSubset<T, serviceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {serviceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends serviceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, serviceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCategory.
     * @param {serviceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends serviceCategoryDeleteArgs>(args: SelectSubset<T, serviceCategoryDeleteArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {serviceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceCategoryUpdateArgs>(args: SelectSubset<T, serviceCategoryUpdateArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {serviceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceCategoryDeleteManyArgs>(args?: SelectSubset<T, serviceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceCategoryUpdateManyArgs>(args: SelectSubset<T, serviceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories and returns the data updated in the database.
     * @param {serviceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceCategories.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends serviceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, serviceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCategory.
     * @param {serviceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends serviceCategoryUpsertArgs>(args: SelectSubset<T, serviceCategoryUpsertArgs<ExtArgs>>): Prisma__serviceCategoryClient<$Result.GetResult<Prisma.$serviceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends serviceCategoryCountArgs>(
      args?: Subset<T, serviceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: serviceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serviceCategory model
   */
  readonly fields: serviceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    localService<T extends serviceCategory$localServiceArgs<ExtArgs> = {}>(args?: Subset<T, serviceCategory$localServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serviceCategory model
   */
  interface serviceCategoryFieldRefs {
    readonly id: FieldRef<"serviceCategory", 'String'>
    readonly name: FieldRef<"serviceCategory", 'String'>
    readonly description: FieldRef<"serviceCategory", 'String'>
    readonly createdAt: FieldRef<"serviceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"serviceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * serviceCategory findUnique
   */
  export type serviceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which serviceCategory to fetch.
     */
    where: serviceCategoryWhereUniqueInput
  }

  /**
   * serviceCategory findUniqueOrThrow
   */
  export type serviceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which serviceCategory to fetch.
     */
    where: serviceCategoryWhereUniqueInput
  }

  /**
   * serviceCategory findFirst
   */
  export type serviceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which serviceCategory to fetch.
     */
    where?: serviceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCategories to fetch.
     */
    orderBy?: serviceCategoryOrderByWithRelationInput | serviceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceCategories.
     */
    cursor?: serviceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * serviceCategory findFirstOrThrow
   */
  export type serviceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which serviceCategory to fetch.
     */
    where?: serviceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCategories to fetch.
     */
    orderBy?: serviceCategoryOrderByWithRelationInput | serviceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceCategories.
     */
    cursor?: serviceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * serviceCategory findMany
   */
  export type serviceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which serviceCategories to fetch.
     */
    where?: serviceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceCategories to fetch.
     */
    orderBy?: serviceCategoryOrderByWithRelationInput | serviceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceCategories.
     */
    cursor?: serviceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * serviceCategory create
   */
  export type serviceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a serviceCategory.
     */
    data: XOR<serviceCategoryCreateInput, serviceCategoryUncheckedCreateInput>
  }

  /**
   * serviceCategory createMany
   */
  export type serviceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceCategories.
     */
    data: serviceCategoryCreateManyInput | serviceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceCategory createManyAndReturn
   */
  export type serviceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many serviceCategories.
     */
    data: serviceCategoryCreateManyInput | serviceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceCategory update
   */
  export type serviceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a serviceCategory.
     */
    data: XOR<serviceCategoryUpdateInput, serviceCategoryUncheckedUpdateInput>
    /**
     * Choose, which serviceCategory to update.
     */
    where: serviceCategoryWhereUniqueInput
  }

  /**
   * serviceCategory updateMany
   */
  export type serviceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceCategories.
     */
    data: XOR<serviceCategoryUpdateManyMutationInput, serviceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which serviceCategories to update
     */
    where?: serviceCategoryWhereInput
    /**
     * Limit how many serviceCategories to update.
     */
    limit?: number
  }

  /**
   * serviceCategory updateManyAndReturn
   */
  export type serviceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update serviceCategories.
     */
    data: XOR<serviceCategoryUpdateManyMutationInput, serviceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which serviceCategories to update
     */
    where?: serviceCategoryWhereInput
    /**
     * Limit how many serviceCategories to update.
     */
    limit?: number
  }

  /**
   * serviceCategory upsert
   */
  export type serviceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the serviceCategory to update in case it exists.
     */
    where: serviceCategoryWhereUniqueInput
    /**
     * In case the serviceCategory found by the `where` argument doesn't exist, create a new serviceCategory with this data.
     */
    create: XOR<serviceCategoryCreateInput, serviceCategoryUncheckedCreateInput>
    /**
     * In case the serviceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceCategoryUpdateInput, serviceCategoryUncheckedUpdateInput>
  }

  /**
   * serviceCategory delete
   */
  export type serviceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
    /**
     * Filter which serviceCategory to delete.
     */
    where: serviceCategoryWhereUniqueInput
  }

  /**
   * serviceCategory deleteMany
   */
  export type serviceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceCategories to delete
     */
    where?: serviceCategoryWhereInput
    /**
     * Limit how many serviceCategories to delete.
     */
    limit?: number
  }

  /**
   * serviceCategory.localService
   */
  export type serviceCategory$localServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localService
     */
    select?: localServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localService
     */
    omit?: localServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localServiceInclude<ExtArgs> | null
    where?: localServiceWhereInput
    orderBy?: localServiceOrderByWithRelationInput | localServiceOrderByWithRelationInput[]
    cursor?: localServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalServiceScalarFieldEnum | LocalServiceScalarFieldEnum[]
  }

  /**
   * serviceCategory without action
   */
  export type serviceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceCategory
     */
    select?: serviceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceCategory
     */
    omit?: serviceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model skillCategory
   */

  export type AggregateSkillCategory = {
    _count: SkillCategoryCountAggregateOutputType | null
    _min: SkillCategoryMinAggregateOutputType | null
    _max: SkillCategoryMaxAggregateOutputType | null
  }

  export type SkillCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skillCategory to aggregate.
     */
    where?: skillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillCategories to fetch.
     */
    orderBy?: skillCategoryOrderByWithRelationInput | skillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skillCategories
    **/
    _count?: true | SkillCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillCategoryMaxAggregateInputType
  }

  export type GetSkillCategoryAggregateType<T extends SkillCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillCategory[P]>
      : GetScalarType<T[P], AggregateSkillCategory[P]>
  }




  export type skillCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillCategoryWhereInput
    orderBy?: skillCategoryOrderByWithAggregationInput | skillCategoryOrderByWithAggregationInput[]
    by: SkillCategoryScalarFieldEnum[] | SkillCategoryScalarFieldEnum
    having?: skillCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCategoryCountAggregateInputType | true
    _min?: SkillCategoryMinAggregateInputType
    _max?: SkillCategoryMaxAggregateInputType
  }

  export type SkillCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: SkillCategoryCountAggregateOutputType | null
    _min: SkillCategoryMinAggregateOutputType | null
    _max: SkillCategoryMaxAggregateOutputType | null
  }

  type GetSkillCategoryGroupByPayload<T extends skillCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SkillCategoryGroupByOutputType[P]>
        }
      >
    >


  export type skillCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skill?: boolean | skillCategory$skillArgs<ExtArgs>
    _count?: boolean | SkillCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillCategory"]>

  export type skillCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["skillCategory"]>

  export type skillCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["skillCategory"]>

  export type skillCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type skillCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["skillCategory"]>
  export type skillCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | skillCategory$skillArgs<ExtArgs>
    _count?: boolean | SkillCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type skillCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type skillCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $skillCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skillCategory"
    objects: {
      skill: Prisma.$skillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["skillCategory"]>
    composites: {}
  }

  type skillCategoryGetPayload<S extends boolean | null | undefined | skillCategoryDefaultArgs> = $Result.GetResult<Prisma.$skillCategoryPayload, S>

  type skillCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<skillCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCategoryCountAggregateInputType | true
    }

  export interface skillCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skillCategory'], meta: { name: 'skillCategory' } }
    /**
     * Find zero or one SkillCategory that matches the filter.
     * @param {skillCategoryFindUniqueArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skillCategoryFindUniqueArgs>(args: SelectSubset<T, skillCategoryFindUniqueArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkillCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {skillCategoryFindUniqueOrThrowArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skillCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, skillCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCategoryFindFirstArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skillCategoryFindFirstArgs>(args?: SelectSubset<T, skillCategoryFindFirstArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCategoryFindFirstOrThrowArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skillCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, skillCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkillCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillCategories
     * const skillCategories = await prisma.skillCategory.findMany()
     * 
     * // Get first 10 SkillCategories
     * const skillCategories = await prisma.skillCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillCategoryWithIdOnly = await prisma.skillCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skillCategoryFindManyArgs>(args?: SelectSubset<T, skillCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkillCategory.
     * @param {skillCategoryCreateArgs} args - Arguments to create a SkillCategory.
     * @example
     * // Create one SkillCategory
     * const SkillCategory = await prisma.skillCategory.create({
     *   data: {
     *     // ... data to create a SkillCategory
     *   }
     * })
     * 
     */
    create<T extends skillCategoryCreateArgs>(args: SelectSubset<T, skillCategoryCreateArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkillCategories.
     * @param {skillCategoryCreateManyArgs} args - Arguments to create many SkillCategories.
     * @example
     * // Create many SkillCategories
     * const skillCategory = await prisma.skillCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skillCategoryCreateManyArgs>(args?: SelectSubset<T, skillCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillCategories and returns the data saved in the database.
     * @param {skillCategoryCreateManyAndReturnArgs} args - Arguments to create many SkillCategories.
     * @example
     * // Create many SkillCategories
     * const skillCategory = await prisma.skillCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillCategories and only return the `id`
     * const skillCategoryWithIdOnly = await prisma.skillCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends skillCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, skillCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SkillCategory.
     * @param {skillCategoryDeleteArgs} args - Arguments to delete one SkillCategory.
     * @example
     * // Delete one SkillCategory
     * const SkillCategory = await prisma.skillCategory.delete({
     *   where: {
     *     // ... filter to delete one SkillCategory
     *   }
     * })
     * 
     */
    delete<T extends skillCategoryDeleteArgs>(args: SelectSubset<T, skillCategoryDeleteArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkillCategory.
     * @param {skillCategoryUpdateArgs} args - Arguments to update one SkillCategory.
     * @example
     * // Update one SkillCategory
     * const skillCategory = await prisma.skillCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skillCategoryUpdateArgs>(args: SelectSubset<T, skillCategoryUpdateArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkillCategories.
     * @param {skillCategoryDeleteManyArgs} args - Arguments to filter SkillCategories to delete.
     * @example
     * // Delete a few SkillCategories
     * const { count } = await prisma.skillCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skillCategoryDeleteManyArgs>(args?: SelectSubset<T, skillCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillCategories
     * const skillCategory = await prisma.skillCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skillCategoryUpdateManyArgs>(args: SelectSubset<T, skillCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillCategories and returns the data updated in the database.
     * @param {skillCategoryUpdateManyAndReturnArgs} args - Arguments to update many SkillCategories.
     * @example
     * // Update many SkillCategories
     * const skillCategory = await prisma.skillCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkillCategories and only return the `id`
     * const skillCategoryWithIdOnly = await prisma.skillCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends skillCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, skillCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SkillCategory.
     * @param {skillCategoryUpsertArgs} args - Arguments to update or create a SkillCategory.
     * @example
     * // Update or create a SkillCategory
     * const skillCategory = await prisma.skillCategory.upsert({
     *   create: {
     *     // ... data to create a SkillCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillCategory we want to update
     *   }
     * })
     */
    upsert<T extends skillCategoryUpsertArgs>(args: SelectSubset<T, skillCategoryUpsertArgs<ExtArgs>>): Prisma__skillCategoryClient<$Result.GetResult<Prisma.$skillCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SkillCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCategoryCountArgs} args - Arguments to filter SkillCategories to count.
     * @example
     * // Count the number of SkillCategories
     * const count = await prisma.skillCategory.count({
     *   where: {
     *     // ... the filter for the SkillCategories we want to count
     *   }
     * })
    **/
    count<T extends skillCategoryCountArgs>(
      args?: Subset<T, skillCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillCategoryAggregateArgs>(args: Subset<T, SkillCategoryAggregateArgs>): Prisma.PrismaPromise<GetSkillCategoryAggregateType<T>>

    /**
     * Group by SkillCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skillCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skillCategoryGroupByArgs['orderBy'] }
        : { orderBy?: skillCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skillCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skillCategory model
   */
  readonly fields: skillCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skillCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skillCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill<T extends skillCategory$skillArgs<ExtArgs> = {}>(args?: Subset<T, skillCategory$skillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skillCategory model
   */
  interface skillCategoryFieldRefs {
    readonly id: FieldRef<"skillCategory", 'String'>
    readonly name: FieldRef<"skillCategory", 'String'>
    readonly description: FieldRef<"skillCategory", 'String'>
    readonly createdAt: FieldRef<"skillCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"skillCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * skillCategory findUnique
   */
  export type skillCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which skillCategory to fetch.
     */
    where: skillCategoryWhereUniqueInput
  }

  /**
   * skillCategory findUniqueOrThrow
   */
  export type skillCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which skillCategory to fetch.
     */
    where: skillCategoryWhereUniqueInput
  }

  /**
   * skillCategory findFirst
   */
  export type skillCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which skillCategory to fetch.
     */
    where?: skillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillCategories to fetch.
     */
    orderBy?: skillCategoryOrderByWithRelationInput | skillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillCategories.
     */
    cursor?: skillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillCategories.
     */
    distinct?: SkillCategoryScalarFieldEnum | SkillCategoryScalarFieldEnum[]
  }

  /**
   * skillCategory findFirstOrThrow
   */
  export type skillCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which skillCategory to fetch.
     */
    where?: skillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillCategories to fetch.
     */
    orderBy?: skillCategoryOrderByWithRelationInput | skillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillCategories.
     */
    cursor?: skillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillCategories.
     */
    distinct?: SkillCategoryScalarFieldEnum | SkillCategoryScalarFieldEnum[]
  }

  /**
   * skillCategory findMany
   */
  export type skillCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which skillCategories to fetch.
     */
    where?: skillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillCategories to fetch.
     */
    orderBy?: skillCategoryOrderByWithRelationInput | skillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skillCategories.
     */
    cursor?: skillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillCategories.
     */
    skip?: number
    distinct?: SkillCategoryScalarFieldEnum | SkillCategoryScalarFieldEnum[]
  }

  /**
   * skillCategory create
   */
  export type skillCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a skillCategory.
     */
    data: XOR<skillCategoryCreateInput, skillCategoryUncheckedCreateInput>
  }

  /**
   * skillCategory createMany
   */
  export type skillCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skillCategories.
     */
    data: skillCategoryCreateManyInput | skillCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skillCategory createManyAndReturn
   */
  export type skillCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many skillCategories.
     */
    data: skillCategoryCreateManyInput | skillCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skillCategory update
   */
  export type skillCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a skillCategory.
     */
    data: XOR<skillCategoryUpdateInput, skillCategoryUncheckedUpdateInput>
    /**
     * Choose, which skillCategory to update.
     */
    where: skillCategoryWhereUniqueInput
  }

  /**
   * skillCategory updateMany
   */
  export type skillCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skillCategories.
     */
    data: XOR<skillCategoryUpdateManyMutationInput, skillCategoryUncheckedUpdateManyInput>
    /**
     * Filter which skillCategories to update
     */
    where?: skillCategoryWhereInput
    /**
     * Limit how many skillCategories to update.
     */
    limit?: number
  }

  /**
   * skillCategory updateManyAndReturn
   */
  export type skillCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * The data used to update skillCategories.
     */
    data: XOR<skillCategoryUpdateManyMutationInput, skillCategoryUncheckedUpdateManyInput>
    /**
     * Filter which skillCategories to update
     */
    where?: skillCategoryWhereInput
    /**
     * Limit how many skillCategories to update.
     */
    limit?: number
  }

  /**
   * skillCategory upsert
   */
  export type skillCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the skillCategory to update in case it exists.
     */
    where: skillCategoryWhereUniqueInput
    /**
     * In case the skillCategory found by the `where` argument doesn't exist, create a new skillCategory with this data.
     */
    create: XOR<skillCategoryCreateInput, skillCategoryUncheckedCreateInput>
    /**
     * In case the skillCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillCategoryUpdateInput, skillCategoryUncheckedUpdateInput>
  }

  /**
   * skillCategory delete
   */
  export type skillCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
    /**
     * Filter which skillCategory to delete.
     */
    where: skillCategoryWhereUniqueInput
  }

  /**
   * skillCategory deleteMany
   */
  export type skillCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skillCategories to delete
     */
    where?: skillCategoryWhereInput
    /**
     * Limit how many skillCategories to delete.
     */
    limit?: number
  }

  /**
   * skillCategory.skill
   */
  export type skillCategory$skillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skill
     */
    omit?: skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillInclude<ExtArgs> | null
    where?: skillWhereInput
    orderBy?: skillOrderByWithRelationInput | skillOrderByWithRelationInput[]
    cursor?: skillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * skillCategory without action
   */
  export type skillCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillCategory
     */
    select?: skillCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the skillCategory
     */
    omit?: skillCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillCategoryInclude<ExtArgs> | null
  }


  /**
   * Model wellnessCategory
   */

  export type AggregateWellnessCategory = {
    _count: WellnessCategoryCountAggregateOutputType | null
    _min: WellnessCategoryMinAggregateOutputType | null
    _max: WellnessCategoryMaxAggregateOutputType | null
  }

  export type WellnessCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellnessCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellnessCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessCategory to aggregate.
     */
    where?: wellnessCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessCategories to fetch.
     */
    orderBy?: wellnessCategoryOrderByWithRelationInput | wellnessCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wellnessCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wellnessCategories
    **/
    _count?: true | WellnessCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessCategoryMaxAggregateInputType
  }

  export type GetWellnessCategoryAggregateType<T extends WellnessCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessCategory[P]>
      : GetScalarType<T[P], AggregateWellnessCategory[P]>
  }




  export type wellnessCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wellnessCategoryWhereInput
    orderBy?: wellnessCategoryOrderByWithAggregationInput | wellnessCategoryOrderByWithAggregationInput[]
    by: WellnessCategoryScalarFieldEnum[] | WellnessCategoryScalarFieldEnum
    having?: wellnessCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessCategoryCountAggregateInputType | true
    _min?: WellnessCategoryMinAggregateInputType
    _max?: WellnessCategoryMaxAggregateInputType
  }

  export type WellnessCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: WellnessCategoryCountAggregateOutputType | null
    _min: WellnessCategoryMinAggregateOutputType | null
    _max: WellnessCategoryMaxAggregateOutputType | null
  }

  type GetWellnessCategoryGroupByPayload<T extends wellnessCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessCategoryGroupByOutputType[P]>
        }
      >
    >


  export type wellnessCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wellnessBadge?: boolean | wellnessCategory$wellnessBadgeArgs<ExtArgs>
    wellnessGoal?: boolean | wellnessCategory$wellnessGoalArgs<ExtArgs>
    _count?: boolean | WellnessCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessCategory"]>

  export type wellnessCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wellnessCategory"]>

  export type wellnessCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wellnessCategory"]>

  export type wellnessCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type wellnessCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["wellnessCategory"]>
  export type wellnessCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellnessBadge?: boolean | wellnessCategory$wellnessBadgeArgs<ExtArgs>
    wellnessGoal?: boolean | wellnessCategory$wellnessGoalArgs<ExtArgs>
    _count?: boolean | WellnessCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type wellnessCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type wellnessCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $wellnessCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wellnessCategory"
    objects: {
      wellnessBadge: Prisma.$wellnessBadgePayload<ExtArgs>[]
      wellnessGoal: Prisma.$wellnessGoalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["wellnessCategory"]>
    composites: {}
  }

  type wellnessCategoryGetPayload<S extends boolean | null | undefined | wellnessCategoryDefaultArgs> = $Result.GetResult<Prisma.$wellnessCategoryPayload, S>

  type wellnessCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wellnessCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellnessCategoryCountAggregateInputType | true
    }

  export interface wellnessCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wellnessCategory'], meta: { name: 'wellnessCategory' } }
    /**
     * Find zero or one WellnessCategory that matches the filter.
     * @param {wellnessCategoryFindUniqueArgs} args - Arguments to find a WellnessCategory
     * @example
     * // Get one WellnessCategory
     * const wellnessCategory = await prisma.wellnessCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wellnessCategoryFindUniqueArgs>(args: SelectSubset<T, wellnessCategoryFindUniqueArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellnessCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wellnessCategoryFindUniqueOrThrowArgs} args - Arguments to find a WellnessCategory
     * @example
     * // Get one WellnessCategory
     * const wellnessCategory = await prisma.wellnessCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wellnessCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, wellnessCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessCategoryFindFirstArgs} args - Arguments to find a WellnessCategory
     * @example
     * // Get one WellnessCategory
     * const wellnessCategory = await prisma.wellnessCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wellnessCategoryFindFirstArgs>(args?: SelectSubset<T, wellnessCategoryFindFirstArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessCategoryFindFirstOrThrowArgs} args - Arguments to find a WellnessCategory
     * @example
     * // Get one WellnessCategory
     * const wellnessCategory = await prisma.wellnessCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wellnessCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, wellnessCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellnessCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessCategories
     * const wellnessCategories = await prisma.wellnessCategory.findMany()
     * 
     * // Get first 10 WellnessCategories
     * const wellnessCategories = await prisma.wellnessCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessCategoryWithIdOnly = await prisma.wellnessCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wellnessCategoryFindManyArgs>(args?: SelectSubset<T, wellnessCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellnessCategory.
     * @param {wellnessCategoryCreateArgs} args - Arguments to create a WellnessCategory.
     * @example
     * // Create one WellnessCategory
     * const WellnessCategory = await prisma.wellnessCategory.create({
     *   data: {
     *     // ... data to create a WellnessCategory
     *   }
     * })
     * 
     */
    create<T extends wellnessCategoryCreateArgs>(args: SelectSubset<T, wellnessCategoryCreateArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellnessCategories.
     * @param {wellnessCategoryCreateManyArgs} args - Arguments to create many WellnessCategories.
     * @example
     * // Create many WellnessCategories
     * const wellnessCategory = await prisma.wellnessCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wellnessCategoryCreateManyArgs>(args?: SelectSubset<T, wellnessCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessCategories and returns the data saved in the database.
     * @param {wellnessCategoryCreateManyAndReturnArgs} args - Arguments to create many WellnessCategories.
     * @example
     * // Create many WellnessCategories
     * const wellnessCategory = await prisma.wellnessCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessCategories and only return the `id`
     * const wellnessCategoryWithIdOnly = await prisma.wellnessCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wellnessCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, wellnessCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellnessCategory.
     * @param {wellnessCategoryDeleteArgs} args - Arguments to delete one WellnessCategory.
     * @example
     * // Delete one WellnessCategory
     * const WellnessCategory = await prisma.wellnessCategory.delete({
     *   where: {
     *     // ... filter to delete one WellnessCategory
     *   }
     * })
     * 
     */
    delete<T extends wellnessCategoryDeleteArgs>(args: SelectSubset<T, wellnessCategoryDeleteArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellnessCategory.
     * @param {wellnessCategoryUpdateArgs} args - Arguments to update one WellnessCategory.
     * @example
     * // Update one WellnessCategory
     * const wellnessCategory = await prisma.wellnessCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wellnessCategoryUpdateArgs>(args: SelectSubset<T, wellnessCategoryUpdateArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellnessCategories.
     * @param {wellnessCategoryDeleteManyArgs} args - Arguments to filter WellnessCategories to delete.
     * @example
     * // Delete a few WellnessCategories
     * const { count } = await prisma.wellnessCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wellnessCategoryDeleteManyArgs>(args?: SelectSubset<T, wellnessCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessCategories
     * const wellnessCategory = await prisma.wellnessCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wellnessCategoryUpdateManyArgs>(args: SelectSubset<T, wellnessCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessCategories and returns the data updated in the database.
     * @param {wellnessCategoryUpdateManyAndReturnArgs} args - Arguments to update many WellnessCategories.
     * @example
     * // Update many WellnessCategories
     * const wellnessCategory = await prisma.wellnessCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellnessCategories and only return the `id`
     * const wellnessCategoryWithIdOnly = await prisma.wellnessCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends wellnessCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, wellnessCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellnessCategory.
     * @param {wellnessCategoryUpsertArgs} args - Arguments to update or create a WellnessCategory.
     * @example
     * // Update or create a WellnessCategory
     * const wellnessCategory = await prisma.wellnessCategory.upsert({
     *   create: {
     *     // ... data to create a WellnessCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessCategory we want to update
     *   }
     * })
     */
    upsert<T extends wellnessCategoryUpsertArgs>(args: SelectSubset<T, wellnessCategoryUpsertArgs<ExtArgs>>): Prisma__wellnessCategoryClient<$Result.GetResult<Prisma.$wellnessCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellnessCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessCategoryCountArgs} args - Arguments to filter WellnessCategories to count.
     * @example
     * // Count the number of WellnessCategories
     * const count = await prisma.wellnessCategory.count({
     *   where: {
     *     // ... the filter for the WellnessCategories we want to count
     *   }
     * })
    **/
    count<T extends wellnessCategoryCountArgs>(
      args?: Subset<T, wellnessCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessCategoryAggregateArgs>(args: Subset<T, WellnessCategoryAggregateArgs>): Prisma.PrismaPromise<GetWellnessCategoryAggregateType<T>>

    /**
     * Group by WellnessCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wellnessCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wellnessCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wellnessCategoryGroupByArgs['orderBy'] }
        : { orderBy?: wellnessCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wellnessCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wellnessCategory model
   */
  readonly fields: wellnessCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wellnessCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wellnessCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wellnessBadge<T extends wellnessCategory$wellnessBadgeArgs<ExtArgs> = {}>(args?: Subset<T, wellnessCategory$wellnessBadgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellnessGoal<T extends wellnessCategory$wellnessGoalArgs<ExtArgs> = {}>(args?: Subset<T, wellnessCategory$wellnessGoalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wellnessGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wellnessCategory model
   */
  interface wellnessCategoryFieldRefs {
    readonly id: FieldRef<"wellnessCategory", 'String'>
    readonly name: FieldRef<"wellnessCategory", 'String'>
    readonly description: FieldRef<"wellnessCategory", 'String'>
    readonly createdAt: FieldRef<"wellnessCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"wellnessCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wellnessCategory findUnique
   */
  export type wellnessCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * Filter, which wellnessCategory to fetch.
     */
    where: wellnessCategoryWhereUniqueInput
  }

  /**
   * wellnessCategory findUniqueOrThrow
   */
  export type wellnessCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * Filter, which wellnessCategory to fetch.
     */
    where: wellnessCategoryWhereUniqueInput
  }

  /**
   * wellnessCategory findFirst
   */
  export type wellnessCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * Filter, which wellnessCategory to fetch.
     */
    where?: wellnessCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessCategories to fetch.
     */
    orderBy?: wellnessCategoryOrderByWithRelationInput | wellnessCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessCategories.
     */
    cursor?: wellnessCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessCategories.
     */
    distinct?: WellnessCategoryScalarFieldEnum | WellnessCategoryScalarFieldEnum[]
  }

  /**
   * wellnessCategory findFirstOrThrow
   */
  export type wellnessCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * Filter, which wellnessCategory to fetch.
     */
    where?: wellnessCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessCategories to fetch.
     */
    orderBy?: wellnessCategoryOrderByWithRelationInput | wellnessCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wellnessCategories.
     */
    cursor?: wellnessCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wellnessCategories.
     */
    distinct?: WellnessCategoryScalarFieldEnum | WellnessCategoryScalarFieldEnum[]
  }

  /**
   * wellnessCategory findMany
   */
  export type wellnessCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * Filter, which wellnessCategories to fetch.
     */
    where?: wellnessCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wellnessCategories to fetch.
     */
    orderBy?: wellnessCategoryOrderByWithRelationInput | wellnessCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wellnessCategories.
     */
    cursor?: wellnessCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wellnessCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wellnessCategories.
     */
    skip?: number
    distinct?: WellnessCategoryScalarFieldEnum | WellnessCategoryScalarFieldEnum[]
  }

  /**
   * wellnessCategory create
   */
  export type wellnessCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a wellnessCategory.
     */
    data: XOR<wellnessCategoryCreateInput, wellnessCategoryUncheckedCreateInput>
  }

  /**
   * wellnessCategory createMany
   */
  export type wellnessCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wellnessCategories.
     */
    data: wellnessCategoryCreateManyInput | wellnessCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wellnessCategory createManyAndReturn
   */
  export type wellnessCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many wellnessCategories.
     */
    data: wellnessCategoryCreateManyInput | wellnessCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wellnessCategory update
   */
  export type wellnessCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a wellnessCategory.
     */
    data: XOR<wellnessCategoryUpdateInput, wellnessCategoryUncheckedUpdateInput>
    /**
     * Choose, which wellnessCategory to update.
     */
    where: wellnessCategoryWhereUniqueInput
  }

  /**
   * wellnessCategory updateMany
   */
  export type wellnessCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wellnessCategories.
     */
    data: XOR<wellnessCategoryUpdateManyMutationInput, wellnessCategoryUncheckedUpdateManyInput>
    /**
     * Filter which wellnessCategories to update
     */
    where?: wellnessCategoryWhereInput
    /**
     * Limit how many wellnessCategories to update.
     */
    limit?: number
  }

  /**
   * wellnessCategory updateManyAndReturn
   */
  export type wellnessCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * The data used to update wellnessCategories.
     */
    data: XOR<wellnessCategoryUpdateManyMutationInput, wellnessCategoryUncheckedUpdateManyInput>
    /**
     * Filter which wellnessCategories to update
     */
    where?: wellnessCategoryWhereInput
    /**
     * Limit how many wellnessCategories to update.
     */
    limit?: number
  }

  /**
   * wellnessCategory upsert
   */
  export type wellnessCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the wellnessCategory to update in case it exists.
     */
    where: wellnessCategoryWhereUniqueInput
    /**
     * In case the wellnessCategory found by the `where` argument doesn't exist, create a new wellnessCategory with this data.
     */
    create: XOR<wellnessCategoryCreateInput, wellnessCategoryUncheckedCreateInput>
    /**
     * In case the wellnessCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wellnessCategoryUpdateInput, wellnessCategoryUncheckedUpdateInput>
  }

  /**
   * wellnessCategory delete
   */
  export type wellnessCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
    /**
     * Filter which wellnessCategory to delete.
     */
    where: wellnessCategoryWhereUniqueInput
  }

  /**
   * wellnessCategory deleteMany
   */
  export type wellnessCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wellnessCategories to delete
     */
    where?: wellnessCategoryWhereInput
    /**
     * Limit how many wellnessCategories to delete.
     */
    limit?: number
  }

  /**
   * wellnessCategory.wellnessBadge
   */
  export type wellnessCategory$wellnessBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessBadge
     */
    select?: wellnessBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessBadge
     */
    omit?: wellnessBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessBadgeInclude<ExtArgs> | null
    where?: wellnessBadgeWhereInput
    orderBy?: wellnessBadgeOrderByWithRelationInput | wellnessBadgeOrderByWithRelationInput[]
    cursor?: wellnessBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellnessBadgeScalarFieldEnum | WellnessBadgeScalarFieldEnum[]
  }

  /**
   * wellnessCategory.wellnessGoal
   */
  export type wellnessCategory$wellnessGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessGoal
     */
    select?: wellnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessGoal
     */
    omit?: wellnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessGoalInclude<ExtArgs> | null
    where?: wellnessGoalWhereInput
    orderBy?: wellnessGoalOrderByWithRelationInput | wellnessGoalOrderByWithRelationInput[]
    cursor?: wellnessGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellnessGoalScalarFieldEnum | WellnessGoalScalarFieldEnum[]
  }

  /**
   * wellnessCategory without action
   */
  export type wellnessCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wellnessCategory
     */
    select?: wellnessCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wellnessCategory
     */
    omit?: wellnessCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wellnessCategoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    gpsCoordinates: 'gpsCoordinates',
    maxSpots: 'maxSpots',
    categoryId: 'categoryId',
    recurring: 'recurring',
    frequency: 'frequency',
    reducedMobilityAccess: 'reducedMobilityAccess',
    difficultyLevel: 'difficultyLevel',
    cost: 'cost',
    status: 'status',
    weatherRequirements: 'weatherRequirements',
    transportOptions: 'transportOptions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    actionType: 'actionType',
    description: 'description',
    ipAddress: 'ipAddress',
    device: 'device',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const ActivityRegistrationScalarFieldEnum: {
    id: 'id',
    activityId: 'activityId',
    userId: 'userId',
    registrationDate: 'registrationDate',
    status: 'status',
    attendanceConfirmed: 'attendanceConfirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityRegistrationScalarFieldEnum = (typeof ActivityRegistrationScalarFieldEnum)[keyof typeof ActivityRegistrationScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    description: 'description',
    icon: 'icon',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CognitiveExerciseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    difficultyLevel: 'difficultyLevel',
    durationMinutes: 'durationMinutes',
    description: 'description',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    programCategoryId: 'programCategoryId'
  };

  export type CognitiveExerciseScalarFieldEnum = (typeof CognitiveExerciseScalarFieldEnum)[keyof typeof CognitiveExerciseScalarFieldEnum]


  export const CollaborativeProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    creatorId: 'creatorId',
    creationDate: 'creationDate',
    status: 'status',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollaborativeProjectScalarFieldEnum = (typeof CollaborativeProjectScalarFieldEnum)[keyof typeof CollaborativeProjectScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    dateAdded: 'dateAdded',
    administrator: 'administrator',
    lastAccess: 'lastAccess',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const ExerciseProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    difficultyLevel: 'difficultyLevel',
    adaptedForReducedMobility: 'adaptedForReducedMobility',
    durationMinutes: 'durationMinutes',
    description: 'description',
    videoLink: 'videoLink',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseProgramScalarFieldEnum = (typeof ExerciseProgramScalarFieldEnum)[keyof typeof ExerciseProgramScalarFieldEnum]


  export const ForumCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    parentCategoryId: 'parentCategoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumCategoryScalarFieldEnum = (typeof ForumCategoryScalarFieldEnum)[keyof typeof ForumCategoryScalarFieldEnum]


  export const ForumMessageScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    authorId: 'authorId',
    content: 'content',
    solutionMessage: 'solutionMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumMessageScalarFieldEnum = (typeof ForumMessageScalarFieldEnum)[keyof typeof ForumMessageScalarFieldEnum]


  export const ForumTopicScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    authorId: 'authorId',
    title: 'title',
    pinned: 'pinned',
    status: 'status',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumTopicScalarFieldEnum = (typeof ForumTopicScalarFieldEnum)[keyof typeof ForumTopicScalarFieldEnum]


  export const HealthIndicatorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    recordingDate: 'recordingDate',
    stepCount: 'stepCount',
    sleepDurationMinutes: 'sleepDurationMinutes',
    sleepQuality: 'sleepQuality',
    weight: 'weight',
    mood: 'mood',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthIndicatorScalarFieldEnum = (typeof HealthIndicatorScalarFieldEnum)[keyof typeof HealthIndicatorScalarFieldEnum]


  export const HelpOfferScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    helperId: 'helperId',
    offerDate: 'offerDate',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpOfferScalarFieldEnum = (typeof HelpOfferScalarFieldEnum)[keyof typeof HelpOfferScalarFieldEnum]


  export const HelpRequestScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    neededDate: 'neededDate',
    estimatedDuration: 'estimatedDuration',
    location: 'location',
    gpsCoordinates: 'gpsCoordinates',
    categoryId: 'categoryId',
    recurring: 'recurring',
    frequency: 'frequency',
    status: 'status',
    pointsOffered: 'pointsOffered',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpRequestScalarFieldEnum = (typeof HelpRequestScalarFieldEnum)[keyof typeof HelpRequestScalarFieldEnum]


  export const LocalServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    address: 'address',
    gpsCoordinates: 'gpsCoordinates',
    phone: 'phone',
    website: 'website',
    description: 'description',
    hours: 'hours',
    seniorFriendly: 'seniorFriendly',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocalServiceScalarFieldEnum = (typeof LocalServiceScalarFieldEnum)[keyof typeof LocalServiceScalarFieldEnum]


  export const MedicationReminderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    medicationName: 'medicationName',
    dosage: 'dosage',
    morningReminderTime: 'morningReminderTime',
    noonReminderTime: 'noonReminderTime',
    eveningReminderTime: 'eveningReminderTime',
    nightReminderTime: 'nightReminderTime',
    daysOfWeek: 'daysOfWeek',
    instructions: 'instructions',
    active: 'active',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationReminderScalarFieldEnum = (typeof MedicationReminderScalarFieldEnum)[keyof typeof MedicationReminderScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    sendDate: 'sendDate',
    type: 'type',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MunicipalEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    gpsCoordinates: 'gpsCoordinates',
    organizer: 'organizer',
    contact: 'contact',
    officialLink: 'officialLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MunicipalEventScalarFieldEnum = (typeof MunicipalEventScalarFieldEnum)[keyof typeof MunicipalEventScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    content: 'content',
    read: 'read',
    actionLink: 'actionLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPreferencesScalarFieldEnum: {
    userId: 'userId',
    messageNotification: 'messageNotification',
    activityNotification: 'activityNotification',
    helpNotification: 'helpNotification',
    forumNotification: 'forumNotification',
    emailNotification: 'emailNotification',
    smsNotification: 'smsNotification',
    pushNotification: 'pushNotification',
    quietHoursStart: 'quietHoursStart',
    quietHoursEnd: 'quietHoursEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferencesScalarFieldEnum = (typeof NotificationPreferencesScalarFieldEnum)[keyof typeof NotificationPreferencesScalarFieldEnum]


  export const NutritionalAdviceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    categoryId: 'categoryId',
    season: 'season',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NutritionalAdviceScalarFieldEnum = (typeof NutritionalAdviceScalarFieldEnum)[keyof typeof NutritionalAdviceScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    joinDate: 'joinDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const ProjectTaskScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    creationDate: 'creationDate',
    dueDate: 'dueDate',
    status: 'status',
    assigneeId: 'assigneeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectTaskScalarFieldEnum = (typeof ProjectTaskScalarFieldEnum)[keyof typeof ProjectTaskScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    categoryId: 'categoryId',
    authorId: 'authorId',
    adminValidated: 'adminValidated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const SatisfactionSurveyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SatisfactionSurveyScalarFieldEnum = (typeof SatisfactionSurveyScalarFieldEnum)[keyof typeof SatisfactionSurveyScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    refreshToken: 'refreshToken',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ServiceCompletedScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    helperId: 'helperId',
    completionDate: 'completionDate',
    actualDuration: 'actualDuration',
    creatorComment: 'creatorComment',
    helperComment: 'helperComment',
    creatorRating: 'creatorRating',
    helperRating: 'helperRating',
    pointsExchanged: 'pointsExchanged',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCompletedScalarFieldEnum = (typeof ServiceCompletedScalarFieldEnum)[keyof typeof ServiceCompletedScalarFieldEnum]


  export const ServiceRatingScalarFieldEnum: {
    serviceId: 'serviceId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    ratingDate: 'ratingDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceRatingScalarFieldEnum = (typeof ServiceRatingScalarFieldEnum)[keyof typeof ServiceRatingScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const SurveyResponseScalarFieldEnum: {
    surveyId: 'surveyId',
    userId: 'userId',
    responses: 'responses',
    response_date: 'response_date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


  export const TrustCircleScalarFieldEnum: {
    userId: 'userId',
    contactId: 'contactId',
    dateAdded: 'dateAdded',
    accessLevel: 'accessLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrustCircleScalarFieldEnum = (typeof TrustCircleScalarFieldEnum)[keyof typeof TrustCircleScalarFieldEnum]


  export const TrustedContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    relationship: 'relationship',
    shareMedications: 'shareMedications',
    shareHealthIndicators: 'shareHealthIndicators',
    shareWellnessActivities: 'shareWellnessActivities',
    emergencyAlerts: 'emergencyAlerts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrustedContactScalarFieldEnum = (typeof TrustedContactScalarFieldEnum)[keyof typeof TrustedContactScalarFieldEnum]


  export const UrbanIssueReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categoryId: 'categoryId',
    description: 'description',
    address: 'address',
    gpsCoordinates: 'gpsCoordinates',
    reportDate: 'reportDate',
    status: 'status',
    cityReference: 'cityReference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UrbanIssueReportScalarFieldEnum = (typeof UrbanIssueReportScalarFieldEnum)[keyof typeof UrbanIssueReportScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    birthDate: 'birthDate',
    address: 'address',
    gpsCoordinates: 'gpsCoordinates',
    phone: 'phone',
    profilePicture: 'profilePicture',
    registrationDate: 'registrationDate',
    accountVerified: 'accountVerified',
    interfacePreferences: 'interfacePreferences',
    twoFactorAuthentication: 'twoFactorAuthentication',
    helpPoints: 'helpPoints',
    reducedMobility: 'reducedMobility',
    activityLevel: 'activityLevel',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    completionDate: 'completionDate',
    exerciseProgramId: 'exerciseProgramId',
    cognitiveExerciseId: 'cognitiveExerciseId',
    durationMinutes: 'durationMinutes',
    perceivedDifficultyLevel: 'perceivedDifficultyLevel',
    enjoymentLevel: 'enjoymentLevel',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserActivityScalarFieldEnum = (typeof UserActivityScalarFieldEnum)[keyof typeof UserActivityScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    userId: 'userId',
    badgeId: 'badgeId',
    achievementDate: 'achievementDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const UserDeviceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceType: 'deviceType',
    deviceName: 'deviceName',
    operatingSystem: 'operatingSystem',
    notificationToken: 'notificationToken',
    lastConnection: 'lastConnection',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserDeviceScalarFieldEnum = (typeof UserDeviceScalarFieldEnum)[keyof typeof UserDeviceScalarFieldEnum]


  export const UserSkillScalarFieldEnum: {
    userId: 'userId',
    skillId: 'skillId',
    level: 'level',
    created_at: 'created_at',
    updatedAt: 'updatedAt'
  };

  export type UserSkillScalarFieldEnum = (typeof UserSkillScalarFieldEnum)[keyof typeof UserSkillScalarFieldEnum]


  export const UserStatisticsScalarFieldEnum: {
    userId: 'userId',
    servicesProvided: 'servicesProvided',
    servicesReceived: 'servicesReceived',
    activitiesParticipated: 'activitiesParticipated',
    activitiesOrganized: 'activitiesOrganized',
    forumMessages: 'forumMessages',
    totalHelpPoints: 'totalHelpPoints',
    networkSize: 'networkSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserStatisticsScalarFieldEnum = (typeof UserStatisticsScalarFieldEnum)[keyof typeof UserStatisticsScalarFieldEnum]


  export const VideoCallScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    initiatorId: 'initiatorId',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoCallScalarFieldEnum = (typeof VideoCallScalarFieldEnum)[keyof typeof VideoCallScalarFieldEnum]


  export const WellnessBadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    categoryId: 'categoryId',
    image: 'image',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellnessBadgeScalarFieldEnum = (typeof WellnessBadgeScalarFieldEnum)[keyof typeof WellnessBadgeScalarFieldEnum]


  export const WellnessGoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    categoryId: 'categoryId',
    targetValue: 'targetValue',
    unit: 'unit',
    frequency: 'frequency',
    startDate: 'startDate',
    endDate: 'endDate',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellnessGoalScalarFieldEnum = (typeof WellnessGoalScalarFieldEnum)[keyof typeof WellnessGoalScalarFieldEnum]


  export const WellnessGoalProgressScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    recordingDate: 'recordingDate',
    achievedValue: 'achievedValue',
    goalAchieved: 'goalAchieved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellnessGoalProgressScalarFieldEnum = (typeof WellnessGoalProgressScalarFieldEnum)[keyof typeof WellnessGoalProgressScalarFieldEnum]


  export const ActivityCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityCategoryScalarFieldEnum = (typeof ActivityCategoryScalarFieldEnum)[keyof typeof ActivityCategoryScalarFieldEnum]


  export const BadgeCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeCategoryScalarFieldEnum = (typeof BadgeCategoryScalarFieldEnum)[keyof typeof BadgeCategoryScalarFieldEnum]


  export const CognitiveCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CognitiveCategoryScalarFieldEnum = (typeof CognitiveCategoryScalarFieldEnum)[keyof typeof CognitiveCategoryScalarFieldEnum]


  export const HelpCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpCategoryScalarFieldEnum = (typeof HelpCategoryScalarFieldEnum)[keyof typeof HelpCategoryScalarFieldEnum]


  export const IssueCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IssueCategoryScalarFieldEnum = (typeof IssueCategoryScalarFieldEnum)[keyof typeof IssueCategoryScalarFieldEnum]


  export const NutritionalCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NutritionalCategoryScalarFieldEnum = (typeof NutritionalCategoryScalarFieldEnum)[keyof typeof NutritionalCategoryScalarFieldEnum]


  export const ProgramCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramCategoryScalarFieldEnum = (typeof ProgramCategoryScalarFieldEnum)[keyof typeof ProgramCategoryScalarFieldEnum]


  export const ProjectCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectCategoryScalarFieldEnum = (typeof ProjectCategoryScalarFieldEnum)[keyof typeof ProjectCategoryScalarFieldEnum]


  export const ResourceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceCategoryScalarFieldEnum = (typeof ResourceCategoryScalarFieldEnum)[keyof typeof ResourceCategoryScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const SkillCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillCategoryScalarFieldEnum = (typeof SkillCategoryScalarFieldEnum)[keyof typeof SkillCategoryScalarFieldEnum]


  export const WellnessCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellnessCategoryScalarFieldEnum = (typeof WellnessCategoryScalarFieldEnum)[keyof typeof WellnessCategoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type activityWhereInput = {
    AND?: activityWhereInput | activityWhereInput[]
    OR?: activityWhereInput[]
    NOT?: activityWhereInput | activityWhereInput[]
    id?: StringFilter<"activity"> | string
    creatorId?: StringNullableFilter<"activity"> | string | null
    title?: StringFilter<"activity"> | string
    description?: StringNullableFilter<"activity"> | string | null
    startDate?: DateTimeFilter<"activity"> | Date | string
    endDate?: DateTimeNullableFilter<"activity"> | Date | string | null
    location?: StringNullableFilter<"activity"> | string | null
    gpsCoordinates?: StringNullableFilter<"activity"> | string | null
    maxSpots?: IntNullableFilter<"activity"> | number | null
    categoryId?: StringNullableFilter<"activity"> | string | null
    recurring?: BoolNullableFilter<"activity"> | boolean | null
    frequency?: StringNullableFilter<"activity"> | string | null
    reducedMobilityAccess?: BoolFilter<"activity"> | boolean
    difficultyLevel?: IntNullableFilter<"activity"> | number | null
    cost?: FloatNullableFilter<"activity"> | number | null
    status?: StringNullableFilter<"activity"> | string | null
    weatherRequirements?: StringNullableFilter<"activity"> | string | null
    transportOptions?: StringNullableFilter<"activity"> | string | null
    createdAt?: DateTimeFilter<"activity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activity"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    activityCategory?: XOR<ActivityCategoryNullableScalarRelationFilter, activityCategoryWhereInput> | null
    activity_registration?: ActivityRegistrationListRelationFilter
  }

  export type activityOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    maxSpots?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    recurring?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    reducedMobilityAccess?: SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    weatherRequirements?: SortOrderInput | SortOrder
    transportOptions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    activityCategory?: activityCategoryOrderByWithRelationInput
    activity_registration?: activityRegistrationOrderByRelationAggregateInput
  }

  export type activityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: activityWhereInput | activityWhereInput[]
    OR?: activityWhereInput[]
    NOT?: activityWhereInput | activityWhereInput[]
    creatorId?: StringNullableFilter<"activity"> | string | null
    title?: StringFilter<"activity"> | string
    description?: StringNullableFilter<"activity"> | string | null
    startDate?: DateTimeFilter<"activity"> | Date | string
    endDate?: DateTimeNullableFilter<"activity"> | Date | string | null
    location?: StringNullableFilter<"activity"> | string | null
    gpsCoordinates?: StringNullableFilter<"activity"> | string | null
    maxSpots?: IntNullableFilter<"activity"> | number | null
    categoryId?: StringNullableFilter<"activity"> | string | null
    recurring?: BoolNullableFilter<"activity"> | boolean | null
    frequency?: StringNullableFilter<"activity"> | string | null
    reducedMobilityAccess?: BoolFilter<"activity"> | boolean
    difficultyLevel?: IntNullableFilter<"activity"> | number | null
    cost?: FloatNullableFilter<"activity"> | number | null
    status?: StringNullableFilter<"activity"> | string | null
    weatherRequirements?: StringNullableFilter<"activity"> | string | null
    transportOptions?: StringNullableFilter<"activity"> | string | null
    createdAt?: DateTimeFilter<"activity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activity"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    activityCategory?: XOR<ActivityCategoryNullableScalarRelationFilter, activityCategoryWhereInput> | null
    activity_registration?: ActivityRegistrationListRelationFilter
  }, "id">

  export type activityOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    maxSpots?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    recurring?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    reducedMobilityAccess?: SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    weatherRequirements?: SortOrderInput | SortOrder
    transportOptions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: activityCountOrderByAggregateInput
    _avg?: activityAvgOrderByAggregateInput
    _max?: activityMaxOrderByAggregateInput
    _min?: activityMinOrderByAggregateInput
    _sum?: activitySumOrderByAggregateInput
  }

  export type activityScalarWhereWithAggregatesInput = {
    AND?: activityScalarWhereWithAggregatesInput | activityScalarWhereWithAggregatesInput[]
    OR?: activityScalarWhereWithAggregatesInput[]
    NOT?: activityScalarWhereWithAggregatesInput | activityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"activity"> | string
    creatorId?: StringNullableWithAggregatesFilter<"activity"> | string | null
    title?: StringWithAggregatesFilter<"activity"> | string
    description?: StringNullableWithAggregatesFilter<"activity"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"activity"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"activity"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"activity"> | string | null
    gpsCoordinates?: StringNullableWithAggregatesFilter<"activity"> | string | null
    maxSpots?: IntNullableWithAggregatesFilter<"activity"> | number | null
    categoryId?: StringNullableWithAggregatesFilter<"activity"> | string | null
    recurring?: BoolNullableWithAggregatesFilter<"activity"> | boolean | null
    frequency?: StringNullableWithAggregatesFilter<"activity"> | string | null
    reducedMobilityAccess?: BoolWithAggregatesFilter<"activity"> | boolean
    difficultyLevel?: IntNullableWithAggregatesFilter<"activity"> | number | null
    cost?: FloatNullableWithAggregatesFilter<"activity"> | number | null
    status?: StringNullableWithAggregatesFilter<"activity"> | string | null
    weatherRequirements?: StringNullableWithAggregatesFilter<"activity"> | string | null
    transportOptions?: StringNullableWithAggregatesFilter<"activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"activity"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"activity"> | Date | string | null
  }

  export type activityLogWhereInput = {
    AND?: activityLogWhereInput | activityLogWhereInput[]
    OR?: activityLogWhereInput[]
    NOT?: activityLogWhereInput | activityLogWhereInput[]
    id?: StringFilter<"activityLog"> | string
    userId?: StringNullableFilter<"activityLog"> | string | null
    actionType?: StringNullableFilter<"activityLog"> | string | null
    description?: StringNullableFilter<"activityLog"> | string | null
    ipAddress?: StringNullableFilter<"activityLog"> | string | null
    device?: StringNullableFilter<"activityLog"> | string | null
    createdAt?: DateTimeFilter<"activityLog"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityLog"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type activityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    actionType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type activityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: activityLogWhereInput | activityLogWhereInput[]
    OR?: activityLogWhereInput[]
    NOT?: activityLogWhereInput | activityLogWhereInput[]
    userId?: StringNullableFilter<"activityLog"> | string | null
    actionType?: StringNullableFilter<"activityLog"> | string | null
    description?: StringNullableFilter<"activityLog"> | string | null
    ipAddress?: StringNullableFilter<"activityLog"> | string | null
    device?: StringNullableFilter<"activityLog"> | string | null
    createdAt?: DateTimeFilter<"activityLog"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityLog"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type activityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    actionType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: activityLogCountOrderByAggregateInput
    _max?: activityLogMaxOrderByAggregateInput
    _min?: activityLogMinOrderByAggregateInput
  }

  export type activityLogScalarWhereWithAggregatesInput = {
    AND?: activityLogScalarWhereWithAggregatesInput | activityLogScalarWhereWithAggregatesInput[]
    OR?: activityLogScalarWhereWithAggregatesInput[]
    NOT?: activityLogScalarWhereWithAggregatesInput | activityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"activityLog"> | string
    userId?: StringNullableWithAggregatesFilter<"activityLog"> | string | null
    actionType?: StringNullableWithAggregatesFilter<"activityLog"> | string | null
    description?: StringNullableWithAggregatesFilter<"activityLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"activityLog"> | string | null
    device?: StringNullableWithAggregatesFilter<"activityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"activityLog"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"activityLog"> | Date | string | null
  }

  export type activityRegistrationWhereInput = {
    AND?: activityRegistrationWhereInput | activityRegistrationWhereInput[]
    OR?: activityRegistrationWhereInput[]
    NOT?: activityRegistrationWhereInput | activityRegistrationWhereInput[]
    id?: StringFilter<"activityRegistration"> | string
    activityId?: StringFilter<"activityRegistration"> | string
    userId?: StringFilter<"activityRegistration"> | string
    registrationDate?: DateTimeFilter<"activityRegistration"> | Date | string
    status?: StringNullableFilter<"activityRegistration"> | string | null
    attendanceConfirmed?: BoolNullableFilter<"activityRegistration"> | boolean | null
    createdAt?: DateTimeFilter<"activityRegistration"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityRegistration"> | Date | string | null
    activity?: XOR<ActivityScalarRelationFilter, activityWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type activityRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrderInput | SortOrder
    attendanceConfirmed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    activity?: activityOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type activityRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: activityRegistrationWhereInput | activityRegistrationWhereInput[]
    OR?: activityRegistrationWhereInput[]
    NOT?: activityRegistrationWhereInput | activityRegistrationWhereInput[]
    activityId?: StringFilter<"activityRegistration"> | string
    userId?: StringFilter<"activityRegistration"> | string
    registrationDate?: DateTimeFilter<"activityRegistration"> | Date | string
    status?: StringNullableFilter<"activityRegistration"> | string | null
    attendanceConfirmed?: BoolNullableFilter<"activityRegistration"> | boolean | null
    createdAt?: DateTimeFilter<"activityRegistration"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityRegistration"> | Date | string | null
    activity?: XOR<ActivityScalarRelationFilter, activityWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type activityRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrderInput | SortOrder
    attendanceConfirmed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: activityRegistrationCountOrderByAggregateInput
    _max?: activityRegistrationMaxOrderByAggregateInput
    _min?: activityRegistrationMinOrderByAggregateInput
  }

  export type activityRegistrationScalarWhereWithAggregatesInput = {
    AND?: activityRegistrationScalarWhereWithAggregatesInput | activityRegistrationScalarWhereWithAggregatesInput[]
    OR?: activityRegistrationScalarWhereWithAggregatesInput[]
    NOT?: activityRegistrationScalarWhereWithAggregatesInput | activityRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"activityRegistration"> | string
    activityId?: StringWithAggregatesFilter<"activityRegistration"> | string
    userId?: StringWithAggregatesFilter<"activityRegistration"> | string
    registrationDate?: DateTimeWithAggregatesFilter<"activityRegistration"> | Date | string
    status?: StringNullableWithAggregatesFilter<"activityRegistration"> | string | null
    attendanceConfirmed?: BoolNullableWithAggregatesFilter<"activityRegistration"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"activityRegistration"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"activityRegistration"> | Date | string | null
  }

  export type badgeWhereInput = {
    AND?: badgeWhereInput | badgeWhereInput[]
    OR?: badgeWhereInput[]
    NOT?: badgeWhereInput | badgeWhereInput[]
    id?: StringFilter<"badge"> | string
    name?: StringFilter<"badge"> | string
    categoryId?: StringNullableFilter<"badge"> | string | null
    description?: StringNullableFilter<"badge"> | string | null
    icon?: StringNullableFilter<"badge"> | string | null
    level?: IntNullableFilter<"badge"> | number | null
    createdAt?: DateTimeFilter<"badge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"badge"> | Date | string | null
    userBadge?: XOR<UserBadgeNullableScalarRelationFilter, userBadgeWhereInput> | null
    badgeCategory?: XOR<BadgeCategoryNullableScalarRelationFilter, badgeCategoryWhereInput> | null
  }

  export type badgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userBadge?: userBadgeOrderByWithRelationInput
    badgeCategory?: badgeCategoryOrderByWithRelationInput
  }

  export type badgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId?: string
    AND?: badgeWhereInput | badgeWhereInput[]
    OR?: badgeWhereInput[]
    NOT?: badgeWhereInput | badgeWhereInput[]
    name?: StringFilter<"badge"> | string
    description?: StringNullableFilter<"badge"> | string | null
    icon?: StringNullableFilter<"badge"> | string | null
    level?: IntNullableFilter<"badge"> | number | null
    createdAt?: DateTimeFilter<"badge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"badge"> | Date | string | null
    userBadge?: XOR<UserBadgeNullableScalarRelationFilter, userBadgeWhereInput> | null
    badgeCategory?: XOR<BadgeCategoryNullableScalarRelationFilter, badgeCategoryWhereInput> | null
  }, "id" | "categoryId">

  export type badgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: badgeCountOrderByAggregateInput
    _avg?: badgeAvgOrderByAggregateInput
    _max?: badgeMaxOrderByAggregateInput
    _min?: badgeMinOrderByAggregateInput
    _sum?: badgeSumOrderByAggregateInput
  }

  export type badgeScalarWhereWithAggregatesInput = {
    AND?: badgeScalarWhereWithAggregatesInput | badgeScalarWhereWithAggregatesInput[]
    OR?: badgeScalarWhereWithAggregatesInput[]
    NOT?: badgeScalarWhereWithAggregatesInput | badgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"badge"> | string
    name?: StringWithAggregatesFilter<"badge"> | string
    categoryId?: StringNullableWithAggregatesFilter<"badge"> | string | null
    description?: StringNullableWithAggregatesFilter<"badge"> | string | null
    icon?: StringNullableWithAggregatesFilter<"badge"> | string | null
    level?: IntNullableWithAggregatesFilter<"badge"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"badge"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"badge"> | Date | string | null
  }

  export type cognitiveExerciseWhereInput = {
    AND?: cognitiveExerciseWhereInput | cognitiveExerciseWhereInput[]
    OR?: cognitiveExerciseWhereInput[]
    NOT?: cognitiveExerciseWhereInput | cognitiveExerciseWhereInput[]
    id?: StringFilter<"cognitiveExercise"> | string
    name?: StringFilter<"cognitiveExercise"> | string
    categoryId?: StringNullableFilter<"cognitiveExercise"> | string | null
    difficultyLevel?: IntNullableFilter<"cognitiveExercise"> | number | null
    durationMinutes?: IntNullableFilter<"cognitiveExercise"> | number | null
    description?: StringNullableFilter<"cognitiveExercise"> | string | null
    image?: StringNullableFilter<"cognitiveExercise"> | string | null
    createdAt?: DateTimeFilter<"cognitiveExercise"> | Date | string
    updatedAt?: DateTimeNullableFilter<"cognitiveExercise"> | Date | string | null
    programCategoryId?: StringNullableFilter<"cognitiveExercise"> | string | null
    cognitiveCategory?: XOR<CognitiveCategoryNullableScalarRelationFilter, cognitiveCategoryWhereInput> | null
    userActivity?: UserActivityListRelationFilter
    programCategory?: XOR<ProgramCategoryNullableScalarRelationFilter, programCategoryWhereInput> | null
  }

  export type cognitiveExerciseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    programCategoryId?: SortOrderInput | SortOrder
    cognitiveCategory?: cognitiveCategoryOrderByWithRelationInput
    userActivity?: userActivityOrderByRelationAggregateInput
    programCategory?: programCategoryOrderByWithRelationInput
  }

  export type cognitiveExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cognitiveExerciseWhereInput | cognitiveExerciseWhereInput[]
    OR?: cognitiveExerciseWhereInput[]
    NOT?: cognitiveExerciseWhereInput | cognitiveExerciseWhereInput[]
    name?: StringFilter<"cognitiveExercise"> | string
    categoryId?: StringNullableFilter<"cognitiveExercise"> | string | null
    difficultyLevel?: IntNullableFilter<"cognitiveExercise"> | number | null
    durationMinutes?: IntNullableFilter<"cognitiveExercise"> | number | null
    description?: StringNullableFilter<"cognitiveExercise"> | string | null
    image?: StringNullableFilter<"cognitiveExercise"> | string | null
    createdAt?: DateTimeFilter<"cognitiveExercise"> | Date | string
    updatedAt?: DateTimeNullableFilter<"cognitiveExercise"> | Date | string | null
    programCategoryId?: StringNullableFilter<"cognitiveExercise"> | string | null
    cognitiveCategory?: XOR<CognitiveCategoryNullableScalarRelationFilter, cognitiveCategoryWhereInput> | null
    userActivity?: UserActivityListRelationFilter
    programCategory?: XOR<ProgramCategoryNullableScalarRelationFilter, programCategoryWhereInput> | null
  }, "id">

  export type cognitiveExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    programCategoryId?: SortOrderInput | SortOrder
    _count?: cognitiveExerciseCountOrderByAggregateInput
    _avg?: cognitiveExerciseAvgOrderByAggregateInput
    _max?: cognitiveExerciseMaxOrderByAggregateInput
    _min?: cognitiveExerciseMinOrderByAggregateInput
    _sum?: cognitiveExerciseSumOrderByAggregateInput
  }

  export type cognitiveExerciseScalarWhereWithAggregatesInput = {
    AND?: cognitiveExerciseScalarWhereWithAggregatesInput | cognitiveExerciseScalarWhereWithAggregatesInput[]
    OR?: cognitiveExerciseScalarWhereWithAggregatesInput[]
    NOT?: cognitiveExerciseScalarWhereWithAggregatesInput | cognitiveExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cognitiveExercise"> | string
    name?: StringWithAggregatesFilter<"cognitiveExercise"> | string
    categoryId?: StringNullableWithAggregatesFilter<"cognitiveExercise"> | string | null
    difficultyLevel?: IntNullableWithAggregatesFilter<"cognitiveExercise"> | number | null
    durationMinutes?: IntNullableWithAggregatesFilter<"cognitiveExercise"> | number | null
    description?: StringNullableWithAggregatesFilter<"cognitiveExercise"> | string | null
    image?: StringNullableWithAggregatesFilter<"cognitiveExercise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"cognitiveExercise"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"cognitiveExercise"> | Date | string | null
    programCategoryId?: StringNullableWithAggregatesFilter<"cognitiveExercise"> | string | null
  }

  export type collaborativeProjectWhereInput = {
    AND?: collaborativeProjectWhereInput | collaborativeProjectWhereInput[]
    OR?: collaborativeProjectWhereInput[]
    NOT?: collaborativeProjectWhereInput | collaborativeProjectWhereInput[]
    id?: StringFilter<"collaborativeProject"> | string
    title?: StringFilter<"collaborativeProject"> | string
    description?: StringNullableFilter<"collaborativeProject"> | string | null
    creatorId?: StringFilter<"collaborativeProject"> | string
    creationDate?: DateTimeFilter<"collaborativeProject"> | Date | string
    status?: StringNullableFilter<"collaborativeProject"> | string | null
    categoryId?: StringNullableFilter<"collaborativeProject"> | string | null
    createdAt?: DateTimeFilter<"collaborativeProject"> | Date | string
    updatedAt?: DateTimeNullableFilter<"collaborativeProject"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    projectCategory?: XOR<ProjectCategoryNullableScalarRelationFilter, projectCategoryWhereInput> | null
    projectMember?: ProjectMemberListRelationFilter
    projectTask?: ProjectTaskListRelationFilter
  }

  export type collaborativeProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    creationDate?: SortOrder
    status?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    projectCategory?: projectCategoryOrderByWithRelationInput
    projectMember?: projectMemberOrderByRelationAggregateInput
    projectTask?: projectTaskOrderByRelationAggregateInput
  }

  export type collaborativeProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: collaborativeProjectWhereInput | collaborativeProjectWhereInput[]
    OR?: collaborativeProjectWhereInput[]
    NOT?: collaborativeProjectWhereInput | collaborativeProjectWhereInput[]
    title?: StringFilter<"collaborativeProject"> | string
    description?: StringNullableFilter<"collaborativeProject"> | string | null
    creatorId?: StringFilter<"collaborativeProject"> | string
    creationDate?: DateTimeFilter<"collaborativeProject"> | Date | string
    status?: StringNullableFilter<"collaborativeProject"> | string | null
    categoryId?: StringNullableFilter<"collaborativeProject"> | string | null
    createdAt?: DateTimeFilter<"collaborativeProject"> | Date | string
    updatedAt?: DateTimeNullableFilter<"collaborativeProject"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    projectCategory?: XOR<ProjectCategoryNullableScalarRelationFilter, projectCategoryWhereInput> | null
    projectMember?: ProjectMemberListRelationFilter
    projectTask?: ProjectTaskListRelationFilter
  }, "id">

  export type collaborativeProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    creationDate?: SortOrder
    status?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: collaborativeProjectCountOrderByAggregateInput
    _max?: collaborativeProjectMaxOrderByAggregateInput
    _min?: collaborativeProjectMinOrderByAggregateInput
  }

  export type collaborativeProjectScalarWhereWithAggregatesInput = {
    AND?: collaborativeProjectScalarWhereWithAggregatesInput | collaborativeProjectScalarWhereWithAggregatesInput[]
    OR?: collaborativeProjectScalarWhereWithAggregatesInput[]
    NOT?: collaborativeProjectScalarWhereWithAggregatesInput | collaborativeProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"collaborativeProject"> | string
    title?: StringWithAggregatesFilter<"collaborativeProject"> | string
    description?: StringNullableWithAggregatesFilter<"collaborativeProject"> | string | null
    creatorId?: StringWithAggregatesFilter<"collaborativeProject"> | string
    creationDate?: DateTimeWithAggregatesFilter<"collaborativeProject"> | Date | string
    status?: StringNullableWithAggregatesFilter<"collaborativeProject"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"collaborativeProject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"collaborativeProject"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"collaborativeProject"> | Date | string | null
  }

  export type conversationWhereInput = {
    AND?: conversationWhereInput | conversationWhereInput[]
    OR?: conversationWhereInput[]
    NOT?: conversationWhereInput | conversationWhereInput[]
    id?: StringFilter<"conversation"> | string
    type?: StringFilter<"conversation"> | string
    title?: StringFilter<"conversation"> | string
    createdAt?: DateTimeFilter<"conversation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"conversation"> | Date | string | null
    conversationParticipant?: ConversationParticipantListRelationFilter
    message?: MessageListRelationFilter
    videoCall?: VideoCallListRelationFilter
  }

  export type conversationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    conversationParticipant?: conversationParticipantOrderByRelationAggregateInput
    message?: messageOrderByRelationAggregateInput
    videoCall?: videoCallOrderByRelationAggregateInput
  }

  export type conversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: conversationWhereInput | conversationWhereInput[]
    OR?: conversationWhereInput[]
    NOT?: conversationWhereInput | conversationWhereInput[]
    type?: StringFilter<"conversation"> | string
    title?: StringFilter<"conversation"> | string
    createdAt?: DateTimeFilter<"conversation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"conversation"> | Date | string | null
    conversationParticipant?: ConversationParticipantListRelationFilter
    message?: MessageListRelationFilter
    videoCall?: VideoCallListRelationFilter
  }, "id">

  export type conversationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: conversationCountOrderByAggregateInput
    _max?: conversationMaxOrderByAggregateInput
    _min?: conversationMinOrderByAggregateInput
  }

  export type conversationScalarWhereWithAggregatesInput = {
    AND?: conversationScalarWhereWithAggregatesInput | conversationScalarWhereWithAggregatesInput[]
    OR?: conversationScalarWhereWithAggregatesInput[]
    NOT?: conversationScalarWhereWithAggregatesInput | conversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"conversation"> | string
    type?: StringWithAggregatesFilter<"conversation"> | string
    title?: StringWithAggregatesFilter<"conversation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"conversation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"conversation"> | Date | string | null
  }

  export type conversationParticipantWhereInput = {
    AND?: conversationParticipantWhereInput | conversationParticipantWhereInput[]
    OR?: conversationParticipantWhereInput[]
    NOT?: conversationParticipantWhereInput | conversationParticipantWhereInput[]
    id?: StringFilter<"conversationParticipant"> | string
    conversationId?: StringFilter<"conversationParticipant"> | string
    userId?: StringFilter<"conversationParticipant"> | string
    dateAdded?: DateTimeNullableFilter<"conversationParticipant"> | Date | string | null
    administrator?: BoolNullableFilter<"conversationParticipant"> | boolean | null
    lastAccess?: DateTimeFilter<"conversationParticipant"> | Date | string
    createdAt?: DateTimeFilter<"conversationParticipant"> | Date | string
    updatedAt?: DateTimeNullableFilter<"conversationParticipant"> | Date | string | null
    conversation?: XOR<ConversationScalarRelationFilter, conversationWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type conversationParticipantOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    dateAdded?: SortOrderInput | SortOrder
    administrator?: SortOrderInput | SortOrder
    lastAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    conversation?: conversationOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type conversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: conversationParticipantWhereInput | conversationParticipantWhereInput[]
    OR?: conversationParticipantWhereInput[]
    NOT?: conversationParticipantWhereInput | conversationParticipantWhereInput[]
    conversationId?: StringFilter<"conversationParticipant"> | string
    userId?: StringFilter<"conversationParticipant"> | string
    dateAdded?: DateTimeNullableFilter<"conversationParticipant"> | Date | string | null
    administrator?: BoolNullableFilter<"conversationParticipant"> | boolean | null
    lastAccess?: DateTimeFilter<"conversationParticipant"> | Date | string
    createdAt?: DateTimeFilter<"conversationParticipant"> | Date | string
    updatedAt?: DateTimeNullableFilter<"conversationParticipant"> | Date | string | null
    conversation?: XOR<ConversationScalarRelationFilter, conversationWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type conversationParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    dateAdded?: SortOrderInput | SortOrder
    administrator?: SortOrderInput | SortOrder
    lastAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: conversationParticipantCountOrderByAggregateInput
    _max?: conversationParticipantMaxOrderByAggregateInput
    _min?: conversationParticipantMinOrderByAggregateInput
  }

  export type conversationParticipantScalarWhereWithAggregatesInput = {
    AND?: conversationParticipantScalarWhereWithAggregatesInput | conversationParticipantScalarWhereWithAggregatesInput[]
    OR?: conversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: conversationParticipantScalarWhereWithAggregatesInput | conversationParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"conversationParticipant"> | string
    conversationId?: StringWithAggregatesFilter<"conversationParticipant"> | string
    userId?: StringWithAggregatesFilter<"conversationParticipant"> | string
    dateAdded?: DateTimeNullableWithAggregatesFilter<"conversationParticipant"> | Date | string | null
    administrator?: BoolNullableWithAggregatesFilter<"conversationParticipant"> | boolean | null
    lastAccess?: DateTimeWithAggregatesFilter<"conversationParticipant"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"conversationParticipant"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"conversationParticipant"> | Date | string | null
  }

  export type exerciseProgramWhereInput = {
    AND?: exerciseProgramWhereInput | exerciseProgramWhereInput[]
    OR?: exerciseProgramWhereInput[]
    NOT?: exerciseProgramWhereInput | exerciseProgramWhereInput[]
    id?: StringFilter<"exerciseProgram"> | string
    name?: StringFilter<"exerciseProgram"> | string
    categoryId?: StringNullableFilter<"exerciseProgram"> | string | null
    difficultyLevel?: IntNullableFilter<"exerciseProgram"> | number | null
    adaptedForReducedMobility?: BoolNullableFilter<"exerciseProgram"> | boolean | null
    durationMinutes?: IntNullableFilter<"exerciseProgram"> | number | null
    description?: StringNullableFilter<"exerciseProgram"> | string | null
    videoLink?: StringNullableFilter<"exerciseProgram"> | string | null
    image?: StringNullableFilter<"exerciseProgram"> | string | null
    createdAt?: DateTimeFilter<"exerciseProgram"> | Date | string
    updatedAt?: DateTimeNullableFilter<"exerciseProgram"> | Date | string | null
    programCategory?: XOR<ProgramCategoryNullableScalarRelationFilter, programCategoryWhereInput> | null
    userActivity?: UserActivityListRelationFilter
  }

  export type exerciseProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    adaptedForReducedMobility?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    videoLink?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    programCategory?: programCategoryOrderByWithRelationInput
    userActivity?: userActivityOrderByRelationAggregateInput
  }

  export type exerciseProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: exerciseProgramWhereInput | exerciseProgramWhereInput[]
    OR?: exerciseProgramWhereInput[]
    NOT?: exerciseProgramWhereInput | exerciseProgramWhereInput[]
    name?: StringFilter<"exerciseProgram"> | string
    categoryId?: StringNullableFilter<"exerciseProgram"> | string | null
    difficultyLevel?: IntNullableFilter<"exerciseProgram"> | number | null
    adaptedForReducedMobility?: BoolNullableFilter<"exerciseProgram"> | boolean | null
    durationMinutes?: IntNullableFilter<"exerciseProgram"> | number | null
    description?: StringNullableFilter<"exerciseProgram"> | string | null
    videoLink?: StringNullableFilter<"exerciseProgram"> | string | null
    image?: StringNullableFilter<"exerciseProgram"> | string | null
    createdAt?: DateTimeFilter<"exerciseProgram"> | Date | string
    updatedAt?: DateTimeNullableFilter<"exerciseProgram"> | Date | string | null
    programCategory?: XOR<ProgramCategoryNullableScalarRelationFilter, programCategoryWhereInput> | null
    userActivity?: UserActivityListRelationFilter
  }, "id">

  export type exerciseProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    adaptedForReducedMobility?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    videoLink?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: exerciseProgramCountOrderByAggregateInput
    _avg?: exerciseProgramAvgOrderByAggregateInput
    _max?: exerciseProgramMaxOrderByAggregateInput
    _min?: exerciseProgramMinOrderByAggregateInput
    _sum?: exerciseProgramSumOrderByAggregateInput
  }

  export type exerciseProgramScalarWhereWithAggregatesInput = {
    AND?: exerciseProgramScalarWhereWithAggregatesInput | exerciseProgramScalarWhereWithAggregatesInput[]
    OR?: exerciseProgramScalarWhereWithAggregatesInput[]
    NOT?: exerciseProgramScalarWhereWithAggregatesInput | exerciseProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"exerciseProgram"> | string
    name?: StringWithAggregatesFilter<"exerciseProgram"> | string
    categoryId?: StringNullableWithAggregatesFilter<"exerciseProgram"> | string | null
    difficultyLevel?: IntNullableWithAggregatesFilter<"exerciseProgram"> | number | null
    adaptedForReducedMobility?: BoolNullableWithAggregatesFilter<"exerciseProgram"> | boolean | null
    durationMinutes?: IntNullableWithAggregatesFilter<"exerciseProgram"> | number | null
    description?: StringNullableWithAggregatesFilter<"exerciseProgram"> | string | null
    videoLink?: StringNullableWithAggregatesFilter<"exerciseProgram"> | string | null
    image?: StringNullableWithAggregatesFilter<"exerciseProgram"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"exerciseProgram"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"exerciseProgram"> | Date | string | null
  }

  export type forumCategoryWhereInput = {
    AND?: forumCategoryWhereInput | forumCategoryWhereInput[]
    OR?: forumCategoryWhereInput[]
    NOT?: forumCategoryWhereInput | forumCategoryWhereInput[]
    id?: StringFilter<"forumCategory"> | string
    name?: StringFilter<"forumCategory"> | string
    description?: StringNullableFilter<"forumCategory"> | string | null
    parentCategoryId?: StringNullableFilter<"forumCategory"> | string | null
    createdAt?: DateTimeFilter<"forumCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumCategory"> | Date | string | null
    forumTopic?: ForumTopicListRelationFilter
  }

  export type forumCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentCategoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    forumTopic?: forumTopicOrderByRelationAggregateInput
  }

  export type forumCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: forumCategoryWhereInput | forumCategoryWhereInput[]
    OR?: forumCategoryWhereInput[]
    NOT?: forumCategoryWhereInput | forumCategoryWhereInput[]
    name?: StringFilter<"forumCategory"> | string
    description?: StringNullableFilter<"forumCategory"> | string | null
    parentCategoryId?: StringNullableFilter<"forumCategory"> | string | null
    createdAt?: DateTimeFilter<"forumCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumCategory"> | Date | string | null
    forumTopic?: ForumTopicListRelationFilter
  }, "id">

  export type forumCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentCategoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: forumCategoryCountOrderByAggregateInput
    _max?: forumCategoryMaxOrderByAggregateInput
    _min?: forumCategoryMinOrderByAggregateInput
  }

  export type forumCategoryScalarWhereWithAggregatesInput = {
    AND?: forumCategoryScalarWhereWithAggregatesInput | forumCategoryScalarWhereWithAggregatesInput[]
    OR?: forumCategoryScalarWhereWithAggregatesInput[]
    NOT?: forumCategoryScalarWhereWithAggregatesInput | forumCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"forumCategory"> | string
    name?: StringWithAggregatesFilter<"forumCategory"> | string
    description?: StringNullableWithAggregatesFilter<"forumCategory"> | string | null
    parentCategoryId?: StringNullableWithAggregatesFilter<"forumCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"forumCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"forumCategory"> | Date | string | null
  }

  export type forumMessageWhereInput = {
    AND?: forumMessageWhereInput | forumMessageWhereInput[]
    OR?: forumMessageWhereInput[]
    NOT?: forumMessageWhereInput | forumMessageWhereInput[]
    id?: StringFilter<"forumMessage"> | string
    topicId?: StringFilter<"forumMessage"> | string
    authorId?: StringFilter<"forumMessage"> | string
    content?: StringFilter<"forumMessage"> | string
    solutionMessage?: BoolNullableFilter<"forumMessage"> | boolean | null
    createdAt?: DateTimeFilter<"forumMessage"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumMessage"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    forumTopic?: XOR<ForumTopicNullableScalarRelationFilter, forumTopicWhereInput> | null
  }

  export type forumMessageOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    solutionMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    forumTopic?: forumTopicOrderByWithRelationInput
  }

  export type forumMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: forumMessageWhereInput | forumMessageWhereInput[]
    OR?: forumMessageWhereInput[]
    NOT?: forumMessageWhereInput | forumMessageWhereInput[]
    topicId?: StringFilter<"forumMessage"> | string
    authorId?: StringFilter<"forumMessage"> | string
    content?: StringFilter<"forumMessage"> | string
    solutionMessage?: BoolNullableFilter<"forumMessage"> | boolean | null
    createdAt?: DateTimeFilter<"forumMessage"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumMessage"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    forumTopic?: XOR<ForumTopicNullableScalarRelationFilter, forumTopicWhereInput> | null
  }, "id">

  export type forumMessageOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    solutionMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: forumMessageCountOrderByAggregateInput
    _max?: forumMessageMaxOrderByAggregateInput
    _min?: forumMessageMinOrderByAggregateInput
  }

  export type forumMessageScalarWhereWithAggregatesInput = {
    AND?: forumMessageScalarWhereWithAggregatesInput | forumMessageScalarWhereWithAggregatesInput[]
    OR?: forumMessageScalarWhereWithAggregatesInput[]
    NOT?: forumMessageScalarWhereWithAggregatesInput | forumMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"forumMessage"> | string
    topicId?: StringWithAggregatesFilter<"forumMessage"> | string
    authorId?: StringWithAggregatesFilter<"forumMessage"> | string
    content?: StringWithAggregatesFilter<"forumMessage"> | string
    solutionMessage?: BoolNullableWithAggregatesFilter<"forumMessage"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"forumMessage"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"forumMessage"> | Date | string | null
  }

  export type forumTopicWhereInput = {
    AND?: forumTopicWhereInput | forumTopicWhereInput[]
    OR?: forumTopicWhereInput[]
    NOT?: forumTopicWhereInput | forumTopicWhereInput[]
    id?: StringFilter<"forumTopic"> | string
    categoryId?: StringFilter<"forumTopic"> | string
    authorId?: StringFilter<"forumTopic"> | string
    title?: StringFilter<"forumTopic"> | string
    pinned?: BoolNullableFilter<"forumTopic"> | boolean | null
    status?: StringNullableFilter<"forumTopic"> | string | null
    views?: IntNullableFilter<"forumTopic"> | number | null
    createdAt?: DateTimeFilter<"forumTopic"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumTopic"> | Date | string | null
    forumMessage?: ForumMessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    forumCategory?: XOR<ForumCategoryNullableScalarRelationFilter, forumCategoryWhereInput> | null
  }

  export type forumTopicOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    pinned?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    forumMessage?: forumMessageOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    forumCategory?: forumCategoryOrderByWithRelationInput
  }

  export type forumTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: forumTopicWhereInput | forumTopicWhereInput[]
    OR?: forumTopicWhereInput[]
    NOT?: forumTopicWhereInput | forumTopicWhereInput[]
    categoryId?: StringFilter<"forumTopic"> | string
    authorId?: StringFilter<"forumTopic"> | string
    title?: StringFilter<"forumTopic"> | string
    pinned?: BoolNullableFilter<"forumTopic"> | boolean | null
    status?: StringNullableFilter<"forumTopic"> | string | null
    views?: IntNullableFilter<"forumTopic"> | number | null
    createdAt?: DateTimeFilter<"forumTopic"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumTopic"> | Date | string | null
    forumMessage?: ForumMessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    forumCategory?: XOR<ForumCategoryNullableScalarRelationFilter, forumCategoryWhereInput> | null
  }, "id">

  export type forumTopicOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    pinned?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: forumTopicCountOrderByAggregateInput
    _avg?: forumTopicAvgOrderByAggregateInput
    _max?: forumTopicMaxOrderByAggregateInput
    _min?: forumTopicMinOrderByAggregateInput
    _sum?: forumTopicSumOrderByAggregateInput
  }

  export type forumTopicScalarWhereWithAggregatesInput = {
    AND?: forumTopicScalarWhereWithAggregatesInput | forumTopicScalarWhereWithAggregatesInput[]
    OR?: forumTopicScalarWhereWithAggregatesInput[]
    NOT?: forumTopicScalarWhereWithAggregatesInput | forumTopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"forumTopic"> | string
    categoryId?: StringWithAggregatesFilter<"forumTopic"> | string
    authorId?: StringWithAggregatesFilter<"forumTopic"> | string
    title?: StringWithAggregatesFilter<"forumTopic"> | string
    pinned?: BoolNullableWithAggregatesFilter<"forumTopic"> | boolean | null
    status?: StringNullableWithAggregatesFilter<"forumTopic"> | string | null
    views?: IntNullableWithAggregatesFilter<"forumTopic"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"forumTopic"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"forumTopic"> | Date | string | null
  }

  export type healthIndicatorWhereInput = {
    AND?: healthIndicatorWhereInput | healthIndicatorWhereInput[]
    OR?: healthIndicatorWhereInput[]
    NOT?: healthIndicatorWhereInput | healthIndicatorWhereInput[]
    id?: StringFilter<"healthIndicator"> | string
    userId?: StringFilter<"healthIndicator"> | string
    recordingDate?: DateTimeFilter<"healthIndicator"> | Date | string
    stepCount?: IntNullableFilter<"healthIndicator"> | number | null
    sleepDurationMinutes?: IntNullableFilter<"healthIndicator"> | number | null
    sleepQuality?: IntNullableFilter<"healthIndicator"> | number | null
    weight?: FloatNullableFilter<"healthIndicator"> | number | null
    mood?: StringNullableFilter<"healthIndicator"> | string | null
    notes?: StringNullableFilter<"healthIndicator"> | string | null
    createdAt?: DateTimeFilter<"healthIndicator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"healthIndicator"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type healthIndicatorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    recordingDate?: SortOrder
    stepCount?: SortOrderInput | SortOrder
    sleepDurationMinutes?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type healthIndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: healthIndicatorWhereInput | healthIndicatorWhereInput[]
    OR?: healthIndicatorWhereInput[]
    NOT?: healthIndicatorWhereInput | healthIndicatorWhereInput[]
    userId?: StringFilter<"healthIndicator"> | string
    recordingDate?: DateTimeFilter<"healthIndicator"> | Date | string
    stepCount?: IntNullableFilter<"healthIndicator"> | number | null
    sleepDurationMinutes?: IntNullableFilter<"healthIndicator"> | number | null
    sleepQuality?: IntNullableFilter<"healthIndicator"> | number | null
    weight?: FloatNullableFilter<"healthIndicator"> | number | null
    mood?: StringNullableFilter<"healthIndicator"> | string | null
    notes?: StringNullableFilter<"healthIndicator"> | string | null
    createdAt?: DateTimeFilter<"healthIndicator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"healthIndicator"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type healthIndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    recordingDate?: SortOrder
    stepCount?: SortOrderInput | SortOrder
    sleepDurationMinutes?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: healthIndicatorCountOrderByAggregateInput
    _avg?: healthIndicatorAvgOrderByAggregateInput
    _max?: healthIndicatorMaxOrderByAggregateInput
    _min?: healthIndicatorMinOrderByAggregateInput
    _sum?: healthIndicatorSumOrderByAggregateInput
  }

  export type healthIndicatorScalarWhereWithAggregatesInput = {
    AND?: healthIndicatorScalarWhereWithAggregatesInput | healthIndicatorScalarWhereWithAggregatesInput[]
    OR?: healthIndicatorScalarWhereWithAggregatesInput[]
    NOT?: healthIndicatorScalarWhereWithAggregatesInput | healthIndicatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"healthIndicator"> | string
    userId?: StringWithAggregatesFilter<"healthIndicator"> | string
    recordingDate?: DateTimeWithAggregatesFilter<"healthIndicator"> | Date | string
    stepCount?: IntNullableWithAggregatesFilter<"healthIndicator"> | number | null
    sleepDurationMinutes?: IntNullableWithAggregatesFilter<"healthIndicator"> | number | null
    sleepQuality?: IntNullableWithAggregatesFilter<"healthIndicator"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"healthIndicator"> | number | null
    mood?: StringNullableWithAggregatesFilter<"healthIndicator"> | string | null
    notes?: StringNullableWithAggregatesFilter<"healthIndicator"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"healthIndicator"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"healthIndicator"> | Date | string | null
  }

  export type helpOfferWhereInput = {
    AND?: helpOfferWhereInput | helpOfferWhereInput[]
    OR?: helpOfferWhereInput[]
    NOT?: helpOfferWhereInput | helpOfferWhereInput[]
    id?: StringFilter<"helpOffer"> | string
    requestId?: StringFilter<"helpOffer"> | string
    helperId?: StringFilter<"helpOffer"> | string
    offerDate?: DateTimeFilter<"helpOffer"> | Date | string
    message?: StringNullableFilter<"helpOffer"> | string | null
    status?: StringNullableFilter<"helpOffer"> | string | null
    createdAt?: DateTimeFilter<"helpOffer"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpOffer"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    helpRequest?: XOR<HelpRequestScalarRelationFilter, helpRequestWhereInput>
  }

  export type helpOfferOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    offerDate?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    helpRequest?: helpRequestOrderByWithRelationInput
  }

  export type helpOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: helpOfferWhereInput | helpOfferWhereInput[]
    OR?: helpOfferWhereInput[]
    NOT?: helpOfferWhereInput | helpOfferWhereInput[]
    requestId?: StringFilter<"helpOffer"> | string
    helperId?: StringFilter<"helpOffer"> | string
    offerDate?: DateTimeFilter<"helpOffer"> | Date | string
    message?: StringNullableFilter<"helpOffer"> | string | null
    status?: StringNullableFilter<"helpOffer"> | string | null
    createdAt?: DateTimeFilter<"helpOffer"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpOffer"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    helpRequest?: XOR<HelpRequestScalarRelationFilter, helpRequestWhereInput>
  }, "id">

  export type helpOfferOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    offerDate?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: helpOfferCountOrderByAggregateInput
    _max?: helpOfferMaxOrderByAggregateInput
    _min?: helpOfferMinOrderByAggregateInput
  }

  export type helpOfferScalarWhereWithAggregatesInput = {
    AND?: helpOfferScalarWhereWithAggregatesInput | helpOfferScalarWhereWithAggregatesInput[]
    OR?: helpOfferScalarWhereWithAggregatesInput[]
    NOT?: helpOfferScalarWhereWithAggregatesInput | helpOfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"helpOffer"> | string
    requestId?: StringWithAggregatesFilter<"helpOffer"> | string
    helperId?: StringWithAggregatesFilter<"helpOffer"> | string
    offerDate?: DateTimeWithAggregatesFilter<"helpOffer"> | Date | string
    message?: StringNullableWithAggregatesFilter<"helpOffer"> | string | null
    status?: StringNullableWithAggregatesFilter<"helpOffer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"helpOffer"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"helpOffer"> | Date | string | null
  }

  export type helpRequestWhereInput = {
    AND?: helpRequestWhereInput | helpRequestWhereInput[]
    OR?: helpRequestWhereInput[]
    NOT?: helpRequestWhereInput | helpRequestWhereInput[]
    id?: StringFilter<"helpRequest"> | string
    creatorId?: StringFilter<"helpRequest"> | string
    title?: StringFilter<"helpRequest"> | string
    description?: StringNullableFilter<"helpRequest"> | string | null
    neededDate?: DateTimeFilter<"helpRequest"> | Date | string
    estimatedDuration?: IntNullableFilter<"helpRequest"> | number | null
    location?: StringNullableFilter<"helpRequest"> | string | null
    gpsCoordinates?: StringNullableFilter<"helpRequest"> | string | null
    categoryId?: StringFilter<"helpRequest"> | string
    recurring?: BoolNullableFilter<"helpRequest"> | boolean | null
    frequency?: StringNullableFilter<"helpRequest"> | string | null
    status?: StringNullableFilter<"helpRequest"> | string | null
    pointsOffered?: IntNullableFilter<"helpRequest"> | number | null
    createdAt?: DateTimeFilter<"helpRequest"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpRequest"> | Date | string | null
    helpOffer?: HelpOfferListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    serviceCompleted?: ServiceCompletedListRelationFilter
    helpCategory?: XOR<HelpCategoryNullableScalarRelationFilter, helpCategoryWhereInput> | null
  }

  export type helpRequestOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    neededDate?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    recurring?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    pointsOffered?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    helpOffer?: helpOfferOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    serviceCompleted?: serviceCompletedOrderByRelationAggregateInput
    helpCategory?: helpCategoryOrderByWithRelationInput
  }

  export type helpRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: helpRequestWhereInput | helpRequestWhereInput[]
    OR?: helpRequestWhereInput[]
    NOT?: helpRequestWhereInput | helpRequestWhereInput[]
    creatorId?: StringFilter<"helpRequest"> | string
    title?: StringFilter<"helpRequest"> | string
    description?: StringNullableFilter<"helpRequest"> | string | null
    neededDate?: DateTimeFilter<"helpRequest"> | Date | string
    estimatedDuration?: IntNullableFilter<"helpRequest"> | number | null
    location?: StringNullableFilter<"helpRequest"> | string | null
    gpsCoordinates?: StringNullableFilter<"helpRequest"> | string | null
    categoryId?: StringFilter<"helpRequest"> | string
    recurring?: BoolNullableFilter<"helpRequest"> | boolean | null
    frequency?: StringNullableFilter<"helpRequest"> | string | null
    status?: StringNullableFilter<"helpRequest"> | string | null
    pointsOffered?: IntNullableFilter<"helpRequest"> | number | null
    createdAt?: DateTimeFilter<"helpRequest"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpRequest"> | Date | string | null
    helpOffer?: HelpOfferListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    serviceCompleted?: ServiceCompletedListRelationFilter
    helpCategory?: XOR<HelpCategoryNullableScalarRelationFilter, helpCategoryWhereInput> | null
  }, "id">

  export type helpRequestOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    neededDate?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    recurring?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    pointsOffered?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: helpRequestCountOrderByAggregateInput
    _avg?: helpRequestAvgOrderByAggregateInput
    _max?: helpRequestMaxOrderByAggregateInput
    _min?: helpRequestMinOrderByAggregateInput
    _sum?: helpRequestSumOrderByAggregateInput
  }

  export type helpRequestScalarWhereWithAggregatesInput = {
    AND?: helpRequestScalarWhereWithAggregatesInput | helpRequestScalarWhereWithAggregatesInput[]
    OR?: helpRequestScalarWhereWithAggregatesInput[]
    NOT?: helpRequestScalarWhereWithAggregatesInput | helpRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"helpRequest"> | string
    creatorId?: StringWithAggregatesFilter<"helpRequest"> | string
    title?: StringWithAggregatesFilter<"helpRequest"> | string
    description?: StringNullableWithAggregatesFilter<"helpRequest"> | string | null
    neededDate?: DateTimeWithAggregatesFilter<"helpRequest"> | Date | string
    estimatedDuration?: IntNullableWithAggregatesFilter<"helpRequest"> | number | null
    location?: StringNullableWithAggregatesFilter<"helpRequest"> | string | null
    gpsCoordinates?: StringNullableWithAggregatesFilter<"helpRequest"> | string | null
    categoryId?: StringWithAggregatesFilter<"helpRequest"> | string
    recurring?: BoolNullableWithAggregatesFilter<"helpRequest"> | boolean | null
    frequency?: StringNullableWithAggregatesFilter<"helpRequest"> | string | null
    status?: StringNullableWithAggregatesFilter<"helpRequest"> | string | null
    pointsOffered?: IntNullableWithAggregatesFilter<"helpRequest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"helpRequest"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"helpRequest"> | Date | string | null
  }

  export type localServiceWhereInput = {
    AND?: localServiceWhereInput | localServiceWhereInput[]
    OR?: localServiceWhereInput[]
    NOT?: localServiceWhereInput | localServiceWhereInput[]
    id?: StringFilter<"localService"> | string
    name?: StringFilter<"localService"> | string
    categoryId?: StringFilter<"localService"> | string
    address?: StringNullableFilter<"localService"> | string | null
    gpsCoordinates?: StringNullableFilter<"localService"> | string | null
    phone?: StringNullableFilter<"localService"> | string | null
    website?: StringNullableFilter<"localService"> | string | null
    description?: StringNullableFilter<"localService"> | string | null
    hours?: StringNullableFilter<"localService"> | string | null
    seniorFriendly?: BoolNullableFilter<"localService"> | boolean | null
    createdAt?: DateTimeFilter<"localService"> | Date | string
    updatedAt?: DateTimeNullableFilter<"localService"> | Date | string | null
    serviceCategory?: XOR<ServiceCategoryNullableScalarRelationFilter, serviceCategoryWhereInput> | null
    serviceRating?: ServiceRatingListRelationFilter
  }

  export type localServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    address?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    seniorFriendly?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    serviceCategory?: serviceCategoryOrderByWithRelationInput
    serviceRating?: serviceRatingOrderByRelationAggregateInput
  }

  export type localServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: localServiceWhereInput | localServiceWhereInput[]
    OR?: localServiceWhereInput[]
    NOT?: localServiceWhereInput | localServiceWhereInput[]
    name?: StringFilter<"localService"> | string
    categoryId?: StringFilter<"localService"> | string
    address?: StringNullableFilter<"localService"> | string | null
    gpsCoordinates?: StringNullableFilter<"localService"> | string | null
    phone?: StringNullableFilter<"localService"> | string | null
    website?: StringNullableFilter<"localService"> | string | null
    description?: StringNullableFilter<"localService"> | string | null
    hours?: StringNullableFilter<"localService"> | string | null
    seniorFriendly?: BoolNullableFilter<"localService"> | boolean | null
    createdAt?: DateTimeFilter<"localService"> | Date | string
    updatedAt?: DateTimeNullableFilter<"localService"> | Date | string | null
    serviceCategory?: XOR<ServiceCategoryNullableScalarRelationFilter, serviceCategoryWhereInput> | null
    serviceRating?: ServiceRatingListRelationFilter
  }, "id">

  export type localServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    address?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    seniorFriendly?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: localServiceCountOrderByAggregateInput
    _max?: localServiceMaxOrderByAggregateInput
    _min?: localServiceMinOrderByAggregateInput
  }

  export type localServiceScalarWhereWithAggregatesInput = {
    AND?: localServiceScalarWhereWithAggregatesInput | localServiceScalarWhereWithAggregatesInput[]
    OR?: localServiceScalarWhereWithAggregatesInput[]
    NOT?: localServiceScalarWhereWithAggregatesInput | localServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"localService"> | string
    name?: StringWithAggregatesFilter<"localService"> | string
    categoryId?: StringWithAggregatesFilter<"localService"> | string
    address?: StringNullableWithAggregatesFilter<"localService"> | string | null
    gpsCoordinates?: StringNullableWithAggregatesFilter<"localService"> | string | null
    phone?: StringNullableWithAggregatesFilter<"localService"> | string | null
    website?: StringNullableWithAggregatesFilter<"localService"> | string | null
    description?: StringNullableWithAggregatesFilter<"localService"> | string | null
    hours?: StringNullableWithAggregatesFilter<"localService"> | string | null
    seniorFriendly?: BoolNullableWithAggregatesFilter<"localService"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"localService"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"localService"> | Date | string | null
  }

  export type medicationReminderWhereInput = {
    AND?: medicationReminderWhereInput | medicationReminderWhereInput[]
    OR?: medicationReminderWhereInput[]
    NOT?: medicationReminderWhereInput | medicationReminderWhereInput[]
    id?: StringFilter<"medicationReminder"> | string
    userId?: StringFilter<"medicationReminder"> | string
    medicationName?: StringFilter<"medicationReminder"> | string
    dosage?: StringNullableFilter<"medicationReminder"> | string | null
    morningReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    noonReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    eveningReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    nightReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    daysOfWeek?: StringNullableFilter<"medicationReminder"> | string | null
    instructions?: StringNullableFilter<"medicationReminder"> | string | null
    active?: BoolNullableFilter<"medicationReminder"> | boolean | null
    startDate?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    endDate?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    createdAt?: DateTimeFilter<"medicationReminder"> | Date | string
    updatedAt?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type medicationReminderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrderInput | SortOrder
    morningReminderTime?: SortOrderInput | SortOrder
    noonReminderTime?: SortOrderInput | SortOrder
    eveningReminderTime?: SortOrderInput | SortOrder
    nightReminderTime?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type medicationReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: medicationReminderWhereInput | medicationReminderWhereInput[]
    OR?: medicationReminderWhereInput[]
    NOT?: medicationReminderWhereInput | medicationReminderWhereInput[]
    userId?: StringFilter<"medicationReminder"> | string
    medicationName?: StringFilter<"medicationReminder"> | string
    dosage?: StringNullableFilter<"medicationReminder"> | string | null
    morningReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    noonReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    eveningReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    nightReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    daysOfWeek?: StringNullableFilter<"medicationReminder"> | string | null
    instructions?: StringNullableFilter<"medicationReminder"> | string | null
    active?: BoolNullableFilter<"medicationReminder"> | boolean | null
    startDate?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    endDate?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    createdAt?: DateTimeFilter<"medicationReminder"> | Date | string
    updatedAt?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type medicationReminderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrderInput | SortOrder
    morningReminderTime?: SortOrderInput | SortOrder
    noonReminderTime?: SortOrderInput | SortOrder
    eveningReminderTime?: SortOrderInput | SortOrder
    nightReminderTime?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: medicationReminderCountOrderByAggregateInput
    _max?: medicationReminderMaxOrderByAggregateInput
    _min?: medicationReminderMinOrderByAggregateInput
  }

  export type medicationReminderScalarWhereWithAggregatesInput = {
    AND?: medicationReminderScalarWhereWithAggregatesInput | medicationReminderScalarWhereWithAggregatesInput[]
    OR?: medicationReminderScalarWhereWithAggregatesInput[]
    NOT?: medicationReminderScalarWhereWithAggregatesInput | medicationReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"medicationReminder"> | string
    userId?: StringWithAggregatesFilter<"medicationReminder"> | string
    medicationName?: StringWithAggregatesFilter<"medicationReminder"> | string
    dosage?: StringNullableWithAggregatesFilter<"medicationReminder"> | string | null
    morningReminderTime?: DateTimeNullableWithAggregatesFilter<"medicationReminder"> | Date | string | null
    noonReminderTime?: DateTimeNullableWithAggregatesFilter<"medicationReminder"> | Date | string | null
    eveningReminderTime?: DateTimeNullableWithAggregatesFilter<"medicationReminder"> | Date | string | null
    nightReminderTime?: DateTimeNullableWithAggregatesFilter<"medicationReminder"> | Date | string | null
    daysOfWeek?: StringNullableWithAggregatesFilter<"medicationReminder"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"medicationReminder"> | string | null
    active?: BoolNullableWithAggregatesFilter<"medicationReminder"> | boolean | null
    startDate?: DateTimeNullableWithAggregatesFilter<"medicationReminder"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"medicationReminder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"medicationReminder"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"medicationReminder"> | Date | string | null
  }

  export type messageWhereInput = {
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    id?: StringFilter<"message"> | string
    conversationId?: StringFilter<"message"> | string
    senderId?: StringFilter<"message"> | string
    content?: StringFilter<"message"> | string
    sendDate?: DateTimeFilter<"message"> | Date | string
    type?: StringNullableFilter<"message"> | string | null
    read?: BoolNullableFilter<"message"> | boolean | null
    createdAt?: DateTimeFilter<"message"> | Date | string
    updatedAt?: DateTimeNullableFilter<"message"> | Date | string | null
    conversation?: XOR<ConversationNullableScalarRelationFilter, conversationWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type messageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    sendDate?: SortOrder
    type?: SortOrderInput | SortOrder
    read?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    conversation?: conversationOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type messageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    conversationId?: StringFilter<"message"> | string
    senderId?: StringFilter<"message"> | string
    content?: StringFilter<"message"> | string
    sendDate?: DateTimeFilter<"message"> | Date | string
    type?: StringNullableFilter<"message"> | string | null
    read?: BoolNullableFilter<"message"> | boolean | null
    createdAt?: DateTimeFilter<"message"> | Date | string
    updatedAt?: DateTimeNullableFilter<"message"> | Date | string | null
    conversation?: XOR<ConversationNullableScalarRelationFilter, conversationWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type messageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    sendDate?: SortOrder
    type?: SortOrderInput | SortOrder
    read?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: messageCountOrderByAggregateInput
    _max?: messageMaxOrderByAggregateInput
    _min?: messageMinOrderByAggregateInput
  }

  export type messageScalarWhereWithAggregatesInput = {
    AND?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    OR?: messageScalarWhereWithAggregatesInput[]
    NOT?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"message"> | string
    conversationId?: StringWithAggregatesFilter<"message"> | string
    senderId?: StringWithAggregatesFilter<"message"> | string
    content?: StringWithAggregatesFilter<"message"> | string
    sendDate?: DateTimeWithAggregatesFilter<"message"> | Date | string
    type?: StringNullableWithAggregatesFilter<"message"> | string | null
    read?: BoolNullableWithAggregatesFilter<"message"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"message"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"message"> | Date | string | null
  }

  export type municipalEventWhereInput = {
    AND?: municipalEventWhereInput | municipalEventWhereInput[]
    OR?: municipalEventWhereInput[]
    NOT?: municipalEventWhereInput | municipalEventWhereInput[]
    id?: StringFilter<"municipalEvent"> | string
    title?: StringFilter<"municipalEvent"> | string
    description?: StringNullableFilter<"municipalEvent"> | string | null
    startDate?: DateTimeFilter<"municipalEvent"> | Date | string
    endDate?: DateTimeFilter<"municipalEvent"> | Date | string
    location?: StringFilter<"municipalEvent"> | string
    gpsCoordinates?: StringNullableFilter<"municipalEvent"> | string | null
    organizer?: StringNullableFilter<"municipalEvent"> | string | null
    contact?: StringNullableFilter<"municipalEvent"> | string | null
    officialLink?: StringNullableFilter<"municipalEvent"> | string | null
    createdAt?: DateTimeFilter<"municipalEvent"> | Date | string
    updatedAt?: DateTimeNullableFilter<"municipalEvent"> | Date | string | null
  }

  export type municipalEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    organizer?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    officialLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type municipalEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: municipalEventWhereInput | municipalEventWhereInput[]
    OR?: municipalEventWhereInput[]
    NOT?: municipalEventWhereInput | municipalEventWhereInput[]
    title?: StringFilter<"municipalEvent"> | string
    description?: StringNullableFilter<"municipalEvent"> | string | null
    startDate?: DateTimeFilter<"municipalEvent"> | Date | string
    endDate?: DateTimeFilter<"municipalEvent"> | Date | string
    location?: StringFilter<"municipalEvent"> | string
    gpsCoordinates?: StringNullableFilter<"municipalEvent"> | string | null
    organizer?: StringNullableFilter<"municipalEvent"> | string | null
    contact?: StringNullableFilter<"municipalEvent"> | string | null
    officialLink?: StringNullableFilter<"municipalEvent"> | string | null
    createdAt?: DateTimeFilter<"municipalEvent"> | Date | string
    updatedAt?: DateTimeNullableFilter<"municipalEvent"> | Date | string | null
  }, "id">

  export type municipalEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    organizer?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    officialLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: municipalEventCountOrderByAggregateInput
    _max?: municipalEventMaxOrderByAggregateInput
    _min?: municipalEventMinOrderByAggregateInput
  }

  export type municipalEventScalarWhereWithAggregatesInput = {
    AND?: municipalEventScalarWhereWithAggregatesInput | municipalEventScalarWhereWithAggregatesInput[]
    OR?: municipalEventScalarWhereWithAggregatesInput[]
    NOT?: municipalEventScalarWhereWithAggregatesInput | municipalEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"municipalEvent"> | string
    title?: StringWithAggregatesFilter<"municipalEvent"> | string
    description?: StringNullableWithAggregatesFilter<"municipalEvent"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"municipalEvent"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"municipalEvent"> | Date | string
    location?: StringWithAggregatesFilter<"municipalEvent"> | string
    gpsCoordinates?: StringNullableWithAggregatesFilter<"municipalEvent"> | string | null
    organizer?: StringNullableWithAggregatesFilter<"municipalEvent"> | string | null
    contact?: StringNullableWithAggregatesFilter<"municipalEvent"> | string | null
    officialLink?: StringNullableWithAggregatesFilter<"municipalEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"municipalEvent"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"municipalEvent"> | Date | string | null
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: StringFilter<"notification"> | string
    userId?: StringFilter<"notification"> | string
    type?: StringFilter<"notification"> | string
    content?: StringFilter<"notification"> | string
    read?: BoolNullableFilter<"notification"> | boolean | null
    actionLink?: StringNullableFilter<"notification"> | string | null
    createdAt?: DateTimeFilter<"notification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrderInput | SortOrder
    actionLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    userId?: StringFilter<"notification"> | string
    type?: StringFilter<"notification"> | string
    content?: StringFilter<"notification"> | string
    read?: BoolNullableFilter<"notification"> | boolean | null
    actionLink?: StringNullableFilter<"notification"> | string | null
    createdAt?: DateTimeFilter<"notification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrderInput | SortOrder
    actionLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: notificationCountOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification"> | string
    userId?: StringWithAggregatesFilter<"notification"> | string
    type?: StringWithAggregatesFilter<"notification"> | string
    content?: StringWithAggregatesFilter<"notification"> | string
    read?: BoolNullableWithAggregatesFilter<"notification"> | boolean | null
    actionLink?: StringNullableWithAggregatesFilter<"notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notification"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
  }

  export type notificationPreferencesWhereInput = {
    AND?: notificationPreferencesWhereInput | notificationPreferencesWhereInput[]
    OR?: notificationPreferencesWhereInput[]
    NOT?: notificationPreferencesWhereInput | notificationPreferencesWhereInput[]
    userId?: StringFilter<"notificationPreferences"> | string
    messageNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    activityNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    helpNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    forumNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    emailNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    smsNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    pushNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    quietHoursStart?: DateTimeNullableFilter<"notificationPreferences"> | Date | string | null
    quietHoursEnd?: DateTimeNullableFilter<"notificationPreferences"> | Date | string | null
    createdAt?: DateTimeFilter<"notificationPreferences"> | Date | string
    updatedAt?: DateTimeNullableFilter<"notificationPreferences"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type notificationPreferencesOrderByWithRelationInput = {
    userId?: SortOrder
    messageNotification?: SortOrderInput | SortOrder
    activityNotification?: SortOrderInput | SortOrder
    helpNotification?: SortOrderInput | SortOrder
    forumNotification?: SortOrderInput | SortOrder
    emailNotification?: SortOrderInput | SortOrder
    smsNotification?: SortOrderInput | SortOrder
    pushNotification?: SortOrderInput | SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type notificationPreferencesWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: notificationPreferencesWhereInput | notificationPreferencesWhereInput[]
    OR?: notificationPreferencesWhereInput[]
    NOT?: notificationPreferencesWhereInput | notificationPreferencesWhereInput[]
    messageNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    activityNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    helpNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    forumNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    emailNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    smsNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    pushNotification?: BoolNullableFilter<"notificationPreferences"> | boolean | null
    quietHoursStart?: DateTimeNullableFilter<"notificationPreferences"> | Date | string | null
    quietHoursEnd?: DateTimeNullableFilter<"notificationPreferences"> | Date | string | null
    createdAt?: DateTimeFilter<"notificationPreferences"> | Date | string
    updatedAt?: DateTimeNullableFilter<"notificationPreferences"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "userId">

  export type notificationPreferencesOrderByWithAggregationInput = {
    userId?: SortOrder
    messageNotification?: SortOrderInput | SortOrder
    activityNotification?: SortOrderInput | SortOrder
    helpNotification?: SortOrderInput | SortOrder
    forumNotification?: SortOrderInput | SortOrder
    emailNotification?: SortOrderInput | SortOrder
    smsNotification?: SortOrderInput | SortOrder
    pushNotification?: SortOrderInput | SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: notificationPreferencesCountOrderByAggregateInput
    _max?: notificationPreferencesMaxOrderByAggregateInput
    _min?: notificationPreferencesMinOrderByAggregateInput
  }

  export type notificationPreferencesScalarWhereWithAggregatesInput = {
    AND?: notificationPreferencesScalarWhereWithAggregatesInput | notificationPreferencesScalarWhereWithAggregatesInput[]
    OR?: notificationPreferencesScalarWhereWithAggregatesInput[]
    NOT?: notificationPreferencesScalarWhereWithAggregatesInput | notificationPreferencesScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"notificationPreferences"> | string
    messageNotification?: BoolNullableWithAggregatesFilter<"notificationPreferences"> | boolean | null
    activityNotification?: BoolNullableWithAggregatesFilter<"notificationPreferences"> | boolean | null
    helpNotification?: BoolNullableWithAggregatesFilter<"notificationPreferences"> | boolean | null
    forumNotification?: BoolNullableWithAggregatesFilter<"notificationPreferences"> | boolean | null
    emailNotification?: BoolNullableWithAggregatesFilter<"notificationPreferences"> | boolean | null
    smsNotification?: BoolNullableWithAggregatesFilter<"notificationPreferences"> | boolean | null
    pushNotification?: BoolNullableWithAggregatesFilter<"notificationPreferences"> | boolean | null
    quietHoursStart?: DateTimeNullableWithAggregatesFilter<"notificationPreferences"> | Date | string | null
    quietHoursEnd?: DateTimeNullableWithAggregatesFilter<"notificationPreferences"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notificationPreferences"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"notificationPreferences"> | Date | string | null
  }

  export type nutritionalAdviceWhereInput = {
    AND?: nutritionalAdviceWhereInput | nutritionalAdviceWhereInput[]
    OR?: nutritionalAdviceWhereInput[]
    NOT?: nutritionalAdviceWhereInput | nutritionalAdviceWhereInput[]
    id?: StringFilter<"nutritionalAdvice"> | string
    title?: StringFilter<"nutritionalAdvice"> | string
    description?: StringNullableFilter<"nutritionalAdvice"> | string | null
    categoryId?: StringFilter<"nutritionalAdvice"> | string
    season?: StringNullableFilter<"nutritionalAdvice"> | string | null
    image?: StringNullableFilter<"nutritionalAdvice"> | string | null
    createdAt?: DateTimeFilter<"nutritionalAdvice"> | Date | string
    updatedAt?: DateTimeNullableFilter<"nutritionalAdvice"> | Date | string | null
    nutritionalCategory?: XOR<NutritionalCategoryNullableScalarRelationFilter, nutritionalCategoryWhereInput> | null
  }

  export type nutritionalAdviceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    season?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    nutritionalCategory?: nutritionalCategoryOrderByWithRelationInput
  }

  export type nutritionalAdviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: nutritionalAdviceWhereInput | nutritionalAdviceWhereInput[]
    OR?: nutritionalAdviceWhereInput[]
    NOT?: nutritionalAdviceWhereInput | nutritionalAdviceWhereInput[]
    title?: StringFilter<"nutritionalAdvice"> | string
    description?: StringNullableFilter<"nutritionalAdvice"> | string | null
    categoryId?: StringFilter<"nutritionalAdvice"> | string
    season?: StringNullableFilter<"nutritionalAdvice"> | string | null
    image?: StringNullableFilter<"nutritionalAdvice"> | string | null
    createdAt?: DateTimeFilter<"nutritionalAdvice"> | Date | string
    updatedAt?: DateTimeNullableFilter<"nutritionalAdvice"> | Date | string | null
    nutritionalCategory?: XOR<NutritionalCategoryNullableScalarRelationFilter, nutritionalCategoryWhereInput> | null
  }, "id">

  export type nutritionalAdviceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    season?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: nutritionalAdviceCountOrderByAggregateInput
    _max?: nutritionalAdviceMaxOrderByAggregateInput
    _min?: nutritionalAdviceMinOrderByAggregateInput
  }

  export type nutritionalAdviceScalarWhereWithAggregatesInput = {
    AND?: nutritionalAdviceScalarWhereWithAggregatesInput | nutritionalAdviceScalarWhereWithAggregatesInput[]
    OR?: nutritionalAdviceScalarWhereWithAggregatesInput[]
    NOT?: nutritionalAdviceScalarWhereWithAggregatesInput | nutritionalAdviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"nutritionalAdvice"> | string
    title?: StringWithAggregatesFilter<"nutritionalAdvice"> | string
    description?: StringNullableWithAggregatesFilter<"nutritionalAdvice"> | string | null
    categoryId?: StringWithAggregatesFilter<"nutritionalAdvice"> | string
    season?: StringNullableWithAggregatesFilter<"nutritionalAdvice"> | string | null
    image?: StringNullableWithAggregatesFilter<"nutritionalAdvice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"nutritionalAdvice"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"nutritionalAdvice"> | Date | string | null
  }

  export type projectMemberWhereInput = {
    AND?: projectMemberWhereInput | projectMemberWhereInput[]
    OR?: projectMemberWhereInput[]
    NOT?: projectMemberWhereInput | projectMemberWhereInput[]
    projectId?: StringFilter<"projectMember"> | string
    userId?: StringFilter<"projectMember"> | string
    role?: StringFilter<"projectMember"> | string
    joinDate?: DateTimeFilter<"projectMember"> | Date | string
    createdAt?: DateTimeFilter<"projectMember"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectMember"> | Date | string | null
    collaborativeProject?: XOR<CollaborativeProjectScalarRelationFilter, collaborativeProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type projectMemberOrderByWithRelationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    collaborativeProject?: collaborativeProjectOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type projectMemberWhereUniqueInput = Prisma.AtLeast<{
    projectId_userId?: projectMemberProjectIdUserIdCompoundUniqueInput
    AND?: projectMemberWhereInput | projectMemberWhereInput[]
    OR?: projectMemberWhereInput[]
    NOT?: projectMemberWhereInput | projectMemberWhereInput[]
    projectId?: StringFilter<"projectMember"> | string
    userId?: StringFilter<"projectMember"> | string
    role?: StringFilter<"projectMember"> | string
    joinDate?: DateTimeFilter<"projectMember"> | Date | string
    createdAt?: DateTimeFilter<"projectMember"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectMember"> | Date | string | null
    collaborativeProject?: XOR<CollaborativeProjectScalarRelationFilter, collaborativeProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "projectId_userId">

  export type projectMemberOrderByWithAggregationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: projectMemberCountOrderByAggregateInput
    _max?: projectMemberMaxOrderByAggregateInput
    _min?: projectMemberMinOrderByAggregateInput
  }

  export type projectMemberScalarWhereWithAggregatesInput = {
    AND?: projectMemberScalarWhereWithAggregatesInput | projectMemberScalarWhereWithAggregatesInput[]
    OR?: projectMemberScalarWhereWithAggregatesInput[]
    NOT?: projectMemberScalarWhereWithAggregatesInput | projectMemberScalarWhereWithAggregatesInput[]
    projectId?: StringWithAggregatesFilter<"projectMember"> | string
    userId?: StringWithAggregatesFilter<"projectMember"> | string
    role?: StringWithAggregatesFilter<"projectMember"> | string
    joinDate?: DateTimeWithAggregatesFilter<"projectMember"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"projectMember"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"projectMember"> | Date | string | null
  }

  export type projectTaskWhereInput = {
    AND?: projectTaskWhereInput | projectTaskWhereInput[]
    OR?: projectTaskWhereInput[]
    NOT?: projectTaskWhereInput | projectTaskWhereInput[]
    id?: StringFilter<"projectTask"> | string
    projectId?: StringFilter<"projectTask"> | string
    title?: StringFilter<"projectTask"> | string
    description?: StringNullableFilter<"projectTask"> | string | null
    creationDate?: DateTimeFilter<"projectTask"> | Date | string
    dueDate?: DateTimeNullableFilter<"projectTask"> | Date | string | null
    status?: StringNullableFilter<"projectTask"> | string | null
    assigneeId?: StringNullableFilter<"projectTask"> | string | null
    createdAt?: DateTimeFilter<"projectTask"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectTask"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    collaborativeProject?: XOR<CollaborativeProjectNullableScalarRelationFilter, collaborativeProjectWhereInput> | null
  }

  export type projectTaskOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creationDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    collaborativeProject?: collaborativeProjectOrderByWithRelationInput
  }

  export type projectTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: projectTaskWhereInput | projectTaskWhereInput[]
    OR?: projectTaskWhereInput[]
    NOT?: projectTaskWhereInput | projectTaskWhereInput[]
    projectId?: StringFilter<"projectTask"> | string
    title?: StringFilter<"projectTask"> | string
    description?: StringNullableFilter<"projectTask"> | string | null
    creationDate?: DateTimeFilter<"projectTask"> | Date | string
    dueDate?: DateTimeNullableFilter<"projectTask"> | Date | string | null
    status?: StringNullableFilter<"projectTask"> | string | null
    assigneeId?: StringNullableFilter<"projectTask"> | string | null
    createdAt?: DateTimeFilter<"projectTask"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectTask"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    collaborativeProject?: XOR<CollaborativeProjectNullableScalarRelationFilter, collaborativeProjectWhereInput> | null
  }, "id">

  export type projectTaskOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creationDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: projectTaskCountOrderByAggregateInput
    _max?: projectTaskMaxOrderByAggregateInput
    _min?: projectTaskMinOrderByAggregateInput
  }

  export type projectTaskScalarWhereWithAggregatesInput = {
    AND?: projectTaskScalarWhereWithAggregatesInput | projectTaskScalarWhereWithAggregatesInput[]
    OR?: projectTaskScalarWhereWithAggregatesInput[]
    NOT?: projectTaskScalarWhereWithAggregatesInput | projectTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"projectTask"> | string
    projectId?: StringWithAggregatesFilter<"projectTask"> | string
    title?: StringWithAggregatesFilter<"projectTask"> | string
    description?: StringNullableWithAggregatesFilter<"projectTask"> | string | null
    creationDate?: DateTimeWithAggregatesFilter<"projectTask"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"projectTask"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"projectTask"> | string | null
    assigneeId?: StringNullableWithAggregatesFilter<"projectTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"projectTask"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"projectTask"> | Date | string | null
  }

  export type resourceWhereInput = {
    AND?: resourceWhereInput | resourceWhereInput[]
    OR?: resourceWhereInput[]
    NOT?: resourceWhereInput | resourceWhereInput[]
    id?: StringFilter<"resource"> | string
    title?: StringFilter<"resource"> | string
    content?: StringNullableFilter<"resource"> | string | null
    type?: StringFilter<"resource"> | string
    categoryId?: StringNullableFilter<"resource"> | string | null
    authorId?: StringFilter<"resource"> | string
    adminValidated?: BoolNullableFilter<"resource"> | boolean | null
    createdAt?: DateTimeFilter<"resource"> | Date | string
    updatedAt?: DateTimeNullableFilter<"resource"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    resourceCategory?: XOR<ResourceCategoryNullableScalarRelationFilter, resourceCategoryWhereInput> | null
  }

  export type resourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    adminValidated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    resourceCategory?: resourceCategoryOrderByWithRelationInput
  }

  export type resourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: resourceWhereInput | resourceWhereInput[]
    OR?: resourceWhereInput[]
    NOT?: resourceWhereInput | resourceWhereInput[]
    title?: StringFilter<"resource"> | string
    content?: StringNullableFilter<"resource"> | string | null
    type?: StringFilter<"resource"> | string
    categoryId?: StringNullableFilter<"resource"> | string | null
    authorId?: StringFilter<"resource"> | string
    adminValidated?: BoolNullableFilter<"resource"> | boolean | null
    createdAt?: DateTimeFilter<"resource"> | Date | string
    updatedAt?: DateTimeNullableFilter<"resource"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    resourceCategory?: XOR<ResourceCategoryNullableScalarRelationFilter, resourceCategoryWhereInput> | null
  }, "id">

  export type resourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    adminValidated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: resourceCountOrderByAggregateInput
    _max?: resourceMaxOrderByAggregateInput
    _min?: resourceMinOrderByAggregateInput
  }

  export type resourceScalarWhereWithAggregatesInput = {
    AND?: resourceScalarWhereWithAggregatesInput | resourceScalarWhereWithAggregatesInput[]
    OR?: resourceScalarWhereWithAggregatesInput[]
    NOT?: resourceScalarWhereWithAggregatesInput | resourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"resource"> | string
    title?: StringWithAggregatesFilter<"resource"> | string
    content?: StringNullableWithAggregatesFilter<"resource"> | string | null
    type?: StringWithAggregatesFilter<"resource"> | string
    categoryId?: StringNullableWithAggregatesFilter<"resource"> | string | null
    authorId?: StringWithAggregatesFilter<"resource"> | string
    adminValidated?: BoolNullableWithAggregatesFilter<"resource"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"resource"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"resource"> | Date | string | null
  }

  export type satisfactionSurveyWhereInput = {
    AND?: satisfactionSurveyWhereInput | satisfactionSurveyWhereInput[]
    OR?: satisfactionSurveyWhereInput[]
    NOT?: satisfactionSurveyWhereInput | satisfactionSurveyWhereInput[]
    id?: StringFilter<"satisfactionSurvey"> | string
    title?: StringFilter<"satisfactionSurvey"> | string
    description?: StringNullableFilter<"satisfactionSurvey"> | string | null
    startDate?: DateTimeNullableFilter<"satisfactionSurvey"> | Date | string | null
    endDate?: DateTimeNullableFilter<"satisfactionSurvey"> | Date | string | null
    active?: BoolNullableFilter<"satisfactionSurvey"> | boolean | null
    createdAt?: DateTimeFilter<"satisfactionSurvey"> | Date | string
    updatedAt?: DateTimeNullableFilter<"satisfactionSurvey"> | Date | string | null
    surveyResponse?: SurveyResponseListRelationFilter
  }

  export type satisfactionSurveyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    surveyResponse?: surveyResponseOrderByRelationAggregateInput
  }

  export type satisfactionSurveyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: satisfactionSurveyWhereInput | satisfactionSurveyWhereInput[]
    OR?: satisfactionSurveyWhereInput[]
    NOT?: satisfactionSurveyWhereInput | satisfactionSurveyWhereInput[]
    title?: StringFilter<"satisfactionSurvey"> | string
    description?: StringNullableFilter<"satisfactionSurvey"> | string | null
    startDate?: DateTimeNullableFilter<"satisfactionSurvey"> | Date | string | null
    endDate?: DateTimeNullableFilter<"satisfactionSurvey"> | Date | string | null
    active?: BoolNullableFilter<"satisfactionSurvey"> | boolean | null
    createdAt?: DateTimeFilter<"satisfactionSurvey"> | Date | string
    updatedAt?: DateTimeNullableFilter<"satisfactionSurvey"> | Date | string | null
    surveyResponse?: SurveyResponseListRelationFilter
  }, "id">

  export type satisfactionSurveyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: satisfactionSurveyCountOrderByAggregateInput
    _max?: satisfactionSurveyMaxOrderByAggregateInput
    _min?: satisfactionSurveyMinOrderByAggregateInput
  }

  export type satisfactionSurveyScalarWhereWithAggregatesInput = {
    AND?: satisfactionSurveyScalarWhereWithAggregatesInput | satisfactionSurveyScalarWhereWithAggregatesInput[]
    OR?: satisfactionSurveyScalarWhereWithAggregatesInput[]
    NOT?: satisfactionSurveyScalarWhereWithAggregatesInput | satisfactionSurveyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"satisfactionSurvey"> | string
    title?: StringWithAggregatesFilter<"satisfactionSurvey"> | string
    description?: StringNullableWithAggregatesFilter<"satisfactionSurvey"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"satisfactionSurvey"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"satisfactionSurvey"> | Date | string | null
    active?: BoolNullableWithAggregatesFilter<"satisfactionSurvey"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"satisfactionSurvey"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"satisfactionSurvey"> | Date | string | null
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    id?: StringFilter<"session"> | string
    refreshToken?: StringFilter<"session"> | string
    userId?: StringFilter<"session"> | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    userAgent?: StringNullableFilter<"session"> | string | null
    ipAddress?: StringNullableFilter<"session"> | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    userId?: StringFilter<"session"> | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    userAgent?: StringNullableFilter<"session"> | string | null
    ipAddress?: StringNullableFilter<"session"> | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "refreshToken">

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session"> | string
    refreshToken?: StringWithAggregatesFilter<"session"> | string
    userId?: StringWithAggregatesFilter<"session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    userAgent?: StringNullableWithAggregatesFilter<"session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"session"> | string | null
  }

  export type serviceCompletedWhereInput = {
    AND?: serviceCompletedWhereInput | serviceCompletedWhereInput[]
    OR?: serviceCompletedWhereInput[]
    NOT?: serviceCompletedWhereInput | serviceCompletedWhereInput[]
    id?: StringFilter<"serviceCompleted"> | string
    requestId?: StringFilter<"serviceCompleted"> | string
    helperId?: StringFilter<"serviceCompleted"> | string
    completionDate?: DateTimeFilter<"serviceCompleted"> | Date | string
    actualDuration?: IntNullableFilter<"serviceCompleted"> | number | null
    creatorComment?: StringNullableFilter<"serviceCompleted"> | string | null
    helperComment?: StringNullableFilter<"serviceCompleted"> | string | null
    creatorRating?: IntNullableFilter<"serviceCompleted"> | number | null
    helperRating?: IntNullableFilter<"serviceCompleted"> | number | null
    pointsExchanged?: IntNullableFilter<"serviceCompleted"> | number | null
    createdAt?: DateTimeFilter<"serviceCompleted"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceCompleted"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    helpRequest?: XOR<HelpRequestScalarRelationFilter, helpRequestWhereInput>
  }

  export type serviceCompletedOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    completionDate?: SortOrder
    actualDuration?: SortOrderInput | SortOrder
    creatorComment?: SortOrderInput | SortOrder
    helperComment?: SortOrderInput | SortOrder
    creatorRating?: SortOrderInput | SortOrder
    helperRating?: SortOrderInput | SortOrder
    pointsExchanged?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    helpRequest?: helpRequestOrderByWithRelationInput
  }

  export type serviceCompletedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: serviceCompletedWhereInput | serviceCompletedWhereInput[]
    OR?: serviceCompletedWhereInput[]
    NOT?: serviceCompletedWhereInput | serviceCompletedWhereInput[]
    requestId?: StringFilter<"serviceCompleted"> | string
    helperId?: StringFilter<"serviceCompleted"> | string
    completionDate?: DateTimeFilter<"serviceCompleted"> | Date | string
    actualDuration?: IntNullableFilter<"serviceCompleted"> | number | null
    creatorComment?: StringNullableFilter<"serviceCompleted"> | string | null
    helperComment?: StringNullableFilter<"serviceCompleted"> | string | null
    creatorRating?: IntNullableFilter<"serviceCompleted"> | number | null
    helperRating?: IntNullableFilter<"serviceCompleted"> | number | null
    pointsExchanged?: IntNullableFilter<"serviceCompleted"> | number | null
    createdAt?: DateTimeFilter<"serviceCompleted"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceCompleted"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    helpRequest?: XOR<HelpRequestScalarRelationFilter, helpRequestWhereInput>
  }, "id">

  export type serviceCompletedOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    completionDate?: SortOrder
    actualDuration?: SortOrderInput | SortOrder
    creatorComment?: SortOrderInput | SortOrder
    helperComment?: SortOrderInput | SortOrder
    creatorRating?: SortOrderInput | SortOrder
    helperRating?: SortOrderInput | SortOrder
    pointsExchanged?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: serviceCompletedCountOrderByAggregateInput
    _avg?: serviceCompletedAvgOrderByAggregateInput
    _max?: serviceCompletedMaxOrderByAggregateInput
    _min?: serviceCompletedMinOrderByAggregateInput
    _sum?: serviceCompletedSumOrderByAggregateInput
  }

  export type serviceCompletedScalarWhereWithAggregatesInput = {
    AND?: serviceCompletedScalarWhereWithAggregatesInput | serviceCompletedScalarWhereWithAggregatesInput[]
    OR?: serviceCompletedScalarWhereWithAggregatesInput[]
    NOT?: serviceCompletedScalarWhereWithAggregatesInput | serviceCompletedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"serviceCompleted"> | string
    requestId?: StringWithAggregatesFilter<"serviceCompleted"> | string
    helperId?: StringWithAggregatesFilter<"serviceCompleted"> | string
    completionDate?: DateTimeWithAggregatesFilter<"serviceCompleted"> | Date | string
    actualDuration?: IntNullableWithAggregatesFilter<"serviceCompleted"> | number | null
    creatorComment?: StringNullableWithAggregatesFilter<"serviceCompleted"> | string | null
    helperComment?: StringNullableWithAggregatesFilter<"serviceCompleted"> | string | null
    creatorRating?: IntNullableWithAggregatesFilter<"serviceCompleted"> | number | null
    helperRating?: IntNullableWithAggregatesFilter<"serviceCompleted"> | number | null
    pointsExchanged?: IntNullableWithAggregatesFilter<"serviceCompleted"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"serviceCompleted"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"serviceCompleted"> | Date | string | null
  }

  export type serviceRatingWhereInput = {
    AND?: serviceRatingWhereInput | serviceRatingWhereInput[]
    OR?: serviceRatingWhereInput[]
    NOT?: serviceRatingWhereInput | serviceRatingWhereInput[]
    serviceId?: StringFilter<"serviceRating"> | string
    userId?: StringFilter<"serviceRating"> | string
    rating?: IntNullableFilter<"serviceRating"> | number | null
    comment?: StringNullableFilter<"serviceRating"> | string | null
    ratingDate?: DateTimeNullableFilter<"serviceRating"> | Date | string | null
    createdAt?: DateTimeFilter<"serviceRating"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceRating"> | Date | string | null
    localService?: XOR<LocalServiceScalarRelationFilter, localServiceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type serviceRatingOrderByWithRelationInput = {
    serviceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    ratingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    localService?: localServiceOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type serviceRatingWhereUniqueInput = Prisma.AtLeast<{
    serviceId_userId?: serviceRatingServiceIdUserIdCompoundUniqueInput
    AND?: serviceRatingWhereInput | serviceRatingWhereInput[]
    OR?: serviceRatingWhereInput[]
    NOT?: serviceRatingWhereInput | serviceRatingWhereInput[]
    serviceId?: StringFilter<"serviceRating"> | string
    userId?: StringFilter<"serviceRating"> | string
    rating?: IntNullableFilter<"serviceRating"> | number | null
    comment?: StringNullableFilter<"serviceRating"> | string | null
    ratingDate?: DateTimeNullableFilter<"serviceRating"> | Date | string | null
    createdAt?: DateTimeFilter<"serviceRating"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceRating"> | Date | string | null
    localService?: XOR<LocalServiceScalarRelationFilter, localServiceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "serviceId_userId">

  export type serviceRatingOrderByWithAggregationInput = {
    serviceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    ratingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: serviceRatingCountOrderByAggregateInput
    _avg?: serviceRatingAvgOrderByAggregateInput
    _max?: serviceRatingMaxOrderByAggregateInput
    _min?: serviceRatingMinOrderByAggregateInput
    _sum?: serviceRatingSumOrderByAggregateInput
  }

  export type serviceRatingScalarWhereWithAggregatesInput = {
    AND?: serviceRatingScalarWhereWithAggregatesInput | serviceRatingScalarWhereWithAggregatesInput[]
    OR?: serviceRatingScalarWhereWithAggregatesInput[]
    NOT?: serviceRatingScalarWhereWithAggregatesInput | serviceRatingScalarWhereWithAggregatesInput[]
    serviceId?: StringWithAggregatesFilter<"serviceRating"> | string
    userId?: StringWithAggregatesFilter<"serviceRating"> | string
    rating?: IntNullableWithAggregatesFilter<"serviceRating"> | number | null
    comment?: StringNullableWithAggregatesFilter<"serviceRating"> | string | null
    ratingDate?: DateTimeNullableWithAggregatesFilter<"serviceRating"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"serviceRating"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"serviceRating"> | Date | string | null
  }

  export type skillWhereInput = {
    AND?: skillWhereInput | skillWhereInput[]
    OR?: skillWhereInput[]
    NOT?: skillWhereInput | skillWhereInput[]
    id?: StringFilter<"skill"> | string
    name?: StringFilter<"skill"> | string
    description?: StringNullableFilter<"skill"> | string | null
    categoryId?: StringNullableFilter<"skill"> | string | null
    createdAt?: DateTimeFilter<"skill"> | Date | string
    updatedAt?: DateTimeNullableFilter<"skill"> | Date | string | null
    skillCategory?: XOR<SkillCategoryNullableScalarRelationFilter, skillCategoryWhereInput> | null
    userSkill?: UserSkillListRelationFilter
  }

  export type skillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    skillCategory?: skillCategoryOrderByWithRelationInput
    userSkill?: userSkillOrderByRelationAggregateInput
  }

  export type skillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: skillWhereInput | skillWhereInput[]
    OR?: skillWhereInput[]
    NOT?: skillWhereInput | skillWhereInput[]
    name?: StringFilter<"skill"> | string
    description?: StringNullableFilter<"skill"> | string | null
    categoryId?: StringNullableFilter<"skill"> | string | null
    createdAt?: DateTimeFilter<"skill"> | Date | string
    updatedAt?: DateTimeNullableFilter<"skill"> | Date | string | null
    skillCategory?: XOR<SkillCategoryNullableScalarRelationFilter, skillCategoryWhereInput> | null
    userSkill?: UserSkillListRelationFilter
  }, "id">

  export type skillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: skillCountOrderByAggregateInput
    _max?: skillMaxOrderByAggregateInput
    _min?: skillMinOrderByAggregateInput
  }

  export type skillScalarWhereWithAggregatesInput = {
    AND?: skillScalarWhereWithAggregatesInput | skillScalarWhereWithAggregatesInput[]
    OR?: skillScalarWhereWithAggregatesInput[]
    NOT?: skillScalarWhereWithAggregatesInput | skillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"skill"> | string
    name?: StringWithAggregatesFilter<"skill"> | string
    description?: StringNullableWithAggregatesFilter<"skill"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"skill"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"skill"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"skill"> | Date | string | null
  }

  export type surveyResponseWhereInput = {
    AND?: surveyResponseWhereInput | surveyResponseWhereInput[]
    OR?: surveyResponseWhereInput[]
    NOT?: surveyResponseWhereInput | surveyResponseWhereInput[]
    surveyId?: StringFilter<"surveyResponse"> | string
    userId?: StringFilter<"surveyResponse"> | string
    responses?: JsonNullableFilter<"surveyResponse">
    response_date?: DateTimeNullableFilter<"surveyResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"surveyResponse"> | Date | string
    updatedAt?: DateTimeNullableFilter<"surveyResponse"> | Date | string | null
    satisfactionSurvey?: XOR<SatisfactionSurveyScalarRelationFilter, satisfactionSurveyWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type surveyResponseOrderByWithRelationInput = {
    surveyId?: SortOrder
    userId?: SortOrder
    responses?: SortOrderInput | SortOrder
    response_date?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    satisfactionSurvey?: satisfactionSurveyOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type surveyResponseWhereUniqueInput = Prisma.AtLeast<{
    surveyId_userId?: surveyResponseSurveyIdUserIdCompoundUniqueInput
    AND?: surveyResponseWhereInput | surveyResponseWhereInput[]
    OR?: surveyResponseWhereInput[]
    NOT?: surveyResponseWhereInput | surveyResponseWhereInput[]
    surveyId?: StringFilter<"surveyResponse"> | string
    userId?: StringFilter<"surveyResponse"> | string
    responses?: JsonNullableFilter<"surveyResponse">
    response_date?: DateTimeNullableFilter<"surveyResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"surveyResponse"> | Date | string
    updatedAt?: DateTimeNullableFilter<"surveyResponse"> | Date | string | null
    satisfactionSurvey?: XOR<SatisfactionSurveyScalarRelationFilter, satisfactionSurveyWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "surveyId_userId">

  export type surveyResponseOrderByWithAggregationInput = {
    surveyId?: SortOrder
    userId?: SortOrder
    responses?: SortOrderInput | SortOrder
    response_date?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: surveyResponseCountOrderByAggregateInput
    _max?: surveyResponseMaxOrderByAggregateInput
    _min?: surveyResponseMinOrderByAggregateInput
  }

  export type surveyResponseScalarWhereWithAggregatesInput = {
    AND?: surveyResponseScalarWhereWithAggregatesInput | surveyResponseScalarWhereWithAggregatesInput[]
    OR?: surveyResponseScalarWhereWithAggregatesInput[]
    NOT?: surveyResponseScalarWhereWithAggregatesInput | surveyResponseScalarWhereWithAggregatesInput[]
    surveyId?: StringWithAggregatesFilter<"surveyResponse"> | string
    userId?: StringWithAggregatesFilter<"surveyResponse"> | string
    responses?: JsonNullableWithAggregatesFilter<"surveyResponse">
    response_date?: DateTimeNullableWithAggregatesFilter<"surveyResponse"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"surveyResponse"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"surveyResponse"> | Date | string | null
  }

  export type trustCircleWhereInput = {
    AND?: trustCircleWhereInput | trustCircleWhereInput[]
    OR?: trustCircleWhereInput[]
    NOT?: trustCircleWhereInput | trustCircleWhereInput[]
    userId?: StringFilter<"trustCircle"> | string
    contactId?: StringFilter<"trustCircle"> | string
    dateAdded?: DateTimeFilter<"trustCircle"> | Date | string
    accessLevel?: StringFilter<"trustCircle"> | string
    createdAt?: DateTimeFilter<"trustCircle"> | Date | string
    updatedAt?: DateTimeNullableFilter<"trustCircle"> | Date | string | null
  }

  export type trustCircleOrderByWithRelationInput = {
    userId?: SortOrder
    contactId?: SortOrder
    dateAdded?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type trustCircleWhereUniqueInput = Prisma.AtLeast<{
    userId_contactId?: trustCircleUserIdContactIdCompoundUniqueInput
    AND?: trustCircleWhereInput | trustCircleWhereInput[]
    OR?: trustCircleWhereInput[]
    NOT?: trustCircleWhereInput | trustCircleWhereInput[]
    userId?: StringFilter<"trustCircle"> | string
    contactId?: StringFilter<"trustCircle"> | string
    dateAdded?: DateTimeFilter<"trustCircle"> | Date | string
    accessLevel?: StringFilter<"trustCircle"> | string
    createdAt?: DateTimeFilter<"trustCircle"> | Date | string
    updatedAt?: DateTimeNullableFilter<"trustCircle"> | Date | string | null
  }, "userId_contactId">

  export type trustCircleOrderByWithAggregationInput = {
    userId?: SortOrder
    contactId?: SortOrder
    dateAdded?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: trustCircleCountOrderByAggregateInput
    _max?: trustCircleMaxOrderByAggregateInput
    _min?: trustCircleMinOrderByAggregateInput
  }

  export type trustCircleScalarWhereWithAggregatesInput = {
    AND?: trustCircleScalarWhereWithAggregatesInput | trustCircleScalarWhereWithAggregatesInput[]
    OR?: trustCircleScalarWhereWithAggregatesInput[]
    NOT?: trustCircleScalarWhereWithAggregatesInput | trustCircleScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"trustCircle"> | string
    contactId?: StringWithAggregatesFilter<"trustCircle"> | string
    dateAdded?: DateTimeWithAggregatesFilter<"trustCircle"> | Date | string
    accessLevel?: StringWithAggregatesFilter<"trustCircle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"trustCircle"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"trustCircle"> | Date | string | null
  }

  export type trustedContactWhereInput = {
    AND?: trustedContactWhereInput | trustedContactWhereInput[]
    OR?: trustedContactWhereInput[]
    NOT?: trustedContactWhereInput | trustedContactWhereInput[]
    id?: StringFilter<"trustedContact"> | string
    userId?: StringFilter<"trustedContact"> | string
    firstName?: StringFilter<"trustedContact"> | string
    lastName?: StringFilter<"trustedContact"> | string
    email?: StringNullableFilter<"trustedContact"> | string | null
    phone?: StringFilter<"trustedContact"> | string
    relationship?: StringNullableFilter<"trustedContact"> | string | null
    shareMedications?: BoolFilter<"trustedContact"> | boolean
    shareHealthIndicators?: BoolFilter<"trustedContact"> | boolean
    shareWellnessActivities?: BoolFilter<"trustedContact"> | boolean
    emergencyAlerts?: BoolFilter<"trustedContact"> | boolean
    createdAt?: DateTimeFilter<"trustedContact"> | Date | string
    updatedAt?: DateTimeNullableFilter<"trustedContact"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type trustedContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    relationship?: SortOrderInput | SortOrder
    shareMedications?: SortOrder
    shareHealthIndicators?: SortOrder
    shareWellnessActivities?: SortOrder
    emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type trustedContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: trustedContactWhereInput | trustedContactWhereInput[]
    OR?: trustedContactWhereInput[]
    NOT?: trustedContactWhereInput | trustedContactWhereInput[]
    userId?: StringFilter<"trustedContact"> | string
    firstName?: StringFilter<"trustedContact"> | string
    lastName?: StringFilter<"trustedContact"> | string
    phone?: StringFilter<"trustedContact"> | string
    relationship?: StringNullableFilter<"trustedContact"> | string | null
    shareMedications?: BoolFilter<"trustedContact"> | boolean
    shareHealthIndicators?: BoolFilter<"trustedContact"> | boolean
    shareWellnessActivities?: BoolFilter<"trustedContact"> | boolean
    emergencyAlerts?: BoolFilter<"trustedContact"> | boolean
    createdAt?: DateTimeFilter<"trustedContact"> | Date | string
    updatedAt?: DateTimeNullableFilter<"trustedContact"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "email">

  export type trustedContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    relationship?: SortOrderInput | SortOrder
    shareMedications?: SortOrder
    shareHealthIndicators?: SortOrder
    shareWellnessActivities?: SortOrder
    emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: trustedContactCountOrderByAggregateInput
    _max?: trustedContactMaxOrderByAggregateInput
    _min?: trustedContactMinOrderByAggregateInput
  }

  export type trustedContactScalarWhereWithAggregatesInput = {
    AND?: trustedContactScalarWhereWithAggregatesInput | trustedContactScalarWhereWithAggregatesInput[]
    OR?: trustedContactScalarWhereWithAggregatesInput[]
    NOT?: trustedContactScalarWhereWithAggregatesInput | trustedContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"trustedContact"> | string
    userId?: StringWithAggregatesFilter<"trustedContact"> | string
    firstName?: StringWithAggregatesFilter<"trustedContact"> | string
    lastName?: StringWithAggregatesFilter<"trustedContact"> | string
    email?: StringNullableWithAggregatesFilter<"trustedContact"> | string | null
    phone?: StringWithAggregatesFilter<"trustedContact"> | string
    relationship?: StringNullableWithAggregatesFilter<"trustedContact"> | string | null
    shareMedications?: BoolWithAggregatesFilter<"trustedContact"> | boolean
    shareHealthIndicators?: BoolWithAggregatesFilter<"trustedContact"> | boolean
    shareWellnessActivities?: BoolWithAggregatesFilter<"trustedContact"> | boolean
    emergencyAlerts?: BoolWithAggregatesFilter<"trustedContact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"trustedContact"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"trustedContact"> | Date | string | null
  }

  export type urbanIssueReportWhereInput = {
    AND?: urbanIssueReportWhereInput | urbanIssueReportWhereInput[]
    OR?: urbanIssueReportWhereInput[]
    NOT?: urbanIssueReportWhereInput | urbanIssueReportWhereInput[]
    id?: StringFilter<"urbanIssueReport"> | string
    userId?: StringFilter<"urbanIssueReport"> | string
    categoryId?: StringNullableFilter<"urbanIssueReport"> | string | null
    description?: StringFilter<"urbanIssueReport"> | string
    address?: StringFilter<"urbanIssueReport"> | string
    gpsCoordinates?: StringNullableFilter<"urbanIssueReport"> | string | null
    reportDate?: DateTimeFilter<"urbanIssueReport"> | Date | string
    status?: StringNullableFilter<"urbanIssueReport"> | string | null
    cityReference?: StringNullableFilter<"urbanIssueReport"> | string | null
    createdAt?: DateTimeFilter<"urbanIssueReport"> | Date | string
    updatedAt?: DateTimeNullableFilter<"urbanIssueReport"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    issueCategory?: XOR<IssueCategoryNullableScalarRelationFilter, issueCategoryWhereInput> | null
  }

  export type urbanIssueReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    description?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    reportDate?: SortOrder
    status?: SortOrderInput | SortOrder
    cityReference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    issueCategory?: issueCategoryOrderByWithRelationInput
  }

  export type urbanIssueReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: urbanIssueReportWhereInput | urbanIssueReportWhereInput[]
    OR?: urbanIssueReportWhereInput[]
    NOT?: urbanIssueReportWhereInput | urbanIssueReportWhereInput[]
    userId?: StringFilter<"urbanIssueReport"> | string
    categoryId?: StringNullableFilter<"urbanIssueReport"> | string | null
    description?: StringFilter<"urbanIssueReport"> | string
    address?: StringFilter<"urbanIssueReport"> | string
    gpsCoordinates?: StringNullableFilter<"urbanIssueReport"> | string | null
    reportDate?: DateTimeFilter<"urbanIssueReport"> | Date | string
    status?: StringNullableFilter<"urbanIssueReport"> | string | null
    cityReference?: StringNullableFilter<"urbanIssueReport"> | string | null
    createdAt?: DateTimeFilter<"urbanIssueReport"> | Date | string
    updatedAt?: DateTimeNullableFilter<"urbanIssueReport"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    issueCategory?: XOR<IssueCategoryNullableScalarRelationFilter, issueCategoryWhereInput> | null
  }, "id">

  export type urbanIssueReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    description?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    reportDate?: SortOrder
    status?: SortOrderInput | SortOrder
    cityReference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: urbanIssueReportCountOrderByAggregateInput
    _max?: urbanIssueReportMaxOrderByAggregateInput
    _min?: urbanIssueReportMinOrderByAggregateInput
  }

  export type urbanIssueReportScalarWhereWithAggregatesInput = {
    AND?: urbanIssueReportScalarWhereWithAggregatesInput | urbanIssueReportScalarWhereWithAggregatesInput[]
    OR?: urbanIssueReportScalarWhereWithAggregatesInput[]
    NOT?: urbanIssueReportScalarWhereWithAggregatesInput | urbanIssueReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"urbanIssueReport"> | string
    userId?: StringWithAggregatesFilter<"urbanIssueReport"> | string
    categoryId?: StringNullableWithAggregatesFilter<"urbanIssueReport"> | string | null
    description?: StringWithAggregatesFilter<"urbanIssueReport"> | string
    address?: StringWithAggregatesFilter<"urbanIssueReport"> | string
    gpsCoordinates?: StringNullableWithAggregatesFilter<"urbanIssueReport"> | string | null
    reportDate?: DateTimeWithAggregatesFilter<"urbanIssueReport"> | Date | string
    status?: StringNullableWithAggregatesFilter<"urbanIssueReport"> | string | null
    cityReference?: StringNullableWithAggregatesFilter<"urbanIssueReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"urbanIssueReport"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"urbanIssueReport"> | Date | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    passwordHash?: StringFilter<"user"> | string
    firstName?: StringNullableFilter<"user"> | string | null
    lastName?: StringNullableFilter<"user"> | string | null
    birthDate?: DateTimeNullableFilter<"user"> | Date | string | null
    address?: StringNullableFilter<"user"> | string | null
    gpsCoordinates?: StringNullableFilter<"user"> | string | null
    phone?: StringNullableFilter<"user"> | string | null
    profilePicture?: StringNullableFilter<"user"> | string | null
    registrationDate?: DateTimeFilter<"user"> | Date | string
    accountVerified?: BoolFilter<"user"> | boolean
    interfacePreferences?: StringNullableFilter<"user"> | string | null
    twoFactorAuthentication?: BoolFilter<"user"> | boolean
    helpPoints?: IntNullableFilter<"user"> | number | null
    reducedMobility?: BoolNullableFilter<"user"> | boolean | null
    activityLevel?: StringNullableFilter<"user"> | string | null
    status?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    activity?: ActivityListRelationFilter
    activityLog?: ActivityLogListRelationFilter
    activityRegistration?: ActivityRegistrationListRelationFilter
    collaborativeProject?: CollaborativeProjectListRelationFilter
    conversationParticipant?: ConversationParticipantListRelationFilter
    forumMessage?: ForumMessageListRelationFilter
    forumTopic?: ForumTopicListRelationFilter
    healthIndicator?: HealthIndicatorListRelationFilter
    helpOffer?: HelpOfferListRelationFilter
    helpRequest?: HelpRequestListRelationFilter
    medicationReminder?: MedicationReminderListRelationFilter
    message?: MessageListRelationFilter
    notification?: NotificationListRelationFilter
    notificationPreferences?: XOR<NotificationPreferencesNullableScalarRelationFilter, notificationPreferencesWhereInput> | null
    projectMember?: ProjectMemberListRelationFilter
    projectTask?: ProjectTaskListRelationFilter
    resource?: ResourceListRelationFilter
    serviceCompleted?: ServiceCompletedListRelationFilter
    serviceRating?: ServiceRatingListRelationFilter
    surveyResponse?: SurveyResponseListRelationFilter
    trustedContact?: TrustedContactListRelationFilter
    urbanIssueReport?: UrbanIssueReportListRelationFilter
    userActivity?: UserActivityListRelationFilter
    userBadge?: UserBadgeListRelationFilter
    userDevice?: UserDeviceListRelationFilter
    userSkill?: UserSkillListRelationFilter
    userStatistics?: XOR<UserStatisticsNullableScalarRelationFilter, userStatisticsWhereInput> | null
    videoCall?: VideoCallListRelationFilter
    wellnessGoal?: WellnessGoalListRelationFilter
    session?: SessionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    registrationDate?: SortOrder
    accountVerified?: SortOrder
    interfacePreferences?: SortOrderInput | SortOrder
    twoFactorAuthentication?: SortOrder
    helpPoints?: SortOrderInput | SortOrder
    reducedMobility?: SortOrderInput | SortOrder
    activityLevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    activity?: activityOrderByRelationAggregateInput
    activityLog?: activityLogOrderByRelationAggregateInput
    activityRegistration?: activityRegistrationOrderByRelationAggregateInput
    collaborativeProject?: collaborativeProjectOrderByRelationAggregateInput
    conversationParticipant?: conversationParticipantOrderByRelationAggregateInput
    forumMessage?: forumMessageOrderByRelationAggregateInput
    forumTopic?: forumTopicOrderByRelationAggregateInput
    healthIndicator?: healthIndicatorOrderByRelationAggregateInput
    helpOffer?: helpOfferOrderByRelationAggregateInput
    helpRequest?: helpRequestOrderByRelationAggregateInput
    medicationReminder?: medicationReminderOrderByRelationAggregateInput
    message?: messageOrderByRelationAggregateInput
    notification?: notificationOrderByRelationAggregateInput
    notificationPreferences?: notificationPreferencesOrderByWithRelationInput
    projectMember?: projectMemberOrderByRelationAggregateInput
    projectTask?: projectTaskOrderByRelationAggregateInput
    resource?: resourceOrderByRelationAggregateInput
    serviceCompleted?: serviceCompletedOrderByRelationAggregateInput
    serviceRating?: serviceRatingOrderByRelationAggregateInput
    surveyResponse?: surveyResponseOrderByRelationAggregateInput
    trustedContact?: trustedContactOrderByRelationAggregateInput
    urbanIssueReport?: urbanIssueReportOrderByRelationAggregateInput
    userActivity?: userActivityOrderByRelationAggregateInput
    userBadge?: userBadgeOrderByRelationAggregateInput
    userDevice?: userDeviceOrderByRelationAggregateInput
    userSkill?: userSkillOrderByRelationAggregateInput
    userStatistics?: userStatisticsOrderByWithRelationInput
    videoCall?: videoCallOrderByRelationAggregateInput
    wellnessGoal?: wellnessGoalOrderByRelationAggregateInput
    session?: sessionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    passwordHash?: StringFilter<"user"> | string
    firstName?: StringNullableFilter<"user"> | string | null
    lastName?: StringNullableFilter<"user"> | string | null
    birthDate?: DateTimeNullableFilter<"user"> | Date | string | null
    address?: StringNullableFilter<"user"> | string | null
    gpsCoordinates?: StringNullableFilter<"user"> | string | null
    phone?: StringNullableFilter<"user"> | string | null
    profilePicture?: StringNullableFilter<"user"> | string | null
    registrationDate?: DateTimeFilter<"user"> | Date | string
    accountVerified?: BoolFilter<"user"> | boolean
    interfacePreferences?: StringNullableFilter<"user"> | string | null
    twoFactorAuthentication?: BoolFilter<"user"> | boolean
    helpPoints?: IntNullableFilter<"user"> | number | null
    reducedMobility?: BoolNullableFilter<"user"> | boolean | null
    activityLevel?: StringNullableFilter<"user"> | string | null
    status?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    activity?: ActivityListRelationFilter
    activityLog?: ActivityLogListRelationFilter
    activityRegistration?: ActivityRegistrationListRelationFilter
    collaborativeProject?: CollaborativeProjectListRelationFilter
    conversationParticipant?: ConversationParticipantListRelationFilter
    forumMessage?: ForumMessageListRelationFilter
    forumTopic?: ForumTopicListRelationFilter
    healthIndicator?: HealthIndicatorListRelationFilter
    helpOffer?: HelpOfferListRelationFilter
    helpRequest?: HelpRequestListRelationFilter
    medicationReminder?: MedicationReminderListRelationFilter
    message?: MessageListRelationFilter
    notification?: NotificationListRelationFilter
    notificationPreferences?: XOR<NotificationPreferencesNullableScalarRelationFilter, notificationPreferencesWhereInput> | null
    projectMember?: ProjectMemberListRelationFilter
    projectTask?: ProjectTaskListRelationFilter
    resource?: ResourceListRelationFilter
    serviceCompleted?: ServiceCompletedListRelationFilter
    serviceRating?: ServiceRatingListRelationFilter
    surveyResponse?: SurveyResponseListRelationFilter
    trustedContact?: TrustedContactListRelationFilter
    urbanIssueReport?: UrbanIssueReportListRelationFilter
    userActivity?: UserActivityListRelationFilter
    userBadge?: UserBadgeListRelationFilter
    userDevice?: UserDeviceListRelationFilter
    userSkill?: UserSkillListRelationFilter
    userStatistics?: XOR<UserStatisticsNullableScalarRelationFilter, userStatisticsWhereInput> | null
    videoCall?: VideoCallListRelationFilter
    wellnessGoal?: WellnessGoalListRelationFilter
    session?: SessionListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    gpsCoordinates?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    registrationDate?: SortOrder
    accountVerified?: SortOrder
    interfacePreferences?: SortOrderInput | SortOrder
    twoFactorAuthentication?: SortOrder
    helpPoints?: SortOrderInput | SortOrder
    reducedMobility?: SortOrderInput | SortOrder
    activityLevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    passwordHash?: StringWithAggregatesFilter<"user"> | string
    firstName?: StringNullableWithAggregatesFilter<"user"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"user"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"user"> | string | null
    gpsCoordinates?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone?: StringNullableWithAggregatesFilter<"user"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"user"> | string | null
    registrationDate?: DateTimeWithAggregatesFilter<"user"> | Date | string
    accountVerified?: BoolWithAggregatesFilter<"user"> | boolean
    interfacePreferences?: StringNullableWithAggregatesFilter<"user"> | string | null
    twoFactorAuthentication?: BoolWithAggregatesFilter<"user"> | boolean
    helpPoints?: IntNullableWithAggregatesFilter<"user"> | number | null
    reducedMobility?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    activityLevel?: StringNullableWithAggregatesFilter<"user"> | string | null
    status?: StringNullableWithAggregatesFilter<"user"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type userActivityWhereInput = {
    AND?: userActivityWhereInput | userActivityWhereInput[]
    OR?: userActivityWhereInput[]
    NOT?: userActivityWhereInput | userActivityWhereInput[]
    id?: StringFilter<"userActivity"> | string
    userId?: StringFilter<"userActivity"> | string
    completionDate?: DateTimeFilter<"userActivity"> | Date | string
    exerciseProgramId?: StringNullableFilter<"userActivity"> | string | null
    cognitiveExerciseId?: StringNullableFilter<"userActivity"> | string | null
    durationMinutes?: IntNullableFilter<"userActivity"> | number | null
    perceivedDifficultyLevel?: IntNullableFilter<"userActivity"> | number | null
    enjoymentLevel?: IntNullableFilter<"userActivity"> | number | null
    comment?: StringNullableFilter<"userActivity"> | string | null
    createdAt?: DateTimeFilter<"userActivity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userActivity"> | Date | string | null
    cognitiveExercise?: XOR<CognitiveExerciseNullableScalarRelationFilter, cognitiveExerciseWhereInput> | null
    exerciseProgram?: XOR<ExerciseProgramNullableScalarRelationFilter, exerciseProgramWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    completionDate?: SortOrder
    exerciseProgramId?: SortOrderInput | SortOrder
    cognitiveExerciseId?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    perceivedDifficultyLevel?: SortOrderInput | SortOrder
    enjoymentLevel?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    cognitiveExercise?: cognitiveExerciseOrderByWithRelationInput
    exerciseProgram?: exerciseProgramOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: userActivityWhereInput | userActivityWhereInput[]
    OR?: userActivityWhereInput[]
    NOT?: userActivityWhereInput | userActivityWhereInput[]
    userId?: StringFilter<"userActivity"> | string
    completionDate?: DateTimeFilter<"userActivity"> | Date | string
    exerciseProgramId?: StringNullableFilter<"userActivity"> | string | null
    cognitiveExerciseId?: StringNullableFilter<"userActivity"> | string | null
    durationMinutes?: IntNullableFilter<"userActivity"> | number | null
    perceivedDifficultyLevel?: IntNullableFilter<"userActivity"> | number | null
    enjoymentLevel?: IntNullableFilter<"userActivity"> | number | null
    comment?: StringNullableFilter<"userActivity"> | string | null
    createdAt?: DateTimeFilter<"userActivity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userActivity"> | Date | string | null
    cognitiveExercise?: XOR<CognitiveExerciseNullableScalarRelationFilter, cognitiveExerciseWhereInput> | null
    exerciseProgram?: XOR<ExerciseProgramNullableScalarRelationFilter, exerciseProgramWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type userActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    completionDate?: SortOrder
    exerciseProgramId?: SortOrderInput | SortOrder
    cognitiveExerciseId?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    perceivedDifficultyLevel?: SortOrderInput | SortOrder
    enjoymentLevel?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: userActivityCountOrderByAggregateInput
    _avg?: userActivityAvgOrderByAggregateInput
    _max?: userActivityMaxOrderByAggregateInput
    _min?: userActivityMinOrderByAggregateInput
    _sum?: userActivitySumOrderByAggregateInput
  }

  export type userActivityScalarWhereWithAggregatesInput = {
    AND?: userActivityScalarWhereWithAggregatesInput | userActivityScalarWhereWithAggregatesInput[]
    OR?: userActivityScalarWhereWithAggregatesInput[]
    NOT?: userActivityScalarWhereWithAggregatesInput | userActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userActivity"> | string
    userId?: StringWithAggregatesFilter<"userActivity"> | string
    completionDate?: DateTimeWithAggregatesFilter<"userActivity"> | Date | string
    exerciseProgramId?: StringNullableWithAggregatesFilter<"userActivity"> | string | null
    cognitiveExerciseId?: StringNullableWithAggregatesFilter<"userActivity"> | string | null
    durationMinutes?: IntNullableWithAggregatesFilter<"userActivity"> | number | null
    perceivedDifficultyLevel?: IntNullableWithAggregatesFilter<"userActivity"> | number | null
    enjoymentLevel?: IntNullableWithAggregatesFilter<"userActivity"> | number | null
    comment?: StringNullableWithAggregatesFilter<"userActivity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"userActivity"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"userActivity"> | Date | string | null
  }

  export type userBadgeWhereInput = {
    AND?: userBadgeWhereInput | userBadgeWhereInput[]
    OR?: userBadgeWhereInput[]
    NOT?: userBadgeWhereInput | userBadgeWhereInput[]
    userId?: StringFilter<"userBadge"> | string
    badgeId?: StringFilter<"userBadge"> | string
    achievementDate?: DateTimeFilter<"userBadge"> | Date | string
    createdAt?: DateTimeFilter<"userBadge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userBadge"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, badgeWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userBadgeOrderByWithRelationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    achievementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    badge?: badgeOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userBadgeWhereUniqueInput = Prisma.AtLeast<{
    badgeId?: string
    userId_badgeId?: userBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: userBadgeWhereInput | userBadgeWhereInput[]
    OR?: userBadgeWhereInput[]
    NOT?: userBadgeWhereInput | userBadgeWhereInput[]
    userId?: StringFilter<"userBadge"> | string
    achievementDate?: DateTimeFilter<"userBadge"> | Date | string
    createdAt?: DateTimeFilter<"userBadge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userBadge"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, badgeWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "userId_badgeId" | "badgeId">

  export type userBadgeOrderByWithAggregationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    achievementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: userBadgeCountOrderByAggregateInput
    _max?: userBadgeMaxOrderByAggregateInput
    _min?: userBadgeMinOrderByAggregateInput
  }

  export type userBadgeScalarWhereWithAggregatesInput = {
    AND?: userBadgeScalarWhereWithAggregatesInput | userBadgeScalarWhereWithAggregatesInput[]
    OR?: userBadgeScalarWhereWithAggregatesInput[]
    NOT?: userBadgeScalarWhereWithAggregatesInput | userBadgeScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"userBadge"> | string
    badgeId?: StringWithAggregatesFilter<"userBadge"> | string
    achievementDate?: DateTimeWithAggregatesFilter<"userBadge"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"userBadge"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"userBadge"> | Date | string | null
  }

  export type userDeviceWhereInput = {
    AND?: userDeviceWhereInput | userDeviceWhereInput[]
    OR?: userDeviceWhereInput[]
    NOT?: userDeviceWhereInput | userDeviceWhereInput[]
    id?: StringFilter<"userDevice"> | string
    userId?: StringFilter<"userDevice"> | string
    deviceType?: StringFilter<"userDevice"> | string
    deviceName?: StringNullableFilter<"userDevice"> | string | null
    operatingSystem?: StringNullableFilter<"userDevice"> | string | null
    notificationToken?: StringFilter<"userDevice"> | string
    lastConnection?: DateTimeFilter<"userDevice"> | Date | string
    createdAt?: DateTimeFilter<"userDevice"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userDevice"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type userDeviceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    operatingSystem?: SortOrderInput | SortOrder
    notificationToken?: SortOrder
    lastConnection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type userDeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: userDeviceWhereInput | userDeviceWhereInput[]
    OR?: userDeviceWhereInput[]
    NOT?: userDeviceWhereInput | userDeviceWhereInput[]
    userId?: StringFilter<"userDevice"> | string
    deviceType?: StringFilter<"userDevice"> | string
    deviceName?: StringNullableFilter<"userDevice"> | string | null
    operatingSystem?: StringNullableFilter<"userDevice"> | string | null
    notificationToken?: StringFilter<"userDevice"> | string
    lastConnection?: DateTimeFilter<"userDevice"> | Date | string
    createdAt?: DateTimeFilter<"userDevice"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userDevice"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type userDeviceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    operatingSystem?: SortOrderInput | SortOrder
    notificationToken?: SortOrder
    lastConnection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: userDeviceCountOrderByAggregateInput
    _max?: userDeviceMaxOrderByAggregateInput
    _min?: userDeviceMinOrderByAggregateInput
  }

  export type userDeviceScalarWhereWithAggregatesInput = {
    AND?: userDeviceScalarWhereWithAggregatesInput | userDeviceScalarWhereWithAggregatesInput[]
    OR?: userDeviceScalarWhereWithAggregatesInput[]
    NOT?: userDeviceScalarWhereWithAggregatesInput | userDeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userDevice"> | string
    userId?: StringWithAggregatesFilter<"userDevice"> | string
    deviceType?: StringWithAggregatesFilter<"userDevice"> | string
    deviceName?: StringNullableWithAggregatesFilter<"userDevice"> | string | null
    operatingSystem?: StringNullableWithAggregatesFilter<"userDevice"> | string | null
    notificationToken?: StringWithAggregatesFilter<"userDevice"> | string
    lastConnection?: DateTimeWithAggregatesFilter<"userDevice"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"userDevice"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"userDevice"> | Date | string | null
  }

  export type userSkillWhereInput = {
    AND?: userSkillWhereInput | userSkillWhereInput[]
    OR?: userSkillWhereInput[]
    NOT?: userSkillWhereInput | userSkillWhereInput[]
    userId?: StringFilter<"userSkill"> | string
    skillId?: StringFilter<"userSkill"> | string
    level?: IntNullableFilter<"userSkill"> | number | null
    created_at?: DateTimeFilter<"userSkill"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userSkill"> | Date | string | null
    skill?: XOR<SkillScalarRelationFilter, skillWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userSkillOrderByWithRelationInput = {
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    skill?: skillOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userSkillWhereUniqueInput = Prisma.AtLeast<{
    userId_skillId?: userSkillUserIdSkillIdCompoundUniqueInput
    AND?: userSkillWhereInput | userSkillWhereInput[]
    OR?: userSkillWhereInput[]
    NOT?: userSkillWhereInput | userSkillWhereInput[]
    userId?: StringFilter<"userSkill"> | string
    skillId?: StringFilter<"userSkill"> | string
    level?: IntNullableFilter<"userSkill"> | number | null
    created_at?: DateTimeFilter<"userSkill"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userSkill"> | Date | string | null
    skill?: XOR<SkillScalarRelationFilter, skillWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "userId_skillId">

  export type userSkillOrderByWithAggregationInput = {
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: userSkillCountOrderByAggregateInput
    _avg?: userSkillAvgOrderByAggregateInput
    _max?: userSkillMaxOrderByAggregateInput
    _min?: userSkillMinOrderByAggregateInput
    _sum?: userSkillSumOrderByAggregateInput
  }

  export type userSkillScalarWhereWithAggregatesInput = {
    AND?: userSkillScalarWhereWithAggregatesInput | userSkillScalarWhereWithAggregatesInput[]
    OR?: userSkillScalarWhereWithAggregatesInput[]
    NOT?: userSkillScalarWhereWithAggregatesInput | userSkillScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"userSkill"> | string
    skillId?: StringWithAggregatesFilter<"userSkill"> | string
    level?: IntNullableWithAggregatesFilter<"userSkill"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"userSkill"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"userSkill"> | Date | string | null
  }

  export type userStatisticsWhereInput = {
    AND?: userStatisticsWhereInput | userStatisticsWhereInput[]
    OR?: userStatisticsWhereInput[]
    NOT?: userStatisticsWhereInput | userStatisticsWhereInput[]
    userId?: StringFilter<"userStatistics"> | string
    servicesProvided?: IntNullableFilter<"userStatistics"> | number | null
    servicesReceived?: IntNullableFilter<"userStatistics"> | number | null
    activitiesParticipated?: IntNullableFilter<"userStatistics"> | number | null
    activitiesOrganized?: IntNullableFilter<"userStatistics"> | number | null
    forumMessages?: IntNullableFilter<"userStatistics"> | number | null
    totalHelpPoints?: IntNullableFilter<"userStatistics"> | number | null
    networkSize?: IntNullableFilter<"userStatistics"> | number | null
    createdAt?: DateTimeFilter<"userStatistics"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userStatistics"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userStatisticsOrderByWithRelationInput = {
    userId?: SortOrder
    servicesProvided?: SortOrderInput | SortOrder
    servicesReceived?: SortOrderInput | SortOrder
    activitiesParticipated?: SortOrderInput | SortOrder
    activitiesOrganized?: SortOrderInput | SortOrder
    forumMessages?: SortOrderInput | SortOrder
    totalHelpPoints?: SortOrderInput | SortOrder
    networkSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type userStatisticsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: userStatisticsWhereInput | userStatisticsWhereInput[]
    OR?: userStatisticsWhereInput[]
    NOT?: userStatisticsWhereInput | userStatisticsWhereInput[]
    servicesProvided?: IntNullableFilter<"userStatistics"> | number | null
    servicesReceived?: IntNullableFilter<"userStatistics"> | number | null
    activitiesParticipated?: IntNullableFilter<"userStatistics"> | number | null
    activitiesOrganized?: IntNullableFilter<"userStatistics"> | number | null
    forumMessages?: IntNullableFilter<"userStatistics"> | number | null
    totalHelpPoints?: IntNullableFilter<"userStatistics"> | number | null
    networkSize?: IntNullableFilter<"userStatistics"> | number | null
    createdAt?: DateTimeFilter<"userStatistics"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userStatistics"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "userId">

  export type userStatisticsOrderByWithAggregationInput = {
    userId?: SortOrder
    servicesProvided?: SortOrderInput | SortOrder
    servicesReceived?: SortOrderInput | SortOrder
    activitiesParticipated?: SortOrderInput | SortOrder
    activitiesOrganized?: SortOrderInput | SortOrder
    forumMessages?: SortOrderInput | SortOrder
    totalHelpPoints?: SortOrderInput | SortOrder
    networkSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: userStatisticsCountOrderByAggregateInput
    _avg?: userStatisticsAvgOrderByAggregateInput
    _max?: userStatisticsMaxOrderByAggregateInput
    _min?: userStatisticsMinOrderByAggregateInput
    _sum?: userStatisticsSumOrderByAggregateInput
  }

  export type userStatisticsScalarWhereWithAggregatesInput = {
    AND?: userStatisticsScalarWhereWithAggregatesInput | userStatisticsScalarWhereWithAggregatesInput[]
    OR?: userStatisticsScalarWhereWithAggregatesInput[]
    NOT?: userStatisticsScalarWhereWithAggregatesInput | userStatisticsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"userStatistics"> | string
    servicesProvided?: IntNullableWithAggregatesFilter<"userStatistics"> | number | null
    servicesReceived?: IntNullableWithAggregatesFilter<"userStatistics"> | number | null
    activitiesParticipated?: IntNullableWithAggregatesFilter<"userStatistics"> | number | null
    activitiesOrganized?: IntNullableWithAggregatesFilter<"userStatistics"> | number | null
    forumMessages?: IntNullableWithAggregatesFilter<"userStatistics"> | number | null
    totalHelpPoints?: IntNullableWithAggregatesFilter<"userStatistics"> | number | null
    networkSize?: IntNullableWithAggregatesFilter<"userStatistics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"userStatistics"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"userStatistics"> | Date | string | null
  }

  export type videoCallWhereInput = {
    AND?: videoCallWhereInput | videoCallWhereInput[]
    OR?: videoCallWhereInput[]
    NOT?: videoCallWhereInput | videoCallWhereInput[]
    id?: StringFilter<"videoCall"> | string
    conversationId?: StringFilter<"videoCall"> | string
    initiatorId?: StringFilter<"videoCall"> | string
    startDate?: DateTimeFilter<"videoCall"> | Date | string
    endDate?: DateTimeFilter<"videoCall"> | Date | string
    status?: StringFilter<"videoCall"> | string
    createdAt?: DateTimeFilter<"videoCall"> | Date | string
    updatedAt?: DateTimeNullableFilter<"videoCall"> | Date | string | null
    conversation?: XOR<ConversationNullableScalarRelationFilter, conversationWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type videoCallOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    initiatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    conversation?: conversationOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type videoCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: videoCallWhereInput | videoCallWhereInput[]
    OR?: videoCallWhereInput[]
    NOT?: videoCallWhereInput | videoCallWhereInput[]
    conversationId?: StringFilter<"videoCall"> | string
    initiatorId?: StringFilter<"videoCall"> | string
    startDate?: DateTimeFilter<"videoCall"> | Date | string
    endDate?: DateTimeFilter<"videoCall"> | Date | string
    status?: StringFilter<"videoCall"> | string
    createdAt?: DateTimeFilter<"videoCall"> | Date | string
    updatedAt?: DateTimeNullableFilter<"videoCall"> | Date | string | null
    conversation?: XOR<ConversationNullableScalarRelationFilter, conversationWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type videoCallOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    initiatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: videoCallCountOrderByAggregateInput
    _max?: videoCallMaxOrderByAggregateInput
    _min?: videoCallMinOrderByAggregateInput
  }

  export type videoCallScalarWhereWithAggregatesInput = {
    AND?: videoCallScalarWhereWithAggregatesInput | videoCallScalarWhereWithAggregatesInput[]
    OR?: videoCallScalarWhereWithAggregatesInput[]
    NOT?: videoCallScalarWhereWithAggregatesInput | videoCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"videoCall"> | string
    conversationId?: StringWithAggregatesFilter<"videoCall"> | string
    initiatorId?: StringWithAggregatesFilter<"videoCall"> | string
    startDate?: DateTimeWithAggregatesFilter<"videoCall"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"videoCall"> | Date | string
    status?: StringWithAggregatesFilter<"videoCall"> | string
    createdAt?: DateTimeWithAggregatesFilter<"videoCall"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"videoCall"> | Date | string | null
  }

  export type wellnessBadgeWhereInput = {
    AND?: wellnessBadgeWhereInput | wellnessBadgeWhereInput[]
    OR?: wellnessBadgeWhereInput[]
    NOT?: wellnessBadgeWhereInput | wellnessBadgeWhereInput[]
    id?: StringFilter<"wellnessBadge"> | string
    name?: StringFilter<"wellnessBadge"> | string
    description?: StringNullableFilter<"wellnessBadge"> | string | null
    categoryId?: StringNullableFilter<"wellnessBadge"> | string | null
    image?: StringNullableFilter<"wellnessBadge"> | string | null
    level?: IntFilter<"wellnessBadge"> | number
    createdAt?: DateTimeFilter<"wellnessBadge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessBadge"> | Date | string | null
    wellnessCategory?: XOR<WellnessCategoryNullableScalarRelationFilter, wellnessCategoryWhereInput> | null
  }

  export type wellnessBadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    wellnessCategory?: wellnessCategoryOrderByWithRelationInput
  }

  export type wellnessBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: wellnessBadgeWhereInput | wellnessBadgeWhereInput[]
    OR?: wellnessBadgeWhereInput[]
    NOT?: wellnessBadgeWhereInput | wellnessBadgeWhereInput[]
    name?: StringFilter<"wellnessBadge"> | string
    description?: StringNullableFilter<"wellnessBadge"> | string | null
    categoryId?: StringNullableFilter<"wellnessBadge"> | string | null
    image?: StringNullableFilter<"wellnessBadge"> | string | null
    level?: IntFilter<"wellnessBadge"> | number
    createdAt?: DateTimeFilter<"wellnessBadge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessBadge"> | Date | string | null
    wellnessCategory?: XOR<WellnessCategoryNullableScalarRelationFilter, wellnessCategoryWhereInput> | null
  }, "id">

  export type wellnessBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: wellnessBadgeCountOrderByAggregateInput
    _avg?: wellnessBadgeAvgOrderByAggregateInput
    _max?: wellnessBadgeMaxOrderByAggregateInput
    _min?: wellnessBadgeMinOrderByAggregateInput
    _sum?: wellnessBadgeSumOrderByAggregateInput
  }

  export type wellnessBadgeScalarWhereWithAggregatesInput = {
    AND?: wellnessBadgeScalarWhereWithAggregatesInput | wellnessBadgeScalarWhereWithAggregatesInput[]
    OR?: wellnessBadgeScalarWhereWithAggregatesInput[]
    NOT?: wellnessBadgeScalarWhereWithAggregatesInput | wellnessBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"wellnessBadge"> | string
    name?: StringWithAggregatesFilter<"wellnessBadge"> | string
    description?: StringNullableWithAggregatesFilter<"wellnessBadge"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"wellnessBadge"> | string | null
    image?: StringNullableWithAggregatesFilter<"wellnessBadge"> | string | null
    level?: IntWithAggregatesFilter<"wellnessBadge"> | number
    createdAt?: DateTimeWithAggregatesFilter<"wellnessBadge"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"wellnessBadge"> | Date | string | null
  }

  export type wellnessGoalWhereInput = {
    AND?: wellnessGoalWhereInput | wellnessGoalWhereInput[]
    OR?: wellnessGoalWhereInput[]
    NOT?: wellnessGoalWhereInput | wellnessGoalWhereInput[]
    id?: StringFilter<"wellnessGoal"> | string
    userId?: StringFilter<"wellnessGoal"> | string
    title?: StringFilter<"wellnessGoal"> | string
    categoryId?: StringNullableFilter<"wellnessGoal"> | string | null
    targetValue?: IntFilter<"wellnessGoal"> | number
    unit?: StringFilter<"wellnessGoal"> | string
    frequency?: StringFilter<"wellnessGoal"> | string
    startDate?: DateTimeFilter<"wellnessGoal"> | Date | string
    endDate?: DateTimeFilter<"wellnessGoal"> | Date | string
    active?: BoolFilter<"wellnessGoal"> | boolean
    createdAt?: DateTimeFilter<"wellnessGoal"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessGoal"> | Date | string | null
    wellnessGoalProgress?: WellnessGoalProgressListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    wellnessCategory?: XOR<WellnessCategoryNullableScalarRelationFilter, wellnessCategoryWhereInput> | null
  }

  export type wellnessGoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    wellnessGoalProgress?: wellnessGoalProgressOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    wellnessCategory?: wellnessCategoryOrderByWithRelationInput
  }

  export type wellnessGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: wellnessGoalWhereInput | wellnessGoalWhereInput[]
    OR?: wellnessGoalWhereInput[]
    NOT?: wellnessGoalWhereInput | wellnessGoalWhereInput[]
    userId?: StringFilter<"wellnessGoal"> | string
    title?: StringFilter<"wellnessGoal"> | string
    categoryId?: StringNullableFilter<"wellnessGoal"> | string | null
    targetValue?: IntFilter<"wellnessGoal"> | number
    unit?: StringFilter<"wellnessGoal"> | string
    frequency?: StringFilter<"wellnessGoal"> | string
    startDate?: DateTimeFilter<"wellnessGoal"> | Date | string
    endDate?: DateTimeFilter<"wellnessGoal"> | Date | string
    active?: BoolFilter<"wellnessGoal"> | boolean
    createdAt?: DateTimeFilter<"wellnessGoal"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessGoal"> | Date | string | null
    wellnessGoalProgress?: WellnessGoalProgressListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    wellnessCategory?: XOR<WellnessCategoryNullableScalarRelationFilter, wellnessCategoryWhereInput> | null
  }, "id">

  export type wellnessGoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: wellnessGoalCountOrderByAggregateInput
    _avg?: wellnessGoalAvgOrderByAggregateInput
    _max?: wellnessGoalMaxOrderByAggregateInput
    _min?: wellnessGoalMinOrderByAggregateInput
    _sum?: wellnessGoalSumOrderByAggregateInput
  }

  export type wellnessGoalScalarWhereWithAggregatesInput = {
    AND?: wellnessGoalScalarWhereWithAggregatesInput | wellnessGoalScalarWhereWithAggregatesInput[]
    OR?: wellnessGoalScalarWhereWithAggregatesInput[]
    NOT?: wellnessGoalScalarWhereWithAggregatesInput | wellnessGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"wellnessGoal"> | string
    userId?: StringWithAggregatesFilter<"wellnessGoal"> | string
    title?: StringWithAggregatesFilter<"wellnessGoal"> | string
    categoryId?: StringNullableWithAggregatesFilter<"wellnessGoal"> | string | null
    targetValue?: IntWithAggregatesFilter<"wellnessGoal"> | number
    unit?: StringWithAggregatesFilter<"wellnessGoal"> | string
    frequency?: StringWithAggregatesFilter<"wellnessGoal"> | string
    startDate?: DateTimeWithAggregatesFilter<"wellnessGoal"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"wellnessGoal"> | Date | string
    active?: BoolWithAggregatesFilter<"wellnessGoal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"wellnessGoal"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"wellnessGoal"> | Date | string | null
  }

  export type wellnessGoalProgressWhereInput = {
    AND?: wellnessGoalProgressWhereInput | wellnessGoalProgressWhereInput[]
    OR?: wellnessGoalProgressWhereInput[]
    NOT?: wellnessGoalProgressWhereInput | wellnessGoalProgressWhereInput[]
    id?: StringFilter<"wellnessGoalProgress"> | string
    goalId?: StringFilter<"wellnessGoalProgress"> | string
    recordingDate?: DateTimeFilter<"wellnessGoalProgress"> | Date | string
    achievedValue?: IntFilter<"wellnessGoalProgress"> | number
    goalAchieved?: BoolFilter<"wellnessGoalProgress"> | boolean
    createdAt?: DateTimeFilter<"wellnessGoalProgress"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessGoalProgress"> | Date | string | null
    wellnessGoal?: XOR<WellnessGoalScalarRelationFilter, wellnessGoalWhereInput>
  }

  export type wellnessGoalProgressOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    recordingDate?: SortOrder
    achievedValue?: SortOrder
    goalAchieved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    wellnessGoal?: wellnessGoalOrderByWithRelationInput
  }

  export type wellnessGoalProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: wellnessGoalProgressWhereInput | wellnessGoalProgressWhereInput[]
    OR?: wellnessGoalProgressWhereInput[]
    NOT?: wellnessGoalProgressWhereInput | wellnessGoalProgressWhereInput[]
    goalId?: StringFilter<"wellnessGoalProgress"> | string
    recordingDate?: DateTimeFilter<"wellnessGoalProgress"> | Date | string
    achievedValue?: IntFilter<"wellnessGoalProgress"> | number
    goalAchieved?: BoolFilter<"wellnessGoalProgress"> | boolean
    createdAt?: DateTimeFilter<"wellnessGoalProgress"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessGoalProgress"> | Date | string | null
    wellnessGoal?: XOR<WellnessGoalScalarRelationFilter, wellnessGoalWhereInput>
  }, "id">

  export type wellnessGoalProgressOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    recordingDate?: SortOrder
    achievedValue?: SortOrder
    goalAchieved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: wellnessGoalProgressCountOrderByAggregateInput
    _avg?: wellnessGoalProgressAvgOrderByAggregateInput
    _max?: wellnessGoalProgressMaxOrderByAggregateInput
    _min?: wellnessGoalProgressMinOrderByAggregateInput
    _sum?: wellnessGoalProgressSumOrderByAggregateInput
  }

  export type wellnessGoalProgressScalarWhereWithAggregatesInput = {
    AND?: wellnessGoalProgressScalarWhereWithAggregatesInput | wellnessGoalProgressScalarWhereWithAggregatesInput[]
    OR?: wellnessGoalProgressScalarWhereWithAggregatesInput[]
    NOT?: wellnessGoalProgressScalarWhereWithAggregatesInput | wellnessGoalProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"wellnessGoalProgress"> | string
    goalId?: StringWithAggregatesFilter<"wellnessGoalProgress"> | string
    recordingDate?: DateTimeWithAggregatesFilter<"wellnessGoalProgress"> | Date | string
    achievedValue?: IntWithAggregatesFilter<"wellnessGoalProgress"> | number
    goalAchieved?: BoolWithAggregatesFilter<"wellnessGoalProgress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"wellnessGoalProgress"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"wellnessGoalProgress"> | Date | string | null
  }

  export type activityCategoryWhereInput = {
    AND?: activityCategoryWhereInput | activityCategoryWhereInput[]
    OR?: activityCategoryWhereInput[]
    NOT?: activityCategoryWhereInput | activityCategoryWhereInput[]
    id?: StringFilter<"activityCategory"> | string
    name?: StringFilter<"activityCategory"> | string
    description?: StringNullableFilter<"activityCategory"> | string | null
    createdAt?: DateTimeFilter<"activityCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityCategory"> | Date | string | null
    activity?: ActivityListRelationFilter
  }

  export type activityCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    activity?: activityOrderByRelationAggregateInput
  }

  export type activityCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: activityCategoryWhereInput | activityCategoryWhereInput[]
    OR?: activityCategoryWhereInput[]
    NOT?: activityCategoryWhereInput | activityCategoryWhereInput[]
    name?: StringFilter<"activityCategory"> | string
    description?: StringNullableFilter<"activityCategory"> | string | null
    createdAt?: DateTimeFilter<"activityCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityCategory"> | Date | string | null
    activity?: ActivityListRelationFilter
  }, "id">

  export type activityCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: activityCategoryCountOrderByAggregateInput
    _max?: activityCategoryMaxOrderByAggregateInput
    _min?: activityCategoryMinOrderByAggregateInput
  }

  export type activityCategoryScalarWhereWithAggregatesInput = {
    AND?: activityCategoryScalarWhereWithAggregatesInput | activityCategoryScalarWhereWithAggregatesInput[]
    OR?: activityCategoryScalarWhereWithAggregatesInput[]
    NOT?: activityCategoryScalarWhereWithAggregatesInput | activityCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"activityCategory"> | string
    name?: StringWithAggregatesFilter<"activityCategory"> | string
    description?: StringNullableWithAggregatesFilter<"activityCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"activityCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"activityCategory"> | Date | string | null
  }

  export type badgeCategoryWhereInput = {
    AND?: badgeCategoryWhereInput | badgeCategoryWhereInput[]
    OR?: badgeCategoryWhereInput[]
    NOT?: badgeCategoryWhereInput | badgeCategoryWhereInput[]
    id?: StringFilter<"badgeCategory"> | string
    name?: StringFilter<"badgeCategory"> | string
    description?: StringNullableFilter<"badgeCategory"> | string | null
    createdAt?: DateTimeFilter<"badgeCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"badgeCategory"> | Date | string | null
    badge?: BadgeListRelationFilter
  }

  export type badgeCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    badge?: badgeOrderByRelationAggregateInput
  }

  export type badgeCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: badgeCategoryWhereInput | badgeCategoryWhereInput[]
    OR?: badgeCategoryWhereInput[]
    NOT?: badgeCategoryWhereInput | badgeCategoryWhereInput[]
    name?: StringFilter<"badgeCategory"> | string
    description?: StringNullableFilter<"badgeCategory"> | string | null
    createdAt?: DateTimeFilter<"badgeCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"badgeCategory"> | Date | string | null
    badge?: BadgeListRelationFilter
  }, "id">

  export type badgeCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: badgeCategoryCountOrderByAggregateInput
    _max?: badgeCategoryMaxOrderByAggregateInput
    _min?: badgeCategoryMinOrderByAggregateInput
  }

  export type badgeCategoryScalarWhereWithAggregatesInput = {
    AND?: badgeCategoryScalarWhereWithAggregatesInput | badgeCategoryScalarWhereWithAggregatesInput[]
    OR?: badgeCategoryScalarWhereWithAggregatesInput[]
    NOT?: badgeCategoryScalarWhereWithAggregatesInput | badgeCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"badgeCategory"> | string
    name?: StringWithAggregatesFilter<"badgeCategory"> | string
    description?: StringNullableWithAggregatesFilter<"badgeCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"badgeCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"badgeCategory"> | Date | string | null
  }

  export type cognitiveCategoryWhereInput = {
    AND?: cognitiveCategoryWhereInput | cognitiveCategoryWhereInput[]
    OR?: cognitiveCategoryWhereInput[]
    NOT?: cognitiveCategoryWhereInput | cognitiveCategoryWhereInput[]
    id?: StringFilter<"cognitiveCategory"> | string
    name?: StringFilter<"cognitiveCategory"> | string
    description?: StringNullableFilter<"cognitiveCategory"> | string | null
    createdAt?: DateTimeFilter<"cognitiveCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"cognitiveCategory"> | Date | string | null
    cognitiveExercise?: CognitiveExerciseListRelationFilter
  }

  export type cognitiveCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    cognitiveExercise?: cognitiveExerciseOrderByRelationAggregateInput
  }

  export type cognitiveCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cognitiveCategoryWhereInput | cognitiveCategoryWhereInput[]
    OR?: cognitiveCategoryWhereInput[]
    NOT?: cognitiveCategoryWhereInput | cognitiveCategoryWhereInput[]
    name?: StringFilter<"cognitiveCategory"> | string
    description?: StringNullableFilter<"cognitiveCategory"> | string | null
    createdAt?: DateTimeFilter<"cognitiveCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"cognitiveCategory"> | Date | string | null
    cognitiveExercise?: CognitiveExerciseListRelationFilter
  }, "id">

  export type cognitiveCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: cognitiveCategoryCountOrderByAggregateInput
    _max?: cognitiveCategoryMaxOrderByAggregateInput
    _min?: cognitiveCategoryMinOrderByAggregateInput
  }

  export type cognitiveCategoryScalarWhereWithAggregatesInput = {
    AND?: cognitiveCategoryScalarWhereWithAggregatesInput | cognitiveCategoryScalarWhereWithAggregatesInput[]
    OR?: cognitiveCategoryScalarWhereWithAggregatesInput[]
    NOT?: cognitiveCategoryScalarWhereWithAggregatesInput | cognitiveCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cognitiveCategory"> | string
    name?: StringWithAggregatesFilter<"cognitiveCategory"> | string
    description?: StringNullableWithAggregatesFilter<"cognitiveCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"cognitiveCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"cognitiveCategory"> | Date | string | null
  }

  export type helpCategoryWhereInput = {
    AND?: helpCategoryWhereInput | helpCategoryWhereInput[]
    OR?: helpCategoryWhereInput[]
    NOT?: helpCategoryWhereInput | helpCategoryWhereInput[]
    id?: StringFilter<"helpCategory"> | string
    name?: StringFilter<"helpCategory"> | string
    description?: StringNullableFilter<"helpCategory"> | string | null
    createdAt?: DateTimeFilter<"helpCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpCategory"> | Date | string | null
    helpRequest?: HelpRequestListRelationFilter
  }

  export type helpCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    helpRequest?: helpRequestOrderByRelationAggregateInput
  }

  export type helpCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: helpCategoryWhereInput | helpCategoryWhereInput[]
    OR?: helpCategoryWhereInput[]
    NOT?: helpCategoryWhereInput | helpCategoryWhereInput[]
    name?: StringFilter<"helpCategory"> | string
    description?: StringNullableFilter<"helpCategory"> | string | null
    createdAt?: DateTimeFilter<"helpCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpCategory"> | Date | string | null
    helpRequest?: HelpRequestListRelationFilter
  }, "id">

  export type helpCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: helpCategoryCountOrderByAggregateInput
    _max?: helpCategoryMaxOrderByAggregateInput
    _min?: helpCategoryMinOrderByAggregateInput
  }

  export type helpCategoryScalarWhereWithAggregatesInput = {
    AND?: helpCategoryScalarWhereWithAggregatesInput | helpCategoryScalarWhereWithAggregatesInput[]
    OR?: helpCategoryScalarWhereWithAggregatesInput[]
    NOT?: helpCategoryScalarWhereWithAggregatesInput | helpCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"helpCategory"> | string
    name?: StringWithAggregatesFilter<"helpCategory"> | string
    description?: StringNullableWithAggregatesFilter<"helpCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"helpCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"helpCategory"> | Date | string | null
  }

  export type issueCategoryWhereInput = {
    AND?: issueCategoryWhereInput | issueCategoryWhereInput[]
    OR?: issueCategoryWhereInput[]
    NOT?: issueCategoryWhereInput | issueCategoryWhereInput[]
    id?: StringFilter<"issueCategory"> | string
    name?: StringFilter<"issueCategory"> | string
    description?: StringNullableFilter<"issueCategory"> | string | null
    createdAt?: DateTimeFilter<"issueCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"issueCategory"> | Date | string | null
    urbanIssueReport?: UrbanIssueReportListRelationFilter
  }

  export type issueCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    urbanIssueReport?: urbanIssueReportOrderByRelationAggregateInput
  }

  export type issueCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: issueCategoryWhereInput | issueCategoryWhereInput[]
    OR?: issueCategoryWhereInput[]
    NOT?: issueCategoryWhereInput | issueCategoryWhereInput[]
    name?: StringFilter<"issueCategory"> | string
    description?: StringNullableFilter<"issueCategory"> | string | null
    createdAt?: DateTimeFilter<"issueCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"issueCategory"> | Date | string | null
    urbanIssueReport?: UrbanIssueReportListRelationFilter
  }, "id">

  export type issueCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: issueCategoryCountOrderByAggregateInput
    _max?: issueCategoryMaxOrderByAggregateInput
    _min?: issueCategoryMinOrderByAggregateInput
  }

  export type issueCategoryScalarWhereWithAggregatesInput = {
    AND?: issueCategoryScalarWhereWithAggregatesInput | issueCategoryScalarWhereWithAggregatesInput[]
    OR?: issueCategoryScalarWhereWithAggregatesInput[]
    NOT?: issueCategoryScalarWhereWithAggregatesInput | issueCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"issueCategory"> | string
    name?: StringWithAggregatesFilter<"issueCategory"> | string
    description?: StringNullableWithAggregatesFilter<"issueCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"issueCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"issueCategory"> | Date | string | null
  }

  export type nutritionalCategoryWhereInput = {
    AND?: nutritionalCategoryWhereInput | nutritionalCategoryWhereInput[]
    OR?: nutritionalCategoryWhereInput[]
    NOT?: nutritionalCategoryWhereInput | nutritionalCategoryWhereInput[]
    id?: StringFilter<"nutritionalCategory"> | string
    name?: StringFilter<"nutritionalCategory"> | string
    description?: StringNullableFilter<"nutritionalCategory"> | string | null
    createdAt?: DateTimeFilter<"nutritionalCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"nutritionalCategory"> | Date | string | null
    nutritionalAdvice?: NutritionalAdviceListRelationFilter
  }

  export type nutritionalCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    nutritionalAdvice?: nutritionalAdviceOrderByRelationAggregateInput
  }

  export type nutritionalCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: nutritionalCategoryWhereInput | nutritionalCategoryWhereInput[]
    OR?: nutritionalCategoryWhereInput[]
    NOT?: nutritionalCategoryWhereInput | nutritionalCategoryWhereInput[]
    name?: StringFilter<"nutritionalCategory"> | string
    description?: StringNullableFilter<"nutritionalCategory"> | string | null
    createdAt?: DateTimeFilter<"nutritionalCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"nutritionalCategory"> | Date | string | null
    nutritionalAdvice?: NutritionalAdviceListRelationFilter
  }, "id">

  export type nutritionalCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: nutritionalCategoryCountOrderByAggregateInput
    _max?: nutritionalCategoryMaxOrderByAggregateInput
    _min?: nutritionalCategoryMinOrderByAggregateInput
  }

  export type nutritionalCategoryScalarWhereWithAggregatesInput = {
    AND?: nutritionalCategoryScalarWhereWithAggregatesInput | nutritionalCategoryScalarWhereWithAggregatesInput[]
    OR?: nutritionalCategoryScalarWhereWithAggregatesInput[]
    NOT?: nutritionalCategoryScalarWhereWithAggregatesInput | nutritionalCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"nutritionalCategory"> | string
    name?: StringWithAggregatesFilter<"nutritionalCategory"> | string
    description?: StringNullableWithAggregatesFilter<"nutritionalCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"nutritionalCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"nutritionalCategory"> | Date | string | null
  }

  export type programCategoryWhereInput = {
    AND?: programCategoryWhereInput | programCategoryWhereInput[]
    OR?: programCategoryWhereInput[]
    NOT?: programCategoryWhereInput | programCategoryWhereInput[]
    id?: StringFilter<"programCategory"> | string
    name?: StringFilter<"programCategory"> | string
    description?: StringNullableFilter<"programCategory"> | string | null
    createdAt?: DateTimeFilter<"programCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"programCategory"> | Date | string | null
    cognitiveExercise?: CognitiveExerciseListRelationFilter
    exerciseProgram?: ExerciseProgramListRelationFilter
  }

  export type programCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    cognitiveExercise?: cognitiveExerciseOrderByRelationAggregateInput
    exerciseProgram?: exerciseProgramOrderByRelationAggregateInput
  }

  export type programCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: programCategoryWhereInput | programCategoryWhereInput[]
    OR?: programCategoryWhereInput[]
    NOT?: programCategoryWhereInput | programCategoryWhereInput[]
    name?: StringFilter<"programCategory"> | string
    description?: StringNullableFilter<"programCategory"> | string | null
    createdAt?: DateTimeFilter<"programCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"programCategory"> | Date | string | null
    cognitiveExercise?: CognitiveExerciseListRelationFilter
    exerciseProgram?: ExerciseProgramListRelationFilter
  }, "id">

  export type programCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: programCategoryCountOrderByAggregateInput
    _max?: programCategoryMaxOrderByAggregateInput
    _min?: programCategoryMinOrderByAggregateInput
  }

  export type programCategoryScalarWhereWithAggregatesInput = {
    AND?: programCategoryScalarWhereWithAggregatesInput | programCategoryScalarWhereWithAggregatesInput[]
    OR?: programCategoryScalarWhereWithAggregatesInput[]
    NOT?: programCategoryScalarWhereWithAggregatesInput | programCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"programCategory"> | string
    name?: StringWithAggregatesFilter<"programCategory"> | string
    description?: StringNullableWithAggregatesFilter<"programCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"programCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"programCategory"> | Date | string | null
  }

  export type projectCategoryWhereInput = {
    AND?: projectCategoryWhereInput | projectCategoryWhereInput[]
    OR?: projectCategoryWhereInput[]
    NOT?: projectCategoryWhereInput | projectCategoryWhereInput[]
    id?: StringFilter<"projectCategory"> | string
    name?: StringFilter<"projectCategory"> | string
    description?: StringNullableFilter<"projectCategory"> | string | null
    createdAt?: DateTimeFilter<"projectCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectCategory"> | Date | string | null
    collaborativeProject?: CollaborativeProjectListRelationFilter
  }

  export type projectCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    collaborativeProject?: collaborativeProjectOrderByRelationAggregateInput
  }

  export type projectCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: projectCategoryWhereInput | projectCategoryWhereInput[]
    OR?: projectCategoryWhereInput[]
    NOT?: projectCategoryWhereInput | projectCategoryWhereInput[]
    name?: StringFilter<"projectCategory"> | string
    description?: StringNullableFilter<"projectCategory"> | string | null
    createdAt?: DateTimeFilter<"projectCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectCategory"> | Date | string | null
    collaborativeProject?: CollaborativeProjectListRelationFilter
  }, "id">

  export type projectCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: projectCategoryCountOrderByAggregateInput
    _max?: projectCategoryMaxOrderByAggregateInput
    _min?: projectCategoryMinOrderByAggregateInput
  }

  export type projectCategoryScalarWhereWithAggregatesInput = {
    AND?: projectCategoryScalarWhereWithAggregatesInput | projectCategoryScalarWhereWithAggregatesInput[]
    OR?: projectCategoryScalarWhereWithAggregatesInput[]
    NOT?: projectCategoryScalarWhereWithAggregatesInput | projectCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"projectCategory"> | string
    name?: StringWithAggregatesFilter<"projectCategory"> | string
    description?: StringNullableWithAggregatesFilter<"projectCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"projectCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"projectCategory"> | Date | string | null
  }

  export type resourceCategoryWhereInput = {
    AND?: resourceCategoryWhereInput | resourceCategoryWhereInput[]
    OR?: resourceCategoryWhereInput[]
    NOT?: resourceCategoryWhereInput | resourceCategoryWhereInput[]
    id?: StringFilter<"resourceCategory"> | string
    name?: StringFilter<"resourceCategory"> | string
    description?: StringNullableFilter<"resourceCategory"> | string | null
    createdAt?: DateTimeFilter<"resourceCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"resourceCategory"> | Date | string | null
    resource?: ResourceListRelationFilter
  }

  export type resourceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    resource?: resourceOrderByRelationAggregateInput
  }

  export type resourceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: resourceCategoryWhereInput | resourceCategoryWhereInput[]
    OR?: resourceCategoryWhereInput[]
    NOT?: resourceCategoryWhereInput | resourceCategoryWhereInput[]
    name?: StringFilter<"resourceCategory"> | string
    description?: StringNullableFilter<"resourceCategory"> | string | null
    createdAt?: DateTimeFilter<"resourceCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"resourceCategory"> | Date | string | null
    resource?: ResourceListRelationFilter
  }, "id">

  export type resourceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: resourceCategoryCountOrderByAggregateInput
    _max?: resourceCategoryMaxOrderByAggregateInput
    _min?: resourceCategoryMinOrderByAggregateInput
  }

  export type resourceCategoryScalarWhereWithAggregatesInput = {
    AND?: resourceCategoryScalarWhereWithAggregatesInput | resourceCategoryScalarWhereWithAggregatesInput[]
    OR?: resourceCategoryScalarWhereWithAggregatesInput[]
    NOT?: resourceCategoryScalarWhereWithAggregatesInput | resourceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"resourceCategory"> | string
    name?: StringWithAggregatesFilter<"resourceCategory"> | string
    description?: StringNullableWithAggregatesFilter<"resourceCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"resourceCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"resourceCategory"> | Date | string | null
  }

  export type serviceCategoryWhereInput = {
    AND?: serviceCategoryWhereInput | serviceCategoryWhereInput[]
    OR?: serviceCategoryWhereInput[]
    NOT?: serviceCategoryWhereInput | serviceCategoryWhereInput[]
    id?: StringFilter<"serviceCategory"> | string
    name?: StringFilter<"serviceCategory"> | string
    description?: StringNullableFilter<"serviceCategory"> | string | null
    createdAt?: DateTimeFilter<"serviceCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceCategory"> | Date | string | null
    localService?: LocalServiceListRelationFilter
  }

  export type serviceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    localService?: localServiceOrderByRelationAggregateInput
  }

  export type serviceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: serviceCategoryWhereInput | serviceCategoryWhereInput[]
    OR?: serviceCategoryWhereInput[]
    NOT?: serviceCategoryWhereInput | serviceCategoryWhereInput[]
    name?: StringFilter<"serviceCategory"> | string
    description?: StringNullableFilter<"serviceCategory"> | string | null
    createdAt?: DateTimeFilter<"serviceCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceCategory"> | Date | string | null
    localService?: LocalServiceListRelationFilter
  }, "id">

  export type serviceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: serviceCategoryCountOrderByAggregateInput
    _max?: serviceCategoryMaxOrderByAggregateInput
    _min?: serviceCategoryMinOrderByAggregateInput
  }

  export type serviceCategoryScalarWhereWithAggregatesInput = {
    AND?: serviceCategoryScalarWhereWithAggregatesInput | serviceCategoryScalarWhereWithAggregatesInput[]
    OR?: serviceCategoryScalarWhereWithAggregatesInput[]
    NOT?: serviceCategoryScalarWhereWithAggregatesInput | serviceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"serviceCategory"> | string
    name?: StringWithAggregatesFilter<"serviceCategory"> | string
    description?: StringNullableWithAggregatesFilter<"serviceCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"serviceCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"serviceCategory"> | Date | string | null
  }

  export type skillCategoryWhereInput = {
    AND?: skillCategoryWhereInput | skillCategoryWhereInput[]
    OR?: skillCategoryWhereInput[]
    NOT?: skillCategoryWhereInput | skillCategoryWhereInput[]
    id?: StringFilter<"skillCategory"> | string
    name?: StringFilter<"skillCategory"> | string
    description?: StringNullableFilter<"skillCategory"> | string | null
    createdAt?: DateTimeFilter<"skillCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"skillCategory"> | Date | string | null
    skill?: SkillListRelationFilter
  }

  export type skillCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    skill?: skillOrderByRelationAggregateInput
  }

  export type skillCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: skillCategoryWhereInput | skillCategoryWhereInput[]
    OR?: skillCategoryWhereInput[]
    NOT?: skillCategoryWhereInput | skillCategoryWhereInput[]
    name?: StringFilter<"skillCategory"> | string
    description?: StringNullableFilter<"skillCategory"> | string | null
    createdAt?: DateTimeFilter<"skillCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"skillCategory"> | Date | string | null
    skill?: SkillListRelationFilter
  }, "id">

  export type skillCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: skillCategoryCountOrderByAggregateInput
    _max?: skillCategoryMaxOrderByAggregateInput
    _min?: skillCategoryMinOrderByAggregateInput
  }

  export type skillCategoryScalarWhereWithAggregatesInput = {
    AND?: skillCategoryScalarWhereWithAggregatesInput | skillCategoryScalarWhereWithAggregatesInput[]
    OR?: skillCategoryScalarWhereWithAggregatesInput[]
    NOT?: skillCategoryScalarWhereWithAggregatesInput | skillCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"skillCategory"> | string
    name?: StringWithAggregatesFilter<"skillCategory"> | string
    description?: StringNullableWithAggregatesFilter<"skillCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"skillCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"skillCategory"> | Date | string | null
  }

  export type wellnessCategoryWhereInput = {
    AND?: wellnessCategoryWhereInput | wellnessCategoryWhereInput[]
    OR?: wellnessCategoryWhereInput[]
    NOT?: wellnessCategoryWhereInput | wellnessCategoryWhereInput[]
    id?: StringFilter<"wellnessCategory"> | string
    name?: StringFilter<"wellnessCategory"> | string
    description?: StringNullableFilter<"wellnessCategory"> | string | null
    createdAt?: DateTimeFilter<"wellnessCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessCategory"> | Date | string | null
    wellnessBadge?: WellnessBadgeListRelationFilter
    wellnessGoal?: WellnessGoalListRelationFilter
  }

  export type wellnessCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    wellnessBadge?: wellnessBadgeOrderByRelationAggregateInput
    wellnessGoal?: wellnessGoalOrderByRelationAggregateInput
  }

  export type wellnessCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: wellnessCategoryWhereInput | wellnessCategoryWhereInput[]
    OR?: wellnessCategoryWhereInput[]
    NOT?: wellnessCategoryWhereInput | wellnessCategoryWhereInput[]
    name?: StringFilter<"wellnessCategory"> | string
    description?: StringNullableFilter<"wellnessCategory"> | string | null
    createdAt?: DateTimeFilter<"wellnessCategory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessCategory"> | Date | string | null
    wellnessBadge?: WellnessBadgeListRelationFilter
    wellnessGoal?: WellnessGoalListRelationFilter
  }, "id">

  export type wellnessCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: wellnessCategoryCountOrderByAggregateInput
    _max?: wellnessCategoryMaxOrderByAggregateInput
    _min?: wellnessCategoryMinOrderByAggregateInput
  }

  export type wellnessCategoryScalarWhereWithAggregatesInput = {
    AND?: wellnessCategoryScalarWhereWithAggregatesInput | wellnessCategoryScalarWhereWithAggregatesInput[]
    OR?: wellnessCategoryScalarWhereWithAggregatesInput[]
    NOT?: wellnessCategoryScalarWhereWithAggregatesInput | wellnessCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"wellnessCategory"> | string
    name?: StringWithAggregatesFilter<"wellnessCategory"> | string
    description?: StringNullableWithAggregatesFilter<"wellnessCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"wellnessCategory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"wellnessCategory"> | Date | string | null
  }

  export type activityCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutActivityInput
    activityCategory?: activityCategoryCreateNestedOneWithoutActivityInput
    activity_registration?: activityRegistrationCreateNestedManyWithoutActivityInput
  }

  export type activityUncheckedCreateInput = {
    id?: string
    creatorId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    categoryId?: string | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity_registration?: activityRegistrationUncheckedCreateNestedManyWithoutActivityInput
  }

  export type activityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutActivityNestedInput
    activityCategory?: activityCategoryUpdateOneWithoutActivityNestedInput
    activity_registration?: activityRegistrationUpdateManyWithoutActivityNestedInput
  }

  export type activityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_registration?: activityRegistrationUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type activityCreateManyInput = {
    id?: string
    creatorId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    categoryId?: string | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityLogCreateInput = {
    id?: string
    actionType?: string | null
    description?: string | null
    ipAddress?: string | null
    device?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutActivityLogInput
  }

  export type activityLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    actionType?: string | null
    description?: string | null
    ipAddress?: string | null
    device?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutActivityLogNestedInput
  }

  export type activityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityLogCreateManyInput = {
    id?: string
    userId?: string | null
    actionType?: string | null
    description?: string | null
    ipAddress?: string | null
    device?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityRegistrationCreateInput = {
    id?: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity: activityCreateNestedOneWithoutActivity_registrationInput
    user: userCreateNestedOneWithoutActivityRegistrationInput
  }

  export type activityRegistrationUncheckedCreateInput = {
    id?: string
    activityId: string
    userId: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateOneRequiredWithoutActivity_registrationNestedInput
    user?: userUpdateOneRequiredWithoutActivityRegistrationNestedInput
  }

  export type activityRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityRegistrationCreateManyInput = {
    id?: string
    activityId: string
    userId: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userBadge?: userBadgeCreateNestedOneWithoutBadgeInput
    badgeCategory?: badgeCategoryCreateNestedOneWithoutBadgeInput
  }

  export type badgeUncheckedCreateInput = {
    id?: string
    name: string
    categoryId?: string | null
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userBadge?: userBadgeUncheckedCreateNestedOneWithoutBadgeInput
  }

  export type badgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBadge?: userBadgeUpdateOneWithoutBadgeNestedInput
    badgeCategory?: badgeCategoryUpdateOneWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBadge?: userBadgeUncheckedUpdateOneWithoutBadgeNestedInput
  }

  export type badgeCreateManyInput = {
    id?: string
    name: string
    categoryId?: string | null
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type badgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveExerciseCreateInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveCategory?: cognitiveCategoryCreateNestedOneWithoutCognitiveExerciseInput
    userActivity?: userActivityCreateNestedManyWithoutCognitiveExerciseInput
    programCategory?: programCategoryCreateNestedOneWithoutCognitiveExerciseInput
  }

  export type cognitiveExerciseUncheckedCreateInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    programCategoryId?: string | null
    userActivity?: userActivityUncheckedCreateNestedManyWithoutCognitiveExerciseInput
  }

  export type cognitiveExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveCategory?: cognitiveCategoryUpdateOneWithoutCognitiveExerciseNestedInput
    userActivity?: userActivityUpdateManyWithoutCognitiveExerciseNestedInput
    programCategory?: programCategoryUpdateOneWithoutCognitiveExerciseNestedInput
  }

  export type cognitiveExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    userActivity?: userActivityUncheckedUpdateManyWithoutCognitiveExerciseNestedInput
  }

  export type cognitiveExerciseCreateManyInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    programCategoryId?: string | null
  }

  export type cognitiveExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collaborativeProjectCreateInput = {
    id?: string
    title: string
    description?: string | null
    creationDate?: Date | string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutCollaborativeProjectInput
    projectCategory?: projectCategoryCreateNestedOneWithoutCollaborativeProjectInput
    projectMember?: projectMemberCreateNestedManyWithoutCollaborativeProjectInput
    projectTask?: projectTaskCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    creatorId: string
    creationDate?: Date | string
    status?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutCollaborativeProjectInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutCollaborativeProjectNestedInput
    projectCategory?: projectCategoryUpdateOneWithoutCollaborativeProjectNestedInput
    projectMember?: projectMemberUpdateManyWithoutCollaborativeProjectNestedInput
    projectTask?: projectTaskUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectMember?: projectMemberUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    creatorId: string
    creationDate?: Date | string
    status?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type collaborativeProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collaborativeProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationCreateInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutConversationInput
    message?: messageCreateNestedManyWithoutConversationInput
    videoCall?: videoCallCreateNestedManyWithoutConversationInput
  }

  export type conversationUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    message?: messageUncheckedCreateNestedManyWithoutConversationInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutConversationInput
  }

  export type conversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationParticipant?: conversationParticipantUpdateManyWithoutConversationNestedInput
    message?: messageUpdateManyWithoutConversationNestedInput
    videoCall?: videoCallUpdateManyWithoutConversationNestedInput
  }

  export type conversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    message?: messageUncheckedUpdateManyWithoutConversationNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type conversationCreateManyInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type conversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationParticipantCreateInput = {
    id?: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversation: conversationCreateNestedOneWithoutConversationParticipantInput
    user: userCreateNestedOneWithoutConversationParticipantInput
  }

  export type conversationParticipantUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type conversationParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: conversationUpdateOneRequiredWithoutConversationParticipantNestedInput
    user?: userUpdateOneRequiredWithoutConversationParticipantNestedInput
  }

  export type conversationParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationParticipantCreateManyInput = {
    id?: string
    conversationId: string
    userId: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type conversationParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type exerciseProgramCreateInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    programCategory?: programCategoryCreateNestedOneWithoutExerciseProgramInput
    userActivity?: userActivityCreateNestedManyWithoutExerciseProgramInput
  }

  export type exerciseProgramUncheckedCreateInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userActivity?: userActivityUncheckedCreateNestedManyWithoutExerciseProgramInput
  }

  export type exerciseProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programCategory?: programCategoryUpdateOneWithoutExerciseProgramNestedInput
    userActivity?: userActivityUpdateManyWithoutExerciseProgramNestedInput
  }

  export type exerciseProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userActivity?: userActivityUncheckedUpdateManyWithoutExerciseProgramNestedInput
  }

  export type exerciseProgramCreateManyInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type exerciseProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type exerciseProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    parentCategoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumTopic?: forumTopicCreateNestedManyWithoutForumCategoryInput
  }

  export type forumCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    parentCategoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutForumCategoryInput
  }

  export type forumCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumTopic?: forumTopicUpdateManyWithoutForumCategoryNestedInput
  }

  export type forumCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumTopic?: forumTopicUncheckedUpdateManyWithoutForumCategoryNestedInput
  }

  export type forumCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    parentCategoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageCreateInput = {
    id?: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutForumMessageInput
    forumTopic?: forumTopicCreateNestedOneWithoutForumMessageInput
  }

  export type forumMessageUncheckedCreateInput = {
    id?: string
    topicId: string
    authorId: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutForumMessageNestedInput
    forumTopic?: forumTopicUpdateOneWithoutForumMessageNestedInput
  }

  export type forumMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageCreateManyInput = {
    id?: string
    topicId: string
    authorId: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumTopicCreateInput = {
    id?: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumMessage?: forumMessageCreateNestedManyWithoutForumTopicInput
    user: userCreateNestedOneWithoutForumTopicInput
    forumCategory?: forumCategoryCreateNestedOneWithoutForumTopicInput
  }

  export type forumTopicUncheckedCreateInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutForumTopicInput
  }

  export type forumTopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumMessage?: forumMessageUpdateManyWithoutForumTopicNestedInput
    user?: userUpdateOneRequiredWithoutForumTopicNestedInput
    forumCategory?: forumCategoryUpdateOneWithoutForumTopicNestedInput
  }

  export type forumTopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumMessage?: forumMessageUncheckedUpdateManyWithoutForumTopicNestedInput
  }

  export type forumTopicCreateManyInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumTopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumTopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type healthIndicatorCreateInput = {
    id?: string
    recordingDate: Date | string
    stepCount?: number | null
    sleepDurationMinutes?: number | null
    sleepQuality?: number | null
    weight?: number | null
    mood?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutHealthIndicatorInput
  }

  export type healthIndicatorUncheckedCreateInput = {
    id?: string
    userId: string
    recordingDate: Date | string
    stepCount?: number | null
    sleepDurationMinutes?: number | null
    sleepQuality?: number | null
    weight?: number | null
    mood?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type healthIndicatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCount?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutHealthIndicatorNestedInput
  }

  export type healthIndicatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCount?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type healthIndicatorCreateManyInput = {
    id?: string
    userId: string
    recordingDate: Date | string
    stepCount?: number | null
    sleepDurationMinutes?: number | null
    sleepQuality?: number | null
    weight?: number | null
    mood?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type healthIndicatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCount?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type healthIndicatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCount?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpOfferCreateInput = {
    id?: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutHelpOfferInput
    helpRequest: helpRequestCreateNestedOneWithoutHelpOfferInput
  }

  export type helpOfferUncheckedCreateInput = {
    id?: string
    requestId: string
    helperId: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutHelpOfferNestedInput
    helpRequest?: helpRequestUpdateOneRequiredWithoutHelpOfferNestedInput
  }

  export type helpOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpOfferCreateManyInput = {
    id?: string
    requestId: string
    helperId: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpRequestCreateInput = {
    id?: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferCreateNestedManyWithoutHelpRequestInput
    user: userCreateNestedOneWithoutHelpRequestInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutHelpRequestInput
    helpCategory?: helpCategoryCreateNestedOneWithoutHelpRequestInput
  }

  export type helpRequestUncheckedCreateInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    categoryId: string
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutHelpRequestInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutHelpRequestInput
  }

  export type helpRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUpdateManyWithoutHelpRequestNestedInput
    user?: userUpdateOneRequiredWithoutHelpRequestNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutHelpRequestNestedInput
    helpCategory?: helpCategoryUpdateOneWithoutHelpRequestNestedInput
  }

  export type helpRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUncheckedUpdateManyWithoutHelpRequestNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutHelpRequestNestedInput
  }

  export type helpRequestCreateManyInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    categoryId: string
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type localServiceCreateInput = {
    id?: string
    name: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    serviceCategory?: serviceCategoryCreateNestedOneWithoutLocalServiceInput
    serviceRating?: serviceRatingCreateNestedManyWithoutLocalServiceInput
  }

  export type localServiceUncheckedCreateInput = {
    id?: string
    name: string
    categoryId: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutLocalServiceInput
  }

  export type localServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCategory?: serviceCategoryUpdateOneWithoutLocalServiceNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutLocalServiceNestedInput
  }

  export type localServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutLocalServiceNestedInput
  }

  export type localServiceCreateManyInput = {
    id?: string
    name: string
    categoryId: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type localServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type localServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicationReminderCreateInput = {
    id?: string
    medicationName: string
    dosage?: string | null
    morningReminderTime?: Date | string | null
    noonReminderTime?: Date | string | null
    eveningReminderTime?: Date | string | null
    nightReminderTime?: Date | string | null
    daysOfWeek?: string | null
    instructions?: string | null
    active?: boolean | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutMedicationReminderInput
  }

  export type medicationReminderUncheckedCreateInput = {
    id?: string
    userId: string
    medicationName: string
    dosage?: string | null
    morningReminderTime?: Date | string | null
    noonReminderTime?: Date | string | null
    eveningReminderTime?: Date | string | null
    nightReminderTime?: Date | string | null
    daysOfWeek?: string | null
    instructions?: string | null
    active?: boolean | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type medicationReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    morningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noonReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eveningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutMedicationReminderNestedInput
  }

  export type medicationReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    morningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noonReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eveningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicationReminderCreateManyInput = {
    id?: string
    userId: string
    medicationName: string
    dosage?: string | null
    morningReminderTime?: Date | string | null
    noonReminderTime?: Date | string | null
    eveningReminderTime?: Date | string | null
    nightReminderTime?: Date | string | null
    daysOfWeek?: string | null
    instructions?: string | null
    active?: boolean | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type medicationReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    morningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noonReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eveningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicationReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    morningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noonReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eveningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageCreateInput = {
    id?: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversation?: conversationCreateNestedOneWithoutMessageInput
    user?: userCreateNestedOneWithoutMessageInput
  }

  export type messageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type messageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: conversationUpdateOneWithoutMessageNestedInput
    user?: userUpdateOneWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type messageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type municipalEventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    gpsCoordinates?: string | null
    organizer?: string | null
    contact?: string | null
    officialLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type municipalEventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    gpsCoordinates?: string | null
    organizer?: string | null
    contact?: string | null
    officialLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type municipalEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    officialLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type municipalEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    officialLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type municipalEventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    gpsCoordinates?: string | null
    organizer?: string | null
    contact?: string | null
    officialLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type municipalEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    officialLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type municipalEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    officialLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationCreateInput = {
    id?: string
    type: string
    content: string
    read?: boolean | null
    actionLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    content: string
    read?: boolean | null
    actionLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    actionLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    actionLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    content: string
    read?: boolean | null
    actionLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    actionLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    actionLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationPreferencesCreateInput = {
    messageNotification?: boolean | null
    activityNotification?: boolean | null
    helpNotification?: boolean | null
    forumNotification?: boolean | null
    emailNotification?: boolean | null
    smsNotification?: boolean | null
    pushNotification?: boolean | null
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type notificationPreferencesUncheckedCreateInput = {
    userId: string
    messageNotification?: boolean | null
    activityNotification?: boolean | null
    helpNotification?: boolean | null
    forumNotification?: boolean | null
    emailNotification?: boolean | null
    smsNotification?: boolean | null
    pushNotification?: boolean | null
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationPreferencesUpdateInput = {
    messageNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    forumNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    smsNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type notificationPreferencesUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    messageNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    forumNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    smsNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationPreferencesCreateManyInput = {
    userId: string
    messageNotification?: boolean | null
    activityNotification?: boolean | null
    helpNotification?: boolean | null
    forumNotification?: boolean | null
    emailNotification?: boolean | null
    smsNotification?: boolean | null
    pushNotification?: boolean | null
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationPreferencesUpdateManyMutationInput = {
    messageNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    forumNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    smsNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationPreferencesUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    messageNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    forumNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    smsNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalAdviceCreateInput = {
    id?: string
    title: string
    description?: string | null
    season?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    nutritionalCategory?: nutritionalCategoryCreateNestedOneWithoutNutritionalAdviceInput
  }

  export type nutritionalAdviceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    categoryId: string
    season?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalAdviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionalCategory?: nutritionalCategoryUpdateOneWithoutNutritionalAdviceNestedInput
  }

  export type nutritionalAdviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    season?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalAdviceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    categoryId: string
    season?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalAdviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalAdviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    season?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberCreateInput = {
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    collaborativeProject: collaborativeProjectCreateNestedOneWithoutProjectMemberInput
    user: userCreateNestedOneWithoutProjectMemberInput
  }

  export type projectMemberUncheckedCreateInput = {
    projectId: string
    userId: string
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectMemberUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborativeProject?: collaborativeProjectUpdateOneRequiredWithoutProjectMemberNestedInput
    user?: userUpdateOneRequiredWithoutProjectMemberNestedInput
  }

  export type projectMemberUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberCreateManyInput = {
    projectId: string
    userId: string
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectMemberUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutProjectTaskInput
    collaborativeProject?: collaborativeProjectCreateNestedOneWithoutProjectTaskInput
  }

  export type projectTaskUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    assigneeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutProjectTaskNestedInput
    collaborativeProject?: collaborativeProjectUpdateOneWithoutProjectTaskNestedInput
  }

  export type projectTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectTaskCreateManyInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    assigneeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceCreateInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutResourceInput
    resourceCategory?: resourceCategoryCreateNestedOneWithoutResourceInput
  }

  export type resourceUncheckedCreateInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    categoryId?: string | null
    authorId: string
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutResourceNestedInput
    resourceCategory?: resourceCategoryUpdateOneWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceCreateManyInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    categoryId?: string | null
    authorId: string
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type satisfactionSurveyCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    surveyResponse?: surveyResponseCreateNestedManyWithoutSatisfactionSurveyInput
  }

  export type satisfactionSurveyUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutSatisfactionSurveyInput
  }

  export type satisfactionSurveyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyResponse?: surveyResponseUpdateManyWithoutSatisfactionSurveyNestedInput
  }

  export type satisfactionSurveyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutSatisfactionSurveyNestedInput
  }

  export type satisfactionSurveyCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type satisfactionSurveyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type satisfactionSurveyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionCreateInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    user: userCreateNestedOneWithoutSessionInput
  }

  export type sessionUncheckedCreateInput = {
    id?: string
    refreshToken: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionCreateManyInput = {
    id?: string
    refreshToken: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceCompletedCreateInput = {
    id?: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutServiceCompletedInput
    helpRequest: helpRequestCreateNestedOneWithoutServiceCompletedInput
  }

  export type serviceCompletedUncheckedCreateInput = {
    id?: string
    requestId: string
    helperId: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCompletedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceCompletedNestedInput
    helpRequest?: helpRequestUpdateOneRequiredWithoutServiceCompletedNestedInput
  }

  export type serviceCompletedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCompletedCreateManyInput = {
    id?: string
    requestId: string
    helperId: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCompletedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCompletedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingCreateInput = {
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    localService: localServiceCreateNestedOneWithoutServiceRatingInput
    user: userCreateNestedOneWithoutServiceRatingInput
  }

  export type serviceRatingUncheckedCreateInput = {
    serviceId: string
    userId: string
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceRatingUpdateInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localService?: localServiceUpdateOneRequiredWithoutServiceRatingNestedInput
    user?: userUpdateOneRequiredWithoutServiceRatingNestedInput
  }

  export type serviceRatingUncheckedUpdateInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingCreateManyInput = {
    serviceId: string
    userId: string
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceRatingUpdateManyMutationInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingUncheckedUpdateManyInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type skillCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    skillCategory?: skillCategoryCreateNestedOneWithoutSkillInput
    userSkill?: userSkillCreateNestedManyWithoutSkillInput
  }

  export type skillUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userSkill?: userSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type skillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skillCategory?: skillCategoryUpdateOneWithoutSkillNestedInput
    userSkill?: userSkillUpdateManyWithoutSkillNestedInput
  }

  export type skillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userSkill?: userSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type skillCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type skillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type skillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseCreateInput = {
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    satisfactionSurvey: satisfactionSurveyCreateNestedOneWithoutSurveyResponseInput
    user: userCreateNestedOneWithoutSurveyResponseInput
  }

  export type surveyResponseUncheckedCreateInput = {
    surveyId: string
    userId: string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type surveyResponseUpdateInput = {
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    satisfactionSurvey?: satisfactionSurveyUpdateOneRequiredWithoutSurveyResponseNestedInput
    user?: userUpdateOneRequiredWithoutSurveyResponseNestedInput
  }

  export type surveyResponseUncheckedUpdateInput = {
    surveyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseCreateManyInput = {
    surveyId: string
    userId: string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type surveyResponseUpdateManyMutationInput = {
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseUncheckedUpdateManyInput = {
    surveyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustCircleCreateInput = {
    userId: string
    contactId: string
    dateAdded: Date | string
    accessLevel: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustCircleUncheckedCreateInput = {
    userId: string
    contactId: string
    dateAdded: Date | string
    accessLevel: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustCircleUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    accessLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustCircleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    accessLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustCircleCreateManyInput = {
    userId: string
    contactId: string
    dateAdded: Date | string
    accessLevel: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustCircleUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    accessLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustCircleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    accessLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustedContactCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    relationship?: string | null
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutTrustedContactInput
  }

  export type trustedContactUncheckedCreateInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    relationship?: string | null
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustedContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    shareMedications?: BoolFieldUpdateOperationsInput | boolean
    shareHealthIndicators?: BoolFieldUpdateOperationsInput | boolean
    shareWellnessActivities?: BoolFieldUpdateOperationsInput | boolean
    emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutTrustedContactNestedInput
  }

  export type trustedContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    shareMedications?: BoolFieldUpdateOperationsInput | boolean
    shareHealthIndicators?: BoolFieldUpdateOperationsInput | boolean
    shareWellnessActivities?: BoolFieldUpdateOperationsInput | boolean
    emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustedContactCreateManyInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    relationship?: string | null
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustedContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    shareMedications?: BoolFieldUpdateOperationsInput | boolean
    shareHealthIndicators?: BoolFieldUpdateOperationsInput | boolean
    shareWellnessActivities?: BoolFieldUpdateOperationsInput | boolean
    emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustedContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    shareMedications?: BoolFieldUpdateOperationsInput | boolean
    shareHealthIndicators?: BoolFieldUpdateOperationsInput | boolean
    shareWellnessActivities?: BoolFieldUpdateOperationsInput | boolean
    emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type urbanIssueReportCreateInput = {
    id?: string
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutUrbanIssueReportInput
    issueCategory?: issueCategoryCreateNestedOneWithoutUrbanIssueReportInput
  }

  export type urbanIssueReportUncheckedCreateInput = {
    id?: string
    userId: string
    categoryId?: string | null
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type urbanIssueReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutUrbanIssueReportNestedInput
    issueCategory?: issueCategoryUpdateOneWithoutUrbanIssueReportNestedInput
  }

  export type urbanIssueReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type urbanIssueReportCreateManyInput = {
    id?: string
    userId: string
    categoryId?: string | null
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type urbanIssueReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type urbanIssueReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityCreateInput = {
    id?: string
    completionDate: Date | string
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseCreateNestedOneWithoutUserActivityInput
    exerciseProgram?: exerciseProgramCreateNestedOneWithoutUserActivityInput
    user: userCreateNestedOneWithoutUserActivityInput
  }

  export type userActivityUncheckedCreateInput = {
    id?: string
    userId: string
    completionDate: Date | string
    exerciseProgramId?: string | null
    cognitiveExerciseId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUpdateOneWithoutUserActivityNestedInput
    exerciseProgram?: exerciseProgramUpdateOneWithoutUserActivityNestedInput
    user?: userUpdateOneRequiredWithoutUserActivityNestedInput
  }

  export type userActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    cognitiveExerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityCreateManyInput = {
    id?: string
    userId: string
    completionDate: Date | string
    exerciseProgramId?: string | null
    cognitiveExerciseId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    cognitiveExerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userBadgeCreateInput = {
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    badge: badgeCreateNestedOneWithoutUserBadgeInput
    user: userCreateNestedOneWithoutUserBadgeInput
  }

  export type userBadgeUncheckedCreateInput = {
    userId: string
    badgeId: string
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userBadgeUpdateInput = {
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateOneRequiredWithoutUserBadgeNestedInput
    user?: userUpdateOneRequiredWithoutUserBadgeNestedInput
  }

  export type userBadgeUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userBadgeCreateManyInput = {
    userId: string
    badgeId: string
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userBadgeUpdateManyMutationInput = {
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userBadgeUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userDeviceCreateInput = {
    id?: string
    deviceType: string
    deviceName?: string | null
    operatingSystem?: string | null
    notificationToken: string
    lastConnection: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutUserDeviceInput
  }

  export type userDeviceUncheckedCreateInput = {
    id?: string
    userId: string
    deviceType: string
    deviceName?: string | null
    operatingSystem?: string | null
    notificationToken: string
    lastConnection: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userDeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToken?: StringFieldUpdateOperationsInput | string
    lastConnection?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutUserDeviceNestedInput
  }

  export type userDeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToken?: StringFieldUpdateOperationsInput | string
    lastConnection?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userDeviceCreateManyInput = {
    id?: string
    userId: string
    deviceType: string
    deviceName?: string | null
    operatingSystem?: string | null
    notificationToken: string
    lastConnection: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userDeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToken?: StringFieldUpdateOperationsInput | string
    lastConnection?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userDeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToken?: StringFieldUpdateOperationsInput | string
    lastConnection?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillCreateInput = {
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
    skill: skillCreateNestedOneWithoutUserSkillInput
    user: userCreateNestedOneWithoutUserSkillInput
  }

  export type userSkillUncheckedCreateInput = {
    userId: string
    skillId: string
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
  }

  export type userSkillUpdateInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skill?: skillUpdateOneRequiredWithoutUserSkillNestedInput
    user?: userUpdateOneRequiredWithoutUserSkillNestedInput
  }

  export type userSkillUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillCreateManyInput = {
    userId: string
    skillId: string
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
  }

  export type userSkillUpdateManyMutationInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userStatisticsCreateInput = {
    servicesProvided?: number | null
    servicesReceived?: number | null
    activitiesParticipated?: number | null
    activitiesOrganized?: number | null
    forumMessages?: number | null
    totalHelpPoints?: number | null
    networkSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutUserStatisticsInput
  }

  export type userStatisticsUncheckedCreateInput = {
    userId: string
    servicesProvided?: number | null
    servicesReceived?: number | null
    activitiesParticipated?: number | null
    activitiesOrganized?: number | null
    forumMessages?: number | null
    totalHelpPoints?: number | null
    networkSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userStatisticsUpdateInput = {
    servicesProvided?: NullableIntFieldUpdateOperationsInput | number | null
    servicesReceived?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesParticipated?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesOrganized?: NullableIntFieldUpdateOperationsInput | number | null
    forumMessages?: NullableIntFieldUpdateOperationsInput | number | null
    totalHelpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutUserStatisticsNestedInput
  }

  export type userStatisticsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    servicesProvided?: NullableIntFieldUpdateOperationsInput | number | null
    servicesReceived?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesParticipated?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesOrganized?: NullableIntFieldUpdateOperationsInput | number | null
    forumMessages?: NullableIntFieldUpdateOperationsInput | number | null
    totalHelpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userStatisticsCreateManyInput = {
    userId: string
    servicesProvided?: number | null
    servicesReceived?: number | null
    activitiesParticipated?: number | null
    activitiesOrganized?: number | null
    forumMessages?: number | null
    totalHelpPoints?: number | null
    networkSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userStatisticsUpdateManyMutationInput = {
    servicesProvided?: NullableIntFieldUpdateOperationsInput | number | null
    servicesReceived?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesParticipated?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesOrganized?: NullableIntFieldUpdateOperationsInput | number | null
    forumMessages?: NullableIntFieldUpdateOperationsInput | number | null
    totalHelpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userStatisticsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    servicesProvided?: NullableIntFieldUpdateOperationsInput | number | null
    servicesReceived?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesParticipated?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesOrganized?: NullableIntFieldUpdateOperationsInput | number | null
    forumMessages?: NullableIntFieldUpdateOperationsInput | number | null
    totalHelpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversation?: conversationCreateNestedOneWithoutVideoCallInput
    user?: userCreateNestedOneWithoutVideoCallInput
  }

  export type videoCallUncheckedCreateInput = {
    id?: string
    conversationId: string
    initiatorId: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type videoCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: conversationUpdateOneWithoutVideoCallNestedInput
    user?: userUpdateOneWithoutVideoCallNestedInput
  }

  export type videoCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallCreateManyInput = {
    id?: string
    conversationId: string
    initiatorId: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type videoCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessBadgeCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    level: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessCategory?: wellnessCategoryCreateNestedOneWithoutWellnessBadgeInput
  }

  export type wellnessBadgeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    categoryId?: string | null
    image?: string | null
    level: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessCategory?: wellnessCategoryUpdateOneWithoutWellnessBadgeNestedInput
  }

  export type wellnessBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessBadgeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    categoryId?: string | null
    image?: string | null
    level: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalCreateInput = {
    id?: string
    title: string
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressCreateNestedManyWithoutWellnessGoalInput
    user?: userCreateNestedOneWithoutWellnessGoalInput
    wellnessCategory?: wellnessCategoryCreateNestedOneWithoutWellnessGoalInput
  }

  export type wellnessGoalUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    categoryId?: string | null
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUncheckedCreateNestedManyWithoutWellnessGoalInput
  }

  export type wellnessGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUpdateManyWithoutWellnessGoalNestedInput
    user?: userUpdateOneWithoutWellnessGoalNestedInput
    wellnessCategory?: wellnessCategoryUpdateOneWithoutWellnessGoalNestedInput
  }

  export type wellnessGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUncheckedUpdateManyWithoutWellnessGoalNestedInput
  }

  export type wellnessGoalCreateManyInput = {
    id?: string
    userId: string
    title: string
    categoryId?: string | null
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalProgressCreateInput = {
    id?: string
    recordingDate: Date | string
    achievedValue: number
    goalAchieved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoal: wellnessGoalCreateNestedOneWithoutWellnessGoalProgressInput
  }

  export type wellnessGoalProgressUncheckedCreateInput = {
    id?: string
    goalId: string
    recordingDate: Date | string
    achievedValue: number
    goalAchieved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievedValue?: IntFieldUpdateOperationsInput | number
    goalAchieved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoal?: wellnessGoalUpdateOneRequiredWithoutWellnessGoalProgressNestedInput
  }

  export type wellnessGoalProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievedValue?: IntFieldUpdateOperationsInput | number
    goalAchieved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalProgressCreateManyInput = {
    id?: string
    goalId: string
    recordingDate: Date | string
    achievedValue: number
    goalAchieved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievedValue?: IntFieldUpdateOperationsInput | number
    goalAchieved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievedValue?: IntFieldUpdateOperationsInput | number
    goalAchieved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutActivityCategoryInput
  }

  export type activityCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutActivityCategoryInput
  }

  export type activityCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutActivityCategoryNestedInput
  }

  export type activityCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutActivityCategoryNestedInput
  }

  export type activityCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    badge?: badgeCreateNestedManyWithoutBadgeCategoryInput
  }

  export type badgeCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    badge?: badgeUncheckedCreateNestedManyWithoutBadgeCategoryInput
  }

  export type badgeCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateManyWithoutBadgeCategoryNestedInput
  }

  export type badgeCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUncheckedUpdateManyWithoutBadgeCategoryNestedInput
  }

  export type badgeCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type badgeCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseCreateNestedManyWithoutCognitiveCategoryInput
  }

  export type cognitiveCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseUncheckedCreateNestedManyWithoutCognitiveCategoryInput
  }

  export type cognitiveCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUpdateManyWithoutCognitiveCategoryNestedInput
  }

  export type cognitiveCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUncheckedUpdateManyWithoutCognitiveCategoryNestedInput
  }

  export type cognitiveCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type cognitiveCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpRequest?: helpRequestCreateNestedManyWithoutHelpCategoryInput
  }

  export type helpCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutHelpCategoryInput
  }

  export type helpCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpRequest?: helpRequestUpdateManyWithoutHelpCategoryNestedInput
  }

  export type helpCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpRequest?: helpRequestUncheckedUpdateManyWithoutHelpCategoryNestedInput
  }

  export type helpCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issueCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutIssueCategoryInput
  }

  export type issueCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutIssueCategoryInput
  }

  export type issueCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutIssueCategoryNestedInput
  }

  export type issueCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutIssueCategoryNestedInput
  }

  export type issueCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type issueCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issueCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    nutritionalAdvice?: nutritionalAdviceCreateNestedManyWithoutNutritionalCategoryInput
  }

  export type nutritionalCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    nutritionalAdvice?: nutritionalAdviceUncheckedCreateNestedManyWithoutNutritionalCategoryInput
  }

  export type nutritionalCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionalAdvice?: nutritionalAdviceUpdateManyWithoutNutritionalCategoryNestedInput
  }

  export type nutritionalCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionalAdvice?: nutritionalAdviceUncheckedUpdateManyWithoutNutritionalCategoryNestedInput
  }

  export type nutritionalCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type programCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseCreateNestedManyWithoutProgramCategoryInput
    exerciseProgram?: exerciseProgramCreateNestedManyWithoutProgramCategoryInput
  }

  export type programCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseUncheckedCreateNestedManyWithoutProgramCategoryInput
    exerciseProgram?: exerciseProgramUncheckedCreateNestedManyWithoutProgramCategoryInput
  }

  export type programCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUpdateManyWithoutProgramCategoryNestedInput
    exerciseProgram?: exerciseProgramUpdateManyWithoutProgramCategoryNestedInput
  }

  export type programCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUncheckedUpdateManyWithoutProgramCategoryNestedInput
    exerciseProgram?: exerciseProgramUncheckedUpdateManyWithoutProgramCategoryNestedInput
  }

  export type programCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type programCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type programCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutProjectCategoryInput
  }

  export type projectCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutProjectCategoryInput
  }

  export type projectCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborativeProject?: collaborativeProjectUpdateManyWithoutProjectCategoryNestedInput
  }

  export type projectCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutProjectCategoryNestedInput
  }

  export type projectCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    resource?: resourceCreateNestedManyWithoutResourceCategoryInput
  }

  export type resourceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    resource?: resourceUncheckedCreateNestedManyWithoutResourceCategoryInput
  }

  export type resourceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: resourceUpdateManyWithoutResourceCategoryNestedInput
  }

  export type resourceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: resourceUncheckedUpdateManyWithoutResourceCategoryNestedInput
  }

  export type resourceCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    localService?: localServiceCreateNestedManyWithoutServiceCategoryInput
  }

  export type serviceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    localService?: localServiceUncheckedCreateNestedManyWithoutServiceCategoryInput
  }

  export type serviceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localService?: localServiceUpdateManyWithoutServiceCategoryNestedInput
  }

  export type serviceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localService?: localServiceUncheckedUpdateManyWithoutServiceCategoryNestedInput
  }

  export type serviceCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type skillCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    skill?: skillCreateNestedManyWithoutSkillCategoryInput
  }

  export type skillCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    skill?: skillUncheckedCreateNestedManyWithoutSkillCategoryInput
  }

  export type skillCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skill?: skillUpdateManyWithoutSkillCategoryNestedInput
  }

  export type skillCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skill?: skillUncheckedUpdateManyWithoutSkillCategoryNestedInput
  }

  export type skillCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type skillCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type skillCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessBadge?: wellnessBadgeCreateNestedManyWithoutWellnessCategoryInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutWellnessCategoryInput
  }

  export type wellnessCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessBadge?: wellnessBadgeUncheckedCreateNestedManyWithoutWellnessCategoryInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutWellnessCategoryInput
  }

  export type wellnessCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessBadge?: wellnessBadgeUpdateManyWithoutWellnessCategoryNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutWellnessCategoryNestedInput
  }

  export type wellnessCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessBadge?: wellnessBadgeUncheckedUpdateManyWithoutWellnessCategoryNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutWellnessCategoryNestedInput
  }

  export type wellnessCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type ActivityCategoryNullableScalarRelationFilter = {
    is?: activityCategoryWhereInput | null
    isNot?: activityCategoryWhereInput | null
  }

  export type ActivityRegistrationListRelationFilter = {
    every?: activityRegistrationWhereInput
    some?: activityRegistrationWhereInput
    none?: activityRegistrationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type activityRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type activityCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    maxSpots?: SortOrder
    categoryId?: SortOrder
    recurring?: SortOrder
    frequency?: SortOrder
    reducedMobilityAccess?: SortOrder
    difficultyLevel?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    weatherRequirements?: SortOrder
    transportOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityAvgOrderByAggregateInput = {
    maxSpots?: SortOrder
    difficultyLevel?: SortOrder
    cost?: SortOrder
  }

  export type activityMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    maxSpots?: SortOrder
    categoryId?: SortOrder
    recurring?: SortOrder
    frequency?: SortOrder
    reducedMobilityAccess?: SortOrder
    difficultyLevel?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    weatherRequirements?: SortOrder
    transportOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    maxSpots?: SortOrder
    categoryId?: SortOrder
    recurring?: SortOrder
    frequency?: SortOrder
    reducedMobilityAccess?: SortOrder
    difficultyLevel?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    weatherRequirements?: SortOrder
    transportOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activitySumOrderByAggregateInput = {
    maxSpots?: SortOrder
    difficultyLevel?: SortOrder
    cost?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type activityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityScalarRelationFilter = {
    is?: activityWhereInput
    isNot?: activityWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type activityRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    attendanceConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    attendanceConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    attendanceConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBadgeNullableScalarRelationFilter = {
    is?: userBadgeWhereInput | null
    isNot?: userBadgeWhereInput | null
  }

  export type BadgeCategoryNullableScalarRelationFilter = {
    is?: badgeCategoryWhereInput | null
    isNot?: badgeCategoryWhereInput | null
  }

  export type badgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type badgeAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type badgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type badgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type badgeSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type CognitiveCategoryNullableScalarRelationFilter = {
    is?: cognitiveCategoryWhereInput | null
    isNot?: cognitiveCategoryWhereInput | null
  }

  export type UserActivityListRelationFilter = {
    every?: userActivityWhereInput
    some?: userActivityWhereInput
    none?: userActivityWhereInput
  }

  export type ProgramCategoryNullableScalarRelationFilter = {
    is?: programCategoryWhereInput | null
    isNot?: programCategoryWhereInput | null
  }

  export type userActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cognitiveExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    difficultyLevel?: SortOrder
    durationMinutes?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programCategoryId?: SortOrder
  }

  export type cognitiveExerciseAvgOrderByAggregateInput = {
    difficultyLevel?: SortOrder
    durationMinutes?: SortOrder
  }

  export type cognitiveExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    difficultyLevel?: SortOrder
    durationMinutes?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programCategoryId?: SortOrder
  }

  export type cognitiveExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    difficultyLevel?: SortOrder
    durationMinutes?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programCategoryId?: SortOrder
  }

  export type cognitiveExerciseSumOrderByAggregateInput = {
    difficultyLevel?: SortOrder
    durationMinutes?: SortOrder
  }

  export type ProjectCategoryNullableScalarRelationFilter = {
    is?: projectCategoryWhereInput | null
    isNot?: projectCategoryWhereInput | null
  }

  export type ProjectMemberListRelationFilter = {
    every?: projectMemberWhereInput
    some?: projectMemberWhereInput
    none?: projectMemberWhereInput
  }

  export type ProjectTaskListRelationFilter = {
    every?: projectTaskWhereInput
    some?: projectTaskWhereInput
    none?: projectTaskWhereInput
  }

  export type projectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projectTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collaborativeProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    creationDate?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type collaborativeProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    creationDate?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type collaborativeProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    creationDate?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationParticipantListRelationFilter = {
    every?: conversationParticipantWhereInput
    some?: conversationParticipantWhereInput
    none?: conversationParticipantWhereInput
  }

  export type MessageListRelationFilter = {
    every?: messageWhereInput
    some?: messageWhereInput
    none?: messageWhereInput
  }

  export type VideoCallListRelationFilter = {
    every?: videoCallWhereInput
    some?: videoCallWhereInput
    none?: videoCallWhereInput
  }

  export type conversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type videoCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type conversationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type conversationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: conversationWhereInput
    isNot?: conversationWhereInput
  }

  export type conversationParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    dateAdded?: SortOrder
    administrator?: SortOrder
    lastAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type conversationParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    dateAdded?: SortOrder
    administrator?: SortOrder
    lastAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type conversationParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    dateAdded?: SortOrder
    administrator?: SortOrder
    lastAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type exerciseProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    difficultyLevel?: SortOrder
    adaptedForReducedMobility?: SortOrder
    durationMinutes?: SortOrder
    description?: SortOrder
    videoLink?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type exerciseProgramAvgOrderByAggregateInput = {
    difficultyLevel?: SortOrder
    durationMinutes?: SortOrder
  }

  export type exerciseProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    difficultyLevel?: SortOrder
    adaptedForReducedMobility?: SortOrder
    durationMinutes?: SortOrder
    description?: SortOrder
    videoLink?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type exerciseProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    difficultyLevel?: SortOrder
    adaptedForReducedMobility?: SortOrder
    durationMinutes?: SortOrder
    description?: SortOrder
    videoLink?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type exerciseProgramSumOrderByAggregateInput = {
    difficultyLevel?: SortOrder
    durationMinutes?: SortOrder
  }

  export type ForumTopicListRelationFilter = {
    every?: forumTopicWhereInput
    some?: forumTopicWhereInput
    none?: forumTopicWhereInput
  }

  export type forumTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type forumCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type forumCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type forumCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicNullableScalarRelationFilter = {
    is?: forumTopicWhereInput | null
    isNot?: forumTopicWhereInput | null
  }

  export type forumMessageCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    solutionMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type forumMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    solutionMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type forumMessageMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    solutionMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumMessageListRelationFilter = {
    every?: forumMessageWhereInput
    some?: forumMessageWhereInput
    none?: forumMessageWhereInput
  }

  export type ForumCategoryNullableScalarRelationFilter = {
    is?: forumCategoryWhereInput | null
    isNot?: forumCategoryWhereInput | null
  }

  export type forumMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type forumTopicCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    pinned?: SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type forumTopicAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type forumTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    pinned?: SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type forumTopicMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    pinned?: SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type forumTopicSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type healthIndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recordingDate?: SortOrder
    stepCount?: SortOrder
    sleepDurationMinutes?: SortOrder
    sleepQuality?: SortOrder
    weight?: SortOrder
    mood?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type healthIndicatorAvgOrderByAggregateInput = {
    stepCount?: SortOrder
    sleepDurationMinutes?: SortOrder
    sleepQuality?: SortOrder
    weight?: SortOrder
  }

  export type healthIndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recordingDate?: SortOrder
    stepCount?: SortOrder
    sleepDurationMinutes?: SortOrder
    sleepQuality?: SortOrder
    weight?: SortOrder
    mood?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type healthIndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recordingDate?: SortOrder
    stepCount?: SortOrder
    sleepDurationMinutes?: SortOrder
    sleepQuality?: SortOrder
    weight?: SortOrder
    mood?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type healthIndicatorSumOrderByAggregateInput = {
    stepCount?: SortOrder
    sleepDurationMinutes?: SortOrder
    sleepQuality?: SortOrder
    weight?: SortOrder
  }

  export type HelpRequestScalarRelationFilter = {
    is?: helpRequestWhereInput
    isNot?: helpRequestWhereInput
  }

  export type helpOfferCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    offerDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    offerDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpOfferMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    offerDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpOfferListRelationFilter = {
    every?: helpOfferWhereInput
    some?: helpOfferWhereInput
    none?: helpOfferWhereInput
  }

  export type ServiceCompletedListRelationFilter = {
    every?: serviceCompletedWhereInput
    some?: serviceCompletedWhereInput
    none?: serviceCompletedWhereInput
  }

  export type HelpCategoryNullableScalarRelationFilter = {
    is?: helpCategoryWhereInput | null
    isNot?: helpCategoryWhereInput | null
  }

  export type helpOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviceCompletedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type helpRequestCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    neededDate?: SortOrder
    estimatedDuration?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    categoryId?: SortOrder
    recurring?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    pointsOffered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpRequestAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    pointsOffered?: SortOrder
  }

  export type helpRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    neededDate?: SortOrder
    estimatedDuration?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    categoryId?: SortOrder
    recurring?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    pointsOffered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpRequestMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    neededDate?: SortOrder
    estimatedDuration?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    categoryId?: SortOrder
    recurring?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    pointsOffered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpRequestSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    pointsOffered?: SortOrder
  }

  export type ServiceCategoryNullableScalarRelationFilter = {
    is?: serviceCategoryWhereInput | null
    isNot?: serviceCategoryWhereInput | null
  }

  export type ServiceRatingListRelationFilter = {
    every?: serviceRatingWhereInput
    some?: serviceRatingWhereInput
    none?: serviceRatingWhereInput
  }

  export type serviceRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type localServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    hours?: SortOrder
    seniorFriendly?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type localServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    hours?: SortOrder
    seniorFriendly?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type localServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    hours?: SortOrder
    seniorFriendly?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type medicationReminderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    morningReminderTime?: SortOrder
    noonReminderTime?: SortOrder
    eveningReminderTime?: SortOrder
    nightReminderTime?: SortOrder
    daysOfWeek?: SortOrder
    instructions?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type medicationReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    morningReminderTime?: SortOrder
    noonReminderTime?: SortOrder
    eveningReminderTime?: SortOrder
    nightReminderTime?: SortOrder
    daysOfWeek?: SortOrder
    instructions?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type medicationReminderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    morningReminderTime?: SortOrder
    noonReminderTime?: SortOrder
    eveningReminderTime?: SortOrder
    nightReminderTime?: SortOrder
    daysOfWeek?: SortOrder
    instructions?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationNullableScalarRelationFilter = {
    is?: conversationWhereInput | null
    isNot?: conversationWhereInput | null
  }

  export type messageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    sendDate?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type messageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    sendDate?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type messageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    sendDate?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type municipalEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    organizer?: SortOrder
    contact?: SortOrder
    officialLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type municipalEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    organizer?: SortOrder
    contact?: SortOrder
    officialLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type municipalEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    gpsCoordinates?: SortOrder
    organizer?: SortOrder
    contact?: SortOrder
    officialLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    actionLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    actionLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    actionLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationPreferencesCountOrderByAggregateInput = {
    userId?: SortOrder
    messageNotification?: SortOrder
    activityNotification?: SortOrder
    helpNotification?: SortOrder
    forumNotification?: SortOrder
    emailNotification?: SortOrder
    smsNotification?: SortOrder
    pushNotification?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationPreferencesMaxOrderByAggregateInput = {
    userId?: SortOrder
    messageNotification?: SortOrder
    activityNotification?: SortOrder
    helpNotification?: SortOrder
    forumNotification?: SortOrder
    emailNotification?: SortOrder
    smsNotification?: SortOrder
    pushNotification?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationPreferencesMinOrderByAggregateInput = {
    userId?: SortOrder
    messageNotification?: SortOrder
    activityNotification?: SortOrder
    helpNotification?: SortOrder
    forumNotification?: SortOrder
    emailNotification?: SortOrder
    smsNotification?: SortOrder
    pushNotification?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionalCategoryNullableScalarRelationFilter = {
    is?: nutritionalCategoryWhereInput | null
    isNot?: nutritionalCategoryWhereInput | null
  }

  export type nutritionalAdviceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    season?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type nutritionalAdviceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    season?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type nutritionalAdviceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    season?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaborativeProjectScalarRelationFilter = {
    is?: collaborativeProjectWhereInput
    isNot?: collaborativeProjectWhereInput
  }

  export type projectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type projectMemberCountOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type projectMemberMaxOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type projectMemberMinOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaborativeProjectNullableScalarRelationFilter = {
    is?: collaborativeProjectWhereInput | null
    isNot?: collaborativeProjectWhereInput | null
  }

  export type projectTaskCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creationDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type projectTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creationDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type projectTaskMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creationDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceCategoryNullableScalarRelationFilter = {
    is?: resourceCategoryWhereInput | null
    isNot?: resourceCategoryWhereInput | null
  }

  export type resourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    adminValidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type resourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    adminValidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type resourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    adminValidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyResponseListRelationFilter = {
    every?: surveyResponseWhereInput
    some?: surveyResponseWhereInput
    none?: surveyResponseWhereInput
  }

  export type surveyResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type satisfactionSurveyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type satisfactionSurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type satisfactionSurveyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
  }

  export type serviceCompletedCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    completionDate?: SortOrder
    actualDuration?: SortOrder
    creatorComment?: SortOrder
    helperComment?: SortOrder
    creatorRating?: SortOrder
    helperRating?: SortOrder
    pointsExchanged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceCompletedAvgOrderByAggregateInput = {
    actualDuration?: SortOrder
    creatorRating?: SortOrder
    helperRating?: SortOrder
    pointsExchanged?: SortOrder
  }

  export type serviceCompletedMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    completionDate?: SortOrder
    actualDuration?: SortOrder
    creatorComment?: SortOrder
    helperComment?: SortOrder
    creatorRating?: SortOrder
    helperRating?: SortOrder
    pointsExchanged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceCompletedMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    helperId?: SortOrder
    completionDate?: SortOrder
    actualDuration?: SortOrder
    creatorComment?: SortOrder
    helperComment?: SortOrder
    creatorRating?: SortOrder
    helperRating?: SortOrder
    pointsExchanged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceCompletedSumOrderByAggregateInput = {
    actualDuration?: SortOrder
    creatorRating?: SortOrder
    helperRating?: SortOrder
    pointsExchanged?: SortOrder
  }

  export type LocalServiceScalarRelationFilter = {
    is?: localServiceWhereInput
    isNot?: localServiceWhereInput
  }

  export type serviceRatingServiceIdUserIdCompoundUniqueInput = {
    serviceId: string
    userId: string
  }

  export type serviceRatingCountOrderByAggregateInput = {
    serviceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type serviceRatingMaxOrderByAggregateInput = {
    serviceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceRatingMinOrderByAggregateInput = {
    serviceId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type SkillCategoryNullableScalarRelationFilter = {
    is?: skillCategoryWhereInput | null
    isNot?: skillCategoryWhereInput | null
  }

  export type UserSkillListRelationFilter = {
    every?: userSkillWhereInput
    some?: userSkillWhereInput
    none?: userSkillWhereInput
  }

  export type userSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type skillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type skillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type skillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SatisfactionSurveyScalarRelationFilter = {
    is?: satisfactionSurveyWhereInput
    isNot?: satisfactionSurveyWhereInput
  }

  export type surveyResponseSurveyIdUserIdCompoundUniqueInput = {
    surveyId: string
    userId: string
  }

  export type surveyResponseCountOrderByAggregateInput = {
    surveyId?: SortOrder
    userId?: SortOrder
    responses?: SortOrder
    response_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type surveyResponseMaxOrderByAggregateInput = {
    surveyId?: SortOrder
    userId?: SortOrder
    response_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type surveyResponseMinOrderByAggregateInput = {
    surveyId?: SortOrder
    userId?: SortOrder
    response_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type trustCircleUserIdContactIdCompoundUniqueInput = {
    userId: string
    contactId: string
  }

  export type trustCircleCountOrderByAggregateInput = {
    userId?: SortOrder
    contactId?: SortOrder
    dateAdded?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trustCircleMaxOrderByAggregateInput = {
    userId?: SortOrder
    contactId?: SortOrder
    dateAdded?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trustCircleMinOrderByAggregateInput = {
    userId?: SortOrder
    contactId?: SortOrder
    dateAdded?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trustedContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    relationship?: SortOrder
    shareMedications?: SortOrder
    shareHealthIndicators?: SortOrder
    shareWellnessActivities?: SortOrder
    emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trustedContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    relationship?: SortOrder
    shareMedications?: SortOrder
    shareHealthIndicators?: SortOrder
    shareWellnessActivities?: SortOrder
    emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trustedContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    relationship?: SortOrder
    shareMedications?: SortOrder
    shareHealthIndicators?: SortOrder
    shareWellnessActivities?: SortOrder
    emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssueCategoryNullableScalarRelationFilter = {
    is?: issueCategoryWhereInput | null
    isNot?: issueCategoryWhereInput | null
  }

  export type urbanIssueReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    cityReference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type urbanIssueReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    cityReference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type urbanIssueReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    cityReference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityListRelationFilter = {
    every?: activityWhereInput
    some?: activityWhereInput
    none?: activityWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: activityLogWhereInput
    some?: activityLogWhereInput
    none?: activityLogWhereInput
  }

  export type CollaborativeProjectListRelationFilter = {
    every?: collaborativeProjectWhereInput
    some?: collaborativeProjectWhereInput
    none?: collaborativeProjectWhereInput
  }

  export type HealthIndicatorListRelationFilter = {
    every?: healthIndicatorWhereInput
    some?: healthIndicatorWhereInput
    none?: healthIndicatorWhereInput
  }

  export type HelpRequestListRelationFilter = {
    every?: helpRequestWhereInput
    some?: helpRequestWhereInput
    none?: helpRequestWhereInput
  }

  export type MedicationReminderListRelationFilter = {
    every?: medicationReminderWhereInput
    some?: medicationReminderWhereInput
    none?: medicationReminderWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type NotificationPreferencesNullableScalarRelationFilter = {
    is?: notificationPreferencesWhereInput | null
    isNot?: notificationPreferencesWhereInput | null
  }

  export type ResourceListRelationFilter = {
    every?: resourceWhereInput
    some?: resourceWhereInput
    none?: resourceWhereInput
  }

  export type TrustedContactListRelationFilter = {
    every?: trustedContactWhereInput
    some?: trustedContactWhereInput
    none?: trustedContactWhereInput
  }

  export type UrbanIssueReportListRelationFilter = {
    every?: urbanIssueReportWhereInput
    some?: urbanIssueReportWhereInput
    none?: urbanIssueReportWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: userBadgeWhereInput
    some?: userBadgeWhereInput
    none?: userBadgeWhereInput
  }

  export type UserDeviceListRelationFilter = {
    every?: userDeviceWhereInput
    some?: userDeviceWhereInput
    none?: userDeviceWhereInput
  }

  export type UserStatisticsNullableScalarRelationFilter = {
    is?: userStatisticsWhereInput | null
    isNot?: userStatisticsWhereInput | null
  }

  export type WellnessGoalListRelationFilter = {
    every?: wellnessGoalWhereInput
    some?: wellnessGoalWhereInput
    none?: wellnessGoalWhereInput
  }

  export type SessionListRelationFilter = {
    every?: sessionWhereInput
    some?: sessionWhereInput
    none?: sessionWhereInput
  }

  export type activityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type activityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collaborativeProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type healthIndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type helpRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medicationReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type resourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type trustedContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type urbanIssueReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wellnessGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    phone?: SortOrder
    profilePicture?: SortOrder
    registrationDate?: SortOrder
    accountVerified?: SortOrder
    interfacePreferences?: SortOrder
    twoFactorAuthentication?: SortOrder
    helpPoints?: SortOrder
    reducedMobility?: SortOrder
    activityLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    helpPoints?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    phone?: SortOrder
    profilePicture?: SortOrder
    registrationDate?: SortOrder
    accountVerified?: SortOrder
    interfacePreferences?: SortOrder
    twoFactorAuthentication?: SortOrder
    helpPoints?: SortOrder
    reducedMobility?: SortOrder
    activityLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    gpsCoordinates?: SortOrder
    phone?: SortOrder
    profilePicture?: SortOrder
    registrationDate?: SortOrder
    accountVerified?: SortOrder
    interfacePreferences?: SortOrder
    twoFactorAuthentication?: SortOrder
    helpPoints?: SortOrder
    reducedMobility?: SortOrder
    activityLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    helpPoints?: SortOrder
  }

  export type CognitiveExerciseNullableScalarRelationFilter = {
    is?: cognitiveExerciseWhereInput | null
    isNot?: cognitiveExerciseWhereInput | null
  }

  export type ExerciseProgramNullableScalarRelationFilter = {
    is?: exerciseProgramWhereInput | null
    isNot?: exerciseProgramWhereInput | null
  }

  export type userActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completionDate?: SortOrder
    exerciseProgramId?: SortOrder
    cognitiveExerciseId?: SortOrder
    durationMinutes?: SortOrder
    perceivedDifficultyLevel?: SortOrder
    enjoymentLevel?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userActivityAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    perceivedDifficultyLevel?: SortOrder
    enjoymentLevel?: SortOrder
  }

  export type userActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completionDate?: SortOrder
    exerciseProgramId?: SortOrder
    cognitiveExerciseId?: SortOrder
    durationMinutes?: SortOrder
    perceivedDifficultyLevel?: SortOrder
    enjoymentLevel?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completionDate?: SortOrder
    exerciseProgramId?: SortOrder
    cognitiveExerciseId?: SortOrder
    durationMinutes?: SortOrder
    perceivedDifficultyLevel?: SortOrder
    enjoymentLevel?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userActivitySumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    perceivedDifficultyLevel?: SortOrder
    enjoymentLevel?: SortOrder
  }

  export type BadgeScalarRelationFilter = {
    is?: badgeWhereInput
    isNot?: badgeWhereInput
  }

  export type userBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: string
  }

  export type userBadgeCountOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    achievementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userBadgeMaxOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    achievementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userBadgeMinOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    achievementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userDeviceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    operatingSystem?: SortOrder
    notificationToken?: SortOrder
    lastConnection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userDeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    operatingSystem?: SortOrder
    notificationToken?: SortOrder
    lastConnection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userDeviceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    operatingSystem?: SortOrder
    notificationToken?: SortOrder
    lastConnection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillScalarRelationFilter = {
    is?: skillWhereInput
    isNot?: skillWhereInput
  }

  export type userSkillUserIdSkillIdCompoundUniqueInput = {
    userId: string
    skillId: string
  }

  export type userSkillCountOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSkillAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type userSkillMaxOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSkillMinOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSkillSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type userStatisticsCountOrderByAggregateInput = {
    userId?: SortOrder
    servicesProvided?: SortOrder
    servicesReceived?: SortOrder
    activitiesParticipated?: SortOrder
    activitiesOrganized?: SortOrder
    forumMessages?: SortOrder
    totalHelpPoints?: SortOrder
    networkSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userStatisticsAvgOrderByAggregateInput = {
    servicesProvided?: SortOrder
    servicesReceived?: SortOrder
    activitiesParticipated?: SortOrder
    activitiesOrganized?: SortOrder
    forumMessages?: SortOrder
    totalHelpPoints?: SortOrder
    networkSize?: SortOrder
  }

  export type userStatisticsMaxOrderByAggregateInput = {
    userId?: SortOrder
    servicesProvided?: SortOrder
    servicesReceived?: SortOrder
    activitiesParticipated?: SortOrder
    activitiesOrganized?: SortOrder
    forumMessages?: SortOrder
    totalHelpPoints?: SortOrder
    networkSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userStatisticsMinOrderByAggregateInput = {
    userId?: SortOrder
    servicesProvided?: SortOrder
    servicesReceived?: SortOrder
    activitiesParticipated?: SortOrder
    activitiesOrganized?: SortOrder
    forumMessages?: SortOrder
    totalHelpPoints?: SortOrder
    networkSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userStatisticsSumOrderByAggregateInput = {
    servicesProvided?: SortOrder
    servicesReceived?: SortOrder
    activitiesParticipated?: SortOrder
    activitiesOrganized?: SortOrder
    forumMessages?: SortOrder
    totalHelpPoints?: SortOrder
    networkSize?: SortOrder
  }

  export type videoCallCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    initiatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type videoCallMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    initiatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type videoCallMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    initiatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type WellnessCategoryNullableScalarRelationFilter = {
    is?: wellnessCategoryWhereInput | null
    isNot?: wellnessCategoryWhereInput | null
  }

  export type wellnessBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    image?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessBadgeAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type wellnessBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    image?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    image?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessBadgeSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type WellnessGoalProgressListRelationFilter = {
    every?: wellnessGoalProgressWhereInput
    some?: wellnessGoalProgressWhereInput
    none?: wellnessGoalProgressWhereInput
  }

  export type wellnessGoalProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wellnessGoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessGoalAvgOrderByAggregateInput = {
    targetValue?: SortOrder
  }

  export type wellnessGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessGoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessGoalSumOrderByAggregateInput = {
    targetValue?: SortOrder
  }

  export type WellnessGoalScalarRelationFilter = {
    is?: wellnessGoalWhereInput
    isNot?: wellnessGoalWhereInput
  }

  export type wellnessGoalProgressCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    recordingDate?: SortOrder
    achievedValue?: SortOrder
    goalAchieved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessGoalProgressAvgOrderByAggregateInput = {
    achievedValue?: SortOrder
  }

  export type wellnessGoalProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    recordingDate?: SortOrder
    achievedValue?: SortOrder
    goalAchieved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessGoalProgressMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    recordingDate?: SortOrder
    achievedValue?: SortOrder
    goalAchieved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessGoalProgressSumOrderByAggregateInput = {
    achievedValue?: SortOrder
  }

  export type activityCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activityCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeListRelationFilter = {
    every?: badgeWhereInput
    some?: badgeWhereInput
    none?: badgeWhereInput
  }

  export type badgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type badgeCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type badgeCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type badgeCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CognitiveExerciseListRelationFilter = {
    every?: cognitiveExerciseWhereInput
    some?: cognitiveExerciseWhereInput
    none?: cognitiveExerciseWhereInput
  }

  export type cognitiveExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cognitiveCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cognitiveCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cognitiveCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type helpCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type issueCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type issueCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type issueCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionalAdviceListRelationFilter = {
    every?: nutritionalAdviceWhereInput
    some?: nutritionalAdviceWhereInput
    none?: nutritionalAdviceWhereInput
  }

  export type nutritionalAdviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type nutritionalCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type nutritionalCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type nutritionalCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseProgramListRelationFilter = {
    every?: exerciseProgramWhereInput
    some?: exerciseProgramWhereInput
    none?: exerciseProgramWhereInput
  }

  export type exerciseProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type programCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type programCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type programCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type projectCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type projectCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type projectCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type resourceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type resourceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type resourceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalServiceListRelationFilter = {
    every?: localServiceWhereInput
    some?: localServiceWhereInput
    none?: localServiceWhereInput
  }

  export type localServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type serviceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillListRelationFilter = {
    every?: skillWhereInput
    some?: skillWhereInput
    none?: skillWhereInput
  }

  export type skillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type skillCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type skillCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type skillCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessBadgeListRelationFilter = {
    every?: wellnessBadgeWhereInput
    some?: wellnessBadgeWhereInput
    none?: wellnessBadgeWhereInput
  }

  export type wellnessBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wellnessCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wellnessCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userCreateNestedOneWithoutActivityInput = {
    create?: XOR<userCreateWithoutActivityInput, userUncheckedCreateWithoutActivityInput>
    connectOrCreate?: userCreateOrConnectWithoutActivityInput
    connect?: userWhereUniqueInput
  }

  export type activityCategoryCreateNestedOneWithoutActivityInput = {
    create?: XOR<activityCategoryCreateWithoutActivityInput, activityCategoryUncheckedCreateWithoutActivityInput>
    connectOrCreate?: activityCategoryCreateOrConnectWithoutActivityInput
    connect?: activityCategoryWhereUniqueInput
  }

  export type activityRegistrationCreateNestedManyWithoutActivityInput = {
    create?: XOR<activityRegistrationCreateWithoutActivityInput, activityRegistrationUncheckedCreateWithoutActivityInput> | activityRegistrationCreateWithoutActivityInput[] | activityRegistrationUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutActivityInput | activityRegistrationCreateOrConnectWithoutActivityInput[]
    createMany?: activityRegistrationCreateManyActivityInputEnvelope
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
  }

  export type activityRegistrationUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<activityRegistrationCreateWithoutActivityInput, activityRegistrationUncheckedCreateWithoutActivityInput> | activityRegistrationCreateWithoutActivityInput[] | activityRegistrationUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutActivityInput | activityRegistrationCreateOrConnectWithoutActivityInput[]
    createMany?: activityRegistrationCreateManyActivityInputEnvelope
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userUpdateOneWithoutActivityNestedInput = {
    create?: XOR<userCreateWithoutActivityInput, userUncheckedCreateWithoutActivityInput>
    connectOrCreate?: userCreateOrConnectWithoutActivityInput
    upsert?: userUpsertWithoutActivityInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutActivityInput, userUpdateWithoutActivityInput>, userUncheckedUpdateWithoutActivityInput>
  }

  export type activityCategoryUpdateOneWithoutActivityNestedInput = {
    create?: XOR<activityCategoryCreateWithoutActivityInput, activityCategoryUncheckedCreateWithoutActivityInput>
    connectOrCreate?: activityCategoryCreateOrConnectWithoutActivityInput
    upsert?: activityCategoryUpsertWithoutActivityInput
    disconnect?: activityCategoryWhereInput | boolean
    delete?: activityCategoryWhereInput | boolean
    connect?: activityCategoryWhereUniqueInput
    update?: XOR<XOR<activityCategoryUpdateToOneWithWhereWithoutActivityInput, activityCategoryUpdateWithoutActivityInput>, activityCategoryUncheckedUpdateWithoutActivityInput>
  }

  export type activityRegistrationUpdateManyWithoutActivityNestedInput = {
    create?: XOR<activityRegistrationCreateWithoutActivityInput, activityRegistrationUncheckedCreateWithoutActivityInput> | activityRegistrationCreateWithoutActivityInput[] | activityRegistrationUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutActivityInput | activityRegistrationCreateOrConnectWithoutActivityInput[]
    upsert?: activityRegistrationUpsertWithWhereUniqueWithoutActivityInput | activityRegistrationUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: activityRegistrationCreateManyActivityInputEnvelope
    set?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    disconnect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    delete?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    update?: activityRegistrationUpdateWithWhereUniqueWithoutActivityInput | activityRegistrationUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: activityRegistrationUpdateManyWithWhereWithoutActivityInput | activityRegistrationUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: activityRegistrationScalarWhereInput | activityRegistrationScalarWhereInput[]
  }

  export type activityRegistrationUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<activityRegistrationCreateWithoutActivityInput, activityRegistrationUncheckedCreateWithoutActivityInput> | activityRegistrationCreateWithoutActivityInput[] | activityRegistrationUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutActivityInput | activityRegistrationCreateOrConnectWithoutActivityInput[]
    upsert?: activityRegistrationUpsertWithWhereUniqueWithoutActivityInput | activityRegistrationUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: activityRegistrationCreateManyActivityInputEnvelope
    set?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    disconnect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    delete?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    update?: activityRegistrationUpdateWithWhereUniqueWithoutActivityInput | activityRegistrationUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: activityRegistrationUpdateManyWithWhereWithoutActivityInput | activityRegistrationUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: activityRegistrationScalarWhereInput | activityRegistrationScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<userCreateWithoutActivityLogInput, userUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: userCreateOrConnectWithoutActivityLogInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutActivityLogNestedInput = {
    create?: XOR<userCreateWithoutActivityLogInput, userUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: userCreateOrConnectWithoutActivityLogInput
    upsert?: userUpsertWithoutActivityLogInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutActivityLogInput, userUpdateWithoutActivityLogInput>, userUncheckedUpdateWithoutActivityLogInput>
  }

  export type activityCreateNestedOneWithoutActivity_registrationInput = {
    create?: XOR<activityCreateWithoutActivity_registrationInput, activityUncheckedCreateWithoutActivity_registrationInput>
    connectOrCreate?: activityCreateOrConnectWithoutActivity_registrationInput
    connect?: activityWhereUniqueInput
  }

  export type userCreateNestedOneWithoutActivityRegistrationInput = {
    create?: XOR<userCreateWithoutActivityRegistrationInput, userUncheckedCreateWithoutActivityRegistrationInput>
    connectOrCreate?: userCreateOrConnectWithoutActivityRegistrationInput
    connect?: userWhereUniqueInput
  }

  export type activityUpdateOneRequiredWithoutActivity_registrationNestedInput = {
    create?: XOR<activityCreateWithoutActivity_registrationInput, activityUncheckedCreateWithoutActivity_registrationInput>
    connectOrCreate?: activityCreateOrConnectWithoutActivity_registrationInput
    upsert?: activityUpsertWithoutActivity_registrationInput
    connect?: activityWhereUniqueInput
    update?: XOR<XOR<activityUpdateToOneWithWhereWithoutActivity_registrationInput, activityUpdateWithoutActivity_registrationInput>, activityUncheckedUpdateWithoutActivity_registrationInput>
  }

  export type userUpdateOneRequiredWithoutActivityRegistrationNestedInput = {
    create?: XOR<userCreateWithoutActivityRegistrationInput, userUncheckedCreateWithoutActivityRegistrationInput>
    connectOrCreate?: userCreateOrConnectWithoutActivityRegistrationInput
    upsert?: userUpsertWithoutActivityRegistrationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutActivityRegistrationInput, userUpdateWithoutActivityRegistrationInput>, userUncheckedUpdateWithoutActivityRegistrationInput>
  }

  export type userBadgeCreateNestedOneWithoutBadgeInput = {
    create?: XOR<userBadgeCreateWithoutBadgeInput, userBadgeUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: userBadgeCreateOrConnectWithoutBadgeInput
    connect?: userBadgeWhereUniqueInput
  }

  export type badgeCategoryCreateNestedOneWithoutBadgeInput = {
    create?: XOR<badgeCategoryCreateWithoutBadgeInput, badgeCategoryUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: badgeCategoryCreateOrConnectWithoutBadgeInput
    connect?: badgeCategoryWhereUniqueInput
  }

  export type userBadgeUncheckedCreateNestedOneWithoutBadgeInput = {
    create?: XOR<userBadgeCreateWithoutBadgeInput, userBadgeUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: userBadgeCreateOrConnectWithoutBadgeInput
    connect?: userBadgeWhereUniqueInput
  }

  export type userBadgeUpdateOneWithoutBadgeNestedInput = {
    create?: XOR<userBadgeCreateWithoutBadgeInput, userBadgeUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: userBadgeCreateOrConnectWithoutBadgeInput
    upsert?: userBadgeUpsertWithoutBadgeInput
    disconnect?: userBadgeWhereInput | boolean
    delete?: userBadgeWhereInput | boolean
    connect?: userBadgeWhereUniqueInput
    update?: XOR<XOR<userBadgeUpdateToOneWithWhereWithoutBadgeInput, userBadgeUpdateWithoutBadgeInput>, userBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type badgeCategoryUpdateOneWithoutBadgeNestedInput = {
    create?: XOR<badgeCategoryCreateWithoutBadgeInput, badgeCategoryUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: badgeCategoryCreateOrConnectWithoutBadgeInput
    upsert?: badgeCategoryUpsertWithoutBadgeInput
    disconnect?: badgeCategoryWhereInput | boolean
    delete?: badgeCategoryWhereInput | boolean
    connect?: badgeCategoryWhereUniqueInput
    update?: XOR<XOR<badgeCategoryUpdateToOneWithWhereWithoutBadgeInput, badgeCategoryUpdateWithoutBadgeInput>, badgeCategoryUncheckedUpdateWithoutBadgeInput>
  }

  export type userBadgeUncheckedUpdateOneWithoutBadgeNestedInput = {
    create?: XOR<userBadgeCreateWithoutBadgeInput, userBadgeUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: userBadgeCreateOrConnectWithoutBadgeInput
    upsert?: userBadgeUpsertWithoutBadgeInput
    disconnect?: userBadgeWhereInput | boolean
    delete?: userBadgeWhereInput | boolean
    connect?: userBadgeWhereUniqueInput
    update?: XOR<XOR<userBadgeUpdateToOneWithWhereWithoutBadgeInput, userBadgeUpdateWithoutBadgeInput>, userBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type cognitiveCategoryCreateNestedOneWithoutCognitiveExerciseInput = {
    create?: XOR<cognitiveCategoryCreateWithoutCognitiveExerciseInput, cognitiveCategoryUncheckedCreateWithoutCognitiveExerciseInput>
    connectOrCreate?: cognitiveCategoryCreateOrConnectWithoutCognitiveExerciseInput
    connect?: cognitiveCategoryWhereUniqueInput
  }

  export type userActivityCreateNestedManyWithoutCognitiveExerciseInput = {
    create?: XOR<userActivityCreateWithoutCognitiveExerciseInput, userActivityUncheckedCreateWithoutCognitiveExerciseInput> | userActivityCreateWithoutCognitiveExerciseInput[] | userActivityUncheckedCreateWithoutCognitiveExerciseInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutCognitiveExerciseInput | userActivityCreateOrConnectWithoutCognitiveExerciseInput[]
    createMany?: userActivityCreateManyCognitiveExerciseInputEnvelope
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
  }

  export type programCategoryCreateNestedOneWithoutCognitiveExerciseInput = {
    create?: XOR<programCategoryCreateWithoutCognitiveExerciseInput, programCategoryUncheckedCreateWithoutCognitiveExerciseInput>
    connectOrCreate?: programCategoryCreateOrConnectWithoutCognitiveExerciseInput
    connect?: programCategoryWhereUniqueInput
  }

  export type userActivityUncheckedCreateNestedManyWithoutCognitiveExerciseInput = {
    create?: XOR<userActivityCreateWithoutCognitiveExerciseInput, userActivityUncheckedCreateWithoutCognitiveExerciseInput> | userActivityCreateWithoutCognitiveExerciseInput[] | userActivityUncheckedCreateWithoutCognitiveExerciseInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutCognitiveExerciseInput | userActivityCreateOrConnectWithoutCognitiveExerciseInput[]
    createMany?: userActivityCreateManyCognitiveExerciseInputEnvelope
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
  }

  export type cognitiveCategoryUpdateOneWithoutCognitiveExerciseNestedInput = {
    create?: XOR<cognitiveCategoryCreateWithoutCognitiveExerciseInput, cognitiveCategoryUncheckedCreateWithoutCognitiveExerciseInput>
    connectOrCreate?: cognitiveCategoryCreateOrConnectWithoutCognitiveExerciseInput
    upsert?: cognitiveCategoryUpsertWithoutCognitiveExerciseInput
    disconnect?: cognitiveCategoryWhereInput | boolean
    delete?: cognitiveCategoryWhereInput | boolean
    connect?: cognitiveCategoryWhereUniqueInput
    update?: XOR<XOR<cognitiveCategoryUpdateToOneWithWhereWithoutCognitiveExerciseInput, cognitiveCategoryUpdateWithoutCognitiveExerciseInput>, cognitiveCategoryUncheckedUpdateWithoutCognitiveExerciseInput>
  }

  export type userActivityUpdateManyWithoutCognitiveExerciseNestedInput = {
    create?: XOR<userActivityCreateWithoutCognitiveExerciseInput, userActivityUncheckedCreateWithoutCognitiveExerciseInput> | userActivityCreateWithoutCognitiveExerciseInput[] | userActivityUncheckedCreateWithoutCognitiveExerciseInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutCognitiveExerciseInput | userActivityCreateOrConnectWithoutCognitiveExerciseInput[]
    upsert?: userActivityUpsertWithWhereUniqueWithoutCognitiveExerciseInput | userActivityUpsertWithWhereUniqueWithoutCognitiveExerciseInput[]
    createMany?: userActivityCreateManyCognitiveExerciseInputEnvelope
    set?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    disconnect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    delete?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    update?: userActivityUpdateWithWhereUniqueWithoutCognitiveExerciseInput | userActivityUpdateWithWhereUniqueWithoutCognitiveExerciseInput[]
    updateMany?: userActivityUpdateManyWithWhereWithoutCognitiveExerciseInput | userActivityUpdateManyWithWhereWithoutCognitiveExerciseInput[]
    deleteMany?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
  }

  export type programCategoryUpdateOneWithoutCognitiveExerciseNestedInput = {
    create?: XOR<programCategoryCreateWithoutCognitiveExerciseInput, programCategoryUncheckedCreateWithoutCognitiveExerciseInput>
    connectOrCreate?: programCategoryCreateOrConnectWithoutCognitiveExerciseInput
    upsert?: programCategoryUpsertWithoutCognitiveExerciseInput
    disconnect?: programCategoryWhereInput | boolean
    delete?: programCategoryWhereInput | boolean
    connect?: programCategoryWhereUniqueInput
    update?: XOR<XOR<programCategoryUpdateToOneWithWhereWithoutCognitiveExerciseInput, programCategoryUpdateWithoutCognitiveExerciseInput>, programCategoryUncheckedUpdateWithoutCognitiveExerciseInput>
  }

  export type userActivityUncheckedUpdateManyWithoutCognitiveExerciseNestedInput = {
    create?: XOR<userActivityCreateWithoutCognitiveExerciseInput, userActivityUncheckedCreateWithoutCognitiveExerciseInput> | userActivityCreateWithoutCognitiveExerciseInput[] | userActivityUncheckedCreateWithoutCognitiveExerciseInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutCognitiveExerciseInput | userActivityCreateOrConnectWithoutCognitiveExerciseInput[]
    upsert?: userActivityUpsertWithWhereUniqueWithoutCognitiveExerciseInput | userActivityUpsertWithWhereUniqueWithoutCognitiveExerciseInput[]
    createMany?: userActivityCreateManyCognitiveExerciseInputEnvelope
    set?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    disconnect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    delete?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    update?: userActivityUpdateWithWhereUniqueWithoutCognitiveExerciseInput | userActivityUpdateWithWhereUniqueWithoutCognitiveExerciseInput[]
    updateMany?: userActivityUpdateManyWithWhereWithoutCognitiveExerciseInput | userActivityUpdateManyWithWhereWithoutCognitiveExerciseInput[]
    deleteMany?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutCollaborativeProjectInput = {
    create?: XOR<userCreateWithoutCollaborativeProjectInput, userUncheckedCreateWithoutCollaborativeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutCollaborativeProjectInput
    connect?: userWhereUniqueInput
  }

  export type projectCategoryCreateNestedOneWithoutCollaborativeProjectInput = {
    create?: XOR<projectCategoryCreateWithoutCollaborativeProjectInput, projectCategoryUncheckedCreateWithoutCollaborativeProjectInput>
    connectOrCreate?: projectCategoryCreateOrConnectWithoutCollaborativeProjectInput
    connect?: projectCategoryWhereUniqueInput
  }

  export type projectMemberCreateNestedManyWithoutCollaborativeProjectInput = {
    create?: XOR<projectMemberCreateWithoutCollaborativeProjectInput, projectMemberUncheckedCreateWithoutCollaborativeProjectInput> | projectMemberCreateWithoutCollaborativeProjectInput[] | projectMemberUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutCollaborativeProjectInput | projectMemberCreateOrConnectWithoutCollaborativeProjectInput[]
    createMany?: projectMemberCreateManyCollaborativeProjectInputEnvelope
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
  }

  export type projectTaskCreateNestedManyWithoutCollaborativeProjectInput = {
    create?: XOR<projectTaskCreateWithoutCollaborativeProjectInput, projectTaskUncheckedCreateWithoutCollaborativeProjectInput> | projectTaskCreateWithoutCollaborativeProjectInput[] | projectTaskUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutCollaborativeProjectInput | projectTaskCreateOrConnectWithoutCollaborativeProjectInput[]
    createMany?: projectTaskCreateManyCollaborativeProjectInputEnvelope
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
  }

  export type projectMemberUncheckedCreateNestedManyWithoutCollaborativeProjectInput = {
    create?: XOR<projectMemberCreateWithoutCollaborativeProjectInput, projectMemberUncheckedCreateWithoutCollaborativeProjectInput> | projectMemberCreateWithoutCollaborativeProjectInput[] | projectMemberUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutCollaborativeProjectInput | projectMemberCreateOrConnectWithoutCollaborativeProjectInput[]
    createMany?: projectMemberCreateManyCollaborativeProjectInputEnvelope
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
  }

  export type projectTaskUncheckedCreateNestedManyWithoutCollaborativeProjectInput = {
    create?: XOR<projectTaskCreateWithoutCollaborativeProjectInput, projectTaskUncheckedCreateWithoutCollaborativeProjectInput> | projectTaskCreateWithoutCollaborativeProjectInput[] | projectTaskUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutCollaborativeProjectInput | projectTaskCreateOrConnectWithoutCollaborativeProjectInput[]
    createMany?: projectTaskCreateManyCollaborativeProjectInputEnvelope
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
  }

  export type userUpdateOneWithoutCollaborativeProjectNestedInput = {
    create?: XOR<userCreateWithoutCollaborativeProjectInput, userUncheckedCreateWithoutCollaborativeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutCollaborativeProjectInput
    upsert?: userUpsertWithoutCollaborativeProjectInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCollaborativeProjectInput, userUpdateWithoutCollaborativeProjectInput>, userUncheckedUpdateWithoutCollaborativeProjectInput>
  }

  export type projectCategoryUpdateOneWithoutCollaborativeProjectNestedInput = {
    create?: XOR<projectCategoryCreateWithoutCollaborativeProjectInput, projectCategoryUncheckedCreateWithoutCollaborativeProjectInput>
    connectOrCreate?: projectCategoryCreateOrConnectWithoutCollaborativeProjectInput
    upsert?: projectCategoryUpsertWithoutCollaborativeProjectInput
    disconnect?: projectCategoryWhereInput | boolean
    delete?: projectCategoryWhereInput | boolean
    connect?: projectCategoryWhereUniqueInput
    update?: XOR<XOR<projectCategoryUpdateToOneWithWhereWithoutCollaborativeProjectInput, projectCategoryUpdateWithoutCollaborativeProjectInput>, projectCategoryUncheckedUpdateWithoutCollaborativeProjectInput>
  }

  export type projectMemberUpdateManyWithoutCollaborativeProjectNestedInput = {
    create?: XOR<projectMemberCreateWithoutCollaborativeProjectInput, projectMemberUncheckedCreateWithoutCollaborativeProjectInput> | projectMemberCreateWithoutCollaborativeProjectInput[] | projectMemberUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutCollaborativeProjectInput | projectMemberCreateOrConnectWithoutCollaborativeProjectInput[]
    upsert?: projectMemberUpsertWithWhereUniqueWithoutCollaborativeProjectInput | projectMemberUpsertWithWhereUniqueWithoutCollaborativeProjectInput[]
    createMany?: projectMemberCreateManyCollaborativeProjectInputEnvelope
    set?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    disconnect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    delete?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    update?: projectMemberUpdateWithWhereUniqueWithoutCollaborativeProjectInput | projectMemberUpdateWithWhereUniqueWithoutCollaborativeProjectInput[]
    updateMany?: projectMemberUpdateManyWithWhereWithoutCollaborativeProjectInput | projectMemberUpdateManyWithWhereWithoutCollaborativeProjectInput[]
    deleteMany?: projectMemberScalarWhereInput | projectMemberScalarWhereInput[]
  }

  export type projectTaskUpdateManyWithoutCollaborativeProjectNestedInput = {
    create?: XOR<projectTaskCreateWithoutCollaborativeProjectInput, projectTaskUncheckedCreateWithoutCollaborativeProjectInput> | projectTaskCreateWithoutCollaborativeProjectInput[] | projectTaskUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutCollaborativeProjectInput | projectTaskCreateOrConnectWithoutCollaborativeProjectInput[]
    upsert?: projectTaskUpsertWithWhereUniqueWithoutCollaborativeProjectInput | projectTaskUpsertWithWhereUniqueWithoutCollaborativeProjectInput[]
    createMany?: projectTaskCreateManyCollaborativeProjectInputEnvelope
    set?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    disconnect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    delete?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    update?: projectTaskUpdateWithWhereUniqueWithoutCollaborativeProjectInput | projectTaskUpdateWithWhereUniqueWithoutCollaborativeProjectInput[]
    updateMany?: projectTaskUpdateManyWithWhereWithoutCollaborativeProjectInput | projectTaskUpdateManyWithWhereWithoutCollaborativeProjectInput[]
    deleteMany?: projectTaskScalarWhereInput | projectTaskScalarWhereInput[]
  }

  export type projectMemberUncheckedUpdateManyWithoutCollaborativeProjectNestedInput = {
    create?: XOR<projectMemberCreateWithoutCollaborativeProjectInput, projectMemberUncheckedCreateWithoutCollaborativeProjectInput> | projectMemberCreateWithoutCollaborativeProjectInput[] | projectMemberUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutCollaborativeProjectInput | projectMemberCreateOrConnectWithoutCollaborativeProjectInput[]
    upsert?: projectMemberUpsertWithWhereUniqueWithoutCollaborativeProjectInput | projectMemberUpsertWithWhereUniqueWithoutCollaborativeProjectInput[]
    createMany?: projectMemberCreateManyCollaborativeProjectInputEnvelope
    set?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    disconnect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    delete?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    update?: projectMemberUpdateWithWhereUniqueWithoutCollaborativeProjectInput | projectMemberUpdateWithWhereUniqueWithoutCollaborativeProjectInput[]
    updateMany?: projectMemberUpdateManyWithWhereWithoutCollaborativeProjectInput | projectMemberUpdateManyWithWhereWithoutCollaborativeProjectInput[]
    deleteMany?: projectMemberScalarWhereInput | projectMemberScalarWhereInput[]
  }

  export type projectTaskUncheckedUpdateManyWithoutCollaborativeProjectNestedInput = {
    create?: XOR<projectTaskCreateWithoutCollaborativeProjectInput, projectTaskUncheckedCreateWithoutCollaborativeProjectInput> | projectTaskCreateWithoutCollaborativeProjectInput[] | projectTaskUncheckedCreateWithoutCollaborativeProjectInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutCollaborativeProjectInput | projectTaskCreateOrConnectWithoutCollaborativeProjectInput[]
    upsert?: projectTaskUpsertWithWhereUniqueWithoutCollaborativeProjectInput | projectTaskUpsertWithWhereUniqueWithoutCollaborativeProjectInput[]
    createMany?: projectTaskCreateManyCollaborativeProjectInputEnvelope
    set?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    disconnect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    delete?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    update?: projectTaskUpdateWithWhereUniqueWithoutCollaborativeProjectInput | projectTaskUpdateWithWhereUniqueWithoutCollaborativeProjectInput[]
    updateMany?: projectTaskUpdateManyWithWhereWithoutCollaborativeProjectInput | projectTaskUpdateManyWithWhereWithoutCollaborativeProjectInput[]
    deleteMany?: projectTaskScalarWhereInput | projectTaskScalarWhereInput[]
  }

  export type conversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<conversationParticipantCreateWithoutConversationInput, conversationParticipantUncheckedCreateWithoutConversationInput> | conversationParticipantCreateWithoutConversationInput[] | conversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutConversationInput | conversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: conversationParticipantCreateManyConversationInputEnvelope
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutConversationInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type videoCallCreateNestedManyWithoutConversationInput = {
    create?: XOR<videoCallCreateWithoutConversationInput, videoCallUncheckedCreateWithoutConversationInput> | videoCallCreateWithoutConversationInput[] | videoCallUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutConversationInput | videoCallCreateOrConnectWithoutConversationInput[]
    createMany?: videoCallCreateManyConversationInputEnvelope
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
  }

  export type conversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<conversationParticipantCreateWithoutConversationInput, conversationParticipantUncheckedCreateWithoutConversationInput> | conversationParticipantCreateWithoutConversationInput[] | conversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutConversationInput | conversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: conversationParticipantCreateManyConversationInputEnvelope
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type videoCallUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<videoCallCreateWithoutConversationInput, videoCallUncheckedCreateWithoutConversationInput> | videoCallCreateWithoutConversationInput[] | videoCallUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutConversationInput | videoCallCreateOrConnectWithoutConversationInput[]
    createMany?: videoCallCreateManyConversationInputEnvelope
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
  }

  export type conversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<conversationParticipantCreateWithoutConversationInput, conversationParticipantUncheckedCreateWithoutConversationInput> | conversationParticipantCreateWithoutConversationInput[] | conversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutConversationInput | conversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: conversationParticipantUpsertWithWhereUniqueWithoutConversationInput | conversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: conversationParticipantCreateManyConversationInputEnvelope
    set?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    disconnect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    delete?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    update?: conversationParticipantUpdateWithWhereUniqueWithoutConversationInput | conversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: conversationParticipantUpdateManyWithWhereWithoutConversationInput | conversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: conversationParticipantScalarWhereInput | conversationParticipantScalarWhereInput[]
  }

  export type messageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutConversationInput | messageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutConversationInput | messageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: messageUpdateManyWithWhereWithoutConversationInput | messageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type videoCallUpdateManyWithoutConversationNestedInput = {
    create?: XOR<videoCallCreateWithoutConversationInput, videoCallUncheckedCreateWithoutConversationInput> | videoCallCreateWithoutConversationInput[] | videoCallUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutConversationInput | videoCallCreateOrConnectWithoutConversationInput[]
    upsert?: videoCallUpsertWithWhereUniqueWithoutConversationInput | videoCallUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: videoCallCreateManyConversationInputEnvelope
    set?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    disconnect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    delete?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    update?: videoCallUpdateWithWhereUniqueWithoutConversationInput | videoCallUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: videoCallUpdateManyWithWhereWithoutConversationInput | videoCallUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: videoCallScalarWhereInput | videoCallScalarWhereInput[]
  }

  export type conversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<conversationParticipantCreateWithoutConversationInput, conversationParticipantUncheckedCreateWithoutConversationInput> | conversationParticipantCreateWithoutConversationInput[] | conversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutConversationInput | conversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: conversationParticipantUpsertWithWhereUniqueWithoutConversationInput | conversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: conversationParticipantCreateManyConversationInputEnvelope
    set?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    disconnect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    delete?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    update?: conversationParticipantUpdateWithWhereUniqueWithoutConversationInput | conversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: conversationParticipantUpdateManyWithWhereWithoutConversationInput | conversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: conversationParticipantScalarWhereInput | conversationParticipantScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutConversationInput | messageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutConversationInput | messageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: messageUpdateManyWithWhereWithoutConversationInput | messageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type videoCallUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<videoCallCreateWithoutConversationInput, videoCallUncheckedCreateWithoutConversationInput> | videoCallCreateWithoutConversationInput[] | videoCallUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutConversationInput | videoCallCreateOrConnectWithoutConversationInput[]
    upsert?: videoCallUpsertWithWhereUniqueWithoutConversationInput | videoCallUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: videoCallCreateManyConversationInputEnvelope
    set?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    disconnect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    delete?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    update?: videoCallUpdateWithWhereUniqueWithoutConversationInput | videoCallUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: videoCallUpdateManyWithWhereWithoutConversationInput | videoCallUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: videoCallScalarWhereInput | videoCallScalarWhereInput[]
  }

  export type conversationCreateNestedOneWithoutConversationParticipantInput = {
    create?: XOR<conversationCreateWithoutConversationParticipantInput, conversationUncheckedCreateWithoutConversationParticipantInput>
    connectOrCreate?: conversationCreateOrConnectWithoutConversationParticipantInput
    connect?: conversationWhereUniqueInput
  }

  export type userCreateNestedOneWithoutConversationParticipantInput = {
    create?: XOR<userCreateWithoutConversationParticipantInput, userUncheckedCreateWithoutConversationParticipantInput>
    connectOrCreate?: userCreateOrConnectWithoutConversationParticipantInput
    connect?: userWhereUniqueInput
  }

  export type conversationUpdateOneRequiredWithoutConversationParticipantNestedInput = {
    create?: XOR<conversationCreateWithoutConversationParticipantInput, conversationUncheckedCreateWithoutConversationParticipantInput>
    connectOrCreate?: conversationCreateOrConnectWithoutConversationParticipantInput
    upsert?: conversationUpsertWithoutConversationParticipantInput
    connect?: conversationWhereUniqueInput
    update?: XOR<XOR<conversationUpdateToOneWithWhereWithoutConversationParticipantInput, conversationUpdateWithoutConversationParticipantInput>, conversationUncheckedUpdateWithoutConversationParticipantInput>
  }

  export type userUpdateOneRequiredWithoutConversationParticipantNestedInput = {
    create?: XOR<userCreateWithoutConversationParticipantInput, userUncheckedCreateWithoutConversationParticipantInput>
    connectOrCreate?: userCreateOrConnectWithoutConversationParticipantInput
    upsert?: userUpsertWithoutConversationParticipantInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutConversationParticipantInput, userUpdateWithoutConversationParticipantInput>, userUncheckedUpdateWithoutConversationParticipantInput>
  }

  export type programCategoryCreateNestedOneWithoutExerciseProgramInput = {
    create?: XOR<programCategoryCreateWithoutExerciseProgramInput, programCategoryUncheckedCreateWithoutExerciseProgramInput>
    connectOrCreate?: programCategoryCreateOrConnectWithoutExerciseProgramInput
    connect?: programCategoryWhereUniqueInput
  }

  export type userActivityCreateNestedManyWithoutExerciseProgramInput = {
    create?: XOR<userActivityCreateWithoutExerciseProgramInput, userActivityUncheckedCreateWithoutExerciseProgramInput> | userActivityCreateWithoutExerciseProgramInput[] | userActivityUncheckedCreateWithoutExerciseProgramInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutExerciseProgramInput | userActivityCreateOrConnectWithoutExerciseProgramInput[]
    createMany?: userActivityCreateManyExerciseProgramInputEnvelope
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
  }

  export type userActivityUncheckedCreateNestedManyWithoutExerciseProgramInput = {
    create?: XOR<userActivityCreateWithoutExerciseProgramInput, userActivityUncheckedCreateWithoutExerciseProgramInput> | userActivityCreateWithoutExerciseProgramInput[] | userActivityUncheckedCreateWithoutExerciseProgramInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutExerciseProgramInput | userActivityCreateOrConnectWithoutExerciseProgramInput[]
    createMany?: userActivityCreateManyExerciseProgramInputEnvelope
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
  }

  export type programCategoryUpdateOneWithoutExerciseProgramNestedInput = {
    create?: XOR<programCategoryCreateWithoutExerciseProgramInput, programCategoryUncheckedCreateWithoutExerciseProgramInput>
    connectOrCreate?: programCategoryCreateOrConnectWithoutExerciseProgramInput
    upsert?: programCategoryUpsertWithoutExerciseProgramInput
    disconnect?: programCategoryWhereInput | boolean
    delete?: programCategoryWhereInput | boolean
    connect?: programCategoryWhereUniqueInput
    update?: XOR<XOR<programCategoryUpdateToOneWithWhereWithoutExerciseProgramInput, programCategoryUpdateWithoutExerciseProgramInput>, programCategoryUncheckedUpdateWithoutExerciseProgramInput>
  }

  export type userActivityUpdateManyWithoutExerciseProgramNestedInput = {
    create?: XOR<userActivityCreateWithoutExerciseProgramInput, userActivityUncheckedCreateWithoutExerciseProgramInput> | userActivityCreateWithoutExerciseProgramInput[] | userActivityUncheckedCreateWithoutExerciseProgramInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutExerciseProgramInput | userActivityCreateOrConnectWithoutExerciseProgramInput[]
    upsert?: userActivityUpsertWithWhereUniqueWithoutExerciseProgramInput | userActivityUpsertWithWhereUniqueWithoutExerciseProgramInput[]
    createMany?: userActivityCreateManyExerciseProgramInputEnvelope
    set?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    disconnect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    delete?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    update?: userActivityUpdateWithWhereUniqueWithoutExerciseProgramInput | userActivityUpdateWithWhereUniqueWithoutExerciseProgramInput[]
    updateMany?: userActivityUpdateManyWithWhereWithoutExerciseProgramInput | userActivityUpdateManyWithWhereWithoutExerciseProgramInput[]
    deleteMany?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
  }

  export type userActivityUncheckedUpdateManyWithoutExerciseProgramNestedInput = {
    create?: XOR<userActivityCreateWithoutExerciseProgramInput, userActivityUncheckedCreateWithoutExerciseProgramInput> | userActivityCreateWithoutExerciseProgramInput[] | userActivityUncheckedCreateWithoutExerciseProgramInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutExerciseProgramInput | userActivityCreateOrConnectWithoutExerciseProgramInput[]
    upsert?: userActivityUpsertWithWhereUniqueWithoutExerciseProgramInput | userActivityUpsertWithWhereUniqueWithoutExerciseProgramInput[]
    createMany?: userActivityCreateManyExerciseProgramInputEnvelope
    set?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    disconnect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    delete?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    update?: userActivityUpdateWithWhereUniqueWithoutExerciseProgramInput | userActivityUpdateWithWhereUniqueWithoutExerciseProgramInput[]
    updateMany?: userActivityUpdateManyWithWhereWithoutExerciseProgramInput | userActivityUpdateManyWithWhereWithoutExerciseProgramInput[]
    deleteMany?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
  }

  export type forumTopicCreateNestedManyWithoutForumCategoryInput = {
    create?: XOR<forumTopicCreateWithoutForumCategoryInput, forumTopicUncheckedCreateWithoutForumCategoryInput> | forumTopicCreateWithoutForumCategoryInput[] | forumTopicUncheckedCreateWithoutForumCategoryInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutForumCategoryInput | forumTopicCreateOrConnectWithoutForumCategoryInput[]
    createMany?: forumTopicCreateManyForumCategoryInputEnvelope
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
  }

  export type forumTopicUncheckedCreateNestedManyWithoutForumCategoryInput = {
    create?: XOR<forumTopicCreateWithoutForumCategoryInput, forumTopicUncheckedCreateWithoutForumCategoryInput> | forumTopicCreateWithoutForumCategoryInput[] | forumTopicUncheckedCreateWithoutForumCategoryInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutForumCategoryInput | forumTopicCreateOrConnectWithoutForumCategoryInput[]
    createMany?: forumTopicCreateManyForumCategoryInputEnvelope
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
  }

  export type forumTopicUpdateManyWithoutForumCategoryNestedInput = {
    create?: XOR<forumTopicCreateWithoutForumCategoryInput, forumTopicUncheckedCreateWithoutForumCategoryInput> | forumTopicCreateWithoutForumCategoryInput[] | forumTopicUncheckedCreateWithoutForumCategoryInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutForumCategoryInput | forumTopicCreateOrConnectWithoutForumCategoryInput[]
    upsert?: forumTopicUpsertWithWhereUniqueWithoutForumCategoryInput | forumTopicUpsertWithWhereUniqueWithoutForumCategoryInput[]
    createMany?: forumTopicCreateManyForumCategoryInputEnvelope
    set?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    disconnect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    delete?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    update?: forumTopicUpdateWithWhereUniqueWithoutForumCategoryInput | forumTopicUpdateWithWhereUniqueWithoutForumCategoryInput[]
    updateMany?: forumTopicUpdateManyWithWhereWithoutForumCategoryInput | forumTopicUpdateManyWithWhereWithoutForumCategoryInput[]
    deleteMany?: forumTopicScalarWhereInput | forumTopicScalarWhereInput[]
  }

  export type forumTopicUncheckedUpdateManyWithoutForumCategoryNestedInput = {
    create?: XOR<forumTopicCreateWithoutForumCategoryInput, forumTopicUncheckedCreateWithoutForumCategoryInput> | forumTopicCreateWithoutForumCategoryInput[] | forumTopicUncheckedCreateWithoutForumCategoryInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutForumCategoryInput | forumTopicCreateOrConnectWithoutForumCategoryInput[]
    upsert?: forumTopicUpsertWithWhereUniqueWithoutForumCategoryInput | forumTopicUpsertWithWhereUniqueWithoutForumCategoryInput[]
    createMany?: forumTopicCreateManyForumCategoryInputEnvelope
    set?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    disconnect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    delete?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    update?: forumTopicUpdateWithWhereUniqueWithoutForumCategoryInput | forumTopicUpdateWithWhereUniqueWithoutForumCategoryInput[]
    updateMany?: forumTopicUpdateManyWithWhereWithoutForumCategoryInput | forumTopicUpdateManyWithWhereWithoutForumCategoryInput[]
    deleteMany?: forumTopicScalarWhereInput | forumTopicScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutForumMessageInput = {
    create?: XOR<userCreateWithoutForumMessageInput, userUncheckedCreateWithoutForumMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutForumMessageInput
    connect?: userWhereUniqueInput
  }

  export type forumTopicCreateNestedOneWithoutForumMessageInput = {
    create?: XOR<forumTopicCreateWithoutForumMessageInput, forumTopicUncheckedCreateWithoutForumMessageInput>
    connectOrCreate?: forumTopicCreateOrConnectWithoutForumMessageInput
    connect?: forumTopicWhereUniqueInput
  }

  export type userUpdateOneWithoutForumMessageNestedInput = {
    create?: XOR<userCreateWithoutForumMessageInput, userUncheckedCreateWithoutForumMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutForumMessageInput
    upsert?: userUpsertWithoutForumMessageInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutForumMessageInput, userUpdateWithoutForumMessageInput>, userUncheckedUpdateWithoutForumMessageInput>
  }

  export type forumTopicUpdateOneWithoutForumMessageNestedInput = {
    create?: XOR<forumTopicCreateWithoutForumMessageInput, forumTopicUncheckedCreateWithoutForumMessageInput>
    connectOrCreate?: forumTopicCreateOrConnectWithoutForumMessageInput
    upsert?: forumTopicUpsertWithoutForumMessageInput
    disconnect?: forumTopicWhereInput | boolean
    delete?: forumTopicWhereInput | boolean
    connect?: forumTopicWhereUniqueInput
    update?: XOR<XOR<forumTopicUpdateToOneWithWhereWithoutForumMessageInput, forumTopicUpdateWithoutForumMessageInput>, forumTopicUncheckedUpdateWithoutForumMessageInput>
  }

  export type forumMessageCreateNestedManyWithoutForumTopicInput = {
    create?: XOR<forumMessageCreateWithoutForumTopicInput, forumMessageUncheckedCreateWithoutForumTopicInput> | forumMessageCreateWithoutForumTopicInput[] | forumMessageUncheckedCreateWithoutForumTopicInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutForumTopicInput | forumMessageCreateOrConnectWithoutForumTopicInput[]
    createMany?: forumMessageCreateManyForumTopicInputEnvelope
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutForumTopicInput = {
    create?: XOR<userCreateWithoutForumTopicInput, userUncheckedCreateWithoutForumTopicInput>
    connectOrCreate?: userCreateOrConnectWithoutForumTopicInput
    connect?: userWhereUniqueInput
  }

  export type forumCategoryCreateNestedOneWithoutForumTopicInput = {
    create?: XOR<forumCategoryCreateWithoutForumTopicInput, forumCategoryUncheckedCreateWithoutForumTopicInput>
    connectOrCreate?: forumCategoryCreateOrConnectWithoutForumTopicInput
    connect?: forumCategoryWhereUniqueInput
  }

  export type forumMessageUncheckedCreateNestedManyWithoutForumTopicInput = {
    create?: XOR<forumMessageCreateWithoutForumTopicInput, forumMessageUncheckedCreateWithoutForumTopicInput> | forumMessageCreateWithoutForumTopicInput[] | forumMessageUncheckedCreateWithoutForumTopicInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutForumTopicInput | forumMessageCreateOrConnectWithoutForumTopicInput[]
    createMany?: forumMessageCreateManyForumTopicInputEnvelope
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
  }

  export type forumMessageUpdateManyWithoutForumTopicNestedInput = {
    create?: XOR<forumMessageCreateWithoutForumTopicInput, forumMessageUncheckedCreateWithoutForumTopicInput> | forumMessageCreateWithoutForumTopicInput[] | forumMessageUncheckedCreateWithoutForumTopicInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutForumTopicInput | forumMessageCreateOrConnectWithoutForumTopicInput[]
    upsert?: forumMessageUpsertWithWhereUniqueWithoutForumTopicInput | forumMessageUpsertWithWhereUniqueWithoutForumTopicInput[]
    createMany?: forumMessageCreateManyForumTopicInputEnvelope
    set?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    disconnect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    delete?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    update?: forumMessageUpdateWithWhereUniqueWithoutForumTopicInput | forumMessageUpdateWithWhereUniqueWithoutForumTopicInput[]
    updateMany?: forumMessageUpdateManyWithWhereWithoutForumTopicInput | forumMessageUpdateManyWithWhereWithoutForumTopicInput[]
    deleteMany?: forumMessageScalarWhereInput | forumMessageScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutForumTopicNestedInput = {
    create?: XOR<userCreateWithoutForumTopicInput, userUncheckedCreateWithoutForumTopicInput>
    connectOrCreate?: userCreateOrConnectWithoutForumTopicInput
    upsert?: userUpsertWithoutForumTopicInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutForumTopicInput, userUpdateWithoutForumTopicInput>, userUncheckedUpdateWithoutForumTopicInput>
  }

  export type forumCategoryUpdateOneWithoutForumTopicNestedInput = {
    create?: XOR<forumCategoryCreateWithoutForumTopicInput, forumCategoryUncheckedCreateWithoutForumTopicInput>
    connectOrCreate?: forumCategoryCreateOrConnectWithoutForumTopicInput
    upsert?: forumCategoryUpsertWithoutForumTopicInput
    disconnect?: forumCategoryWhereInput | boolean
    delete?: forumCategoryWhereInput | boolean
    connect?: forumCategoryWhereUniqueInput
    update?: XOR<XOR<forumCategoryUpdateToOneWithWhereWithoutForumTopicInput, forumCategoryUpdateWithoutForumTopicInput>, forumCategoryUncheckedUpdateWithoutForumTopicInput>
  }

  export type forumMessageUncheckedUpdateManyWithoutForumTopicNestedInput = {
    create?: XOR<forumMessageCreateWithoutForumTopicInput, forumMessageUncheckedCreateWithoutForumTopicInput> | forumMessageCreateWithoutForumTopicInput[] | forumMessageUncheckedCreateWithoutForumTopicInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutForumTopicInput | forumMessageCreateOrConnectWithoutForumTopicInput[]
    upsert?: forumMessageUpsertWithWhereUniqueWithoutForumTopicInput | forumMessageUpsertWithWhereUniqueWithoutForumTopicInput[]
    createMany?: forumMessageCreateManyForumTopicInputEnvelope
    set?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    disconnect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    delete?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    update?: forumMessageUpdateWithWhereUniqueWithoutForumTopicInput | forumMessageUpdateWithWhereUniqueWithoutForumTopicInput[]
    updateMany?: forumMessageUpdateManyWithWhereWithoutForumTopicInput | forumMessageUpdateManyWithWhereWithoutForumTopicInput[]
    deleteMany?: forumMessageScalarWhereInput | forumMessageScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutHealthIndicatorInput = {
    create?: XOR<userCreateWithoutHealthIndicatorInput, userUncheckedCreateWithoutHealthIndicatorInput>
    connectOrCreate?: userCreateOrConnectWithoutHealthIndicatorInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutHealthIndicatorNestedInput = {
    create?: XOR<userCreateWithoutHealthIndicatorInput, userUncheckedCreateWithoutHealthIndicatorInput>
    connectOrCreate?: userCreateOrConnectWithoutHealthIndicatorInput
    upsert?: userUpsertWithoutHealthIndicatorInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutHealthIndicatorInput, userUpdateWithoutHealthIndicatorInput>, userUncheckedUpdateWithoutHealthIndicatorInput>
  }

  export type userCreateNestedOneWithoutHelpOfferInput = {
    create?: XOR<userCreateWithoutHelpOfferInput, userUncheckedCreateWithoutHelpOfferInput>
    connectOrCreate?: userCreateOrConnectWithoutHelpOfferInput
    connect?: userWhereUniqueInput
  }

  export type helpRequestCreateNestedOneWithoutHelpOfferInput = {
    create?: XOR<helpRequestCreateWithoutHelpOfferInput, helpRequestUncheckedCreateWithoutHelpOfferInput>
    connectOrCreate?: helpRequestCreateOrConnectWithoutHelpOfferInput
    connect?: helpRequestWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutHelpOfferNestedInput = {
    create?: XOR<userCreateWithoutHelpOfferInput, userUncheckedCreateWithoutHelpOfferInput>
    connectOrCreate?: userCreateOrConnectWithoutHelpOfferInput
    upsert?: userUpsertWithoutHelpOfferInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutHelpOfferInput, userUpdateWithoutHelpOfferInput>, userUncheckedUpdateWithoutHelpOfferInput>
  }

  export type helpRequestUpdateOneRequiredWithoutHelpOfferNestedInput = {
    create?: XOR<helpRequestCreateWithoutHelpOfferInput, helpRequestUncheckedCreateWithoutHelpOfferInput>
    connectOrCreate?: helpRequestCreateOrConnectWithoutHelpOfferInput
    upsert?: helpRequestUpsertWithoutHelpOfferInput
    connect?: helpRequestWhereUniqueInput
    update?: XOR<XOR<helpRequestUpdateToOneWithWhereWithoutHelpOfferInput, helpRequestUpdateWithoutHelpOfferInput>, helpRequestUncheckedUpdateWithoutHelpOfferInput>
  }

  export type helpOfferCreateNestedManyWithoutHelpRequestInput = {
    create?: XOR<helpOfferCreateWithoutHelpRequestInput, helpOfferUncheckedCreateWithoutHelpRequestInput> | helpOfferCreateWithoutHelpRequestInput[] | helpOfferUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutHelpRequestInput | helpOfferCreateOrConnectWithoutHelpRequestInput[]
    createMany?: helpOfferCreateManyHelpRequestInputEnvelope
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutHelpRequestInput = {
    create?: XOR<userCreateWithoutHelpRequestInput, userUncheckedCreateWithoutHelpRequestInput>
    connectOrCreate?: userCreateOrConnectWithoutHelpRequestInput
    connect?: userWhereUniqueInput
  }

  export type serviceCompletedCreateNestedManyWithoutHelpRequestInput = {
    create?: XOR<serviceCompletedCreateWithoutHelpRequestInput, serviceCompletedUncheckedCreateWithoutHelpRequestInput> | serviceCompletedCreateWithoutHelpRequestInput[] | serviceCompletedUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutHelpRequestInput | serviceCompletedCreateOrConnectWithoutHelpRequestInput[]
    createMany?: serviceCompletedCreateManyHelpRequestInputEnvelope
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
  }

  export type helpCategoryCreateNestedOneWithoutHelpRequestInput = {
    create?: XOR<helpCategoryCreateWithoutHelpRequestInput, helpCategoryUncheckedCreateWithoutHelpRequestInput>
    connectOrCreate?: helpCategoryCreateOrConnectWithoutHelpRequestInput
    connect?: helpCategoryWhereUniqueInput
  }

  export type helpOfferUncheckedCreateNestedManyWithoutHelpRequestInput = {
    create?: XOR<helpOfferCreateWithoutHelpRequestInput, helpOfferUncheckedCreateWithoutHelpRequestInput> | helpOfferCreateWithoutHelpRequestInput[] | helpOfferUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutHelpRequestInput | helpOfferCreateOrConnectWithoutHelpRequestInput[]
    createMany?: helpOfferCreateManyHelpRequestInputEnvelope
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
  }

  export type serviceCompletedUncheckedCreateNestedManyWithoutHelpRequestInput = {
    create?: XOR<serviceCompletedCreateWithoutHelpRequestInput, serviceCompletedUncheckedCreateWithoutHelpRequestInput> | serviceCompletedCreateWithoutHelpRequestInput[] | serviceCompletedUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutHelpRequestInput | serviceCompletedCreateOrConnectWithoutHelpRequestInput[]
    createMany?: serviceCompletedCreateManyHelpRequestInputEnvelope
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
  }

  export type helpOfferUpdateManyWithoutHelpRequestNestedInput = {
    create?: XOR<helpOfferCreateWithoutHelpRequestInput, helpOfferUncheckedCreateWithoutHelpRequestInput> | helpOfferCreateWithoutHelpRequestInput[] | helpOfferUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutHelpRequestInput | helpOfferCreateOrConnectWithoutHelpRequestInput[]
    upsert?: helpOfferUpsertWithWhereUniqueWithoutHelpRequestInput | helpOfferUpsertWithWhereUniqueWithoutHelpRequestInput[]
    createMany?: helpOfferCreateManyHelpRequestInputEnvelope
    set?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    disconnect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    delete?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    update?: helpOfferUpdateWithWhereUniqueWithoutHelpRequestInput | helpOfferUpdateWithWhereUniqueWithoutHelpRequestInput[]
    updateMany?: helpOfferUpdateManyWithWhereWithoutHelpRequestInput | helpOfferUpdateManyWithWhereWithoutHelpRequestInput[]
    deleteMany?: helpOfferScalarWhereInput | helpOfferScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutHelpRequestNestedInput = {
    create?: XOR<userCreateWithoutHelpRequestInput, userUncheckedCreateWithoutHelpRequestInput>
    connectOrCreate?: userCreateOrConnectWithoutHelpRequestInput
    upsert?: userUpsertWithoutHelpRequestInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutHelpRequestInput, userUpdateWithoutHelpRequestInput>, userUncheckedUpdateWithoutHelpRequestInput>
  }

  export type serviceCompletedUpdateManyWithoutHelpRequestNestedInput = {
    create?: XOR<serviceCompletedCreateWithoutHelpRequestInput, serviceCompletedUncheckedCreateWithoutHelpRequestInput> | serviceCompletedCreateWithoutHelpRequestInput[] | serviceCompletedUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutHelpRequestInput | serviceCompletedCreateOrConnectWithoutHelpRequestInput[]
    upsert?: serviceCompletedUpsertWithWhereUniqueWithoutHelpRequestInput | serviceCompletedUpsertWithWhereUniqueWithoutHelpRequestInput[]
    createMany?: serviceCompletedCreateManyHelpRequestInputEnvelope
    set?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    disconnect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    delete?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    update?: serviceCompletedUpdateWithWhereUniqueWithoutHelpRequestInput | serviceCompletedUpdateWithWhereUniqueWithoutHelpRequestInput[]
    updateMany?: serviceCompletedUpdateManyWithWhereWithoutHelpRequestInput | serviceCompletedUpdateManyWithWhereWithoutHelpRequestInput[]
    deleteMany?: serviceCompletedScalarWhereInput | serviceCompletedScalarWhereInput[]
  }

  export type helpCategoryUpdateOneWithoutHelpRequestNestedInput = {
    create?: XOR<helpCategoryCreateWithoutHelpRequestInput, helpCategoryUncheckedCreateWithoutHelpRequestInput>
    connectOrCreate?: helpCategoryCreateOrConnectWithoutHelpRequestInput
    upsert?: helpCategoryUpsertWithoutHelpRequestInput
    disconnect?: helpCategoryWhereInput | boolean
    delete?: helpCategoryWhereInput | boolean
    connect?: helpCategoryWhereUniqueInput
    update?: XOR<XOR<helpCategoryUpdateToOneWithWhereWithoutHelpRequestInput, helpCategoryUpdateWithoutHelpRequestInput>, helpCategoryUncheckedUpdateWithoutHelpRequestInput>
  }

  export type helpOfferUncheckedUpdateManyWithoutHelpRequestNestedInput = {
    create?: XOR<helpOfferCreateWithoutHelpRequestInput, helpOfferUncheckedCreateWithoutHelpRequestInput> | helpOfferCreateWithoutHelpRequestInput[] | helpOfferUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutHelpRequestInput | helpOfferCreateOrConnectWithoutHelpRequestInput[]
    upsert?: helpOfferUpsertWithWhereUniqueWithoutHelpRequestInput | helpOfferUpsertWithWhereUniqueWithoutHelpRequestInput[]
    createMany?: helpOfferCreateManyHelpRequestInputEnvelope
    set?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    disconnect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    delete?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    update?: helpOfferUpdateWithWhereUniqueWithoutHelpRequestInput | helpOfferUpdateWithWhereUniqueWithoutHelpRequestInput[]
    updateMany?: helpOfferUpdateManyWithWhereWithoutHelpRequestInput | helpOfferUpdateManyWithWhereWithoutHelpRequestInput[]
    deleteMany?: helpOfferScalarWhereInput | helpOfferScalarWhereInput[]
  }

  export type serviceCompletedUncheckedUpdateManyWithoutHelpRequestNestedInput = {
    create?: XOR<serviceCompletedCreateWithoutHelpRequestInput, serviceCompletedUncheckedCreateWithoutHelpRequestInput> | serviceCompletedCreateWithoutHelpRequestInput[] | serviceCompletedUncheckedCreateWithoutHelpRequestInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutHelpRequestInput | serviceCompletedCreateOrConnectWithoutHelpRequestInput[]
    upsert?: serviceCompletedUpsertWithWhereUniqueWithoutHelpRequestInput | serviceCompletedUpsertWithWhereUniqueWithoutHelpRequestInput[]
    createMany?: serviceCompletedCreateManyHelpRequestInputEnvelope
    set?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    disconnect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    delete?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    update?: serviceCompletedUpdateWithWhereUniqueWithoutHelpRequestInput | serviceCompletedUpdateWithWhereUniqueWithoutHelpRequestInput[]
    updateMany?: serviceCompletedUpdateManyWithWhereWithoutHelpRequestInput | serviceCompletedUpdateManyWithWhereWithoutHelpRequestInput[]
    deleteMany?: serviceCompletedScalarWhereInput | serviceCompletedScalarWhereInput[]
  }

  export type serviceCategoryCreateNestedOneWithoutLocalServiceInput = {
    create?: XOR<serviceCategoryCreateWithoutLocalServiceInput, serviceCategoryUncheckedCreateWithoutLocalServiceInput>
    connectOrCreate?: serviceCategoryCreateOrConnectWithoutLocalServiceInput
    connect?: serviceCategoryWhereUniqueInput
  }

  export type serviceRatingCreateNestedManyWithoutLocalServiceInput = {
    create?: XOR<serviceRatingCreateWithoutLocalServiceInput, serviceRatingUncheckedCreateWithoutLocalServiceInput> | serviceRatingCreateWithoutLocalServiceInput[] | serviceRatingUncheckedCreateWithoutLocalServiceInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutLocalServiceInput | serviceRatingCreateOrConnectWithoutLocalServiceInput[]
    createMany?: serviceRatingCreateManyLocalServiceInputEnvelope
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
  }

  export type serviceRatingUncheckedCreateNestedManyWithoutLocalServiceInput = {
    create?: XOR<serviceRatingCreateWithoutLocalServiceInput, serviceRatingUncheckedCreateWithoutLocalServiceInput> | serviceRatingCreateWithoutLocalServiceInput[] | serviceRatingUncheckedCreateWithoutLocalServiceInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutLocalServiceInput | serviceRatingCreateOrConnectWithoutLocalServiceInput[]
    createMany?: serviceRatingCreateManyLocalServiceInputEnvelope
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
  }

  export type serviceCategoryUpdateOneWithoutLocalServiceNestedInput = {
    create?: XOR<serviceCategoryCreateWithoutLocalServiceInput, serviceCategoryUncheckedCreateWithoutLocalServiceInput>
    connectOrCreate?: serviceCategoryCreateOrConnectWithoutLocalServiceInput
    upsert?: serviceCategoryUpsertWithoutLocalServiceInput
    disconnect?: serviceCategoryWhereInput | boolean
    delete?: serviceCategoryWhereInput | boolean
    connect?: serviceCategoryWhereUniqueInput
    update?: XOR<XOR<serviceCategoryUpdateToOneWithWhereWithoutLocalServiceInput, serviceCategoryUpdateWithoutLocalServiceInput>, serviceCategoryUncheckedUpdateWithoutLocalServiceInput>
  }

  export type serviceRatingUpdateManyWithoutLocalServiceNestedInput = {
    create?: XOR<serviceRatingCreateWithoutLocalServiceInput, serviceRatingUncheckedCreateWithoutLocalServiceInput> | serviceRatingCreateWithoutLocalServiceInput[] | serviceRatingUncheckedCreateWithoutLocalServiceInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutLocalServiceInput | serviceRatingCreateOrConnectWithoutLocalServiceInput[]
    upsert?: serviceRatingUpsertWithWhereUniqueWithoutLocalServiceInput | serviceRatingUpsertWithWhereUniqueWithoutLocalServiceInput[]
    createMany?: serviceRatingCreateManyLocalServiceInputEnvelope
    set?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    disconnect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    delete?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    update?: serviceRatingUpdateWithWhereUniqueWithoutLocalServiceInput | serviceRatingUpdateWithWhereUniqueWithoutLocalServiceInput[]
    updateMany?: serviceRatingUpdateManyWithWhereWithoutLocalServiceInput | serviceRatingUpdateManyWithWhereWithoutLocalServiceInput[]
    deleteMany?: serviceRatingScalarWhereInput | serviceRatingScalarWhereInput[]
  }

  export type serviceRatingUncheckedUpdateManyWithoutLocalServiceNestedInput = {
    create?: XOR<serviceRatingCreateWithoutLocalServiceInput, serviceRatingUncheckedCreateWithoutLocalServiceInput> | serviceRatingCreateWithoutLocalServiceInput[] | serviceRatingUncheckedCreateWithoutLocalServiceInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutLocalServiceInput | serviceRatingCreateOrConnectWithoutLocalServiceInput[]
    upsert?: serviceRatingUpsertWithWhereUniqueWithoutLocalServiceInput | serviceRatingUpsertWithWhereUniqueWithoutLocalServiceInput[]
    createMany?: serviceRatingCreateManyLocalServiceInputEnvelope
    set?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    disconnect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    delete?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    update?: serviceRatingUpdateWithWhereUniqueWithoutLocalServiceInput | serviceRatingUpdateWithWhereUniqueWithoutLocalServiceInput[]
    updateMany?: serviceRatingUpdateManyWithWhereWithoutLocalServiceInput | serviceRatingUpdateManyWithWhereWithoutLocalServiceInput[]
    deleteMany?: serviceRatingScalarWhereInput | serviceRatingScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutMedicationReminderInput = {
    create?: XOR<userCreateWithoutMedicationReminderInput, userUncheckedCreateWithoutMedicationReminderInput>
    connectOrCreate?: userCreateOrConnectWithoutMedicationReminderInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutMedicationReminderNestedInput = {
    create?: XOR<userCreateWithoutMedicationReminderInput, userUncheckedCreateWithoutMedicationReminderInput>
    connectOrCreate?: userCreateOrConnectWithoutMedicationReminderInput
    upsert?: userUpsertWithoutMedicationReminderInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMedicationReminderInput, userUpdateWithoutMedicationReminderInput>, userUncheckedUpdateWithoutMedicationReminderInput>
  }

  export type conversationCreateNestedOneWithoutMessageInput = {
    create?: XOR<conversationCreateWithoutMessageInput, conversationUncheckedCreateWithoutMessageInput>
    connectOrCreate?: conversationCreateOrConnectWithoutMessageInput
    connect?: conversationWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMessageInput = {
    create?: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutMessageInput
    connect?: userWhereUniqueInput
  }

  export type conversationUpdateOneWithoutMessageNestedInput = {
    create?: XOR<conversationCreateWithoutMessageInput, conversationUncheckedCreateWithoutMessageInput>
    connectOrCreate?: conversationCreateOrConnectWithoutMessageInput
    upsert?: conversationUpsertWithoutMessageInput
    disconnect?: conversationWhereInput | boolean
    delete?: conversationWhereInput | boolean
    connect?: conversationWhereUniqueInput
    update?: XOR<XOR<conversationUpdateToOneWithWhereWithoutMessageInput, conversationUpdateWithoutMessageInput>, conversationUncheckedUpdateWithoutMessageInput>
  }

  export type userUpdateOneWithoutMessageNestedInput = {
    create?: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutMessageInput
    upsert?: userUpsertWithoutMessageInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMessageInput, userUpdateWithoutMessageInput>, userUncheckedUpdateWithoutMessageInput>
  }

  export type userCreateNestedOneWithoutNotificationInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    upsert?: userUpsertWithoutNotificationInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotificationInput, userUpdateWithoutNotificationInput>, userUncheckedUpdateWithoutNotificationInput>
  }

  export type userCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<userCreateWithoutNotificationPreferencesInput, userUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationPreferencesInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<userCreateWithoutNotificationPreferencesInput, userUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: userUpsertWithoutNotificationPreferencesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotificationPreferencesInput, userUpdateWithoutNotificationPreferencesInput>, userUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type nutritionalCategoryCreateNestedOneWithoutNutritionalAdviceInput = {
    create?: XOR<nutritionalCategoryCreateWithoutNutritionalAdviceInput, nutritionalCategoryUncheckedCreateWithoutNutritionalAdviceInput>
    connectOrCreate?: nutritionalCategoryCreateOrConnectWithoutNutritionalAdviceInput
    connect?: nutritionalCategoryWhereUniqueInput
  }

  export type nutritionalCategoryUpdateOneWithoutNutritionalAdviceNestedInput = {
    create?: XOR<nutritionalCategoryCreateWithoutNutritionalAdviceInput, nutritionalCategoryUncheckedCreateWithoutNutritionalAdviceInput>
    connectOrCreate?: nutritionalCategoryCreateOrConnectWithoutNutritionalAdviceInput
    upsert?: nutritionalCategoryUpsertWithoutNutritionalAdviceInput
    disconnect?: nutritionalCategoryWhereInput | boolean
    delete?: nutritionalCategoryWhereInput | boolean
    connect?: nutritionalCategoryWhereUniqueInput
    update?: XOR<XOR<nutritionalCategoryUpdateToOneWithWhereWithoutNutritionalAdviceInput, nutritionalCategoryUpdateWithoutNutritionalAdviceInput>, nutritionalCategoryUncheckedUpdateWithoutNutritionalAdviceInput>
  }

  export type collaborativeProjectCreateNestedOneWithoutProjectMemberInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectMemberInput, collaborativeProjectUncheckedCreateWithoutProjectMemberInput>
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectMemberInput
    connect?: collaborativeProjectWhereUniqueInput
  }

  export type userCreateNestedOneWithoutProjectMemberInput = {
    create?: XOR<userCreateWithoutProjectMemberInput, userUncheckedCreateWithoutProjectMemberInput>
    connectOrCreate?: userCreateOrConnectWithoutProjectMemberInput
    connect?: userWhereUniqueInput
  }

  export type collaborativeProjectUpdateOneRequiredWithoutProjectMemberNestedInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectMemberInput, collaborativeProjectUncheckedCreateWithoutProjectMemberInput>
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectMemberInput
    upsert?: collaborativeProjectUpsertWithoutProjectMemberInput
    connect?: collaborativeProjectWhereUniqueInput
    update?: XOR<XOR<collaborativeProjectUpdateToOneWithWhereWithoutProjectMemberInput, collaborativeProjectUpdateWithoutProjectMemberInput>, collaborativeProjectUncheckedUpdateWithoutProjectMemberInput>
  }

  export type userUpdateOneRequiredWithoutProjectMemberNestedInput = {
    create?: XOR<userCreateWithoutProjectMemberInput, userUncheckedCreateWithoutProjectMemberInput>
    connectOrCreate?: userCreateOrConnectWithoutProjectMemberInput
    upsert?: userUpsertWithoutProjectMemberInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProjectMemberInput, userUpdateWithoutProjectMemberInput>, userUncheckedUpdateWithoutProjectMemberInput>
  }

  export type userCreateNestedOneWithoutProjectTaskInput = {
    create?: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: userCreateOrConnectWithoutProjectTaskInput
    connect?: userWhereUniqueInput
  }

  export type collaborativeProjectCreateNestedOneWithoutProjectTaskInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectTaskInput, collaborativeProjectUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectTaskInput
    connect?: collaborativeProjectWhereUniqueInput
  }

  export type userUpdateOneWithoutProjectTaskNestedInput = {
    create?: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: userCreateOrConnectWithoutProjectTaskInput
    upsert?: userUpsertWithoutProjectTaskInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProjectTaskInput, userUpdateWithoutProjectTaskInput>, userUncheckedUpdateWithoutProjectTaskInput>
  }

  export type collaborativeProjectUpdateOneWithoutProjectTaskNestedInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectTaskInput, collaborativeProjectUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectTaskInput
    upsert?: collaborativeProjectUpsertWithoutProjectTaskInput
    disconnect?: collaborativeProjectWhereInput | boolean
    delete?: collaborativeProjectWhereInput | boolean
    connect?: collaborativeProjectWhereUniqueInput
    update?: XOR<XOR<collaborativeProjectUpdateToOneWithWhereWithoutProjectTaskInput, collaborativeProjectUpdateWithoutProjectTaskInput>, collaborativeProjectUncheckedUpdateWithoutProjectTaskInput>
  }

  export type userCreateNestedOneWithoutResourceInput = {
    create?: XOR<userCreateWithoutResourceInput, userUncheckedCreateWithoutResourceInput>
    connectOrCreate?: userCreateOrConnectWithoutResourceInput
    connect?: userWhereUniqueInput
  }

  export type resourceCategoryCreateNestedOneWithoutResourceInput = {
    create?: XOR<resourceCategoryCreateWithoutResourceInput, resourceCategoryUncheckedCreateWithoutResourceInput>
    connectOrCreate?: resourceCategoryCreateOrConnectWithoutResourceInput
    connect?: resourceCategoryWhereUniqueInput
  }

  export type userUpdateOneWithoutResourceNestedInput = {
    create?: XOR<userCreateWithoutResourceInput, userUncheckedCreateWithoutResourceInput>
    connectOrCreate?: userCreateOrConnectWithoutResourceInput
    upsert?: userUpsertWithoutResourceInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutResourceInput, userUpdateWithoutResourceInput>, userUncheckedUpdateWithoutResourceInput>
  }

  export type resourceCategoryUpdateOneWithoutResourceNestedInput = {
    create?: XOR<resourceCategoryCreateWithoutResourceInput, resourceCategoryUncheckedCreateWithoutResourceInput>
    connectOrCreate?: resourceCategoryCreateOrConnectWithoutResourceInput
    upsert?: resourceCategoryUpsertWithoutResourceInput
    disconnect?: resourceCategoryWhereInput | boolean
    delete?: resourceCategoryWhereInput | boolean
    connect?: resourceCategoryWhereUniqueInput
    update?: XOR<XOR<resourceCategoryUpdateToOneWithWhereWithoutResourceInput, resourceCategoryUpdateWithoutResourceInput>, resourceCategoryUncheckedUpdateWithoutResourceInput>
  }

  export type surveyResponseCreateNestedManyWithoutSatisfactionSurveyInput = {
    create?: XOR<surveyResponseCreateWithoutSatisfactionSurveyInput, surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput> | surveyResponseCreateWithoutSatisfactionSurveyInput[] | surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput | surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput[]
    createMany?: surveyResponseCreateManySatisfactionSurveyInputEnvelope
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
  }

  export type surveyResponseUncheckedCreateNestedManyWithoutSatisfactionSurveyInput = {
    create?: XOR<surveyResponseCreateWithoutSatisfactionSurveyInput, surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput> | surveyResponseCreateWithoutSatisfactionSurveyInput[] | surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput | surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput[]
    createMany?: surveyResponseCreateManySatisfactionSurveyInputEnvelope
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
  }

  export type surveyResponseUpdateManyWithoutSatisfactionSurveyNestedInput = {
    create?: XOR<surveyResponseCreateWithoutSatisfactionSurveyInput, surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput> | surveyResponseCreateWithoutSatisfactionSurveyInput[] | surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput | surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput[]
    upsert?: surveyResponseUpsertWithWhereUniqueWithoutSatisfactionSurveyInput | surveyResponseUpsertWithWhereUniqueWithoutSatisfactionSurveyInput[]
    createMany?: surveyResponseCreateManySatisfactionSurveyInputEnvelope
    set?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    disconnect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    delete?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    update?: surveyResponseUpdateWithWhereUniqueWithoutSatisfactionSurveyInput | surveyResponseUpdateWithWhereUniqueWithoutSatisfactionSurveyInput[]
    updateMany?: surveyResponseUpdateManyWithWhereWithoutSatisfactionSurveyInput | surveyResponseUpdateManyWithWhereWithoutSatisfactionSurveyInput[]
    deleteMany?: surveyResponseScalarWhereInput | surveyResponseScalarWhereInput[]
  }

  export type surveyResponseUncheckedUpdateManyWithoutSatisfactionSurveyNestedInput = {
    create?: XOR<surveyResponseCreateWithoutSatisfactionSurveyInput, surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput> | surveyResponseCreateWithoutSatisfactionSurveyInput[] | surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput | surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput[]
    upsert?: surveyResponseUpsertWithWhereUniqueWithoutSatisfactionSurveyInput | surveyResponseUpsertWithWhereUniqueWithoutSatisfactionSurveyInput[]
    createMany?: surveyResponseCreateManySatisfactionSurveyInputEnvelope
    set?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    disconnect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    delete?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    update?: surveyResponseUpdateWithWhereUniqueWithoutSatisfactionSurveyInput | surveyResponseUpdateWithWhereUniqueWithoutSatisfactionSurveyInput[]
    updateMany?: surveyResponseUpdateManyWithWhereWithoutSatisfactionSurveyInput | surveyResponseUpdateManyWithWhereWithoutSatisfactionSurveyInput[]
    deleteMany?: surveyResponseScalarWhereInput | surveyResponseScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutSessionInput = {
    create?: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionInput
    upsert?: userUpsertWithoutSessionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSessionInput, userUpdateWithoutSessionInput>, userUncheckedUpdateWithoutSessionInput>
  }

  export type userCreateNestedOneWithoutServiceCompletedInput = {
    create?: XOR<userCreateWithoutServiceCompletedInput, userUncheckedCreateWithoutServiceCompletedInput>
    connectOrCreate?: userCreateOrConnectWithoutServiceCompletedInput
    connect?: userWhereUniqueInput
  }

  export type helpRequestCreateNestedOneWithoutServiceCompletedInput = {
    create?: XOR<helpRequestCreateWithoutServiceCompletedInput, helpRequestUncheckedCreateWithoutServiceCompletedInput>
    connectOrCreate?: helpRequestCreateOrConnectWithoutServiceCompletedInput
    connect?: helpRequestWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutServiceCompletedNestedInput = {
    create?: XOR<userCreateWithoutServiceCompletedInput, userUncheckedCreateWithoutServiceCompletedInput>
    connectOrCreate?: userCreateOrConnectWithoutServiceCompletedInput
    upsert?: userUpsertWithoutServiceCompletedInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutServiceCompletedInput, userUpdateWithoutServiceCompletedInput>, userUncheckedUpdateWithoutServiceCompletedInput>
  }

  export type helpRequestUpdateOneRequiredWithoutServiceCompletedNestedInput = {
    create?: XOR<helpRequestCreateWithoutServiceCompletedInput, helpRequestUncheckedCreateWithoutServiceCompletedInput>
    connectOrCreate?: helpRequestCreateOrConnectWithoutServiceCompletedInput
    upsert?: helpRequestUpsertWithoutServiceCompletedInput
    connect?: helpRequestWhereUniqueInput
    update?: XOR<XOR<helpRequestUpdateToOneWithWhereWithoutServiceCompletedInput, helpRequestUpdateWithoutServiceCompletedInput>, helpRequestUncheckedUpdateWithoutServiceCompletedInput>
  }

  export type localServiceCreateNestedOneWithoutServiceRatingInput = {
    create?: XOR<localServiceCreateWithoutServiceRatingInput, localServiceUncheckedCreateWithoutServiceRatingInput>
    connectOrCreate?: localServiceCreateOrConnectWithoutServiceRatingInput
    connect?: localServiceWhereUniqueInput
  }

  export type userCreateNestedOneWithoutServiceRatingInput = {
    create?: XOR<userCreateWithoutServiceRatingInput, userUncheckedCreateWithoutServiceRatingInput>
    connectOrCreate?: userCreateOrConnectWithoutServiceRatingInput
    connect?: userWhereUniqueInput
  }

  export type localServiceUpdateOneRequiredWithoutServiceRatingNestedInput = {
    create?: XOR<localServiceCreateWithoutServiceRatingInput, localServiceUncheckedCreateWithoutServiceRatingInput>
    connectOrCreate?: localServiceCreateOrConnectWithoutServiceRatingInput
    upsert?: localServiceUpsertWithoutServiceRatingInput
    connect?: localServiceWhereUniqueInput
    update?: XOR<XOR<localServiceUpdateToOneWithWhereWithoutServiceRatingInput, localServiceUpdateWithoutServiceRatingInput>, localServiceUncheckedUpdateWithoutServiceRatingInput>
  }

  export type userUpdateOneRequiredWithoutServiceRatingNestedInput = {
    create?: XOR<userCreateWithoutServiceRatingInput, userUncheckedCreateWithoutServiceRatingInput>
    connectOrCreate?: userCreateOrConnectWithoutServiceRatingInput
    upsert?: userUpsertWithoutServiceRatingInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutServiceRatingInput, userUpdateWithoutServiceRatingInput>, userUncheckedUpdateWithoutServiceRatingInput>
  }

  export type skillCategoryCreateNestedOneWithoutSkillInput = {
    create?: XOR<skillCategoryCreateWithoutSkillInput, skillCategoryUncheckedCreateWithoutSkillInput>
    connectOrCreate?: skillCategoryCreateOrConnectWithoutSkillInput
    connect?: skillCategoryWhereUniqueInput
  }

  export type userSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<userSkillCreateWithoutSkillInput, userSkillUncheckedCreateWithoutSkillInput> | userSkillCreateWithoutSkillInput[] | userSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutSkillInput | userSkillCreateOrConnectWithoutSkillInput[]
    createMany?: userSkillCreateManySkillInputEnvelope
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
  }

  export type userSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<userSkillCreateWithoutSkillInput, userSkillUncheckedCreateWithoutSkillInput> | userSkillCreateWithoutSkillInput[] | userSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutSkillInput | userSkillCreateOrConnectWithoutSkillInput[]
    createMany?: userSkillCreateManySkillInputEnvelope
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
  }

  export type skillCategoryUpdateOneWithoutSkillNestedInput = {
    create?: XOR<skillCategoryCreateWithoutSkillInput, skillCategoryUncheckedCreateWithoutSkillInput>
    connectOrCreate?: skillCategoryCreateOrConnectWithoutSkillInput
    upsert?: skillCategoryUpsertWithoutSkillInput
    disconnect?: skillCategoryWhereInput | boolean
    delete?: skillCategoryWhereInput | boolean
    connect?: skillCategoryWhereUniqueInput
    update?: XOR<XOR<skillCategoryUpdateToOneWithWhereWithoutSkillInput, skillCategoryUpdateWithoutSkillInput>, skillCategoryUncheckedUpdateWithoutSkillInput>
  }

  export type userSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<userSkillCreateWithoutSkillInput, userSkillUncheckedCreateWithoutSkillInput> | userSkillCreateWithoutSkillInput[] | userSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutSkillInput | userSkillCreateOrConnectWithoutSkillInput[]
    upsert?: userSkillUpsertWithWhereUniqueWithoutSkillInput | userSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: userSkillCreateManySkillInputEnvelope
    set?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    disconnect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    delete?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    update?: userSkillUpdateWithWhereUniqueWithoutSkillInput | userSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: userSkillUpdateManyWithWhereWithoutSkillInput | userSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: userSkillScalarWhereInput | userSkillScalarWhereInput[]
  }

  export type userSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<userSkillCreateWithoutSkillInput, userSkillUncheckedCreateWithoutSkillInput> | userSkillCreateWithoutSkillInput[] | userSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutSkillInput | userSkillCreateOrConnectWithoutSkillInput[]
    upsert?: userSkillUpsertWithWhereUniqueWithoutSkillInput | userSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: userSkillCreateManySkillInputEnvelope
    set?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    disconnect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    delete?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    update?: userSkillUpdateWithWhereUniqueWithoutSkillInput | userSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: userSkillUpdateManyWithWhereWithoutSkillInput | userSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: userSkillScalarWhereInput | userSkillScalarWhereInput[]
  }

  export type satisfactionSurveyCreateNestedOneWithoutSurveyResponseInput = {
    create?: XOR<satisfactionSurveyCreateWithoutSurveyResponseInput, satisfactionSurveyUncheckedCreateWithoutSurveyResponseInput>
    connectOrCreate?: satisfactionSurveyCreateOrConnectWithoutSurveyResponseInput
    connect?: satisfactionSurveyWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSurveyResponseInput = {
    create?: XOR<userCreateWithoutSurveyResponseInput, userUncheckedCreateWithoutSurveyResponseInput>
    connectOrCreate?: userCreateOrConnectWithoutSurveyResponseInput
    connect?: userWhereUniqueInput
  }

  export type satisfactionSurveyUpdateOneRequiredWithoutSurveyResponseNestedInput = {
    create?: XOR<satisfactionSurveyCreateWithoutSurveyResponseInput, satisfactionSurveyUncheckedCreateWithoutSurveyResponseInput>
    connectOrCreate?: satisfactionSurveyCreateOrConnectWithoutSurveyResponseInput
    upsert?: satisfactionSurveyUpsertWithoutSurveyResponseInput
    connect?: satisfactionSurveyWhereUniqueInput
    update?: XOR<XOR<satisfactionSurveyUpdateToOneWithWhereWithoutSurveyResponseInput, satisfactionSurveyUpdateWithoutSurveyResponseInput>, satisfactionSurveyUncheckedUpdateWithoutSurveyResponseInput>
  }

  export type userUpdateOneRequiredWithoutSurveyResponseNestedInput = {
    create?: XOR<userCreateWithoutSurveyResponseInput, userUncheckedCreateWithoutSurveyResponseInput>
    connectOrCreate?: userCreateOrConnectWithoutSurveyResponseInput
    upsert?: userUpsertWithoutSurveyResponseInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSurveyResponseInput, userUpdateWithoutSurveyResponseInput>, userUncheckedUpdateWithoutSurveyResponseInput>
  }

  export type userCreateNestedOneWithoutTrustedContactInput = {
    create?: XOR<userCreateWithoutTrustedContactInput, userUncheckedCreateWithoutTrustedContactInput>
    connectOrCreate?: userCreateOrConnectWithoutTrustedContactInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutTrustedContactNestedInput = {
    create?: XOR<userCreateWithoutTrustedContactInput, userUncheckedCreateWithoutTrustedContactInput>
    connectOrCreate?: userCreateOrConnectWithoutTrustedContactInput
    upsert?: userUpsertWithoutTrustedContactInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTrustedContactInput, userUpdateWithoutTrustedContactInput>, userUncheckedUpdateWithoutTrustedContactInput>
  }

  export type userCreateNestedOneWithoutUrbanIssueReportInput = {
    create?: XOR<userCreateWithoutUrbanIssueReportInput, userUncheckedCreateWithoutUrbanIssueReportInput>
    connectOrCreate?: userCreateOrConnectWithoutUrbanIssueReportInput
    connect?: userWhereUniqueInput
  }

  export type issueCategoryCreateNestedOneWithoutUrbanIssueReportInput = {
    create?: XOR<issueCategoryCreateWithoutUrbanIssueReportInput, issueCategoryUncheckedCreateWithoutUrbanIssueReportInput>
    connectOrCreate?: issueCategoryCreateOrConnectWithoutUrbanIssueReportInput
    connect?: issueCategoryWhereUniqueInput
  }

  export type userUpdateOneWithoutUrbanIssueReportNestedInput = {
    create?: XOR<userCreateWithoutUrbanIssueReportInput, userUncheckedCreateWithoutUrbanIssueReportInput>
    connectOrCreate?: userCreateOrConnectWithoutUrbanIssueReportInput
    upsert?: userUpsertWithoutUrbanIssueReportInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUrbanIssueReportInput, userUpdateWithoutUrbanIssueReportInput>, userUncheckedUpdateWithoutUrbanIssueReportInput>
  }

  export type issueCategoryUpdateOneWithoutUrbanIssueReportNestedInput = {
    create?: XOR<issueCategoryCreateWithoutUrbanIssueReportInput, issueCategoryUncheckedCreateWithoutUrbanIssueReportInput>
    connectOrCreate?: issueCategoryCreateOrConnectWithoutUrbanIssueReportInput
    upsert?: issueCategoryUpsertWithoutUrbanIssueReportInput
    disconnect?: issueCategoryWhereInput | boolean
    delete?: issueCategoryWhereInput | boolean
    connect?: issueCategoryWhereUniqueInput
    update?: XOR<XOR<issueCategoryUpdateToOneWithWhereWithoutUrbanIssueReportInput, issueCategoryUpdateWithoutUrbanIssueReportInput>, issueCategoryUncheckedUpdateWithoutUrbanIssueReportInput>
  }

  export type activityCreateNestedManyWithoutUserInput = {
    create?: XOR<activityCreateWithoutUserInput, activityUncheckedCreateWithoutUserInput> | activityCreateWithoutUserInput[] | activityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityCreateOrConnectWithoutUserInput | activityCreateOrConnectWithoutUserInput[]
    createMany?: activityCreateManyUserInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type activityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<activityLogCreateWithoutUserInput, activityLogUncheckedCreateWithoutUserInput> | activityLogCreateWithoutUserInput[] | activityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityLogCreateOrConnectWithoutUserInput | activityLogCreateOrConnectWithoutUserInput[]
    createMany?: activityLogCreateManyUserInputEnvelope
    connect?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
  }

  export type activityRegistrationCreateNestedManyWithoutUserInput = {
    create?: XOR<activityRegistrationCreateWithoutUserInput, activityRegistrationUncheckedCreateWithoutUserInput> | activityRegistrationCreateWithoutUserInput[] | activityRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutUserInput | activityRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: activityRegistrationCreateManyUserInputEnvelope
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
  }

  export type collaborativeProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<collaborativeProjectCreateWithoutUserInput, collaborativeProjectUncheckedCreateWithoutUserInput> | collaborativeProjectCreateWithoutUserInput[] | collaborativeProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutUserInput | collaborativeProjectCreateOrConnectWithoutUserInput[]
    createMany?: collaborativeProjectCreateManyUserInputEnvelope
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
  }

  export type conversationParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<conversationParticipantCreateWithoutUserInput, conversationParticipantUncheckedCreateWithoutUserInput> | conversationParticipantCreateWithoutUserInput[] | conversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutUserInput | conversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: conversationParticipantCreateManyUserInputEnvelope
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
  }

  export type forumMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<forumMessageCreateWithoutUserInput, forumMessageUncheckedCreateWithoutUserInput> | forumMessageCreateWithoutUserInput[] | forumMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutUserInput | forumMessageCreateOrConnectWithoutUserInput[]
    createMany?: forumMessageCreateManyUserInputEnvelope
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
  }

  export type forumTopicCreateNestedManyWithoutUserInput = {
    create?: XOR<forumTopicCreateWithoutUserInput, forumTopicUncheckedCreateWithoutUserInput> | forumTopicCreateWithoutUserInput[] | forumTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutUserInput | forumTopicCreateOrConnectWithoutUserInput[]
    createMany?: forumTopicCreateManyUserInputEnvelope
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
  }

  export type healthIndicatorCreateNestedManyWithoutUserInput = {
    create?: XOR<healthIndicatorCreateWithoutUserInput, healthIndicatorUncheckedCreateWithoutUserInput> | healthIndicatorCreateWithoutUserInput[] | healthIndicatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: healthIndicatorCreateOrConnectWithoutUserInput | healthIndicatorCreateOrConnectWithoutUserInput[]
    createMany?: healthIndicatorCreateManyUserInputEnvelope
    connect?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
  }

  export type helpOfferCreateNestedManyWithoutUserInput = {
    create?: XOR<helpOfferCreateWithoutUserInput, helpOfferUncheckedCreateWithoutUserInput> | helpOfferCreateWithoutUserInput[] | helpOfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutUserInput | helpOfferCreateOrConnectWithoutUserInput[]
    createMany?: helpOfferCreateManyUserInputEnvelope
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
  }

  export type helpRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<helpRequestCreateWithoutUserInput, helpRequestUncheckedCreateWithoutUserInput> | helpRequestCreateWithoutUserInput[] | helpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutUserInput | helpRequestCreateOrConnectWithoutUserInput[]
    createMany?: helpRequestCreateManyUserInputEnvelope
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
  }

  export type medicationReminderCreateNestedManyWithoutUserInput = {
    create?: XOR<medicationReminderCreateWithoutUserInput, medicationReminderUncheckedCreateWithoutUserInput> | medicationReminderCreateWithoutUserInput[] | medicationReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: medicationReminderCreateOrConnectWithoutUserInput | medicationReminderCreateOrConnectWithoutUserInput[]
    createMany?: medicationReminderCreateManyUserInputEnvelope
    connect?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutUserInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type notificationPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<notificationPreferencesCreateWithoutUserInput, notificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: notificationPreferencesCreateOrConnectWithoutUserInput
    connect?: notificationPreferencesWhereUniqueInput
  }

  export type projectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<projectMemberCreateWithoutUserInput, projectMemberUncheckedCreateWithoutUserInput> | projectMemberCreateWithoutUserInput[] | projectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutUserInput | projectMemberCreateOrConnectWithoutUserInput[]
    createMany?: projectMemberCreateManyUserInputEnvelope
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
  }

  export type projectTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput> | projectTaskCreateWithoutUserInput[] | projectTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutUserInput | projectTaskCreateOrConnectWithoutUserInput[]
    createMany?: projectTaskCreateManyUserInputEnvelope
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
  }

  export type resourceCreateNestedManyWithoutUserInput = {
    create?: XOR<resourceCreateWithoutUserInput, resourceUncheckedCreateWithoutUserInput> | resourceCreateWithoutUserInput[] | resourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutUserInput | resourceCreateOrConnectWithoutUserInput[]
    createMany?: resourceCreateManyUserInputEnvelope
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
  }

  export type serviceCompletedCreateNestedManyWithoutUserInput = {
    create?: XOR<serviceCompletedCreateWithoutUserInput, serviceCompletedUncheckedCreateWithoutUserInput> | serviceCompletedCreateWithoutUserInput[] | serviceCompletedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutUserInput | serviceCompletedCreateOrConnectWithoutUserInput[]
    createMany?: serviceCompletedCreateManyUserInputEnvelope
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
  }

  export type serviceRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<serviceRatingCreateWithoutUserInput, serviceRatingUncheckedCreateWithoutUserInput> | serviceRatingCreateWithoutUserInput[] | serviceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutUserInput | serviceRatingCreateOrConnectWithoutUserInput[]
    createMany?: serviceRatingCreateManyUserInputEnvelope
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
  }

  export type surveyResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<surveyResponseCreateWithoutUserInput, surveyResponseUncheckedCreateWithoutUserInput> | surveyResponseCreateWithoutUserInput[] | surveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutUserInput | surveyResponseCreateOrConnectWithoutUserInput[]
    createMany?: surveyResponseCreateManyUserInputEnvelope
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
  }

  export type trustedContactCreateNestedManyWithoutUserInput = {
    create?: XOR<trustedContactCreateWithoutUserInput, trustedContactUncheckedCreateWithoutUserInput> | trustedContactCreateWithoutUserInput[] | trustedContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: trustedContactCreateOrConnectWithoutUserInput | trustedContactCreateOrConnectWithoutUserInput[]
    createMany?: trustedContactCreateManyUserInputEnvelope
    connect?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
  }

  export type urbanIssueReportCreateNestedManyWithoutUserInput = {
    create?: XOR<urbanIssueReportCreateWithoutUserInput, urbanIssueReportUncheckedCreateWithoutUserInput> | urbanIssueReportCreateWithoutUserInput[] | urbanIssueReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutUserInput | urbanIssueReportCreateOrConnectWithoutUserInput[]
    createMany?: urbanIssueReportCreateManyUserInputEnvelope
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
  }

  export type userActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<userActivityCreateWithoutUserInput, userActivityUncheckedCreateWithoutUserInput> | userActivityCreateWithoutUserInput[] | userActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutUserInput | userActivityCreateOrConnectWithoutUserInput[]
    createMany?: userActivityCreateManyUserInputEnvelope
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
  }

  export type userBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<userBadgeCreateWithoutUserInput, userBadgeUncheckedCreateWithoutUserInput> | userBadgeCreateWithoutUserInput[] | userBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userBadgeCreateOrConnectWithoutUserInput | userBadgeCreateOrConnectWithoutUserInput[]
    createMany?: userBadgeCreateManyUserInputEnvelope
    connect?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
  }

  export type userDeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<userDeviceCreateWithoutUserInput, userDeviceUncheckedCreateWithoutUserInput> | userDeviceCreateWithoutUserInput[] | userDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userDeviceCreateOrConnectWithoutUserInput | userDeviceCreateOrConnectWithoutUserInput[]
    createMany?: userDeviceCreateManyUserInputEnvelope
    connect?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
  }

  export type userSkillCreateNestedManyWithoutUserInput = {
    create?: XOR<userSkillCreateWithoutUserInput, userSkillUncheckedCreateWithoutUserInput> | userSkillCreateWithoutUserInput[] | userSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutUserInput | userSkillCreateOrConnectWithoutUserInput[]
    createMany?: userSkillCreateManyUserInputEnvelope
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
  }

  export type userStatisticsCreateNestedOneWithoutUserInput = {
    create?: XOR<userStatisticsCreateWithoutUserInput, userStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: userStatisticsCreateOrConnectWithoutUserInput
    connect?: userStatisticsWhereUniqueInput
  }

  export type videoCallCreateNestedManyWithoutUserInput = {
    create?: XOR<videoCallCreateWithoutUserInput, videoCallUncheckedCreateWithoutUserInput> | videoCallCreateWithoutUserInput[] | videoCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutUserInput | videoCallCreateOrConnectWithoutUserInput[]
    createMany?: videoCallCreateManyUserInputEnvelope
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
  }

  export type wellnessGoalCreateNestedManyWithoutUserInput = {
    create?: XOR<wellnessGoalCreateWithoutUserInput, wellnessGoalUncheckedCreateWithoutUserInput> | wellnessGoalCreateWithoutUserInput[] | wellnessGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutUserInput | wellnessGoalCreateOrConnectWithoutUserInput[]
    createMany?: wellnessGoalCreateManyUserInputEnvelope
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
  }

  export type sessionCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type activityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<activityCreateWithoutUserInput, activityUncheckedCreateWithoutUserInput> | activityCreateWithoutUserInput[] | activityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityCreateOrConnectWithoutUserInput | activityCreateOrConnectWithoutUserInput[]
    createMany?: activityCreateManyUserInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type activityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<activityLogCreateWithoutUserInput, activityLogUncheckedCreateWithoutUserInput> | activityLogCreateWithoutUserInput[] | activityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityLogCreateOrConnectWithoutUserInput | activityLogCreateOrConnectWithoutUserInput[]
    createMany?: activityLogCreateManyUserInputEnvelope
    connect?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
  }

  export type activityRegistrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<activityRegistrationCreateWithoutUserInput, activityRegistrationUncheckedCreateWithoutUserInput> | activityRegistrationCreateWithoutUserInput[] | activityRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutUserInput | activityRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: activityRegistrationCreateManyUserInputEnvelope
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
  }

  export type collaborativeProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<collaborativeProjectCreateWithoutUserInput, collaborativeProjectUncheckedCreateWithoutUserInput> | collaborativeProjectCreateWithoutUserInput[] | collaborativeProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutUserInput | collaborativeProjectCreateOrConnectWithoutUserInput[]
    createMany?: collaborativeProjectCreateManyUserInputEnvelope
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
  }

  export type conversationParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<conversationParticipantCreateWithoutUserInput, conversationParticipantUncheckedCreateWithoutUserInput> | conversationParticipantCreateWithoutUserInput[] | conversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutUserInput | conversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: conversationParticipantCreateManyUserInputEnvelope
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
  }

  export type forumMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<forumMessageCreateWithoutUserInput, forumMessageUncheckedCreateWithoutUserInput> | forumMessageCreateWithoutUserInput[] | forumMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutUserInput | forumMessageCreateOrConnectWithoutUserInput[]
    createMany?: forumMessageCreateManyUserInputEnvelope
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
  }

  export type forumTopicUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<forumTopicCreateWithoutUserInput, forumTopicUncheckedCreateWithoutUserInput> | forumTopicCreateWithoutUserInput[] | forumTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutUserInput | forumTopicCreateOrConnectWithoutUserInput[]
    createMany?: forumTopicCreateManyUserInputEnvelope
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
  }

  export type healthIndicatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<healthIndicatorCreateWithoutUserInput, healthIndicatorUncheckedCreateWithoutUserInput> | healthIndicatorCreateWithoutUserInput[] | healthIndicatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: healthIndicatorCreateOrConnectWithoutUserInput | healthIndicatorCreateOrConnectWithoutUserInput[]
    createMany?: healthIndicatorCreateManyUserInputEnvelope
    connect?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
  }

  export type helpOfferUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<helpOfferCreateWithoutUserInput, helpOfferUncheckedCreateWithoutUserInput> | helpOfferCreateWithoutUserInput[] | helpOfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutUserInput | helpOfferCreateOrConnectWithoutUserInput[]
    createMany?: helpOfferCreateManyUserInputEnvelope
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
  }

  export type helpRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<helpRequestCreateWithoutUserInput, helpRequestUncheckedCreateWithoutUserInput> | helpRequestCreateWithoutUserInput[] | helpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutUserInput | helpRequestCreateOrConnectWithoutUserInput[]
    createMany?: helpRequestCreateManyUserInputEnvelope
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
  }

  export type medicationReminderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<medicationReminderCreateWithoutUserInput, medicationReminderUncheckedCreateWithoutUserInput> | medicationReminderCreateWithoutUserInput[] | medicationReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: medicationReminderCreateOrConnectWithoutUserInput | medicationReminderCreateOrConnectWithoutUserInput[]
    createMany?: medicationReminderCreateManyUserInputEnvelope
    connect?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type notificationPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<notificationPreferencesCreateWithoutUserInput, notificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: notificationPreferencesCreateOrConnectWithoutUserInput
    connect?: notificationPreferencesWhereUniqueInput
  }

  export type projectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<projectMemberCreateWithoutUserInput, projectMemberUncheckedCreateWithoutUserInput> | projectMemberCreateWithoutUserInput[] | projectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutUserInput | projectMemberCreateOrConnectWithoutUserInput[]
    createMany?: projectMemberCreateManyUserInputEnvelope
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
  }

  export type projectTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput> | projectTaskCreateWithoutUserInput[] | projectTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutUserInput | projectTaskCreateOrConnectWithoutUserInput[]
    createMany?: projectTaskCreateManyUserInputEnvelope
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
  }

  export type resourceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<resourceCreateWithoutUserInput, resourceUncheckedCreateWithoutUserInput> | resourceCreateWithoutUserInput[] | resourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutUserInput | resourceCreateOrConnectWithoutUserInput[]
    createMany?: resourceCreateManyUserInputEnvelope
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
  }

  export type serviceCompletedUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<serviceCompletedCreateWithoutUserInput, serviceCompletedUncheckedCreateWithoutUserInput> | serviceCompletedCreateWithoutUserInput[] | serviceCompletedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutUserInput | serviceCompletedCreateOrConnectWithoutUserInput[]
    createMany?: serviceCompletedCreateManyUserInputEnvelope
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
  }

  export type serviceRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<serviceRatingCreateWithoutUserInput, serviceRatingUncheckedCreateWithoutUserInput> | serviceRatingCreateWithoutUserInput[] | serviceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutUserInput | serviceRatingCreateOrConnectWithoutUserInput[]
    createMany?: serviceRatingCreateManyUserInputEnvelope
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
  }

  export type surveyResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<surveyResponseCreateWithoutUserInput, surveyResponseUncheckedCreateWithoutUserInput> | surveyResponseCreateWithoutUserInput[] | surveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutUserInput | surveyResponseCreateOrConnectWithoutUserInput[]
    createMany?: surveyResponseCreateManyUserInputEnvelope
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
  }

  export type trustedContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<trustedContactCreateWithoutUserInput, trustedContactUncheckedCreateWithoutUserInput> | trustedContactCreateWithoutUserInput[] | trustedContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: trustedContactCreateOrConnectWithoutUserInput | trustedContactCreateOrConnectWithoutUserInput[]
    createMany?: trustedContactCreateManyUserInputEnvelope
    connect?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
  }

  export type urbanIssueReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<urbanIssueReportCreateWithoutUserInput, urbanIssueReportUncheckedCreateWithoutUserInput> | urbanIssueReportCreateWithoutUserInput[] | urbanIssueReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutUserInput | urbanIssueReportCreateOrConnectWithoutUserInput[]
    createMany?: urbanIssueReportCreateManyUserInputEnvelope
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
  }

  export type userActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userActivityCreateWithoutUserInput, userActivityUncheckedCreateWithoutUserInput> | userActivityCreateWithoutUserInput[] | userActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutUserInput | userActivityCreateOrConnectWithoutUserInput[]
    createMany?: userActivityCreateManyUserInputEnvelope
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
  }

  export type userBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userBadgeCreateWithoutUserInput, userBadgeUncheckedCreateWithoutUserInput> | userBadgeCreateWithoutUserInput[] | userBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userBadgeCreateOrConnectWithoutUserInput | userBadgeCreateOrConnectWithoutUserInput[]
    createMany?: userBadgeCreateManyUserInputEnvelope
    connect?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
  }

  export type userDeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userDeviceCreateWithoutUserInput, userDeviceUncheckedCreateWithoutUserInput> | userDeviceCreateWithoutUserInput[] | userDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userDeviceCreateOrConnectWithoutUserInput | userDeviceCreateOrConnectWithoutUserInput[]
    createMany?: userDeviceCreateManyUserInputEnvelope
    connect?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
  }

  export type userSkillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userSkillCreateWithoutUserInput, userSkillUncheckedCreateWithoutUserInput> | userSkillCreateWithoutUserInput[] | userSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutUserInput | userSkillCreateOrConnectWithoutUserInput[]
    createMany?: userSkillCreateManyUserInputEnvelope
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
  }

  export type userStatisticsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<userStatisticsCreateWithoutUserInput, userStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: userStatisticsCreateOrConnectWithoutUserInput
    connect?: userStatisticsWhereUniqueInput
  }

  export type videoCallUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<videoCallCreateWithoutUserInput, videoCallUncheckedCreateWithoutUserInput> | videoCallCreateWithoutUserInput[] | videoCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutUserInput | videoCallCreateOrConnectWithoutUserInput[]
    createMany?: videoCallCreateManyUserInputEnvelope
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
  }

  export type wellnessGoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<wellnessGoalCreateWithoutUserInput, wellnessGoalUncheckedCreateWithoutUserInput> | wellnessGoalCreateWithoutUserInput[] | wellnessGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutUserInput | wellnessGoalCreateOrConnectWithoutUserInput[]
    createMany?: wellnessGoalCreateManyUserInputEnvelope
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
  }

  export type sessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type activityUpdateManyWithoutUserNestedInput = {
    create?: XOR<activityCreateWithoutUserInput, activityUncheckedCreateWithoutUserInput> | activityCreateWithoutUserInput[] | activityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityCreateOrConnectWithoutUserInput | activityCreateOrConnectWithoutUserInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutUserInput | activityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activityCreateManyUserInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutUserInput | activityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activityUpdateManyWithWhereWithoutUserInput | activityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type activityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<activityLogCreateWithoutUserInput, activityLogUncheckedCreateWithoutUserInput> | activityLogCreateWithoutUserInput[] | activityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityLogCreateOrConnectWithoutUserInput | activityLogCreateOrConnectWithoutUserInput[]
    upsert?: activityLogUpsertWithWhereUniqueWithoutUserInput | activityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activityLogCreateManyUserInputEnvelope
    set?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    disconnect?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    delete?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    connect?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    update?: activityLogUpdateWithWhereUniqueWithoutUserInput | activityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activityLogUpdateManyWithWhereWithoutUserInput | activityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activityLogScalarWhereInput | activityLogScalarWhereInput[]
  }

  export type activityRegistrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<activityRegistrationCreateWithoutUserInput, activityRegistrationUncheckedCreateWithoutUserInput> | activityRegistrationCreateWithoutUserInput[] | activityRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutUserInput | activityRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: activityRegistrationUpsertWithWhereUniqueWithoutUserInput | activityRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activityRegistrationCreateManyUserInputEnvelope
    set?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    disconnect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    delete?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    update?: activityRegistrationUpdateWithWhereUniqueWithoutUserInput | activityRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activityRegistrationUpdateManyWithWhereWithoutUserInput | activityRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activityRegistrationScalarWhereInput | activityRegistrationScalarWhereInput[]
  }

  export type collaborativeProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<collaborativeProjectCreateWithoutUserInput, collaborativeProjectUncheckedCreateWithoutUserInput> | collaborativeProjectCreateWithoutUserInput[] | collaborativeProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutUserInput | collaborativeProjectCreateOrConnectWithoutUserInput[]
    upsert?: collaborativeProjectUpsertWithWhereUniqueWithoutUserInput | collaborativeProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: collaborativeProjectCreateManyUserInputEnvelope
    set?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    disconnect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    delete?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    update?: collaborativeProjectUpdateWithWhereUniqueWithoutUserInput | collaborativeProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: collaborativeProjectUpdateManyWithWhereWithoutUserInput | collaborativeProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: collaborativeProjectScalarWhereInput | collaborativeProjectScalarWhereInput[]
  }

  export type conversationParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<conversationParticipantCreateWithoutUserInput, conversationParticipantUncheckedCreateWithoutUserInput> | conversationParticipantCreateWithoutUserInput[] | conversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutUserInput | conversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: conversationParticipantUpsertWithWhereUniqueWithoutUserInput | conversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: conversationParticipantCreateManyUserInputEnvelope
    set?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    disconnect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    delete?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    update?: conversationParticipantUpdateWithWhereUniqueWithoutUserInput | conversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: conversationParticipantUpdateManyWithWhereWithoutUserInput | conversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: conversationParticipantScalarWhereInput | conversationParticipantScalarWhereInput[]
  }

  export type forumMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<forumMessageCreateWithoutUserInput, forumMessageUncheckedCreateWithoutUserInput> | forumMessageCreateWithoutUserInput[] | forumMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutUserInput | forumMessageCreateOrConnectWithoutUserInput[]
    upsert?: forumMessageUpsertWithWhereUniqueWithoutUserInput | forumMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: forumMessageCreateManyUserInputEnvelope
    set?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    disconnect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    delete?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    update?: forumMessageUpdateWithWhereUniqueWithoutUserInput | forumMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: forumMessageUpdateManyWithWhereWithoutUserInput | forumMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: forumMessageScalarWhereInput | forumMessageScalarWhereInput[]
  }

  export type forumTopicUpdateManyWithoutUserNestedInput = {
    create?: XOR<forumTopicCreateWithoutUserInput, forumTopicUncheckedCreateWithoutUserInput> | forumTopicCreateWithoutUserInput[] | forumTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutUserInput | forumTopicCreateOrConnectWithoutUserInput[]
    upsert?: forumTopicUpsertWithWhereUniqueWithoutUserInput | forumTopicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: forumTopicCreateManyUserInputEnvelope
    set?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    disconnect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    delete?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    update?: forumTopicUpdateWithWhereUniqueWithoutUserInput | forumTopicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: forumTopicUpdateManyWithWhereWithoutUserInput | forumTopicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: forumTopicScalarWhereInput | forumTopicScalarWhereInput[]
  }

  export type healthIndicatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<healthIndicatorCreateWithoutUserInput, healthIndicatorUncheckedCreateWithoutUserInput> | healthIndicatorCreateWithoutUserInput[] | healthIndicatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: healthIndicatorCreateOrConnectWithoutUserInput | healthIndicatorCreateOrConnectWithoutUserInput[]
    upsert?: healthIndicatorUpsertWithWhereUniqueWithoutUserInput | healthIndicatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: healthIndicatorCreateManyUserInputEnvelope
    set?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    disconnect?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    delete?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    connect?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    update?: healthIndicatorUpdateWithWhereUniqueWithoutUserInput | healthIndicatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: healthIndicatorUpdateManyWithWhereWithoutUserInput | healthIndicatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: healthIndicatorScalarWhereInput | healthIndicatorScalarWhereInput[]
  }

  export type helpOfferUpdateManyWithoutUserNestedInput = {
    create?: XOR<helpOfferCreateWithoutUserInput, helpOfferUncheckedCreateWithoutUserInput> | helpOfferCreateWithoutUserInput[] | helpOfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutUserInput | helpOfferCreateOrConnectWithoutUserInput[]
    upsert?: helpOfferUpsertWithWhereUniqueWithoutUserInput | helpOfferUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: helpOfferCreateManyUserInputEnvelope
    set?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    disconnect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    delete?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    update?: helpOfferUpdateWithWhereUniqueWithoutUserInput | helpOfferUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: helpOfferUpdateManyWithWhereWithoutUserInput | helpOfferUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: helpOfferScalarWhereInput | helpOfferScalarWhereInput[]
  }

  export type helpRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<helpRequestCreateWithoutUserInput, helpRequestUncheckedCreateWithoutUserInput> | helpRequestCreateWithoutUserInput[] | helpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutUserInput | helpRequestCreateOrConnectWithoutUserInput[]
    upsert?: helpRequestUpsertWithWhereUniqueWithoutUserInput | helpRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: helpRequestCreateManyUserInputEnvelope
    set?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    disconnect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    delete?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    update?: helpRequestUpdateWithWhereUniqueWithoutUserInput | helpRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: helpRequestUpdateManyWithWhereWithoutUserInput | helpRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: helpRequestScalarWhereInput | helpRequestScalarWhereInput[]
  }

  export type medicationReminderUpdateManyWithoutUserNestedInput = {
    create?: XOR<medicationReminderCreateWithoutUserInput, medicationReminderUncheckedCreateWithoutUserInput> | medicationReminderCreateWithoutUserInput[] | medicationReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: medicationReminderCreateOrConnectWithoutUserInput | medicationReminderCreateOrConnectWithoutUserInput[]
    upsert?: medicationReminderUpsertWithWhereUniqueWithoutUserInput | medicationReminderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: medicationReminderCreateManyUserInputEnvelope
    set?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    disconnect?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    delete?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    connect?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    update?: medicationReminderUpdateWithWhereUniqueWithoutUserInput | medicationReminderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: medicationReminderUpdateManyWithWhereWithoutUserInput | medicationReminderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: medicationReminderScalarWhereInput | medicationReminderScalarWhereInput[]
  }

  export type messageUpdateManyWithoutUserNestedInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUserInput | messageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUserInput | messageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUserInput | messageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type notificationPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<notificationPreferencesCreateWithoutUserInput, notificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: notificationPreferencesCreateOrConnectWithoutUserInput
    upsert?: notificationPreferencesUpsertWithoutUserInput
    disconnect?: notificationPreferencesWhereInput | boolean
    delete?: notificationPreferencesWhereInput | boolean
    connect?: notificationPreferencesWhereUniqueInput
    update?: XOR<XOR<notificationPreferencesUpdateToOneWithWhereWithoutUserInput, notificationPreferencesUpdateWithoutUserInput>, notificationPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type projectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<projectMemberCreateWithoutUserInput, projectMemberUncheckedCreateWithoutUserInput> | projectMemberCreateWithoutUserInput[] | projectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutUserInput | projectMemberCreateOrConnectWithoutUserInput[]
    upsert?: projectMemberUpsertWithWhereUniqueWithoutUserInput | projectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: projectMemberCreateManyUserInputEnvelope
    set?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    disconnect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    delete?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    update?: projectMemberUpdateWithWhereUniqueWithoutUserInput | projectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: projectMemberUpdateManyWithWhereWithoutUserInput | projectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: projectMemberScalarWhereInput | projectMemberScalarWhereInput[]
  }

  export type projectTaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput> | projectTaskCreateWithoutUserInput[] | projectTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutUserInput | projectTaskCreateOrConnectWithoutUserInput[]
    upsert?: projectTaskUpsertWithWhereUniqueWithoutUserInput | projectTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: projectTaskCreateManyUserInputEnvelope
    set?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    disconnect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    delete?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    update?: projectTaskUpdateWithWhereUniqueWithoutUserInput | projectTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: projectTaskUpdateManyWithWhereWithoutUserInput | projectTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: projectTaskScalarWhereInput | projectTaskScalarWhereInput[]
  }

  export type resourceUpdateManyWithoutUserNestedInput = {
    create?: XOR<resourceCreateWithoutUserInput, resourceUncheckedCreateWithoutUserInput> | resourceCreateWithoutUserInput[] | resourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutUserInput | resourceCreateOrConnectWithoutUserInput[]
    upsert?: resourceUpsertWithWhereUniqueWithoutUserInput | resourceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: resourceCreateManyUserInputEnvelope
    set?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    disconnect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    delete?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    update?: resourceUpdateWithWhereUniqueWithoutUserInput | resourceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: resourceUpdateManyWithWhereWithoutUserInput | resourceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: resourceScalarWhereInput | resourceScalarWhereInput[]
  }

  export type serviceCompletedUpdateManyWithoutUserNestedInput = {
    create?: XOR<serviceCompletedCreateWithoutUserInput, serviceCompletedUncheckedCreateWithoutUserInput> | serviceCompletedCreateWithoutUserInput[] | serviceCompletedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutUserInput | serviceCompletedCreateOrConnectWithoutUserInput[]
    upsert?: serviceCompletedUpsertWithWhereUniqueWithoutUserInput | serviceCompletedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: serviceCompletedCreateManyUserInputEnvelope
    set?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    disconnect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    delete?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    update?: serviceCompletedUpdateWithWhereUniqueWithoutUserInput | serviceCompletedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: serviceCompletedUpdateManyWithWhereWithoutUserInput | serviceCompletedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: serviceCompletedScalarWhereInput | serviceCompletedScalarWhereInput[]
  }

  export type serviceRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<serviceRatingCreateWithoutUserInput, serviceRatingUncheckedCreateWithoutUserInput> | serviceRatingCreateWithoutUserInput[] | serviceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutUserInput | serviceRatingCreateOrConnectWithoutUserInput[]
    upsert?: serviceRatingUpsertWithWhereUniqueWithoutUserInput | serviceRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: serviceRatingCreateManyUserInputEnvelope
    set?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    disconnect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    delete?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    update?: serviceRatingUpdateWithWhereUniqueWithoutUserInput | serviceRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: serviceRatingUpdateManyWithWhereWithoutUserInput | serviceRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: serviceRatingScalarWhereInput | serviceRatingScalarWhereInput[]
  }

  export type surveyResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<surveyResponseCreateWithoutUserInput, surveyResponseUncheckedCreateWithoutUserInput> | surveyResponseCreateWithoutUserInput[] | surveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutUserInput | surveyResponseCreateOrConnectWithoutUserInput[]
    upsert?: surveyResponseUpsertWithWhereUniqueWithoutUserInput | surveyResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: surveyResponseCreateManyUserInputEnvelope
    set?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    disconnect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    delete?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    update?: surveyResponseUpdateWithWhereUniqueWithoutUserInput | surveyResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: surveyResponseUpdateManyWithWhereWithoutUserInput | surveyResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: surveyResponseScalarWhereInput | surveyResponseScalarWhereInput[]
  }

  export type trustedContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<trustedContactCreateWithoutUserInput, trustedContactUncheckedCreateWithoutUserInput> | trustedContactCreateWithoutUserInput[] | trustedContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: trustedContactCreateOrConnectWithoutUserInput | trustedContactCreateOrConnectWithoutUserInput[]
    upsert?: trustedContactUpsertWithWhereUniqueWithoutUserInput | trustedContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: trustedContactCreateManyUserInputEnvelope
    set?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    disconnect?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    delete?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    connect?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    update?: trustedContactUpdateWithWhereUniqueWithoutUserInput | trustedContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: trustedContactUpdateManyWithWhereWithoutUserInput | trustedContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: trustedContactScalarWhereInput | trustedContactScalarWhereInput[]
  }

  export type urbanIssueReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<urbanIssueReportCreateWithoutUserInput, urbanIssueReportUncheckedCreateWithoutUserInput> | urbanIssueReportCreateWithoutUserInput[] | urbanIssueReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutUserInput | urbanIssueReportCreateOrConnectWithoutUserInput[]
    upsert?: urbanIssueReportUpsertWithWhereUniqueWithoutUserInput | urbanIssueReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: urbanIssueReportCreateManyUserInputEnvelope
    set?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    disconnect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    delete?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    update?: urbanIssueReportUpdateWithWhereUniqueWithoutUserInput | urbanIssueReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: urbanIssueReportUpdateManyWithWhereWithoutUserInput | urbanIssueReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: urbanIssueReportScalarWhereInput | urbanIssueReportScalarWhereInput[]
  }

  export type userActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<userActivityCreateWithoutUserInput, userActivityUncheckedCreateWithoutUserInput> | userActivityCreateWithoutUserInput[] | userActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutUserInput | userActivityCreateOrConnectWithoutUserInput[]
    upsert?: userActivityUpsertWithWhereUniqueWithoutUserInput | userActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userActivityCreateManyUserInputEnvelope
    set?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    disconnect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    delete?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    update?: userActivityUpdateWithWhereUniqueWithoutUserInput | userActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userActivityUpdateManyWithWhereWithoutUserInput | userActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
  }

  export type userBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<userBadgeCreateWithoutUserInput, userBadgeUncheckedCreateWithoutUserInput> | userBadgeCreateWithoutUserInput[] | userBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userBadgeCreateOrConnectWithoutUserInput | userBadgeCreateOrConnectWithoutUserInput[]
    upsert?: userBadgeUpsertWithWhereUniqueWithoutUserInput | userBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userBadgeCreateManyUserInputEnvelope
    set?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    disconnect?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    delete?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    connect?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    update?: userBadgeUpdateWithWhereUniqueWithoutUserInput | userBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userBadgeUpdateManyWithWhereWithoutUserInput | userBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userBadgeScalarWhereInput | userBadgeScalarWhereInput[]
  }

  export type userDeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<userDeviceCreateWithoutUserInput, userDeviceUncheckedCreateWithoutUserInput> | userDeviceCreateWithoutUserInput[] | userDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userDeviceCreateOrConnectWithoutUserInput | userDeviceCreateOrConnectWithoutUserInput[]
    upsert?: userDeviceUpsertWithWhereUniqueWithoutUserInput | userDeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userDeviceCreateManyUserInputEnvelope
    set?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    disconnect?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    delete?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    connect?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    update?: userDeviceUpdateWithWhereUniqueWithoutUserInput | userDeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userDeviceUpdateManyWithWhereWithoutUserInput | userDeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userDeviceScalarWhereInput | userDeviceScalarWhereInput[]
  }

  export type userSkillUpdateManyWithoutUserNestedInput = {
    create?: XOR<userSkillCreateWithoutUserInput, userSkillUncheckedCreateWithoutUserInput> | userSkillCreateWithoutUserInput[] | userSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutUserInput | userSkillCreateOrConnectWithoutUserInput[]
    upsert?: userSkillUpsertWithWhereUniqueWithoutUserInput | userSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userSkillCreateManyUserInputEnvelope
    set?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    disconnect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    delete?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    update?: userSkillUpdateWithWhereUniqueWithoutUserInput | userSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userSkillUpdateManyWithWhereWithoutUserInput | userSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userSkillScalarWhereInput | userSkillScalarWhereInput[]
  }

  export type userStatisticsUpdateOneWithoutUserNestedInput = {
    create?: XOR<userStatisticsCreateWithoutUserInput, userStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: userStatisticsCreateOrConnectWithoutUserInput
    upsert?: userStatisticsUpsertWithoutUserInput
    disconnect?: userStatisticsWhereInput | boolean
    delete?: userStatisticsWhereInput | boolean
    connect?: userStatisticsWhereUniqueInput
    update?: XOR<XOR<userStatisticsUpdateToOneWithWhereWithoutUserInput, userStatisticsUpdateWithoutUserInput>, userStatisticsUncheckedUpdateWithoutUserInput>
  }

  export type videoCallUpdateManyWithoutUserNestedInput = {
    create?: XOR<videoCallCreateWithoutUserInput, videoCallUncheckedCreateWithoutUserInput> | videoCallCreateWithoutUserInput[] | videoCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutUserInput | videoCallCreateOrConnectWithoutUserInput[]
    upsert?: videoCallUpsertWithWhereUniqueWithoutUserInput | videoCallUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: videoCallCreateManyUserInputEnvelope
    set?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    disconnect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    delete?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    update?: videoCallUpdateWithWhereUniqueWithoutUserInput | videoCallUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: videoCallUpdateManyWithWhereWithoutUserInput | videoCallUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: videoCallScalarWhereInput | videoCallScalarWhereInput[]
  }

  export type wellnessGoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<wellnessGoalCreateWithoutUserInput, wellnessGoalUncheckedCreateWithoutUserInput> | wellnessGoalCreateWithoutUserInput[] | wellnessGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutUserInput | wellnessGoalCreateOrConnectWithoutUserInput[]
    upsert?: wellnessGoalUpsertWithWhereUniqueWithoutUserInput | wellnessGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: wellnessGoalCreateManyUserInputEnvelope
    set?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    disconnect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    delete?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    update?: wellnessGoalUpdateWithWhereUniqueWithoutUserInput | wellnessGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: wellnessGoalUpdateManyWithWhereWithoutUserInput | wellnessGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: wellnessGoalScalarWhereInput | wellnessGoalScalarWhereInput[]
  }

  export type sessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type activityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<activityCreateWithoutUserInput, activityUncheckedCreateWithoutUserInput> | activityCreateWithoutUserInput[] | activityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityCreateOrConnectWithoutUserInput | activityCreateOrConnectWithoutUserInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutUserInput | activityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activityCreateManyUserInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutUserInput | activityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activityUpdateManyWithWhereWithoutUserInput | activityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type activityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<activityLogCreateWithoutUserInput, activityLogUncheckedCreateWithoutUserInput> | activityLogCreateWithoutUserInput[] | activityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityLogCreateOrConnectWithoutUserInput | activityLogCreateOrConnectWithoutUserInput[]
    upsert?: activityLogUpsertWithWhereUniqueWithoutUserInput | activityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activityLogCreateManyUserInputEnvelope
    set?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    disconnect?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    delete?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    connect?: activityLogWhereUniqueInput | activityLogWhereUniqueInput[]
    update?: activityLogUpdateWithWhereUniqueWithoutUserInput | activityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activityLogUpdateManyWithWhereWithoutUserInput | activityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activityLogScalarWhereInput | activityLogScalarWhereInput[]
  }

  export type activityRegistrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<activityRegistrationCreateWithoutUserInput, activityRegistrationUncheckedCreateWithoutUserInput> | activityRegistrationCreateWithoutUserInput[] | activityRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activityRegistrationCreateOrConnectWithoutUserInput | activityRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: activityRegistrationUpsertWithWhereUniqueWithoutUserInput | activityRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activityRegistrationCreateManyUserInputEnvelope
    set?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    disconnect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    delete?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    connect?: activityRegistrationWhereUniqueInput | activityRegistrationWhereUniqueInput[]
    update?: activityRegistrationUpdateWithWhereUniqueWithoutUserInput | activityRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activityRegistrationUpdateManyWithWhereWithoutUserInput | activityRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activityRegistrationScalarWhereInput | activityRegistrationScalarWhereInput[]
  }

  export type collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<collaborativeProjectCreateWithoutUserInput, collaborativeProjectUncheckedCreateWithoutUserInput> | collaborativeProjectCreateWithoutUserInput[] | collaborativeProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutUserInput | collaborativeProjectCreateOrConnectWithoutUserInput[]
    upsert?: collaborativeProjectUpsertWithWhereUniqueWithoutUserInput | collaborativeProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: collaborativeProjectCreateManyUserInputEnvelope
    set?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    disconnect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    delete?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    update?: collaborativeProjectUpdateWithWhereUniqueWithoutUserInput | collaborativeProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: collaborativeProjectUpdateManyWithWhereWithoutUserInput | collaborativeProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: collaborativeProjectScalarWhereInput | collaborativeProjectScalarWhereInput[]
  }

  export type conversationParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<conversationParticipantCreateWithoutUserInput, conversationParticipantUncheckedCreateWithoutUserInput> | conversationParticipantCreateWithoutUserInput[] | conversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationParticipantCreateOrConnectWithoutUserInput | conversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: conversationParticipantUpsertWithWhereUniqueWithoutUserInput | conversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: conversationParticipantCreateManyUserInputEnvelope
    set?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    disconnect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    delete?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    connect?: conversationParticipantWhereUniqueInput | conversationParticipantWhereUniqueInput[]
    update?: conversationParticipantUpdateWithWhereUniqueWithoutUserInput | conversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: conversationParticipantUpdateManyWithWhereWithoutUserInput | conversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: conversationParticipantScalarWhereInput | conversationParticipantScalarWhereInput[]
  }

  export type forumMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<forumMessageCreateWithoutUserInput, forumMessageUncheckedCreateWithoutUserInput> | forumMessageCreateWithoutUserInput[] | forumMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumMessageCreateOrConnectWithoutUserInput | forumMessageCreateOrConnectWithoutUserInput[]
    upsert?: forumMessageUpsertWithWhereUniqueWithoutUserInput | forumMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: forumMessageCreateManyUserInputEnvelope
    set?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    disconnect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    delete?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    connect?: forumMessageWhereUniqueInput | forumMessageWhereUniqueInput[]
    update?: forumMessageUpdateWithWhereUniqueWithoutUserInput | forumMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: forumMessageUpdateManyWithWhereWithoutUserInput | forumMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: forumMessageScalarWhereInput | forumMessageScalarWhereInput[]
  }

  export type forumTopicUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<forumTopicCreateWithoutUserInput, forumTopicUncheckedCreateWithoutUserInput> | forumTopicCreateWithoutUserInput[] | forumTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: forumTopicCreateOrConnectWithoutUserInput | forumTopicCreateOrConnectWithoutUserInput[]
    upsert?: forumTopicUpsertWithWhereUniqueWithoutUserInput | forumTopicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: forumTopicCreateManyUserInputEnvelope
    set?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    disconnect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    delete?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    connect?: forumTopicWhereUniqueInput | forumTopicWhereUniqueInput[]
    update?: forumTopicUpdateWithWhereUniqueWithoutUserInput | forumTopicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: forumTopicUpdateManyWithWhereWithoutUserInput | forumTopicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: forumTopicScalarWhereInput | forumTopicScalarWhereInput[]
  }

  export type healthIndicatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<healthIndicatorCreateWithoutUserInput, healthIndicatorUncheckedCreateWithoutUserInput> | healthIndicatorCreateWithoutUserInput[] | healthIndicatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: healthIndicatorCreateOrConnectWithoutUserInput | healthIndicatorCreateOrConnectWithoutUserInput[]
    upsert?: healthIndicatorUpsertWithWhereUniqueWithoutUserInput | healthIndicatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: healthIndicatorCreateManyUserInputEnvelope
    set?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    disconnect?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    delete?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    connect?: healthIndicatorWhereUniqueInput | healthIndicatorWhereUniqueInput[]
    update?: healthIndicatorUpdateWithWhereUniqueWithoutUserInput | healthIndicatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: healthIndicatorUpdateManyWithWhereWithoutUserInput | healthIndicatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: healthIndicatorScalarWhereInput | healthIndicatorScalarWhereInput[]
  }

  export type helpOfferUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<helpOfferCreateWithoutUserInput, helpOfferUncheckedCreateWithoutUserInput> | helpOfferCreateWithoutUserInput[] | helpOfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpOfferCreateOrConnectWithoutUserInput | helpOfferCreateOrConnectWithoutUserInput[]
    upsert?: helpOfferUpsertWithWhereUniqueWithoutUserInput | helpOfferUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: helpOfferCreateManyUserInputEnvelope
    set?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    disconnect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    delete?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    connect?: helpOfferWhereUniqueInput | helpOfferWhereUniqueInput[]
    update?: helpOfferUpdateWithWhereUniqueWithoutUserInput | helpOfferUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: helpOfferUpdateManyWithWhereWithoutUserInput | helpOfferUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: helpOfferScalarWhereInput | helpOfferScalarWhereInput[]
  }

  export type helpRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<helpRequestCreateWithoutUserInput, helpRequestUncheckedCreateWithoutUserInput> | helpRequestCreateWithoutUserInput[] | helpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutUserInput | helpRequestCreateOrConnectWithoutUserInput[]
    upsert?: helpRequestUpsertWithWhereUniqueWithoutUserInput | helpRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: helpRequestCreateManyUserInputEnvelope
    set?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    disconnect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    delete?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    update?: helpRequestUpdateWithWhereUniqueWithoutUserInput | helpRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: helpRequestUpdateManyWithWhereWithoutUserInput | helpRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: helpRequestScalarWhereInput | helpRequestScalarWhereInput[]
  }

  export type medicationReminderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<medicationReminderCreateWithoutUserInput, medicationReminderUncheckedCreateWithoutUserInput> | medicationReminderCreateWithoutUserInput[] | medicationReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: medicationReminderCreateOrConnectWithoutUserInput | medicationReminderCreateOrConnectWithoutUserInput[]
    upsert?: medicationReminderUpsertWithWhereUniqueWithoutUserInput | medicationReminderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: medicationReminderCreateManyUserInputEnvelope
    set?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    disconnect?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    delete?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    connect?: medicationReminderWhereUniqueInput | medicationReminderWhereUniqueInput[]
    update?: medicationReminderUpdateWithWhereUniqueWithoutUserInput | medicationReminderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: medicationReminderUpdateManyWithWhereWithoutUserInput | medicationReminderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: medicationReminderScalarWhereInput | medicationReminderScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUserInput | messageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUserInput | messageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUserInput | messageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<notificationPreferencesCreateWithoutUserInput, notificationPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: notificationPreferencesCreateOrConnectWithoutUserInput
    upsert?: notificationPreferencesUpsertWithoutUserInput
    disconnect?: notificationPreferencesWhereInput | boolean
    delete?: notificationPreferencesWhereInput | boolean
    connect?: notificationPreferencesWhereUniqueInput
    update?: XOR<XOR<notificationPreferencesUpdateToOneWithWhereWithoutUserInput, notificationPreferencesUpdateWithoutUserInput>, notificationPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type projectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<projectMemberCreateWithoutUserInput, projectMemberUncheckedCreateWithoutUserInput> | projectMemberCreateWithoutUserInput[] | projectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectMemberCreateOrConnectWithoutUserInput | projectMemberCreateOrConnectWithoutUserInput[]
    upsert?: projectMemberUpsertWithWhereUniqueWithoutUserInput | projectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: projectMemberCreateManyUserInputEnvelope
    set?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    disconnect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    delete?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    connect?: projectMemberWhereUniqueInput | projectMemberWhereUniqueInput[]
    update?: projectMemberUpdateWithWhereUniqueWithoutUserInput | projectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: projectMemberUpdateManyWithWhereWithoutUserInput | projectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: projectMemberScalarWhereInput | projectMemberScalarWhereInput[]
  }

  export type projectTaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput> | projectTaskCreateWithoutUserInput[] | projectTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: projectTaskCreateOrConnectWithoutUserInput | projectTaskCreateOrConnectWithoutUserInput[]
    upsert?: projectTaskUpsertWithWhereUniqueWithoutUserInput | projectTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: projectTaskCreateManyUserInputEnvelope
    set?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    disconnect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    delete?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    connect?: projectTaskWhereUniqueInput | projectTaskWhereUniqueInput[]
    update?: projectTaskUpdateWithWhereUniqueWithoutUserInput | projectTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: projectTaskUpdateManyWithWhereWithoutUserInput | projectTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: projectTaskScalarWhereInput | projectTaskScalarWhereInput[]
  }

  export type resourceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<resourceCreateWithoutUserInput, resourceUncheckedCreateWithoutUserInput> | resourceCreateWithoutUserInput[] | resourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutUserInput | resourceCreateOrConnectWithoutUserInput[]
    upsert?: resourceUpsertWithWhereUniqueWithoutUserInput | resourceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: resourceCreateManyUserInputEnvelope
    set?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    disconnect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    delete?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    update?: resourceUpdateWithWhereUniqueWithoutUserInput | resourceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: resourceUpdateManyWithWhereWithoutUserInput | resourceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: resourceScalarWhereInput | resourceScalarWhereInput[]
  }

  export type serviceCompletedUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<serviceCompletedCreateWithoutUserInput, serviceCompletedUncheckedCreateWithoutUserInput> | serviceCompletedCreateWithoutUserInput[] | serviceCompletedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCompletedCreateOrConnectWithoutUserInput | serviceCompletedCreateOrConnectWithoutUserInput[]
    upsert?: serviceCompletedUpsertWithWhereUniqueWithoutUserInput | serviceCompletedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: serviceCompletedCreateManyUserInputEnvelope
    set?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    disconnect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    delete?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    connect?: serviceCompletedWhereUniqueInput | serviceCompletedWhereUniqueInput[]
    update?: serviceCompletedUpdateWithWhereUniqueWithoutUserInput | serviceCompletedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: serviceCompletedUpdateManyWithWhereWithoutUserInput | serviceCompletedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: serviceCompletedScalarWhereInput | serviceCompletedScalarWhereInput[]
  }

  export type serviceRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<serviceRatingCreateWithoutUserInput, serviceRatingUncheckedCreateWithoutUserInput> | serviceRatingCreateWithoutUserInput[] | serviceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceRatingCreateOrConnectWithoutUserInput | serviceRatingCreateOrConnectWithoutUserInput[]
    upsert?: serviceRatingUpsertWithWhereUniqueWithoutUserInput | serviceRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: serviceRatingCreateManyUserInputEnvelope
    set?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    disconnect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    delete?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    connect?: serviceRatingWhereUniqueInput | serviceRatingWhereUniqueInput[]
    update?: serviceRatingUpdateWithWhereUniqueWithoutUserInput | serviceRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: serviceRatingUpdateManyWithWhereWithoutUserInput | serviceRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: serviceRatingScalarWhereInput | serviceRatingScalarWhereInput[]
  }

  export type surveyResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<surveyResponseCreateWithoutUserInput, surveyResponseUncheckedCreateWithoutUserInput> | surveyResponseCreateWithoutUserInput[] | surveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: surveyResponseCreateOrConnectWithoutUserInput | surveyResponseCreateOrConnectWithoutUserInput[]
    upsert?: surveyResponseUpsertWithWhereUniqueWithoutUserInput | surveyResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: surveyResponseCreateManyUserInputEnvelope
    set?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    disconnect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    delete?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    connect?: surveyResponseWhereUniqueInput | surveyResponseWhereUniqueInput[]
    update?: surveyResponseUpdateWithWhereUniqueWithoutUserInput | surveyResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: surveyResponseUpdateManyWithWhereWithoutUserInput | surveyResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: surveyResponseScalarWhereInput | surveyResponseScalarWhereInput[]
  }

  export type trustedContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<trustedContactCreateWithoutUserInput, trustedContactUncheckedCreateWithoutUserInput> | trustedContactCreateWithoutUserInput[] | trustedContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: trustedContactCreateOrConnectWithoutUserInput | trustedContactCreateOrConnectWithoutUserInput[]
    upsert?: trustedContactUpsertWithWhereUniqueWithoutUserInput | trustedContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: trustedContactCreateManyUserInputEnvelope
    set?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    disconnect?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    delete?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    connect?: trustedContactWhereUniqueInput | trustedContactWhereUniqueInput[]
    update?: trustedContactUpdateWithWhereUniqueWithoutUserInput | trustedContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: trustedContactUpdateManyWithWhereWithoutUserInput | trustedContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: trustedContactScalarWhereInput | trustedContactScalarWhereInput[]
  }

  export type urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<urbanIssueReportCreateWithoutUserInput, urbanIssueReportUncheckedCreateWithoutUserInput> | urbanIssueReportCreateWithoutUserInput[] | urbanIssueReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutUserInput | urbanIssueReportCreateOrConnectWithoutUserInput[]
    upsert?: urbanIssueReportUpsertWithWhereUniqueWithoutUserInput | urbanIssueReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: urbanIssueReportCreateManyUserInputEnvelope
    set?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    disconnect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    delete?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    update?: urbanIssueReportUpdateWithWhereUniqueWithoutUserInput | urbanIssueReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: urbanIssueReportUpdateManyWithWhereWithoutUserInput | urbanIssueReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: urbanIssueReportScalarWhereInput | urbanIssueReportScalarWhereInput[]
  }

  export type userActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userActivityCreateWithoutUserInput, userActivityUncheckedCreateWithoutUserInput> | userActivityCreateWithoutUserInput[] | userActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userActivityCreateOrConnectWithoutUserInput | userActivityCreateOrConnectWithoutUserInput[]
    upsert?: userActivityUpsertWithWhereUniqueWithoutUserInput | userActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userActivityCreateManyUserInputEnvelope
    set?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    disconnect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    delete?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    connect?: userActivityWhereUniqueInput | userActivityWhereUniqueInput[]
    update?: userActivityUpdateWithWhereUniqueWithoutUserInput | userActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userActivityUpdateManyWithWhereWithoutUserInput | userActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
  }

  export type userBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userBadgeCreateWithoutUserInput, userBadgeUncheckedCreateWithoutUserInput> | userBadgeCreateWithoutUserInput[] | userBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userBadgeCreateOrConnectWithoutUserInput | userBadgeCreateOrConnectWithoutUserInput[]
    upsert?: userBadgeUpsertWithWhereUniqueWithoutUserInput | userBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userBadgeCreateManyUserInputEnvelope
    set?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    disconnect?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    delete?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    connect?: userBadgeWhereUniqueInput | userBadgeWhereUniqueInput[]
    update?: userBadgeUpdateWithWhereUniqueWithoutUserInput | userBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userBadgeUpdateManyWithWhereWithoutUserInput | userBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userBadgeScalarWhereInput | userBadgeScalarWhereInput[]
  }

  export type userDeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userDeviceCreateWithoutUserInput, userDeviceUncheckedCreateWithoutUserInput> | userDeviceCreateWithoutUserInput[] | userDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userDeviceCreateOrConnectWithoutUserInput | userDeviceCreateOrConnectWithoutUserInput[]
    upsert?: userDeviceUpsertWithWhereUniqueWithoutUserInput | userDeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userDeviceCreateManyUserInputEnvelope
    set?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    disconnect?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    delete?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    connect?: userDeviceWhereUniqueInput | userDeviceWhereUniqueInput[]
    update?: userDeviceUpdateWithWhereUniqueWithoutUserInput | userDeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userDeviceUpdateManyWithWhereWithoutUserInput | userDeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userDeviceScalarWhereInput | userDeviceScalarWhereInput[]
  }

  export type userSkillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userSkillCreateWithoutUserInput, userSkillUncheckedCreateWithoutUserInput> | userSkillCreateWithoutUserInput[] | userSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userSkillCreateOrConnectWithoutUserInput | userSkillCreateOrConnectWithoutUserInput[]
    upsert?: userSkillUpsertWithWhereUniqueWithoutUserInput | userSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userSkillCreateManyUserInputEnvelope
    set?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    disconnect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    delete?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    connect?: userSkillWhereUniqueInput | userSkillWhereUniqueInput[]
    update?: userSkillUpdateWithWhereUniqueWithoutUserInput | userSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userSkillUpdateManyWithWhereWithoutUserInput | userSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userSkillScalarWhereInput | userSkillScalarWhereInput[]
  }

  export type userStatisticsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<userStatisticsCreateWithoutUserInput, userStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: userStatisticsCreateOrConnectWithoutUserInput
    upsert?: userStatisticsUpsertWithoutUserInput
    disconnect?: userStatisticsWhereInput | boolean
    delete?: userStatisticsWhereInput | boolean
    connect?: userStatisticsWhereUniqueInput
    update?: XOR<XOR<userStatisticsUpdateToOneWithWhereWithoutUserInput, userStatisticsUpdateWithoutUserInput>, userStatisticsUncheckedUpdateWithoutUserInput>
  }

  export type videoCallUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<videoCallCreateWithoutUserInput, videoCallUncheckedCreateWithoutUserInput> | videoCallCreateWithoutUserInput[] | videoCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: videoCallCreateOrConnectWithoutUserInput | videoCallCreateOrConnectWithoutUserInput[]
    upsert?: videoCallUpsertWithWhereUniqueWithoutUserInput | videoCallUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: videoCallCreateManyUserInputEnvelope
    set?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    disconnect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    delete?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    connect?: videoCallWhereUniqueInput | videoCallWhereUniqueInput[]
    update?: videoCallUpdateWithWhereUniqueWithoutUserInput | videoCallUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: videoCallUpdateManyWithWhereWithoutUserInput | videoCallUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: videoCallScalarWhereInput | videoCallScalarWhereInput[]
  }

  export type wellnessGoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<wellnessGoalCreateWithoutUserInput, wellnessGoalUncheckedCreateWithoutUserInput> | wellnessGoalCreateWithoutUserInput[] | wellnessGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutUserInput | wellnessGoalCreateOrConnectWithoutUserInput[]
    upsert?: wellnessGoalUpsertWithWhereUniqueWithoutUserInput | wellnessGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: wellnessGoalCreateManyUserInputEnvelope
    set?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    disconnect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    delete?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    update?: wellnessGoalUpdateWithWhereUniqueWithoutUserInput | wellnessGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: wellnessGoalUpdateManyWithWhereWithoutUserInput | wellnessGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: wellnessGoalScalarWhereInput | wellnessGoalScalarWhereInput[]
  }

  export type sessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type cognitiveExerciseCreateNestedOneWithoutUserActivityInput = {
    create?: XOR<cognitiveExerciseCreateWithoutUserActivityInput, cognitiveExerciseUncheckedCreateWithoutUserActivityInput>
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutUserActivityInput
    connect?: cognitiveExerciseWhereUniqueInput
  }

  export type exerciseProgramCreateNestedOneWithoutUserActivityInput = {
    create?: XOR<exerciseProgramCreateWithoutUserActivityInput, exerciseProgramUncheckedCreateWithoutUserActivityInput>
    connectOrCreate?: exerciseProgramCreateOrConnectWithoutUserActivityInput
    connect?: exerciseProgramWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserActivityInput = {
    create?: XOR<userCreateWithoutUserActivityInput, userUncheckedCreateWithoutUserActivityInput>
    connectOrCreate?: userCreateOrConnectWithoutUserActivityInput
    connect?: userWhereUniqueInput
  }

  export type cognitiveExerciseUpdateOneWithoutUserActivityNestedInput = {
    create?: XOR<cognitiveExerciseCreateWithoutUserActivityInput, cognitiveExerciseUncheckedCreateWithoutUserActivityInput>
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutUserActivityInput
    upsert?: cognitiveExerciseUpsertWithoutUserActivityInput
    disconnect?: cognitiveExerciseWhereInput | boolean
    delete?: cognitiveExerciseWhereInput | boolean
    connect?: cognitiveExerciseWhereUniqueInput
    update?: XOR<XOR<cognitiveExerciseUpdateToOneWithWhereWithoutUserActivityInput, cognitiveExerciseUpdateWithoutUserActivityInput>, cognitiveExerciseUncheckedUpdateWithoutUserActivityInput>
  }

  export type exerciseProgramUpdateOneWithoutUserActivityNestedInput = {
    create?: XOR<exerciseProgramCreateWithoutUserActivityInput, exerciseProgramUncheckedCreateWithoutUserActivityInput>
    connectOrCreate?: exerciseProgramCreateOrConnectWithoutUserActivityInput
    upsert?: exerciseProgramUpsertWithoutUserActivityInput
    disconnect?: exerciseProgramWhereInput | boolean
    delete?: exerciseProgramWhereInput | boolean
    connect?: exerciseProgramWhereUniqueInput
    update?: XOR<XOR<exerciseProgramUpdateToOneWithWhereWithoutUserActivityInput, exerciseProgramUpdateWithoutUserActivityInput>, exerciseProgramUncheckedUpdateWithoutUserActivityInput>
  }

  export type userUpdateOneRequiredWithoutUserActivityNestedInput = {
    create?: XOR<userCreateWithoutUserActivityInput, userUncheckedCreateWithoutUserActivityInput>
    connectOrCreate?: userCreateOrConnectWithoutUserActivityInput
    upsert?: userUpsertWithoutUserActivityInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserActivityInput, userUpdateWithoutUserActivityInput>, userUncheckedUpdateWithoutUserActivityInput>
  }

  export type badgeCreateNestedOneWithoutUserBadgeInput = {
    create?: XOR<badgeCreateWithoutUserBadgeInput, badgeUncheckedCreateWithoutUserBadgeInput>
    connectOrCreate?: badgeCreateOrConnectWithoutUserBadgeInput
    connect?: badgeWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserBadgeInput = {
    create?: XOR<userCreateWithoutUserBadgeInput, userUncheckedCreateWithoutUserBadgeInput>
    connectOrCreate?: userCreateOrConnectWithoutUserBadgeInput
    connect?: userWhereUniqueInput
  }

  export type badgeUpdateOneRequiredWithoutUserBadgeNestedInput = {
    create?: XOR<badgeCreateWithoutUserBadgeInput, badgeUncheckedCreateWithoutUserBadgeInput>
    connectOrCreate?: badgeCreateOrConnectWithoutUserBadgeInput
    upsert?: badgeUpsertWithoutUserBadgeInput
    connect?: badgeWhereUniqueInput
    update?: XOR<XOR<badgeUpdateToOneWithWhereWithoutUserBadgeInput, badgeUpdateWithoutUserBadgeInput>, badgeUncheckedUpdateWithoutUserBadgeInput>
  }

  export type userUpdateOneRequiredWithoutUserBadgeNestedInput = {
    create?: XOR<userCreateWithoutUserBadgeInput, userUncheckedCreateWithoutUserBadgeInput>
    connectOrCreate?: userCreateOrConnectWithoutUserBadgeInput
    upsert?: userUpsertWithoutUserBadgeInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserBadgeInput, userUpdateWithoutUserBadgeInput>, userUncheckedUpdateWithoutUserBadgeInput>
  }

  export type userCreateNestedOneWithoutUserDeviceInput = {
    create?: XOR<userCreateWithoutUserDeviceInput, userUncheckedCreateWithoutUserDeviceInput>
    connectOrCreate?: userCreateOrConnectWithoutUserDeviceInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutUserDeviceNestedInput = {
    create?: XOR<userCreateWithoutUserDeviceInput, userUncheckedCreateWithoutUserDeviceInput>
    connectOrCreate?: userCreateOrConnectWithoutUserDeviceInput
    upsert?: userUpsertWithoutUserDeviceInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserDeviceInput, userUpdateWithoutUserDeviceInput>, userUncheckedUpdateWithoutUserDeviceInput>
  }

  export type skillCreateNestedOneWithoutUserSkillInput = {
    create?: XOR<skillCreateWithoutUserSkillInput, skillUncheckedCreateWithoutUserSkillInput>
    connectOrCreate?: skillCreateOrConnectWithoutUserSkillInput
    connect?: skillWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserSkillInput = {
    create?: XOR<userCreateWithoutUserSkillInput, userUncheckedCreateWithoutUserSkillInput>
    connectOrCreate?: userCreateOrConnectWithoutUserSkillInput
    connect?: userWhereUniqueInput
  }

  export type skillUpdateOneRequiredWithoutUserSkillNestedInput = {
    create?: XOR<skillCreateWithoutUserSkillInput, skillUncheckedCreateWithoutUserSkillInput>
    connectOrCreate?: skillCreateOrConnectWithoutUserSkillInput
    upsert?: skillUpsertWithoutUserSkillInput
    connect?: skillWhereUniqueInput
    update?: XOR<XOR<skillUpdateToOneWithWhereWithoutUserSkillInput, skillUpdateWithoutUserSkillInput>, skillUncheckedUpdateWithoutUserSkillInput>
  }

  export type userUpdateOneRequiredWithoutUserSkillNestedInput = {
    create?: XOR<userCreateWithoutUserSkillInput, userUncheckedCreateWithoutUserSkillInput>
    connectOrCreate?: userCreateOrConnectWithoutUserSkillInput
    upsert?: userUpsertWithoutUserSkillInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserSkillInput, userUpdateWithoutUserSkillInput>, userUncheckedUpdateWithoutUserSkillInput>
  }

  export type userCreateNestedOneWithoutUserStatisticsInput = {
    create?: XOR<userCreateWithoutUserStatisticsInput, userUncheckedCreateWithoutUserStatisticsInput>
    connectOrCreate?: userCreateOrConnectWithoutUserStatisticsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserStatisticsNestedInput = {
    create?: XOR<userCreateWithoutUserStatisticsInput, userUncheckedCreateWithoutUserStatisticsInput>
    connectOrCreate?: userCreateOrConnectWithoutUserStatisticsInput
    upsert?: userUpsertWithoutUserStatisticsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserStatisticsInput, userUpdateWithoutUserStatisticsInput>, userUncheckedUpdateWithoutUserStatisticsInput>
  }

  export type conversationCreateNestedOneWithoutVideoCallInput = {
    create?: XOR<conversationCreateWithoutVideoCallInput, conversationUncheckedCreateWithoutVideoCallInput>
    connectOrCreate?: conversationCreateOrConnectWithoutVideoCallInput
    connect?: conversationWhereUniqueInput
  }

  export type userCreateNestedOneWithoutVideoCallInput = {
    create?: XOR<userCreateWithoutVideoCallInput, userUncheckedCreateWithoutVideoCallInput>
    connectOrCreate?: userCreateOrConnectWithoutVideoCallInput
    connect?: userWhereUniqueInput
  }

  export type conversationUpdateOneWithoutVideoCallNestedInput = {
    create?: XOR<conversationCreateWithoutVideoCallInput, conversationUncheckedCreateWithoutVideoCallInput>
    connectOrCreate?: conversationCreateOrConnectWithoutVideoCallInput
    upsert?: conversationUpsertWithoutVideoCallInput
    disconnect?: conversationWhereInput | boolean
    delete?: conversationWhereInput | boolean
    connect?: conversationWhereUniqueInput
    update?: XOR<XOR<conversationUpdateToOneWithWhereWithoutVideoCallInput, conversationUpdateWithoutVideoCallInput>, conversationUncheckedUpdateWithoutVideoCallInput>
  }

  export type userUpdateOneWithoutVideoCallNestedInput = {
    create?: XOR<userCreateWithoutVideoCallInput, userUncheckedCreateWithoutVideoCallInput>
    connectOrCreate?: userCreateOrConnectWithoutVideoCallInput
    upsert?: userUpsertWithoutVideoCallInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutVideoCallInput, userUpdateWithoutVideoCallInput>, userUncheckedUpdateWithoutVideoCallInput>
  }

  export type wellnessCategoryCreateNestedOneWithoutWellnessBadgeInput = {
    create?: XOR<wellnessCategoryCreateWithoutWellnessBadgeInput, wellnessCategoryUncheckedCreateWithoutWellnessBadgeInput>
    connectOrCreate?: wellnessCategoryCreateOrConnectWithoutWellnessBadgeInput
    connect?: wellnessCategoryWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type wellnessCategoryUpdateOneWithoutWellnessBadgeNestedInput = {
    create?: XOR<wellnessCategoryCreateWithoutWellnessBadgeInput, wellnessCategoryUncheckedCreateWithoutWellnessBadgeInput>
    connectOrCreate?: wellnessCategoryCreateOrConnectWithoutWellnessBadgeInput
    upsert?: wellnessCategoryUpsertWithoutWellnessBadgeInput
    disconnect?: wellnessCategoryWhereInput | boolean
    delete?: wellnessCategoryWhereInput | boolean
    connect?: wellnessCategoryWhereUniqueInput
    update?: XOR<XOR<wellnessCategoryUpdateToOneWithWhereWithoutWellnessBadgeInput, wellnessCategoryUpdateWithoutWellnessBadgeInput>, wellnessCategoryUncheckedUpdateWithoutWellnessBadgeInput>
  }

  export type wellnessGoalProgressCreateNestedManyWithoutWellnessGoalInput = {
    create?: XOR<wellnessGoalProgressCreateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput> | wellnessGoalProgressCreateWithoutWellnessGoalInput[] | wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput[]
    connectOrCreate?: wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput | wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput[]
    createMany?: wellnessGoalProgressCreateManyWellnessGoalInputEnvelope
    connect?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutWellnessGoalInput = {
    create?: XOR<userCreateWithoutWellnessGoalInput, userUncheckedCreateWithoutWellnessGoalInput>
    connectOrCreate?: userCreateOrConnectWithoutWellnessGoalInput
    connect?: userWhereUniqueInput
  }

  export type wellnessCategoryCreateNestedOneWithoutWellnessGoalInput = {
    create?: XOR<wellnessCategoryCreateWithoutWellnessGoalInput, wellnessCategoryUncheckedCreateWithoutWellnessGoalInput>
    connectOrCreate?: wellnessCategoryCreateOrConnectWithoutWellnessGoalInput
    connect?: wellnessCategoryWhereUniqueInput
  }

  export type wellnessGoalProgressUncheckedCreateNestedManyWithoutWellnessGoalInput = {
    create?: XOR<wellnessGoalProgressCreateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput> | wellnessGoalProgressCreateWithoutWellnessGoalInput[] | wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput[]
    connectOrCreate?: wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput | wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput[]
    createMany?: wellnessGoalProgressCreateManyWellnessGoalInputEnvelope
    connect?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
  }

  export type wellnessGoalProgressUpdateManyWithoutWellnessGoalNestedInput = {
    create?: XOR<wellnessGoalProgressCreateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput> | wellnessGoalProgressCreateWithoutWellnessGoalInput[] | wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput[]
    connectOrCreate?: wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput | wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput[]
    upsert?: wellnessGoalProgressUpsertWithWhereUniqueWithoutWellnessGoalInput | wellnessGoalProgressUpsertWithWhereUniqueWithoutWellnessGoalInput[]
    createMany?: wellnessGoalProgressCreateManyWellnessGoalInputEnvelope
    set?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    disconnect?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    delete?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    connect?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    update?: wellnessGoalProgressUpdateWithWhereUniqueWithoutWellnessGoalInput | wellnessGoalProgressUpdateWithWhereUniqueWithoutWellnessGoalInput[]
    updateMany?: wellnessGoalProgressUpdateManyWithWhereWithoutWellnessGoalInput | wellnessGoalProgressUpdateManyWithWhereWithoutWellnessGoalInput[]
    deleteMany?: wellnessGoalProgressScalarWhereInput | wellnessGoalProgressScalarWhereInput[]
  }

  export type userUpdateOneWithoutWellnessGoalNestedInput = {
    create?: XOR<userCreateWithoutWellnessGoalInput, userUncheckedCreateWithoutWellnessGoalInput>
    connectOrCreate?: userCreateOrConnectWithoutWellnessGoalInput
    upsert?: userUpsertWithoutWellnessGoalInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutWellnessGoalInput, userUpdateWithoutWellnessGoalInput>, userUncheckedUpdateWithoutWellnessGoalInput>
  }

  export type wellnessCategoryUpdateOneWithoutWellnessGoalNestedInput = {
    create?: XOR<wellnessCategoryCreateWithoutWellnessGoalInput, wellnessCategoryUncheckedCreateWithoutWellnessGoalInput>
    connectOrCreate?: wellnessCategoryCreateOrConnectWithoutWellnessGoalInput
    upsert?: wellnessCategoryUpsertWithoutWellnessGoalInput
    disconnect?: wellnessCategoryWhereInput | boolean
    delete?: wellnessCategoryWhereInput | boolean
    connect?: wellnessCategoryWhereUniqueInput
    update?: XOR<XOR<wellnessCategoryUpdateToOneWithWhereWithoutWellnessGoalInput, wellnessCategoryUpdateWithoutWellnessGoalInput>, wellnessCategoryUncheckedUpdateWithoutWellnessGoalInput>
  }

  export type wellnessGoalProgressUncheckedUpdateManyWithoutWellnessGoalNestedInput = {
    create?: XOR<wellnessGoalProgressCreateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput> | wellnessGoalProgressCreateWithoutWellnessGoalInput[] | wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput[]
    connectOrCreate?: wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput | wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput[]
    upsert?: wellnessGoalProgressUpsertWithWhereUniqueWithoutWellnessGoalInput | wellnessGoalProgressUpsertWithWhereUniqueWithoutWellnessGoalInput[]
    createMany?: wellnessGoalProgressCreateManyWellnessGoalInputEnvelope
    set?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    disconnect?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    delete?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    connect?: wellnessGoalProgressWhereUniqueInput | wellnessGoalProgressWhereUniqueInput[]
    update?: wellnessGoalProgressUpdateWithWhereUniqueWithoutWellnessGoalInput | wellnessGoalProgressUpdateWithWhereUniqueWithoutWellnessGoalInput[]
    updateMany?: wellnessGoalProgressUpdateManyWithWhereWithoutWellnessGoalInput | wellnessGoalProgressUpdateManyWithWhereWithoutWellnessGoalInput[]
    deleteMany?: wellnessGoalProgressScalarWhereInput | wellnessGoalProgressScalarWhereInput[]
  }

  export type wellnessGoalCreateNestedOneWithoutWellnessGoalProgressInput = {
    create?: XOR<wellnessGoalCreateWithoutWellnessGoalProgressInput, wellnessGoalUncheckedCreateWithoutWellnessGoalProgressInput>
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutWellnessGoalProgressInput
    connect?: wellnessGoalWhereUniqueInput
  }

  export type wellnessGoalUpdateOneRequiredWithoutWellnessGoalProgressNestedInput = {
    create?: XOR<wellnessGoalCreateWithoutWellnessGoalProgressInput, wellnessGoalUncheckedCreateWithoutWellnessGoalProgressInput>
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutWellnessGoalProgressInput
    upsert?: wellnessGoalUpsertWithoutWellnessGoalProgressInput
    connect?: wellnessGoalWhereUniqueInput
    update?: XOR<XOR<wellnessGoalUpdateToOneWithWhereWithoutWellnessGoalProgressInput, wellnessGoalUpdateWithoutWellnessGoalProgressInput>, wellnessGoalUncheckedUpdateWithoutWellnessGoalProgressInput>
  }

  export type activityCreateNestedManyWithoutActivityCategoryInput = {
    create?: XOR<activityCreateWithoutActivityCategoryInput, activityUncheckedCreateWithoutActivityCategoryInput> | activityCreateWithoutActivityCategoryInput[] | activityUncheckedCreateWithoutActivityCategoryInput[]
    connectOrCreate?: activityCreateOrConnectWithoutActivityCategoryInput | activityCreateOrConnectWithoutActivityCategoryInput[]
    createMany?: activityCreateManyActivityCategoryInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type activityUncheckedCreateNestedManyWithoutActivityCategoryInput = {
    create?: XOR<activityCreateWithoutActivityCategoryInput, activityUncheckedCreateWithoutActivityCategoryInput> | activityCreateWithoutActivityCategoryInput[] | activityUncheckedCreateWithoutActivityCategoryInput[]
    connectOrCreate?: activityCreateOrConnectWithoutActivityCategoryInput | activityCreateOrConnectWithoutActivityCategoryInput[]
    createMany?: activityCreateManyActivityCategoryInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type activityUpdateManyWithoutActivityCategoryNestedInput = {
    create?: XOR<activityCreateWithoutActivityCategoryInput, activityUncheckedCreateWithoutActivityCategoryInput> | activityCreateWithoutActivityCategoryInput[] | activityUncheckedCreateWithoutActivityCategoryInput[]
    connectOrCreate?: activityCreateOrConnectWithoutActivityCategoryInput | activityCreateOrConnectWithoutActivityCategoryInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutActivityCategoryInput | activityUpsertWithWhereUniqueWithoutActivityCategoryInput[]
    createMany?: activityCreateManyActivityCategoryInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutActivityCategoryInput | activityUpdateWithWhereUniqueWithoutActivityCategoryInput[]
    updateMany?: activityUpdateManyWithWhereWithoutActivityCategoryInput | activityUpdateManyWithWhereWithoutActivityCategoryInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type activityUncheckedUpdateManyWithoutActivityCategoryNestedInput = {
    create?: XOR<activityCreateWithoutActivityCategoryInput, activityUncheckedCreateWithoutActivityCategoryInput> | activityCreateWithoutActivityCategoryInput[] | activityUncheckedCreateWithoutActivityCategoryInput[]
    connectOrCreate?: activityCreateOrConnectWithoutActivityCategoryInput | activityCreateOrConnectWithoutActivityCategoryInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutActivityCategoryInput | activityUpsertWithWhereUniqueWithoutActivityCategoryInput[]
    createMany?: activityCreateManyActivityCategoryInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutActivityCategoryInput | activityUpdateWithWhereUniqueWithoutActivityCategoryInput[]
    updateMany?: activityUpdateManyWithWhereWithoutActivityCategoryInput | activityUpdateManyWithWhereWithoutActivityCategoryInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type badgeCreateNestedManyWithoutBadgeCategoryInput = {
    create?: XOR<badgeCreateWithoutBadgeCategoryInput, badgeUncheckedCreateWithoutBadgeCategoryInput> | badgeCreateWithoutBadgeCategoryInput[] | badgeUncheckedCreateWithoutBadgeCategoryInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutBadgeCategoryInput | badgeCreateOrConnectWithoutBadgeCategoryInput[]
    createMany?: badgeCreateManyBadgeCategoryInputEnvelope
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
  }

  export type badgeUncheckedCreateNestedManyWithoutBadgeCategoryInput = {
    create?: XOR<badgeCreateWithoutBadgeCategoryInput, badgeUncheckedCreateWithoutBadgeCategoryInput> | badgeCreateWithoutBadgeCategoryInput[] | badgeUncheckedCreateWithoutBadgeCategoryInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutBadgeCategoryInput | badgeCreateOrConnectWithoutBadgeCategoryInput[]
    createMany?: badgeCreateManyBadgeCategoryInputEnvelope
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
  }

  export type badgeUpdateManyWithoutBadgeCategoryNestedInput = {
    create?: XOR<badgeCreateWithoutBadgeCategoryInput, badgeUncheckedCreateWithoutBadgeCategoryInput> | badgeCreateWithoutBadgeCategoryInput[] | badgeUncheckedCreateWithoutBadgeCategoryInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutBadgeCategoryInput | badgeCreateOrConnectWithoutBadgeCategoryInput[]
    upsert?: badgeUpsertWithWhereUniqueWithoutBadgeCategoryInput | badgeUpsertWithWhereUniqueWithoutBadgeCategoryInput[]
    createMany?: badgeCreateManyBadgeCategoryInputEnvelope
    set?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    disconnect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    delete?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    update?: badgeUpdateWithWhereUniqueWithoutBadgeCategoryInput | badgeUpdateWithWhereUniqueWithoutBadgeCategoryInput[]
    updateMany?: badgeUpdateManyWithWhereWithoutBadgeCategoryInput | badgeUpdateManyWithWhereWithoutBadgeCategoryInput[]
    deleteMany?: badgeScalarWhereInput | badgeScalarWhereInput[]
  }

  export type badgeUncheckedUpdateManyWithoutBadgeCategoryNestedInput = {
    create?: XOR<badgeCreateWithoutBadgeCategoryInput, badgeUncheckedCreateWithoutBadgeCategoryInput> | badgeCreateWithoutBadgeCategoryInput[] | badgeUncheckedCreateWithoutBadgeCategoryInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutBadgeCategoryInput | badgeCreateOrConnectWithoutBadgeCategoryInput[]
    upsert?: badgeUpsertWithWhereUniqueWithoutBadgeCategoryInput | badgeUpsertWithWhereUniqueWithoutBadgeCategoryInput[]
    createMany?: badgeCreateManyBadgeCategoryInputEnvelope
    set?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    disconnect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    delete?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    update?: badgeUpdateWithWhereUniqueWithoutBadgeCategoryInput | badgeUpdateWithWhereUniqueWithoutBadgeCategoryInput[]
    updateMany?: badgeUpdateManyWithWhereWithoutBadgeCategoryInput | badgeUpdateManyWithWhereWithoutBadgeCategoryInput[]
    deleteMany?: badgeScalarWhereInput | badgeScalarWhereInput[]
  }

  export type cognitiveExerciseCreateNestedManyWithoutCognitiveCategoryInput = {
    create?: XOR<cognitiveExerciseCreateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput> | cognitiveExerciseCreateWithoutCognitiveCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput | cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput[]
    createMany?: cognitiveExerciseCreateManyCognitiveCategoryInputEnvelope
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
  }

  export type cognitiveExerciseUncheckedCreateNestedManyWithoutCognitiveCategoryInput = {
    create?: XOR<cognitiveExerciseCreateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput> | cognitiveExerciseCreateWithoutCognitiveCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput | cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput[]
    createMany?: cognitiveExerciseCreateManyCognitiveCategoryInputEnvelope
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
  }

  export type cognitiveExerciseUpdateManyWithoutCognitiveCategoryNestedInput = {
    create?: XOR<cognitiveExerciseCreateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput> | cognitiveExerciseCreateWithoutCognitiveCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput | cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput[]
    upsert?: cognitiveExerciseUpsertWithWhereUniqueWithoutCognitiveCategoryInput | cognitiveExerciseUpsertWithWhereUniqueWithoutCognitiveCategoryInput[]
    createMany?: cognitiveExerciseCreateManyCognitiveCategoryInputEnvelope
    set?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    disconnect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    delete?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    update?: cognitiveExerciseUpdateWithWhereUniqueWithoutCognitiveCategoryInput | cognitiveExerciseUpdateWithWhereUniqueWithoutCognitiveCategoryInput[]
    updateMany?: cognitiveExerciseUpdateManyWithWhereWithoutCognitiveCategoryInput | cognitiveExerciseUpdateManyWithWhereWithoutCognitiveCategoryInput[]
    deleteMany?: cognitiveExerciseScalarWhereInput | cognitiveExerciseScalarWhereInput[]
  }

  export type cognitiveExerciseUncheckedUpdateManyWithoutCognitiveCategoryNestedInput = {
    create?: XOR<cognitiveExerciseCreateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput> | cognitiveExerciseCreateWithoutCognitiveCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput | cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput[]
    upsert?: cognitiveExerciseUpsertWithWhereUniqueWithoutCognitiveCategoryInput | cognitiveExerciseUpsertWithWhereUniqueWithoutCognitiveCategoryInput[]
    createMany?: cognitiveExerciseCreateManyCognitiveCategoryInputEnvelope
    set?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    disconnect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    delete?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    update?: cognitiveExerciseUpdateWithWhereUniqueWithoutCognitiveCategoryInput | cognitiveExerciseUpdateWithWhereUniqueWithoutCognitiveCategoryInput[]
    updateMany?: cognitiveExerciseUpdateManyWithWhereWithoutCognitiveCategoryInput | cognitiveExerciseUpdateManyWithWhereWithoutCognitiveCategoryInput[]
    deleteMany?: cognitiveExerciseScalarWhereInput | cognitiveExerciseScalarWhereInput[]
  }

  export type helpRequestCreateNestedManyWithoutHelpCategoryInput = {
    create?: XOR<helpRequestCreateWithoutHelpCategoryInput, helpRequestUncheckedCreateWithoutHelpCategoryInput> | helpRequestCreateWithoutHelpCategoryInput[] | helpRequestUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutHelpCategoryInput | helpRequestCreateOrConnectWithoutHelpCategoryInput[]
    createMany?: helpRequestCreateManyHelpCategoryInputEnvelope
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
  }

  export type helpRequestUncheckedCreateNestedManyWithoutHelpCategoryInput = {
    create?: XOR<helpRequestCreateWithoutHelpCategoryInput, helpRequestUncheckedCreateWithoutHelpCategoryInput> | helpRequestCreateWithoutHelpCategoryInput[] | helpRequestUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutHelpCategoryInput | helpRequestCreateOrConnectWithoutHelpCategoryInput[]
    createMany?: helpRequestCreateManyHelpCategoryInputEnvelope
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
  }

  export type helpRequestUpdateManyWithoutHelpCategoryNestedInput = {
    create?: XOR<helpRequestCreateWithoutHelpCategoryInput, helpRequestUncheckedCreateWithoutHelpCategoryInput> | helpRequestCreateWithoutHelpCategoryInput[] | helpRequestUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutHelpCategoryInput | helpRequestCreateOrConnectWithoutHelpCategoryInput[]
    upsert?: helpRequestUpsertWithWhereUniqueWithoutHelpCategoryInput | helpRequestUpsertWithWhereUniqueWithoutHelpCategoryInput[]
    createMany?: helpRequestCreateManyHelpCategoryInputEnvelope
    set?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    disconnect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    delete?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    update?: helpRequestUpdateWithWhereUniqueWithoutHelpCategoryInput | helpRequestUpdateWithWhereUniqueWithoutHelpCategoryInput[]
    updateMany?: helpRequestUpdateManyWithWhereWithoutHelpCategoryInput | helpRequestUpdateManyWithWhereWithoutHelpCategoryInput[]
    deleteMany?: helpRequestScalarWhereInput | helpRequestScalarWhereInput[]
  }

  export type helpRequestUncheckedUpdateManyWithoutHelpCategoryNestedInput = {
    create?: XOR<helpRequestCreateWithoutHelpCategoryInput, helpRequestUncheckedCreateWithoutHelpCategoryInput> | helpRequestCreateWithoutHelpCategoryInput[] | helpRequestUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: helpRequestCreateOrConnectWithoutHelpCategoryInput | helpRequestCreateOrConnectWithoutHelpCategoryInput[]
    upsert?: helpRequestUpsertWithWhereUniqueWithoutHelpCategoryInput | helpRequestUpsertWithWhereUniqueWithoutHelpCategoryInput[]
    createMany?: helpRequestCreateManyHelpCategoryInputEnvelope
    set?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    disconnect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    delete?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    connect?: helpRequestWhereUniqueInput | helpRequestWhereUniqueInput[]
    update?: helpRequestUpdateWithWhereUniqueWithoutHelpCategoryInput | helpRequestUpdateWithWhereUniqueWithoutHelpCategoryInput[]
    updateMany?: helpRequestUpdateManyWithWhereWithoutHelpCategoryInput | helpRequestUpdateManyWithWhereWithoutHelpCategoryInput[]
    deleteMany?: helpRequestScalarWhereInput | helpRequestScalarWhereInput[]
  }

  export type urbanIssueReportCreateNestedManyWithoutIssueCategoryInput = {
    create?: XOR<urbanIssueReportCreateWithoutIssueCategoryInput, urbanIssueReportUncheckedCreateWithoutIssueCategoryInput> | urbanIssueReportCreateWithoutIssueCategoryInput[] | urbanIssueReportUncheckedCreateWithoutIssueCategoryInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutIssueCategoryInput | urbanIssueReportCreateOrConnectWithoutIssueCategoryInput[]
    createMany?: urbanIssueReportCreateManyIssueCategoryInputEnvelope
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
  }

  export type urbanIssueReportUncheckedCreateNestedManyWithoutIssueCategoryInput = {
    create?: XOR<urbanIssueReportCreateWithoutIssueCategoryInput, urbanIssueReportUncheckedCreateWithoutIssueCategoryInput> | urbanIssueReportCreateWithoutIssueCategoryInput[] | urbanIssueReportUncheckedCreateWithoutIssueCategoryInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutIssueCategoryInput | urbanIssueReportCreateOrConnectWithoutIssueCategoryInput[]
    createMany?: urbanIssueReportCreateManyIssueCategoryInputEnvelope
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
  }

  export type urbanIssueReportUpdateManyWithoutIssueCategoryNestedInput = {
    create?: XOR<urbanIssueReportCreateWithoutIssueCategoryInput, urbanIssueReportUncheckedCreateWithoutIssueCategoryInput> | urbanIssueReportCreateWithoutIssueCategoryInput[] | urbanIssueReportUncheckedCreateWithoutIssueCategoryInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutIssueCategoryInput | urbanIssueReportCreateOrConnectWithoutIssueCategoryInput[]
    upsert?: urbanIssueReportUpsertWithWhereUniqueWithoutIssueCategoryInput | urbanIssueReportUpsertWithWhereUniqueWithoutIssueCategoryInput[]
    createMany?: urbanIssueReportCreateManyIssueCategoryInputEnvelope
    set?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    disconnect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    delete?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    update?: urbanIssueReportUpdateWithWhereUniqueWithoutIssueCategoryInput | urbanIssueReportUpdateWithWhereUniqueWithoutIssueCategoryInput[]
    updateMany?: urbanIssueReportUpdateManyWithWhereWithoutIssueCategoryInput | urbanIssueReportUpdateManyWithWhereWithoutIssueCategoryInput[]
    deleteMany?: urbanIssueReportScalarWhereInput | urbanIssueReportScalarWhereInput[]
  }

  export type urbanIssueReportUncheckedUpdateManyWithoutIssueCategoryNestedInput = {
    create?: XOR<urbanIssueReportCreateWithoutIssueCategoryInput, urbanIssueReportUncheckedCreateWithoutIssueCategoryInput> | urbanIssueReportCreateWithoutIssueCategoryInput[] | urbanIssueReportUncheckedCreateWithoutIssueCategoryInput[]
    connectOrCreate?: urbanIssueReportCreateOrConnectWithoutIssueCategoryInput | urbanIssueReportCreateOrConnectWithoutIssueCategoryInput[]
    upsert?: urbanIssueReportUpsertWithWhereUniqueWithoutIssueCategoryInput | urbanIssueReportUpsertWithWhereUniqueWithoutIssueCategoryInput[]
    createMany?: urbanIssueReportCreateManyIssueCategoryInputEnvelope
    set?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    disconnect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    delete?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    connect?: urbanIssueReportWhereUniqueInput | urbanIssueReportWhereUniqueInput[]
    update?: urbanIssueReportUpdateWithWhereUniqueWithoutIssueCategoryInput | urbanIssueReportUpdateWithWhereUniqueWithoutIssueCategoryInput[]
    updateMany?: urbanIssueReportUpdateManyWithWhereWithoutIssueCategoryInput | urbanIssueReportUpdateManyWithWhereWithoutIssueCategoryInput[]
    deleteMany?: urbanIssueReportScalarWhereInput | urbanIssueReportScalarWhereInput[]
  }

  export type nutritionalAdviceCreateNestedManyWithoutNutritionalCategoryInput = {
    create?: XOR<nutritionalAdviceCreateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput> | nutritionalAdviceCreateWithoutNutritionalCategoryInput[] | nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput[]
    connectOrCreate?: nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput | nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput[]
    createMany?: nutritionalAdviceCreateManyNutritionalCategoryInputEnvelope
    connect?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
  }

  export type nutritionalAdviceUncheckedCreateNestedManyWithoutNutritionalCategoryInput = {
    create?: XOR<nutritionalAdviceCreateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput> | nutritionalAdviceCreateWithoutNutritionalCategoryInput[] | nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput[]
    connectOrCreate?: nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput | nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput[]
    createMany?: nutritionalAdviceCreateManyNutritionalCategoryInputEnvelope
    connect?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
  }

  export type nutritionalAdviceUpdateManyWithoutNutritionalCategoryNestedInput = {
    create?: XOR<nutritionalAdviceCreateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput> | nutritionalAdviceCreateWithoutNutritionalCategoryInput[] | nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput[]
    connectOrCreate?: nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput | nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput[]
    upsert?: nutritionalAdviceUpsertWithWhereUniqueWithoutNutritionalCategoryInput | nutritionalAdviceUpsertWithWhereUniqueWithoutNutritionalCategoryInput[]
    createMany?: nutritionalAdviceCreateManyNutritionalCategoryInputEnvelope
    set?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    disconnect?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    delete?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    connect?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    update?: nutritionalAdviceUpdateWithWhereUniqueWithoutNutritionalCategoryInput | nutritionalAdviceUpdateWithWhereUniqueWithoutNutritionalCategoryInput[]
    updateMany?: nutritionalAdviceUpdateManyWithWhereWithoutNutritionalCategoryInput | nutritionalAdviceUpdateManyWithWhereWithoutNutritionalCategoryInput[]
    deleteMany?: nutritionalAdviceScalarWhereInput | nutritionalAdviceScalarWhereInput[]
  }

  export type nutritionalAdviceUncheckedUpdateManyWithoutNutritionalCategoryNestedInput = {
    create?: XOR<nutritionalAdviceCreateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput> | nutritionalAdviceCreateWithoutNutritionalCategoryInput[] | nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput[]
    connectOrCreate?: nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput | nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput[]
    upsert?: nutritionalAdviceUpsertWithWhereUniqueWithoutNutritionalCategoryInput | nutritionalAdviceUpsertWithWhereUniqueWithoutNutritionalCategoryInput[]
    createMany?: nutritionalAdviceCreateManyNutritionalCategoryInputEnvelope
    set?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    disconnect?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    delete?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    connect?: nutritionalAdviceWhereUniqueInput | nutritionalAdviceWhereUniqueInput[]
    update?: nutritionalAdviceUpdateWithWhereUniqueWithoutNutritionalCategoryInput | nutritionalAdviceUpdateWithWhereUniqueWithoutNutritionalCategoryInput[]
    updateMany?: nutritionalAdviceUpdateManyWithWhereWithoutNutritionalCategoryInput | nutritionalAdviceUpdateManyWithWhereWithoutNutritionalCategoryInput[]
    deleteMany?: nutritionalAdviceScalarWhereInput | nutritionalAdviceScalarWhereInput[]
  }

  export type cognitiveExerciseCreateNestedManyWithoutProgramCategoryInput = {
    create?: XOR<cognitiveExerciseCreateWithoutProgramCategoryInput, cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput> | cognitiveExerciseCreateWithoutProgramCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput | cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput[]
    createMany?: cognitiveExerciseCreateManyProgramCategoryInputEnvelope
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
  }

  export type exerciseProgramCreateNestedManyWithoutProgramCategoryInput = {
    create?: XOR<exerciseProgramCreateWithoutProgramCategoryInput, exerciseProgramUncheckedCreateWithoutProgramCategoryInput> | exerciseProgramCreateWithoutProgramCategoryInput[] | exerciseProgramUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: exerciseProgramCreateOrConnectWithoutProgramCategoryInput | exerciseProgramCreateOrConnectWithoutProgramCategoryInput[]
    createMany?: exerciseProgramCreateManyProgramCategoryInputEnvelope
    connect?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
  }

  export type cognitiveExerciseUncheckedCreateNestedManyWithoutProgramCategoryInput = {
    create?: XOR<cognitiveExerciseCreateWithoutProgramCategoryInput, cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput> | cognitiveExerciseCreateWithoutProgramCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput | cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput[]
    createMany?: cognitiveExerciseCreateManyProgramCategoryInputEnvelope
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
  }

  export type exerciseProgramUncheckedCreateNestedManyWithoutProgramCategoryInput = {
    create?: XOR<exerciseProgramCreateWithoutProgramCategoryInput, exerciseProgramUncheckedCreateWithoutProgramCategoryInput> | exerciseProgramCreateWithoutProgramCategoryInput[] | exerciseProgramUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: exerciseProgramCreateOrConnectWithoutProgramCategoryInput | exerciseProgramCreateOrConnectWithoutProgramCategoryInput[]
    createMany?: exerciseProgramCreateManyProgramCategoryInputEnvelope
    connect?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
  }

  export type cognitiveExerciseUpdateManyWithoutProgramCategoryNestedInput = {
    create?: XOR<cognitiveExerciseCreateWithoutProgramCategoryInput, cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput> | cognitiveExerciseCreateWithoutProgramCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput | cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput[]
    upsert?: cognitiveExerciseUpsertWithWhereUniqueWithoutProgramCategoryInput | cognitiveExerciseUpsertWithWhereUniqueWithoutProgramCategoryInput[]
    createMany?: cognitiveExerciseCreateManyProgramCategoryInputEnvelope
    set?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    disconnect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    delete?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    update?: cognitiveExerciseUpdateWithWhereUniqueWithoutProgramCategoryInput | cognitiveExerciseUpdateWithWhereUniqueWithoutProgramCategoryInput[]
    updateMany?: cognitiveExerciseUpdateManyWithWhereWithoutProgramCategoryInput | cognitiveExerciseUpdateManyWithWhereWithoutProgramCategoryInput[]
    deleteMany?: cognitiveExerciseScalarWhereInput | cognitiveExerciseScalarWhereInput[]
  }

  export type exerciseProgramUpdateManyWithoutProgramCategoryNestedInput = {
    create?: XOR<exerciseProgramCreateWithoutProgramCategoryInput, exerciseProgramUncheckedCreateWithoutProgramCategoryInput> | exerciseProgramCreateWithoutProgramCategoryInput[] | exerciseProgramUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: exerciseProgramCreateOrConnectWithoutProgramCategoryInput | exerciseProgramCreateOrConnectWithoutProgramCategoryInput[]
    upsert?: exerciseProgramUpsertWithWhereUniqueWithoutProgramCategoryInput | exerciseProgramUpsertWithWhereUniqueWithoutProgramCategoryInput[]
    createMany?: exerciseProgramCreateManyProgramCategoryInputEnvelope
    set?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    disconnect?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    delete?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    connect?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    update?: exerciseProgramUpdateWithWhereUniqueWithoutProgramCategoryInput | exerciseProgramUpdateWithWhereUniqueWithoutProgramCategoryInput[]
    updateMany?: exerciseProgramUpdateManyWithWhereWithoutProgramCategoryInput | exerciseProgramUpdateManyWithWhereWithoutProgramCategoryInput[]
    deleteMany?: exerciseProgramScalarWhereInput | exerciseProgramScalarWhereInput[]
  }

  export type cognitiveExerciseUncheckedUpdateManyWithoutProgramCategoryNestedInput = {
    create?: XOR<cognitiveExerciseCreateWithoutProgramCategoryInput, cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput> | cognitiveExerciseCreateWithoutProgramCategoryInput[] | cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput | cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput[]
    upsert?: cognitiveExerciseUpsertWithWhereUniqueWithoutProgramCategoryInput | cognitiveExerciseUpsertWithWhereUniqueWithoutProgramCategoryInput[]
    createMany?: cognitiveExerciseCreateManyProgramCategoryInputEnvelope
    set?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    disconnect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    delete?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    connect?: cognitiveExerciseWhereUniqueInput | cognitiveExerciseWhereUniqueInput[]
    update?: cognitiveExerciseUpdateWithWhereUniqueWithoutProgramCategoryInput | cognitiveExerciseUpdateWithWhereUniqueWithoutProgramCategoryInput[]
    updateMany?: cognitiveExerciseUpdateManyWithWhereWithoutProgramCategoryInput | cognitiveExerciseUpdateManyWithWhereWithoutProgramCategoryInput[]
    deleteMany?: cognitiveExerciseScalarWhereInput | cognitiveExerciseScalarWhereInput[]
  }

  export type exerciseProgramUncheckedUpdateManyWithoutProgramCategoryNestedInput = {
    create?: XOR<exerciseProgramCreateWithoutProgramCategoryInput, exerciseProgramUncheckedCreateWithoutProgramCategoryInput> | exerciseProgramCreateWithoutProgramCategoryInput[] | exerciseProgramUncheckedCreateWithoutProgramCategoryInput[]
    connectOrCreate?: exerciseProgramCreateOrConnectWithoutProgramCategoryInput | exerciseProgramCreateOrConnectWithoutProgramCategoryInput[]
    upsert?: exerciseProgramUpsertWithWhereUniqueWithoutProgramCategoryInput | exerciseProgramUpsertWithWhereUniqueWithoutProgramCategoryInput[]
    createMany?: exerciseProgramCreateManyProgramCategoryInputEnvelope
    set?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    disconnect?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    delete?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    connect?: exerciseProgramWhereUniqueInput | exerciseProgramWhereUniqueInput[]
    update?: exerciseProgramUpdateWithWhereUniqueWithoutProgramCategoryInput | exerciseProgramUpdateWithWhereUniqueWithoutProgramCategoryInput[]
    updateMany?: exerciseProgramUpdateManyWithWhereWithoutProgramCategoryInput | exerciseProgramUpdateManyWithWhereWithoutProgramCategoryInput[]
    deleteMany?: exerciseProgramScalarWhereInput | exerciseProgramScalarWhereInput[]
  }

  export type collaborativeProjectCreateNestedManyWithoutProjectCategoryInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectCategoryInput, collaborativeProjectUncheckedCreateWithoutProjectCategoryInput> | collaborativeProjectCreateWithoutProjectCategoryInput[] | collaborativeProjectUncheckedCreateWithoutProjectCategoryInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectCategoryInput | collaborativeProjectCreateOrConnectWithoutProjectCategoryInput[]
    createMany?: collaborativeProjectCreateManyProjectCategoryInputEnvelope
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
  }

  export type collaborativeProjectUncheckedCreateNestedManyWithoutProjectCategoryInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectCategoryInput, collaborativeProjectUncheckedCreateWithoutProjectCategoryInput> | collaborativeProjectCreateWithoutProjectCategoryInput[] | collaborativeProjectUncheckedCreateWithoutProjectCategoryInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectCategoryInput | collaborativeProjectCreateOrConnectWithoutProjectCategoryInput[]
    createMany?: collaborativeProjectCreateManyProjectCategoryInputEnvelope
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
  }

  export type collaborativeProjectUpdateManyWithoutProjectCategoryNestedInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectCategoryInput, collaborativeProjectUncheckedCreateWithoutProjectCategoryInput> | collaborativeProjectCreateWithoutProjectCategoryInput[] | collaborativeProjectUncheckedCreateWithoutProjectCategoryInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectCategoryInput | collaborativeProjectCreateOrConnectWithoutProjectCategoryInput[]
    upsert?: collaborativeProjectUpsertWithWhereUniqueWithoutProjectCategoryInput | collaborativeProjectUpsertWithWhereUniqueWithoutProjectCategoryInput[]
    createMany?: collaborativeProjectCreateManyProjectCategoryInputEnvelope
    set?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    disconnect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    delete?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    update?: collaborativeProjectUpdateWithWhereUniqueWithoutProjectCategoryInput | collaborativeProjectUpdateWithWhereUniqueWithoutProjectCategoryInput[]
    updateMany?: collaborativeProjectUpdateManyWithWhereWithoutProjectCategoryInput | collaborativeProjectUpdateManyWithWhereWithoutProjectCategoryInput[]
    deleteMany?: collaborativeProjectScalarWhereInput | collaborativeProjectScalarWhereInput[]
  }

  export type collaborativeProjectUncheckedUpdateManyWithoutProjectCategoryNestedInput = {
    create?: XOR<collaborativeProjectCreateWithoutProjectCategoryInput, collaborativeProjectUncheckedCreateWithoutProjectCategoryInput> | collaborativeProjectCreateWithoutProjectCategoryInput[] | collaborativeProjectUncheckedCreateWithoutProjectCategoryInput[]
    connectOrCreate?: collaborativeProjectCreateOrConnectWithoutProjectCategoryInput | collaborativeProjectCreateOrConnectWithoutProjectCategoryInput[]
    upsert?: collaborativeProjectUpsertWithWhereUniqueWithoutProjectCategoryInput | collaborativeProjectUpsertWithWhereUniqueWithoutProjectCategoryInput[]
    createMany?: collaborativeProjectCreateManyProjectCategoryInputEnvelope
    set?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    disconnect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    delete?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    connect?: collaborativeProjectWhereUniqueInput | collaborativeProjectWhereUniqueInput[]
    update?: collaborativeProjectUpdateWithWhereUniqueWithoutProjectCategoryInput | collaborativeProjectUpdateWithWhereUniqueWithoutProjectCategoryInput[]
    updateMany?: collaborativeProjectUpdateManyWithWhereWithoutProjectCategoryInput | collaborativeProjectUpdateManyWithWhereWithoutProjectCategoryInput[]
    deleteMany?: collaborativeProjectScalarWhereInput | collaborativeProjectScalarWhereInput[]
  }

  export type resourceCreateNestedManyWithoutResourceCategoryInput = {
    create?: XOR<resourceCreateWithoutResourceCategoryInput, resourceUncheckedCreateWithoutResourceCategoryInput> | resourceCreateWithoutResourceCategoryInput[] | resourceUncheckedCreateWithoutResourceCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutResourceCategoryInput | resourceCreateOrConnectWithoutResourceCategoryInput[]
    createMany?: resourceCreateManyResourceCategoryInputEnvelope
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
  }

  export type resourceUncheckedCreateNestedManyWithoutResourceCategoryInput = {
    create?: XOR<resourceCreateWithoutResourceCategoryInput, resourceUncheckedCreateWithoutResourceCategoryInput> | resourceCreateWithoutResourceCategoryInput[] | resourceUncheckedCreateWithoutResourceCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutResourceCategoryInput | resourceCreateOrConnectWithoutResourceCategoryInput[]
    createMany?: resourceCreateManyResourceCategoryInputEnvelope
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
  }

  export type resourceUpdateManyWithoutResourceCategoryNestedInput = {
    create?: XOR<resourceCreateWithoutResourceCategoryInput, resourceUncheckedCreateWithoutResourceCategoryInput> | resourceCreateWithoutResourceCategoryInput[] | resourceUncheckedCreateWithoutResourceCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutResourceCategoryInput | resourceCreateOrConnectWithoutResourceCategoryInput[]
    upsert?: resourceUpsertWithWhereUniqueWithoutResourceCategoryInput | resourceUpsertWithWhereUniqueWithoutResourceCategoryInput[]
    createMany?: resourceCreateManyResourceCategoryInputEnvelope
    set?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    disconnect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    delete?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    update?: resourceUpdateWithWhereUniqueWithoutResourceCategoryInput | resourceUpdateWithWhereUniqueWithoutResourceCategoryInput[]
    updateMany?: resourceUpdateManyWithWhereWithoutResourceCategoryInput | resourceUpdateManyWithWhereWithoutResourceCategoryInput[]
    deleteMany?: resourceScalarWhereInput | resourceScalarWhereInput[]
  }

  export type resourceUncheckedUpdateManyWithoutResourceCategoryNestedInput = {
    create?: XOR<resourceCreateWithoutResourceCategoryInput, resourceUncheckedCreateWithoutResourceCategoryInput> | resourceCreateWithoutResourceCategoryInput[] | resourceUncheckedCreateWithoutResourceCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutResourceCategoryInput | resourceCreateOrConnectWithoutResourceCategoryInput[]
    upsert?: resourceUpsertWithWhereUniqueWithoutResourceCategoryInput | resourceUpsertWithWhereUniqueWithoutResourceCategoryInput[]
    createMany?: resourceCreateManyResourceCategoryInputEnvelope
    set?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    disconnect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    delete?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    update?: resourceUpdateWithWhereUniqueWithoutResourceCategoryInput | resourceUpdateWithWhereUniqueWithoutResourceCategoryInput[]
    updateMany?: resourceUpdateManyWithWhereWithoutResourceCategoryInput | resourceUpdateManyWithWhereWithoutResourceCategoryInput[]
    deleteMany?: resourceScalarWhereInput | resourceScalarWhereInput[]
  }

  export type localServiceCreateNestedManyWithoutServiceCategoryInput = {
    create?: XOR<localServiceCreateWithoutServiceCategoryInput, localServiceUncheckedCreateWithoutServiceCategoryInput> | localServiceCreateWithoutServiceCategoryInput[] | localServiceUncheckedCreateWithoutServiceCategoryInput[]
    connectOrCreate?: localServiceCreateOrConnectWithoutServiceCategoryInput | localServiceCreateOrConnectWithoutServiceCategoryInput[]
    createMany?: localServiceCreateManyServiceCategoryInputEnvelope
    connect?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
  }

  export type localServiceUncheckedCreateNestedManyWithoutServiceCategoryInput = {
    create?: XOR<localServiceCreateWithoutServiceCategoryInput, localServiceUncheckedCreateWithoutServiceCategoryInput> | localServiceCreateWithoutServiceCategoryInput[] | localServiceUncheckedCreateWithoutServiceCategoryInput[]
    connectOrCreate?: localServiceCreateOrConnectWithoutServiceCategoryInput | localServiceCreateOrConnectWithoutServiceCategoryInput[]
    createMany?: localServiceCreateManyServiceCategoryInputEnvelope
    connect?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
  }

  export type localServiceUpdateManyWithoutServiceCategoryNestedInput = {
    create?: XOR<localServiceCreateWithoutServiceCategoryInput, localServiceUncheckedCreateWithoutServiceCategoryInput> | localServiceCreateWithoutServiceCategoryInput[] | localServiceUncheckedCreateWithoutServiceCategoryInput[]
    connectOrCreate?: localServiceCreateOrConnectWithoutServiceCategoryInput | localServiceCreateOrConnectWithoutServiceCategoryInput[]
    upsert?: localServiceUpsertWithWhereUniqueWithoutServiceCategoryInput | localServiceUpsertWithWhereUniqueWithoutServiceCategoryInput[]
    createMany?: localServiceCreateManyServiceCategoryInputEnvelope
    set?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    disconnect?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    delete?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    connect?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    update?: localServiceUpdateWithWhereUniqueWithoutServiceCategoryInput | localServiceUpdateWithWhereUniqueWithoutServiceCategoryInput[]
    updateMany?: localServiceUpdateManyWithWhereWithoutServiceCategoryInput | localServiceUpdateManyWithWhereWithoutServiceCategoryInput[]
    deleteMany?: localServiceScalarWhereInput | localServiceScalarWhereInput[]
  }

  export type localServiceUncheckedUpdateManyWithoutServiceCategoryNestedInput = {
    create?: XOR<localServiceCreateWithoutServiceCategoryInput, localServiceUncheckedCreateWithoutServiceCategoryInput> | localServiceCreateWithoutServiceCategoryInput[] | localServiceUncheckedCreateWithoutServiceCategoryInput[]
    connectOrCreate?: localServiceCreateOrConnectWithoutServiceCategoryInput | localServiceCreateOrConnectWithoutServiceCategoryInput[]
    upsert?: localServiceUpsertWithWhereUniqueWithoutServiceCategoryInput | localServiceUpsertWithWhereUniqueWithoutServiceCategoryInput[]
    createMany?: localServiceCreateManyServiceCategoryInputEnvelope
    set?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    disconnect?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    delete?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    connect?: localServiceWhereUniqueInput | localServiceWhereUniqueInput[]
    update?: localServiceUpdateWithWhereUniqueWithoutServiceCategoryInput | localServiceUpdateWithWhereUniqueWithoutServiceCategoryInput[]
    updateMany?: localServiceUpdateManyWithWhereWithoutServiceCategoryInput | localServiceUpdateManyWithWhereWithoutServiceCategoryInput[]
    deleteMany?: localServiceScalarWhereInput | localServiceScalarWhereInput[]
  }

  export type skillCreateNestedManyWithoutSkillCategoryInput = {
    create?: XOR<skillCreateWithoutSkillCategoryInput, skillUncheckedCreateWithoutSkillCategoryInput> | skillCreateWithoutSkillCategoryInput[] | skillUncheckedCreateWithoutSkillCategoryInput[]
    connectOrCreate?: skillCreateOrConnectWithoutSkillCategoryInput | skillCreateOrConnectWithoutSkillCategoryInput[]
    createMany?: skillCreateManySkillCategoryInputEnvelope
    connect?: skillWhereUniqueInput | skillWhereUniqueInput[]
  }

  export type skillUncheckedCreateNestedManyWithoutSkillCategoryInput = {
    create?: XOR<skillCreateWithoutSkillCategoryInput, skillUncheckedCreateWithoutSkillCategoryInput> | skillCreateWithoutSkillCategoryInput[] | skillUncheckedCreateWithoutSkillCategoryInput[]
    connectOrCreate?: skillCreateOrConnectWithoutSkillCategoryInput | skillCreateOrConnectWithoutSkillCategoryInput[]
    createMany?: skillCreateManySkillCategoryInputEnvelope
    connect?: skillWhereUniqueInput | skillWhereUniqueInput[]
  }

  export type skillUpdateManyWithoutSkillCategoryNestedInput = {
    create?: XOR<skillCreateWithoutSkillCategoryInput, skillUncheckedCreateWithoutSkillCategoryInput> | skillCreateWithoutSkillCategoryInput[] | skillUncheckedCreateWithoutSkillCategoryInput[]
    connectOrCreate?: skillCreateOrConnectWithoutSkillCategoryInput | skillCreateOrConnectWithoutSkillCategoryInput[]
    upsert?: skillUpsertWithWhereUniqueWithoutSkillCategoryInput | skillUpsertWithWhereUniqueWithoutSkillCategoryInput[]
    createMany?: skillCreateManySkillCategoryInputEnvelope
    set?: skillWhereUniqueInput | skillWhereUniqueInput[]
    disconnect?: skillWhereUniqueInput | skillWhereUniqueInput[]
    delete?: skillWhereUniqueInput | skillWhereUniqueInput[]
    connect?: skillWhereUniqueInput | skillWhereUniqueInput[]
    update?: skillUpdateWithWhereUniqueWithoutSkillCategoryInput | skillUpdateWithWhereUniqueWithoutSkillCategoryInput[]
    updateMany?: skillUpdateManyWithWhereWithoutSkillCategoryInput | skillUpdateManyWithWhereWithoutSkillCategoryInput[]
    deleteMany?: skillScalarWhereInput | skillScalarWhereInput[]
  }

  export type skillUncheckedUpdateManyWithoutSkillCategoryNestedInput = {
    create?: XOR<skillCreateWithoutSkillCategoryInput, skillUncheckedCreateWithoutSkillCategoryInput> | skillCreateWithoutSkillCategoryInput[] | skillUncheckedCreateWithoutSkillCategoryInput[]
    connectOrCreate?: skillCreateOrConnectWithoutSkillCategoryInput | skillCreateOrConnectWithoutSkillCategoryInput[]
    upsert?: skillUpsertWithWhereUniqueWithoutSkillCategoryInput | skillUpsertWithWhereUniqueWithoutSkillCategoryInput[]
    createMany?: skillCreateManySkillCategoryInputEnvelope
    set?: skillWhereUniqueInput | skillWhereUniqueInput[]
    disconnect?: skillWhereUniqueInput | skillWhereUniqueInput[]
    delete?: skillWhereUniqueInput | skillWhereUniqueInput[]
    connect?: skillWhereUniqueInput | skillWhereUniqueInput[]
    update?: skillUpdateWithWhereUniqueWithoutSkillCategoryInput | skillUpdateWithWhereUniqueWithoutSkillCategoryInput[]
    updateMany?: skillUpdateManyWithWhereWithoutSkillCategoryInput | skillUpdateManyWithWhereWithoutSkillCategoryInput[]
    deleteMany?: skillScalarWhereInput | skillScalarWhereInput[]
  }

  export type wellnessBadgeCreateNestedManyWithoutWellnessCategoryInput = {
    create?: XOR<wellnessBadgeCreateWithoutWellnessCategoryInput, wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput> | wellnessBadgeCreateWithoutWellnessCategoryInput[] | wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput | wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput[]
    createMany?: wellnessBadgeCreateManyWellnessCategoryInputEnvelope
    connect?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
  }

  export type wellnessGoalCreateNestedManyWithoutWellnessCategoryInput = {
    create?: XOR<wellnessGoalCreateWithoutWellnessCategoryInput, wellnessGoalUncheckedCreateWithoutWellnessCategoryInput> | wellnessGoalCreateWithoutWellnessCategoryInput[] | wellnessGoalUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutWellnessCategoryInput | wellnessGoalCreateOrConnectWithoutWellnessCategoryInput[]
    createMany?: wellnessGoalCreateManyWellnessCategoryInputEnvelope
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
  }

  export type wellnessBadgeUncheckedCreateNestedManyWithoutWellnessCategoryInput = {
    create?: XOR<wellnessBadgeCreateWithoutWellnessCategoryInput, wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput> | wellnessBadgeCreateWithoutWellnessCategoryInput[] | wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput | wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput[]
    createMany?: wellnessBadgeCreateManyWellnessCategoryInputEnvelope
    connect?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
  }

  export type wellnessGoalUncheckedCreateNestedManyWithoutWellnessCategoryInput = {
    create?: XOR<wellnessGoalCreateWithoutWellnessCategoryInput, wellnessGoalUncheckedCreateWithoutWellnessCategoryInput> | wellnessGoalCreateWithoutWellnessCategoryInput[] | wellnessGoalUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutWellnessCategoryInput | wellnessGoalCreateOrConnectWithoutWellnessCategoryInput[]
    createMany?: wellnessGoalCreateManyWellnessCategoryInputEnvelope
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
  }

  export type wellnessBadgeUpdateManyWithoutWellnessCategoryNestedInput = {
    create?: XOR<wellnessBadgeCreateWithoutWellnessCategoryInput, wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput> | wellnessBadgeCreateWithoutWellnessCategoryInput[] | wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput | wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput[]
    upsert?: wellnessBadgeUpsertWithWhereUniqueWithoutWellnessCategoryInput | wellnessBadgeUpsertWithWhereUniqueWithoutWellnessCategoryInput[]
    createMany?: wellnessBadgeCreateManyWellnessCategoryInputEnvelope
    set?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    disconnect?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    delete?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    connect?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    update?: wellnessBadgeUpdateWithWhereUniqueWithoutWellnessCategoryInput | wellnessBadgeUpdateWithWhereUniqueWithoutWellnessCategoryInput[]
    updateMany?: wellnessBadgeUpdateManyWithWhereWithoutWellnessCategoryInput | wellnessBadgeUpdateManyWithWhereWithoutWellnessCategoryInput[]
    deleteMany?: wellnessBadgeScalarWhereInput | wellnessBadgeScalarWhereInput[]
  }

  export type wellnessGoalUpdateManyWithoutWellnessCategoryNestedInput = {
    create?: XOR<wellnessGoalCreateWithoutWellnessCategoryInput, wellnessGoalUncheckedCreateWithoutWellnessCategoryInput> | wellnessGoalCreateWithoutWellnessCategoryInput[] | wellnessGoalUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutWellnessCategoryInput | wellnessGoalCreateOrConnectWithoutWellnessCategoryInput[]
    upsert?: wellnessGoalUpsertWithWhereUniqueWithoutWellnessCategoryInput | wellnessGoalUpsertWithWhereUniqueWithoutWellnessCategoryInput[]
    createMany?: wellnessGoalCreateManyWellnessCategoryInputEnvelope
    set?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    disconnect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    delete?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    update?: wellnessGoalUpdateWithWhereUniqueWithoutWellnessCategoryInput | wellnessGoalUpdateWithWhereUniqueWithoutWellnessCategoryInput[]
    updateMany?: wellnessGoalUpdateManyWithWhereWithoutWellnessCategoryInput | wellnessGoalUpdateManyWithWhereWithoutWellnessCategoryInput[]
    deleteMany?: wellnessGoalScalarWhereInput | wellnessGoalScalarWhereInput[]
  }

  export type wellnessBadgeUncheckedUpdateManyWithoutWellnessCategoryNestedInput = {
    create?: XOR<wellnessBadgeCreateWithoutWellnessCategoryInput, wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput> | wellnessBadgeCreateWithoutWellnessCategoryInput[] | wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput | wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput[]
    upsert?: wellnessBadgeUpsertWithWhereUniqueWithoutWellnessCategoryInput | wellnessBadgeUpsertWithWhereUniqueWithoutWellnessCategoryInput[]
    createMany?: wellnessBadgeCreateManyWellnessCategoryInputEnvelope
    set?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    disconnect?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    delete?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    connect?: wellnessBadgeWhereUniqueInput | wellnessBadgeWhereUniqueInput[]
    update?: wellnessBadgeUpdateWithWhereUniqueWithoutWellnessCategoryInput | wellnessBadgeUpdateWithWhereUniqueWithoutWellnessCategoryInput[]
    updateMany?: wellnessBadgeUpdateManyWithWhereWithoutWellnessCategoryInput | wellnessBadgeUpdateManyWithWhereWithoutWellnessCategoryInput[]
    deleteMany?: wellnessBadgeScalarWhereInput | wellnessBadgeScalarWhereInput[]
  }

  export type wellnessGoalUncheckedUpdateManyWithoutWellnessCategoryNestedInput = {
    create?: XOR<wellnessGoalCreateWithoutWellnessCategoryInput, wellnessGoalUncheckedCreateWithoutWellnessCategoryInput> | wellnessGoalCreateWithoutWellnessCategoryInput[] | wellnessGoalUncheckedCreateWithoutWellnessCategoryInput[]
    connectOrCreate?: wellnessGoalCreateOrConnectWithoutWellnessCategoryInput | wellnessGoalCreateOrConnectWithoutWellnessCategoryInput[]
    upsert?: wellnessGoalUpsertWithWhereUniqueWithoutWellnessCategoryInput | wellnessGoalUpsertWithWhereUniqueWithoutWellnessCategoryInput[]
    createMany?: wellnessGoalCreateManyWellnessCategoryInputEnvelope
    set?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    disconnect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    delete?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    connect?: wellnessGoalWhereUniqueInput | wellnessGoalWhereUniqueInput[]
    update?: wellnessGoalUpdateWithWhereUniqueWithoutWellnessCategoryInput | wellnessGoalUpdateWithWhereUniqueWithoutWellnessCategoryInput[]
    updateMany?: wellnessGoalUpdateManyWithWhereWithoutWellnessCategoryInput | wellnessGoalUpdateManyWithWhereWithoutWellnessCategoryInput[]
    deleteMany?: wellnessGoalScalarWhereInput | wellnessGoalScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type userCreateWithoutActivityInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutActivityInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutActivityInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutActivityInput, userUncheckedCreateWithoutActivityInput>
  }

  export type activityCategoryCreateWithoutActivityInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityCategoryUncheckedCreateWithoutActivityInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityCategoryCreateOrConnectWithoutActivityInput = {
    where: activityCategoryWhereUniqueInput
    create: XOR<activityCategoryCreateWithoutActivityInput, activityCategoryUncheckedCreateWithoutActivityInput>
  }

  export type activityRegistrationCreateWithoutActivityInput = {
    id?: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutActivityRegistrationInput
  }

  export type activityRegistrationUncheckedCreateWithoutActivityInput = {
    id?: string
    userId: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityRegistrationCreateOrConnectWithoutActivityInput = {
    where: activityRegistrationWhereUniqueInput
    create: XOR<activityRegistrationCreateWithoutActivityInput, activityRegistrationUncheckedCreateWithoutActivityInput>
  }

  export type activityRegistrationCreateManyActivityInputEnvelope = {
    data: activityRegistrationCreateManyActivityInput | activityRegistrationCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutActivityInput = {
    update: XOR<userUpdateWithoutActivityInput, userUncheckedUpdateWithoutActivityInput>
    create: XOR<userCreateWithoutActivityInput, userUncheckedCreateWithoutActivityInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutActivityInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutActivityInput, userUncheckedUpdateWithoutActivityInput>
  }

  export type userUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type activityCategoryUpsertWithoutActivityInput = {
    update: XOR<activityCategoryUpdateWithoutActivityInput, activityCategoryUncheckedUpdateWithoutActivityInput>
    create: XOR<activityCategoryCreateWithoutActivityInput, activityCategoryUncheckedCreateWithoutActivityInput>
    where?: activityCategoryWhereInput
  }

  export type activityCategoryUpdateToOneWithWhereWithoutActivityInput = {
    where?: activityCategoryWhereInput
    data: XOR<activityCategoryUpdateWithoutActivityInput, activityCategoryUncheckedUpdateWithoutActivityInput>
  }

  export type activityCategoryUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityCategoryUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityRegistrationUpsertWithWhereUniqueWithoutActivityInput = {
    where: activityRegistrationWhereUniqueInput
    update: XOR<activityRegistrationUpdateWithoutActivityInput, activityRegistrationUncheckedUpdateWithoutActivityInput>
    create: XOR<activityRegistrationCreateWithoutActivityInput, activityRegistrationUncheckedCreateWithoutActivityInput>
  }

  export type activityRegistrationUpdateWithWhereUniqueWithoutActivityInput = {
    where: activityRegistrationWhereUniqueInput
    data: XOR<activityRegistrationUpdateWithoutActivityInput, activityRegistrationUncheckedUpdateWithoutActivityInput>
  }

  export type activityRegistrationUpdateManyWithWhereWithoutActivityInput = {
    where: activityRegistrationScalarWhereInput
    data: XOR<activityRegistrationUpdateManyMutationInput, activityRegistrationUncheckedUpdateManyWithoutActivityInput>
  }

  export type activityRegistrationScalarWhereInput = {
    AND?: activityRegistrationScalarWhereInput | activityRegistrationScalarWhereInput[]
    OR?: activityRegistrationScalarWhereInput[]
    NOT?: activityRegistrationScalarWhereInput | activityRegistrationScalarWhereInput[]
    id?: StringFilter<"activityRegistration"> | string
    activityId?: StringFilter<"activityRegistration"> | string
    userId?: StringFilter<"activityRegistration"> | string
    registrationDate?: DateTimeFilter<"activityRegistration"> | Date | string
    status?: StringNullableFilter<"activityRegistration"> | string | null
    attendanceConfirmed?: BoolNullableFilter<"activityRegistration"> | boolean | null
    createdAt?: DateTimeFilter<"activityRegistration"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityRegistration"> | Date | string | null
  }

  export type userCreateWithoutActivityLogInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutActivityLogInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutActivityLogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutActivityLogInput, userUncheckedCreateWithoutActivityLogInput>
  }

  export type userUpsertWithoutActivityLogInput = {
    update: XOR<userUpdateWithoutActivityLogInput, userUncheckedUpdateWithoutActivityLogInput>
    create: XOR<userCreateWithoutActivityLogInput, userUncheckedCreateWithoutActivityLogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutActivityLogInput, userUncheckedUpdateWithoutActivityLogInput>
  }

  export type userUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type activityCreateWithoutActivity_registrationInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutActivityInput
    activityCategory?: activityCategoryCreateNestedOneWithoutActivityInput
  }

  export type activityUncheckedCreateWithoutActivity_registrationInput = {
    id?: string
    creatorId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    categoryId?: string | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityCreateOrConnectWithoutActivity_registrationInput = {
    where: activityWhereUniqueInput
    create: XOR<activityCreateWithoutActivity_registrationInput, activityUncheckedCreateWithoutActivity_registrationInput>
  }

  export type userCreateWithoutActivityRegistrationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutActivityRegistrationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutActivityRegistrationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutActivityRegistrationInput, userUncheckedCreateWithoutActivityRegistrationInput>
  }

  export type activityUpsertWithoutActivity_registrationInput = {
    update: XOR<activityUpdateWithoutActivity_registrationInput, activityUncheckedUpdateWithoutActivity_registrationInput>
    create: XOR<activityCreateWithoutActivity_registrationInput, activityUncheckedCreateWithoutActivity_registrationInput>
    where?: activityWhereInput
  }

  export type activityUpdateToOneWithWhereWithoutActivity_registrationInput = {
    where?: activityWhereInput
    data: XOR<activityUpdateWithoutActivity_registrationInput, activityUncheckedUpdateWithoutActivity_registrationInput>
  }

  export type activityUpdateWithoutActivity_registrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutActivityNestedInput
    activityCategory?: activityCategoryUpdateOneWithoutActivityNestedInput
  }

  export type activityUncheckedUpdateWithoutActivity_registrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutActivityRegistrationInput = {
    update: XOR<userUpdateWithoutActivityRegistrationInput, userUncheckedUpdateWithoutActivityRegistrationInput>
    create: XOR<userCreateWithoutActivityRegistrationInput, userUncheckedCreateWithoutActivityRegistrationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutActivityRegistrationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutActivityRegistrationInput, userUncheckedUpdateWithoutActivityRegistrationInput>
  }

  export type userUpdateWithoutActivityRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutActivityRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userBadgeCreateWithoutBadgeInput = {
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutUserBadgeInput
  }

  export type userBadgeUncheckedCreateWithoutBadgeInput = {
    userId: string
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userBadgeCreateOrConnectWithoutBadgeInput = {
    where: userBadgeWhereUniqueInput
    create: XOR<userBadgeCreateWithoutBadgeInput, userBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type badgeCategoryCreateWithoutBadgeInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type badgeCategoryUncheckedCreateWithoutBadgeInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type badgeCategoryCreateOrConnectWithoutBadgeInput = {
    where: badgeCategoryWhereUniqueInput
    create: XOR<badgeCategoryCreateWithoutBadgeInput, badgeCategoryUncheckedCreateWithoutBadgeInput>
  }

  export type userBadgeUpsertWithoutBadgeInput = {
    update: XOR<userBadgeUpdateWithoutBadgeInput, userBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<userBadgeCreateWithoutBadgeInput, userBadgeUncheckedCreateWithoutBadgeInput>
    where?: userBadgeWhereInput
  }

  export type userBadgeUpdateToOneWithWhereWithoutBadgeInput = {
    where?: userBadgeWhereInput
    data: XOR<userBadgeUpdateWithoutBadgeInput, userBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type userBadgeUpdateWithoutBadgeInput = {
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutUserBadgeNestedInput
  }

  export type userBadgeUncheckedUpdateWithoutBadgeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCategoryUpsertWithoutBadgeInput = {
    update: XOR<badgeCategoryUpdateWithoutBadgeInput, badgeCategoryUncheckedUpdateWithoutBadgeInput>
    create: XOR<badgeCategoryCreateWithoutBadgeInput, badgeCategoryUncheckedCreateWithoutBadgeInput>
    where?: badgeCategoryWhereInput
  }

  export type badgeCategoryUpdateToOneWithWhereWithoutBadgeInput = {
    where?: badgeCategoryWhereInput
    data: XOR<badgeCategoryUpdateWithoutBadgeInput, badgeCategoryUncheckedUpdateWithoutBadgeInput>
  }

  export type badgeCategoryUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCategoryUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveCategoryCreateWithoutCognitiveExerciseInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type cognitiveCategoryUncheckedCreateWithoutCognitiveExerciseInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type cognitiveCategoryCreateOrConnectWithoutCognitiveExerciseInput = {
    where: cognitiveCategoryWhereUniqueInput
    create: XOR<cognitiveCategoryCreateWithoutCognitiveExerciseInput, cognitiveCategoryUncheckedCreateWithoutCognitiveExerciseInput>
  }

  export type userActivityCreateWithoutCognitiveExerciseInput = {
    id?: string
    completionDate: Date | string
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exerciseProgram?: exerciseProgramCreateNestedOneWithoutUserActivityInput
    user: userCreateNestedOneWithoutUserActivityInput
  }

  export type userActivityUncheckedCreateWithoutCognitiveExerciseInput = {
    id?: string
    userId: string
    completionDate: Date | string
    exerciseProgramId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityCreateOrConnectWithoutCognitiveExerciseInput = {
    where: userActivityWhereUniqueInput
    create: XOR<userActivityCreateWithoutCognitiveExerciseInput, userActivityUncheckedCreateWithoutCognitiveExerciseInput>
  }

  export type userActivityCreateManyCognitiveExerciseInputEnvelope = {
    data: userActivityCreateManyCognitiveExerciseInput | userActivityCreateManyCognitiveExerciseInput[]
    skipDuplicates?: boolean
  }

  export type programCategoryCreateWithoutCognitiveExerciseInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exerciseProgram?: exerciseProgramCreateNestedManyWithoutProgramCategoryInput
  }

  export type programCategoryUncheckedCreateWithoutCognitiveExerciseInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exerciseProgram?: exerciseProgramUncheckedCreateNestedManyWithoutProgramCategoryInput
  }

  export type programCategoryCreateOrConnectWithoutCognitiveExerciseInput = {
    where: programCategoryWhereUniqueInput
    create: XOR<programCategoryCreateWithoutCognitiveExerciseInput, programCategoryUncheckedCreateWithoutCognitiveExerciseInput>
  }

  export type cognitiveCategoryUpsertWithoutCognitiveExerciseInput = {
    update: XOR<cognitiveCategoryUpdateWithoutCognitiveExerciseInput, cognitiveCategoryUncheckedUpdateWithoutCognitiveExerciseInput>
    create: XOR<cognitiveCategoryCreateWithoutCognitiveExerciseInput, cognitiveCategoryUncheckedCreateWithoutCognitiveExerciseInput>
    where?: cognitiveCategoryWhereInput
  }

  export type cognitiveCategoryUpdateToOneWithWhereWithoutCognitiveExerciseInput = {
    where?: cognitiveCategoryWhereInput
    data: XOR<cognitiveCategoryUpdateWithoutCognitiveExerciseInput, cognitiveCategoryUncheckedUpdateWithoutCognitiveExerciseInput>
  }

  export type cognitiveCategoryUpdateWithoutCognitiveExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveCategoryUncheckedUpdateWithoutCognitiveExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityUpsertWithWhereUniqueWithoutCognitiveExerciseInput = {
    where: userActivityWhereUniqueInput
    update: XOR<userActivityUpdateWithoutCognitiveExerciseInput, userActivityUncheckedUpdateWithoutCognitiveExerciseInput>
    create: XOR<userActivityCreateWithoutCognitiveExerciseInput, userActivityUncheckedCreateWithoutCognitiveExerciseInput>
  }

  export type userActivityUpdateWithWhereUniqueWithoutCognitiveExerciseInput = {
    where: userActivityWhereUniqueInput
    data: XOR<userActivityUpdateWithoutCognitiveExerciseInput, userActivityUncheckedUpdateWithoutCognitiveExerciseInput>
  }

  export type userActivityUpdateManyWithWhereWithoutCognitiveExerciseInput = {
    where: userActivityScalarWhereInput
    data: XOR<userActivityUpdateManyMutationInput, userActivityUncheckedUpdateManyWithoutCognitiveExerciseInput>
  }

  export type userActivityScalarWhereInput = {
    AND?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
    OR?: userActivityScalarWhereInput[]
    NOT?: userActivityScalarWhereInput | userActivityScalarWhereInput[]
    id?: StringFilter<"userActivity"> | string
    userId?: StringFilter<"userActivity"> | string
    completionDate?: DateTimeFilter<"userActivity"> | Date | string
    exerciseProgramId?: StringNullableFilter<"userActivity"> | string | null
    cognitiveExerciseId?: StringNullableFilter<"userActivity"> | string | null
    durationMinutes?: IntNullableFilter<"userActivity"> | number | null
    perceivedDifficultyLevel?: IntNullableFilter<"userActivity"> | number | null
    enjoymentLevel?: IntNullableFilter<"userActivity"> | number | null
    comment?: StringNullableFilter<"userActivity"> | string | null
    createdAt?: DateTimeFilter<"userActivity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userActivity"> | Date | string | null
  }

  export type programCategoryUpsertWithoutCognitiveExerciseInput = {
    update: XOR<programCategoryUpdateWithoutCognitiveExerciseInput, programCategoryUncheckedUpdateWithoutCognitiveExerciseInput>
    create: XOR<programCategoryCreateWithoutCognitiveExerciseInput, programCategoryUncheckedCreateWithoutCognitiveExerciseInput>
    where?: programCategoryWhereInput
  }

  export type programCategoryUpdateToOneWithWhereWithoutCognitiveExerciseInput = {
    where?: programCategoryWhereInput
    data: XOR<programCategoryUpdateWithoutCognitiveExerciseInput, programCategoryUncheckedUpdateWithoutCognitiveExerciseInput>
  }

  export type programCategoryUpdateWithoutCognitiveExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exerciseProgram?: exerciseProgramUpdateManyWithoutProgramCategoryNestedInput
  }

  export type programCategoryUncheckedUpdateWithoutCognitiveExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exerciseProgram?: exerciseProgramUncheckedUpdateManyWithoutProgramCategoryNestedInput
  }

  export type userCreateWithoutCollaborativeProjectInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCollaborativeProjectInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCollaborativeProjectInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCollaborativeProjectInput, userUncheckedCreateWithoutCollaborativeProjectInput>
  }

  export type projectCategoryCreateWithoutCollaborativeProjectInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectCategoryUncheckedCreateWithoutCollaborativeProjectInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectCategoryCreateOrConnectWithoutCollaborativeProjectInput = {
    where: projectCategoryWhereUniqueInput
    create: XOR<projectCategoryCreateWithoutCollaborativeProjectInput, projectCategoryUncheckedCreateWithoutCollaborativeProjectInput>
  }

  export type projectMemberCreateWithoutCollaborativeProjectInput = {
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutProjectMemberInput
  }

  export type projectMemberUncheckedCreateWithoutCollaborativeProjectInput = {
    userId: string
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectMemberCreateOrConnectWithoutCollaborativeProjectInput = {
    where: projectMemberWhereUniqueInput
    create: XOR<projectMemberCreateWithoutCollaborativeProjectInput, projectMemberUncheckedCreateWithoutCollaborativeProjectInput>
  }

  export type projectMemberCreateManyCollaborativeProjectInputEnvelope = {
    data: projectMemberCreateManyCollaborativeProjectInput | projectMemberCreateManyCollaborativeProjectInput[]
    skipDuplicates?: boolean
  }

  export type projectTaskCreateWithoutCollaborativeProjectInput = {
    id?: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutProjectTaskInput
  }

  export type projectTaskUncheckedCreateWithoutCollaborativeProjectInput = {
    id?: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    assigneeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectTaskCreateOrConnectWithoutCollaborativeProjectInput = {
    where: projectTaskWhereUniqueInput
    create: XOR<projectTaskCreateWithoutCollaborativeProjectInput, projectTaskUncheckedCreateWithoutCollaborativeProjectInput>
  }

  export type projectTaskCreateManyCollaborativeProjectInputEnvelope = {
    data: projectTaskCreateManyCollaborativeProjectInput | projectTaskCreateManyCollaborativeProjectInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutCollaborativeProjectInput = {
    update: XOR<userUpdateWithoutCollaborativeProjectInput, userUncheckedUpdateWithoutCollaborativeProjectInput>
    create: XOR<userCreateWithoutCollaborativeProjectInput, userUncheckedCreateWithoutCollaborativeProjectInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCollaborativeProjectInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCollaborativeProjectInput, userUncheckedUpdateWithoutCollaborativeProjectInput>
  }

  export type userUpdateWithoutCollaborativeProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCollaborativeProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type projectCategoryUpsertWithoutCollaborativeProjectInput = {
    update: XOR<projectCategoryUpdateWithoutCollaborativeProjectInput, projectCategoryUncheckedUpdateWithoutCollaborativeProjectInput>
    create: XOR<projectCategoryCreateWithoutCollaborativeProjectInput, projectCategoryUncheckedCreateWithoutCollaborativeProjectInput>
    where?: projectCategoryWhereInput
  }

  export type projectCategoryUpdateToOneWithWhereWithoutCollaborativeProjectInput = {
    where?: projectCategoryWhereInput
    data: XOR<projectCategoryUpdateWithoutCollaborativeProjectInput, projectCategoryUncheckedUpdateWithoutCollaborativeProjectInput>
  }

  export type projectCategoryUpdateWithoutCollaborativeProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectCategoryUncheckedUpdateWithoutCollaborativeProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberUpsertWithWhereUniqueWithoutCollaborativeProjectInput = {
    where: projectMemberWhereUniqueInput
    update: XOR<projectMemberUpdateWithoutCollaborativeProjectInput, projectMemberUncheckedUpdateWithoutCollaborativeProjectInput>
    create: XOR<projectMemberCreateWithoutCollaborativeProjectInput, projectMemberUncheckedCreateWithoutCollaborativeProjectInput>
  }

  export type projectMemberUpdateWithWhereUniqueWithoutCollaborativeProjectInput = {
    where: projectMemberWhereUniqueInput
    data: XOR<projectMemberUpdateWithoutCollaborativeProjectInput, projectMemberUncheckedUpdateWithoutCollaborativeProjectInput>
  }

  export type projectMemberUpdateManyWithWhereWithoutCollaborativeProjectInput = {
    where: projectMemberScalarWhereInput
    data: XOR<projectMemberUpdateManyMutationInput, projectMemberUncheckedUpdateManyWithoutCollaborativeProjectInput>
  }

  export type projectMemberScalarWhereInput = {
    AND?: projectMemberScalarWhereInput | projectMemberScalarWhereInput[]
    OR?: projectMemberScalarWhereInput[]
    NOT?: projectMemberScalarWhereInput | projectMemberScalarWhereInput[]
    projectId?: StringFilter<"projectMember"> | string
    userId?: StringFilter<"projectMember"> | string
    role?: StringFilter<"projectMember"> | string
    joinDate?: DateTimeFilter<"projectMember"> | Date | string
    createdAt?: DateTimeFilter<"projectMember"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectMember"> | Date | string | null
  }

  export type projectTaskUpsertWithWhereUniqueWithoutCollaborativeProjectInput = {
    where: projectTaskWhereUniqueInput
    update: XOR<projectTaskUpdateWithoutCollaborativeProjectInput, projectTaskUncheckedUpdateWithoutCollaborativeProjectInput>
    create: XOR<projectTaskCreateWithoutCollaborativeProjectInput, projectTaskUncheckedCreateWithoutCollaborativeProjectInput>
  }

  export type projectTaskUpdateWithWhereUniqueWithoutCollaborativeProjectInput = {
    where: projectTaskWhereUniqueInput
    data: XOR<projectTaskUpdateWithoutCollaborativeProjectInput, projectTaskUncheckedUpdateWithoutCollaborativeProjectInput>
  }

  export type projectTaskUpdateManyWithWhereWithoutCollaborativeProjectInput = {
    where: projectTaskScalarWhereInput
    data: XOR<projectTaskUpdateManyMutationInput, projectTaskUncheckedUpdateManyWithoutCollaborativeProjectInput>
  }

  export type projectTaskScalarWhereInput = {
    AND?: projectTaskScalarWhereInput | projectTaskScalarWhereInput[]
    OR?: projectTaskScalarWhereInput[]
    NOT?: projectTaskScalarWhereInput | projectTaskScalarWhereInput[]
    id?: StringFilter<"projectTask"> | string
    projectId?: StringFilter<"projectTask"> | string
    title?: StringFilter<"projectTask"> | string
    description?: StringNullableFilter<"projectTask"> | string | null
    creationDate?: DateTimeFilter<"projectTask"> | Date | string
    dueDate?: DateTimeNullableFilter<"projectTask"> | Date | string | null
    status?: StringNullableFilter<"projectTask"> | string | null
    assigneeId?: StringNullableFilter<"projectTask"> | string | null
    createdAt?: DateTimeFilter<"projectTask"> | Date | string
    updatedAt?: DateTimeNullableFilter<"projectTask"> | Date | string | null
  }

  export type conversationParticipantCreateWithoutConversationInput = {
    id?: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutConversationParticipantInput
  }

  export type conversationParticipantUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type conversationParticipantCreateOrConnectWithoutConversationInput = {
    where: conversationParticipantWhereUniqueInput
    create: XOR<conversationParticipantCreateWithoutConversationInput, conversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type conversationParticipantCreateManyConversationInputEnvelope = {
    data: conversationParticipantCreateManyConversationInput | conversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutConversationInput = {
    id?: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type messageCreateOrConnectWithoutConversationInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput>
  }

  export type messageCreateManyConversationInputEnvelope = {
    data: messageCreateManyConversationInput | messageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type videoCallCreateWithoutConversationInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutVideoCallInput
  }

  export type videoCallUncheckedCreateWithoutConversationInput = {
    id?: string
    initiatorId: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type videoCallCreateOrConnectWithoutConversationInput = {
    where: videoCallWhereUniqueInput
    create: XOR<videoCallCreateWithoutConversationInput, videoCallUncheckedCreateWithoutConversationInput>
  }

  export type videoCallCreateManyConversationInputEnvelope = {
    data: videoCallCreateManyConversationInput | videoCallCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type conversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: conversationParticipantWhereUniqueInput
    update: XOR<conversationParticipantUpdateWithoutConversationInput, conversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<conversationParticipantCreateWithoutConversationInput, conversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type conversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: conversationParticipantWhereUniqueInput
    data: XOR<conversationParticipantUpdateWithoutConversationInput, conversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type conversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: conversationParticipantScalarWhereInput
    data: XOR<conversationParticipantUpdateManyMutationInput, conversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type conversationParticipantScalarWhereInput = {
    AND?: conversationParticipantScalarWhereInput | conversationParticipantScalarWhereInput[]
    OR?: conversationParticipantScalarWhereInput[]
    NOT?: conversationParticipantScalarWhereInput | conversationParticipantScalarWhereInput[]
    id?: StringFilter<"conversationParticipant"> | string
    conversationId?: StringFilter<"conversationParticipant"> | string
    userId?: StringFilter<"conversationParticipant"> | string
    dateAdded?: DateTimeNullableFilter<"conversationParticipant"> | Date | string | null
    administrator?: BoolNullableFilter<"conversationParticipant"> | boolean | null
    lastAccess?: DateTimeFilter<"conversationParticipant"> | Date | string
    createdAt?: DateTimeFilter<"conversationParticipant"> | Date | string
    updatedAt?: DateTimeNullableFilter<"conversationParticipant"> | Date | string | null
  }

  export type messageUpsertWithWhereUniqueWithoutConversationInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutConversationInput, messageUncheckedUpdateWithoutConversationInput>
    create: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput>
  }

  export type messageUpdateWithWhereUniqueWithoutConversationInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutConversationInput, messageUncheckedUpdateWithoutConversationInput>
  }

  export type messageUpdateManyWithWhereWithoutConversationInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutConversationInput>
  }

  export type messageScalarWhereInput = {
    AND?: messageScalarWhereInput | messageScalarWhereInput[]
    OR?: messageScalarWhereInput[]
    NOT?: messageScalarWhereInput | messageScalarWhereInput[]
    id?: StringFilter<"message"> | string
    conversationId?: StringFilter<"message"> | string
    senderId?: StringFilter<"message"> | string
    content?: StringFilter<"message"> | string
    sendDate?: DateTimeFilter<"message"> | Date | string
    type?: StringNullableFilter<"message"> | string | null
    read?: BoolNullableFilter<"message"> | boolean | null
    createdAt?: DateTimeFilter<"message"> | Date | string
    updatedAt?: DateTimeNullableFilter<"message"> | Date | string | null
  }

  export type videoCallUpsertWithWhereUniqueWithoutConversationInput = {
    where: videoCallWhereUniqueInput
    update: XOR<videoCallUpdateWithoutConversationInput, videoCallUncheckedUpdateWithoutConversationInput>
    create: XOR<videoCallCreateWithoutConversationInput, videoCallUncheckedCreateWithoutConversationInput>
  }

  export type videoCallUpdateWithWhereUniqueWithoutConversationInput = {
    where: videoCallWhereUniqueInput
    data: XOR<videoCallUpdateWithoutConversationInput, videoCallUncheckedUpdateWithoutConversationInput>
  }

  export type videoCallUpdateManyWithWhereWithoutConversationInput = {
    where: videoCallScalarWhereInput
    data: XOR<videoCallUpdateManyMutationInput, videoCallUncheckedUpdateManyWithoutConversationInput>
  }

  export type videoCallScalarWhereInput = {
    AND?: videoCallScalarWhereInput | videoCallScalarWhereInput[]
    OR?: videoCallScalarWhereInput[]
    NOT?: videoCallScalarWhereInput | videoCallScalarWhereInput[]
    id?: StringFilter<"videoCall"> | string
    conversationId?: StringFilter<"videoCall"> | string
    initiatorId?: StringFilter<"videoCall"> | string
    startDate?: DateTimeFilter<"videoCall"> | Date | string
    endDate?: DateTimeFilter<"videoCall"> | Date | string
    status?: StringFilter<"videoCall"> | string
    createdAt?: DateTimeFilter<"videoCall"> | Date | string
    updatedAt?: DateTimeNullableFilter<"videoCall"> | Date | string | null
  }

  export type conversationCreateWithoutConversationParticipantInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    message?: messageCreateNestedManyWithoutConversationInput
    videoCall?: videoCallCreateNestedManyWithoutConversationInput
  }

  export type conversationUncheckedCreateWithoutConversationParticipantInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    message?: messageUncheckedCreateNestedManyWithoutConversationInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutConversationInput
  }

  export type conversationCreateOrConnectWithoutConversationParticipantInput = {
    where: conversationWhereUniqueInput
    create: XOR<conversationCreateWithoutConversationParticipantInput, conversationUncheckedCreateWithoutConversationParticipantInput>
  }

  export type userCreateWithoutConversationParticipantInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutConversationParticipantInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutConversationParticipantInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutConversationParticipantInput, userUncheckedCreateWithoutConversationParticipantInput>
  }

  export type conversationUpsertWithoutConversationParticipantInput = {
    update: XOR<conversationUpdateWithoutConversationParticipantInput, conversationUncheckedUpdateWithoutConversationParticipantInput>
    create: XOR<conversationCreateWithoutConversationParticipantInput, conversationUncheckedCreateWithoutConversationParticipantInput>
    where?: conversationWhereInput
  }

  export type conversationUpdateToOneWithWhereWithoutConversationParticipantInput = {
    where?: conversationWhereInput
    data: XOR<conversationUpdateWithoutConversationParticipantInput, conversationUncheckedUpdateWithoutConversationParticipantInput>
  }

  export type conversationUpdateWithoutConversationParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: messageUpdateManyWithoutConversationNestedInput
    videoCall?: videoCallUpdateManyWithoutConversationNestedInput
  }

  export type conversationUncheckedUpdateWithoutConversationParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: messageUncheckedUpdateManyWithoutConversationNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type userUpsertWithoutConversationParticipantInput = {
    update: XOR<userUpdateWithoutConversationParticipantInput, userUncheckedUpdateWithoutConversationParticipantInput>
    create: XOR<userCreateWithoutConversationParticipantInput, userUncheckedCreateWithoutConversationParticipantInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutConversationParticipantInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutConversationParticipantInput, userUncheckedUpdateWithoutConversationParticipantInput>
  }

  export type userUpdateWithoutConversationParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutConversationParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type programCategoryCreateWithoutExerciseProgramInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseCreateNestedManyWithoutProgramCategoryInput
  }

  export type programCategoryUncheckedCreateWithoutExerciseProgramInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseUncheckedCreateNestedManyWithoutProgramCategoryInput
  }

  export type programCategoryCreateOrConnectWithoutExerciseProgramInput = {
    where: programCategoryWhereUniqueInput
    create: XOR<programCategoryCreateWithoutExerciseProgramInput, programCategoryUncheckedCreateWithoutExerciseProgramInput>
  }

  export type userActivityCreateWithoutExerciseProgramInput = {
    id?: string
    completionDate: Date | string
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseCreateNestedOneWithoutUserActivityInput
    user: userCreateNestedOneWithoutUserActivityInput
  }

  export type userActivityUncheckedCreateWithoutExerciseProgramInput = {
    id?: string
    userId: string
    completionDate: Date | string
    cognitiveExerciseId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityCreateOrConnectWithoutExerciseProgramInput = {
    where: userActivityWhereUniqueInput
    create: XOR<userActivityCreateWithoutExerciseProgramInput, userActivityUncheckedCreateWithoutExerciseProgramInput>
  }

  export type userActivityCreateManyExerciseProgramInputEnvelope = {
    data: userActivityCreateManyExerciseProgramInput | userActivityCreateManyExerciseProgramInput[]
    skipDuplicates?: boolean
  }

  export type programCategoryUpsertWithoutExerciseProgramInput = {
    update: XOR<programCategoryUpdateWithoutExerciseProgramInput, programCategoryUncheckedUpdateWithoutExerciseProgramInput>
    create: XOR<programCategoryCreateWithoutExerciseProgramInput, programCategoryUncheckedCreateWithoutExerciseProgramInput>
    where?: programCategoryWhereInput
  }

  export type programCategoryUpdateToOneWithWhereWithoutExerciseProgramInput = {
    where?: programCategoryWhereInput
    data: XOR<programCategoryUpdateWithoutExerciseProgramInput, programCategoryUncheckedUpdateWithoutExerciseProgramInput>
  }

  export type programCategoryUpdateWithoutExerciseProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUpdateManyWithoutProgramCategoryNestedInput
  }

  export type programCategoryUncheckedUpdateWithoutExerciseProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUncheckedUpdateManyWithoutProgramCategoryNestedInput
  }

  export type userActivityUpsertWithWhereUniqueWithoutExerciseProgramInput = {
    where: userActivityWhereUniqueInput
    update: XOR<userActivityUpdateWithoutExerciseProgramInput, userActivityUncheckedUpdateWithoutExerciseProgramInput>
    create: XOR<userActivityCreateWithoutExerciseProgramInput, userActivityUncheckedCreateWithoutExerciseProgramInput>
  }

  export type userActivityUpdateWithWhereUniqueWithoutExerciseProgramInput = {
    where: userActivityWhereUniqueInput
    data: XOR<userActivityUpdateWithoutExerciseProgramInput, userActivityUncheckedUpdateWithoutExerciseProgramInput>
  }

  export type userActivityUpdateManyWithWhereWithoutExerciseProgramInput = {
    where: userActivityScalarWhereInput
    data: XOR<userActivityUpdateManyMutationInput, userActivityUncheckedUpdateManyWithoutExerciseProgramInput>
  }

  export type forumTopicCreateWithoutForumCategoryInput = {
    id?: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumMessage?: forumMessageCreateNestedManyWithoutForumTopicInput
    user: userCreateNestedOneWithoutForumTopicInput
  }

  export type forumTopicUncheckedCreateWithoutForumCategoryInput = {
    id?: string
    authorId: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutForumTopicInput
  }

  export type forumTopicCreateOrConnectWithoutForumCategoryInput = {
    where: forumTopicWhereUniqueInput
    create: XOR<forumTopicCreateWithoutForumCategoryInput, forumTopicUncheckedCreateWithoutForumCategoryInput>
  }

  export type forumTopicCreateManyForumCategoryInputEnvelope = {
    data: forumTopicCreateManyForumCategoryInput | forumTopicCreateManyForumCategoryInput[]
    skipDuplicates?: boolean
  }

  export type forumTopicUpsertWithWhereUniqueWithoutForumCategoryInput = {
    where: forumTopicWhereUniqueInput
    update: XOR<forumTopicUpdateWithoutForumCategoryInput, forumTopicUncheckedUpdateWithoutForumCategoryInput>
    create: XOR<forumTopicCreateWithoutForumCategoryInput, forumTopicUncheckedCreateWithoutForumCategoryInput>
  }

  export type forumTopicUpdateWithWhereUniqueWithoutForumCategoryInput = {
    where: forumTopicWhereUniqueInput
    data: XOR<forumTopicUpdateWithoutForumCategoryInput, forumTopicUncheckedUpdateWithoutForumCategoryInput>
  }

  export type forumTopicUpdateManyWithWhereWithoutForumCategoryInput = {
    where: forumTopicScalarWhereInput
    data: XOR<forumTopicUpdateManyMutationInput, forumTopicUncheckedUpdateManyWithoutForumCategoryInput>
  }

  export type forumTopicScalarWhereInput = {
    AND?: forumTopicScalarWhereInput | forumTopicScalarWhereInput[]
    OR?: forumTopicScalarWhereInput[]
    NOT?: forumTopicScalarWhereInput | forumTopicScalarWhereInput[]
    id?: StringFilter<"forumTopic"> | string
    categoryId?: StringFilter<"forumTopic"> | string
    authorId?: StringFilter<"forumTopic"> | string
    title?: StringFilter<"forumTopic"> | string
    pinned?: BoolNullableFilter<"forumTopic"> | boolean | null
    status?: StringNullableFilter<"forumTopic"> | string | null
    views?: IntNullableFilter<"forumTopic"> | number | null
    createdAt?: DateTimeFilter<"forumTopic"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumTopic"> | Date | string | null
  }

  export type userCreateWithoutForumMessageInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutForumMessageInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutForumMessageInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutForumMessageInput, userUncheckedCreateWithoutForumMessageInput>
  }

  export type forumTopicCreateWithoutForumMessageInput = {
    id?: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutForumTopicInput
    forumCategory?: forumCategoryCreateNestedOneWithoutForumTopicInput
  }

  export type forumTopicUncheckedCreateWithoutForumMessageInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumTopicCreateOrConnectWithoutForumMessageInput = {
    where: forumTopicWhereUniqueInput
    create: XOR<forumTopicCreateWithoutForumMessageInput, forumTopicUncheckedCreateWithoutForumMessageInput>
  }

  export type userUpsertWithoutForumMessageInput = {
    update: XOR<userUpdateWithoutForumMessageInput, userUncheckedUpdateWithoutForumMessageInput>
    create: XOR<userCreateWithoutForumMessageInput, userUncheckedCreateWithoutForumMessageInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutForumMessageInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutForumMessageInput, userUncheckedUpdateWithoutForumMessageInput>
  }

  export type userUpdateWithoutForumMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutForumMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type forumTopicUpsertWithoutForumMessageInput = {
    update: XOR<forumTopicUpdateWithoutForumMessageInput, forumTopicUncheckedUpdateWithoutForumMessageInput>
    create: XOR<forumTopicCreateWithoutForumMessageInput, forumTopicUncheckedCreateWithoutForumMessageInput>
    where?: forumTopicWhereInput
  }

  export type forumTopicUpdateToOneWithWhereWithoutForumMessageInput = {
    where?: forumTopicWhereInput
    data: XOR<forumTopicUpdateWithoutForumMessageInput, forumTopicUncheckedUpdateWithoutForumMessageInput>
  }

  export type forumTopicUpdateWithoutForumMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutForumTopicNestedInput
    forumCategory?: forumCategoryUpdateOneWithoutForumTopicNestedInput
  }

  export type forumTopicUncheckedUpdateWithoutForumMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageCreateWithoutForumTopicInput = {
    id?: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutForumMessageInput
  }

  export type forumMessageUncheckedCreateWithoutForumTopicInput = {
    id?: string
    authorId: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumMessageCreateOrConnectWithoutForumTopicInput = {
    where: forumMessageWhereUniqueInput
    create: XOR<forumMessageCreateWithoutForumTopicInput, forumMessageUncheckedCreateWithoutForumTopicInput>
  }

  export type forumMessageCreateManyForumTopicInputEnvelope = {
    data: forumMessageCreateManyForumTopicInput | forumMessageCreateManyForumTopicInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutForumTopicInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutForumTopicInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutForumTopicInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutForumTopicInput, userUncheckedCreateWithoutForumTopicInput>
  }

  export type forumCategoryCreateWithoutForumTopicInput = {
    id?: string
    name: string
    description?: string | null
    parentCategoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumCategoryUncheckedCreateWithoutForumTopicInput = {
    id?: string
    name: string
    description?: string | null
    parentCategoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumCategoryCreateOrConnectWithoutForumTopicInput = {
    where: forumCategoryWhereUniqueInput
    create: XOR<forumCategoryCreateWithoutForumTopicInput, forumCategoryUncheckedCreateWithoutForumTopicInput>
  }

  export type forumMessageUpsertWithWhereUniqueWithoutForumTopicInput = {
    where: forumMessageWhereUniqueInput
    update: XOR<forumMessageUpdateWithoutForumTopicInput, forumMessageUncheckedUpdateWithoutForumTopicInput>
    create: XOR<forumMessageCreateWithoutForumTopicInput, forumMessageUncheckedCreateWithoutForumTopicInput>
  }

  export type forumMessageUpdateWithWhereUniqueWithoutForumTopicInput = {
    where: forumMessageWhereUniqueInput
    data: XOR<forumMessageUpdateWithoutForumTopicInput, forumMessageUncheckedUpdateWithoutForumTopicInput>
  }

  export type forumMessageUpdateManyWithWhereWithoutForumTopicInput = {
    where: forumMessageScalarWhereInput
    data: XOR<forumMessageUpdateManyMutationInput, forumMessageUncheckedUpdateManyWithoutForumTopicInput>
  }

  export type forumMessageScalarWhereInput = {
    AND?: forumMessageScalarWhereInput | forumMessageScalarWhereInput[]
    OR?: forumMessageScalarWhereInput[]
    NOT?: forumMessageScalarWhereInput | forumMessageScalarWhereInput[]
    id?: StringFilter<"forumMessage"> | string
    topicId?: StringFilter<"forumMessage"> | string
    authorId?: StringFilter<"forumMessage"> | string
    content?: StringFilter<"forumMessage"> | string
    solutionMessage?: BoolNullableFilter<"forumMessage"> | boolean | null
    createdAt?: DateTimeFilter<"forumMessage"> | Date | string
    updatedAt?: DateTimeNullableFilter<"forumMessage"> | Date | string | null
  }

  export type userUpsertWithoutForumTopicInput = {
    update: XOR<userUpdateWithoutForumTopicInput, userUncheckedUpdateWithoutForumTopicInput>
    create: XOR<userCreateWithoutForumTopicInput, userUncheckedCreateWithoutForumTopicInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutForumTopicInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutForumTopicInput, userUncheckedUpdateWithoutForumTopicInput>
  }

  export type userUpdateWithoutForumTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutForumTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type forumCategoryUpsertWithoutForumTopicInput = {
    update: XOR<forumCategoryUpdateWithoutForumTopicInput, forumCategoryUncheckedUpdateWithoutForumTopicInput>
    create: XOR<forumCategoryCreateWithoutForumTopicInput, forumCategoryUncheckedCreateWithoutForumTopicInput>
    where?: forumCategoryWhereInput
  }

  export type forumCategoryUpdateToOneWithWhereWithoutForumTopicInput = {
    where?: forumCategoryWhereInput
    data: XOR<forumCategoryUpdateWithoutForumTopicInput, forumCategoryUncheckedUpdateWithoutForumTopicInput>
  }

  export type forumCategoryUpdateWithoutForumTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumCategoryUncheckedUpdateWithoutForumTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateWithoutHealthIndicatorInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutHealthIndicatorInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutHealthIndicatorInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutHealthIndicatorInput, userUncheckedCreateWithoutHealthIndicatorInput>
  }

  export type userUpsertWithoutHealthIndicatorInput = {
    update: XOR<userUpdateWithoutHealthIndicatorInput, userUncheckedUpdateWithoutHealthIndicatorInput>
    create: XOR<userCreateWithoutHealthIndicatorInput, userUncheckedCreateWithoutHealthIndicatorInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutHealthIndicatorInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutHealthIndicatorInput, userUncheckedUpdateWithoutHealthIndicatorInput>
  }

  export type userUpdateWithoutHealthIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutHealthIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutHelpOfferInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutHelpOfferInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutHelpOfferInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutHelpOfferInput, userUncheckedCreateWithoutHelpOfferInput>
  }

  export type helpRequestCreateWithoutHelpOfferInput = {
    id?: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutHelpRequestInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutHelpRequestInput
    helpCategory?: helpCategoryCreateNestedOneWithoutHelpRequestInput
  }

  export type helpRequestUncheckedCreateWithoutHelpOfferInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    categoryId: string
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutHelpRequestInput
  }

  export type helpRequestCreateOrConnectWithoutHelpOfferInput = {
    where: helpRequestWhereUniqueInput
    create: XOR<helpRequestCreateWithoutHelpOfferInput, helpRequestUncheckedCreateWithoutHelpOfferInput>
  }

  export type userUpsertWithoutHelpOfferInput = {
    update: XOR<userUpdateWithoutHelpOfferInput, userUncheckedUpdateWithoutHelpOfferInput>
    create: XOR<userCreateWithoutHelpOfferInput, userUncheckedCreateWithoutHelpOfferInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutHelpOfferInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutHelpOfferInput, userUncheckedUpdateWithoutHelpOfferInput>
  }

  export type userUpdateWithoutHelpOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutHelpOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type helpRequestUpsertWithoutHelpOfferInput = {
    update: XOR<helpRequestUpdateWithoutHelpOfferInput, helpRequestUncheckedUpdateWithoutHelpOfferInput>
    create: XOR<helpRequestCreateWithoutHelpOfferInput, helpRequestUncheckedCreateWithoutHelpOfferInput>
    where?: helpRequestWhereInput
  }

  export type helpRequestUpdateToOneWithWhereWithoutHelpOfferInput = {
    where?: helpRequestWhereInput
    data: XOR<helpRequestUpdateWithoutHelpOfferInput, helpRequestUncheckedUpdateWithoutHelpOfferInput>
  }

  export type helpRequestUpdateWithoutHelpOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutHelpRequestNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutHelpRequestNestedInput
    helpCategory?: helpCategoryUpdateOneWithoutHelpRequestNestedInput
  }

  export type helpRequestUncheckedUpdateWithoutHelpOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutHelpRequestNestedInput
  }

  export type helpOfferCreateWithoutHelpRequestInput = {
    id?: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutHelpOfferInput
  }

  export type helpOfferUncheckedCreateWithoutHelpRequestInput = {
    id?: string
    helperId: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpOfferCreateOrConnectWithoutHelpRequestInput = {
    where: helpOfferWhereUniqueInput
    create: XOR<helpOfferCreateWithoutHelpRequestInput, helpOfferUncheckedCreateWithoutHelpRequestInput>
  }

  export type helpOfferCreateManyHelpRequestInputEnvelope = {
    data: helpOfferCreateManyHelpRequestInput | helpOfferCreateManyHelpRequestInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutHelpRequestInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutHelpRequestInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutHelpRequestInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutHelpRequestInput, userUncheckedCreateWithoutHelpRequestInput>
  }

  export type serviceCompletedCreateWithoutHelpRequestInput = {
    id?: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutServiceCompletedInput
  }

  export type serviceCompletedUncheckedCreateWithoutHelpRequestInput = {
    id?: string
    helperId: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCompletedCreateOrConnectWithoutHelpRequestInput = {
    where: serviceCompletedWhereUniqueInput
    create: XOR<serviceCompletedCreateWithoutHelpRequestInput, serviceCompletedUncheckedCreateWithoutHelpRequestInput>
  }

  export type serviceCompletedCreateManyHelpRequestInputEnvelope = {
    data: serviceCompletedCreateManyHelpRequestInput | serviceCompletedCreateManyHelpRequestInput[]
    skipDuplicates?: boolean
  }

  export type helpCategoryCreateWithoutHelpRequestInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpCategoryUncheckedCreateWithoutHelpRequestInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpCategoryCreateOrConnectWithoutHelpRequestInput = {
    where: helpCategoryWhereUniqueInput
    create: XOR<helpCategoryCreateWithoutHelpRequestInput, helpCategoryUncheckedCreateWithoutHelpRequestInput>
  }

  export type helpOfferUpsertWithWhereUniqueWithoutHelpRequestInput = {
    where: helpOfferWhereUniqueInput
    update: XOR<helpOfferUpdateWithoutHelpRequestInput, helpOfferUncheckedUpdateWithoutHelpRequestInput>
    create: XOR<helpOfferCreateWithoutHelpRequestInput, helpOfferUncheckedCreateWithoutHelpRequestInput>
  }

  export type helpOfferUpdateWithWhereUniqueWithoutHelpRequestInput = {
    where: helpOfferWhereUniqueInput
    data: XOR<helpOfferUpdateWithoutHelpRequestInput, helpOfferUncheckedUpdateWithoutHelpRequestInput>
  }

  export type helpOfferUpdateManyWithWhereWithoutHelpRequestInput = {
    where: helpOfferScalarWhereInput
    data: XOR<helpOfferUpdateManyMutationInput, helpOfferUncheckedUpdateManyWithoutHelpRequestInput>
  }

  export type helpOfferScalarWhereInput = {
    AND?: helpOfferScalarWhereInput | helpOfferScalarWhereInput[]
    OR?: helpOfferScalarWhereInput[]
    NOT?: helpOfferScalarWhereInput | helpOfferScalarWhereInput[]
    id?: StringFilter<"helpOffer"> | string
    requestId?: StringFilter<"helpOffer"> | string
    helperId?: StringFilter<"helpOffer"> | string
    offerDate?: DateTimeFilter<"helpOffer"> | Date | string
    message?: StringNullableFilter<"helpOffer"> | string | null
    status?: StringNullableFilter<"helpOffer"> | string | null
    createdAt?: DateTimeFilter<"helpOffer"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpOffer"> | Date | string | null
  }

  export type userUpsertWithoutHelpRequestInput = {
    update: XOR<userUpdateWithoutHelpRequestInput, userUncheckedUpdateWithoutHelpRequestInput>
    create: XOR<userCreateWithoutHelpRequestInput, userUncheckedCreateWithoutHelpRequestInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutHelpRequestInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutHelpRequestInput, userUncheckedUpdateWithoutHelpRequestInput>
  }

  export type userUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type serviceCompletedUpsertWithWhereUniqueWithoutHelpRequestInput = {
    where: serviceCompletedWhereUniqueInput
    update: XOR<serviceCompletedUpdateWithoutHelpRequestInput, serviceCompletedUncheckedUpdateWithoutHelpRequestInput>
    create: XOR<serviceCompletedCreateWithoutHelpRequestInput, serviceCompletedUncheckedCreateWithoutHelpRequestInput>
  }

  export type serviceCompletedUpdateWithWhereUniqueWithoutHelpRequestInput = {
    where: serviceCompletedWhereUniqueInput
    data: XOR<serviceCompletedUpdateWithoutHelpRequestInput, serviceCompletedUncheckedUpdateWithoutHelpRequestInput>
  }

  export type serviceCompletedUpdateManyWithWhereWithoutHelpRequestInput = {
    where: serviceCompletedScalarWhereInput
    data: XOR<serviceCompletedUpdateManyMutationInput, serviceCompletedUncheckedUpdateManyWithoutHelpRequestInput>
  }

  export type serviceCompletedScalarWhereInput = {
    AND?: serviceCompletedScalarWhereInput | serviceCompletedScalarWhereInput[]
    OR?: serviceCompletedScalarWhereInput[]
    NOT?: serviceCompletedScalarWhereInput | serviceCompletedScalarWhereInput[]
    id?: StringFilter<"serviceCompleted"> | string
    requestId?: StringFilter<"serviceCompleted"> | string
    helperId?: StringFilter<"serviceCompleted"> | string
    completionDate?: DateTimeFilter<"serviceCompleted"> | Date | string
    actualDuration?: IntNullableFilter<"serviceCompleted"> | number | null
    creatorComment?: StringNullableFilter<"serviceCompleted"> | string | null
    helperComment?: StringNullableFilter<"serviceCompleted"> | string | null
    creatorRating?: IntNullableFilter<"serviceCompleted"> | number | null
    helperRating?: IntNullableFilter<"serviceCompleted"> | number | null
    pointsExchanged?: IntNullableFilter<"serviceCompleted"> | number | null
    createdAt?: DateTimeFilter<"serviceCompleted"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceCompleted"> | Date | string | null
  }

  export type helpCategoryUpsertWithoutHelpRequestInput = {
    update: XOR<helpCategoryUpdateWithoutHelpRequestInput, helpCategoryUncheckedUpdateWithoutHelpRequestInput>
    create: XOR<helpCategoryCreateWithoutHelpRequestInput, helpCategoryUncheckedCreateWithoutHelpRequestInput>
    where?: helpCategoryWhereInput
  }

  export type helpCategoryUpdateToOneWithWhereWithoutHelpRequestInput = {
    where?: helpCategoryWhereInput
    data: XOR<helpCategoryUpdateWithoutHelpRequestInput, helpCategoryUncheckedUpdateWithoutHelpRequestInput>
  }

  export type helpCategoryUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpCategoryUncheckedUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCategoryCreateWithoutLocalServiceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCategoryUncheckedCreateWithoutLocalServiceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCategoryCreateOrConnectWithoutLocalServiceInput = {
    where: serviceCategoryWhereUniqueInput
    create: XOR<serviceCategoryCreateWithoutLocalServiceInput, serviceCategoryUncheckedCreateWithoutLocalServiceInput>
  }

  export type serviceRatingCreateWithoutLocalServiceInput = {
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutServiceRatingInput
  }

  export type serviceRatingUncheckedCreateWithoutLocalServiceInput = {
    userId: string
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceRatingCreateOrConnectWithoutLocalServiceInput = {
    where: serviceRatingWhereUniqueInput
    create: XOR<serviceRatingCreateWithoutLocalServiceInput, serviceRatingUncheckedCreateWithoutLocalServiceInput>
  }

  export type serviceRatingCreateManyLocalServiceInputEnvelope = {
    data: serviceRatingCreateManyLocalServiceInput | serviceRatingCreateManyLocalServiceInput[]
    skipDuplicates?: boolean
  }

  export type serviceCategoryUpsertWithoutLocalServiceInput = {
    update: XOR<serviceCategoryUpdateWithoutLocalServiceInput, serviceCategoryUncheckedUpdateWithoutLocalServiceInput>
    create: XOR<serviceCategoryCreateWithoutLocalServiceInput, serviceCategoryUncheckedCreateWithoutLocalServiceInput>
    where?: serviceCategoryWhereInput
  }

  export type serviceCategoryUpdateToOneWithWhereWithoutLocalServiceInput = {
    where?: serviceCategoryWhereInput
    data: XOR<serviceCategoryUpdateWithoutLocalServiceInput, serviceCategoryUncheckedUpdateWithoutLocalServiceInput>
  }

  export type serviceCategoryUpdateWithoutLocalServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCategoryUncheckedUpdateWithoutLocalServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingUpsertWithWhereUniqueWithoutLocalServiceInput = {
    where: serviceRatingWhereUniqueInput
    update: XOR<serviceRatingUpdateWithoutLocalServiceInput, serviceRatingUncheckedUpdateWithoutLocalServiceInput>
    create: XOR<serviceRatingCreateWithoutLocalServiceInput, serviceRatingUncheckedCreateWithoutLocalServiceInput>
  }

  export type serviceRatingUpdateWithWhereUniqueWithoutLocalServiceInput = {
    where: serviceRatingWhereUniqueInput
    data: XOR<serviceRatingUpdateWithoutLocalServiceInput, serviceRatingUncheckedUpdateWithoutLocalServiceInput>
  }

  export type serviceRatingUpdateManyWithWhereWithoutLocalServiceInput = {
    where: serviceRatingScalarWhereInput
    data: XOR<serviceRatingUpdateManyMutationInput, serviceRatingUncheckedUpdateManyWithoutLocalServiceInput>
  }

  export type serviceRatingScalarWhereInput = {
    AND?: serviceRatingScalarWhereInput | serviceRatingScalarWhereInput[]
    OR?: serviceRatingScalarWhereInput[]
    NOT?: serviceRatingScalarWhereInput | serviceRatingScalarWhereInput[]
    serviceId?: StringFilter<"serviceRating"> | string
    userId?: StringFilter<"serviceRating"> | string
    rating?: IntNullableFilter<"serviceRating"> | number | null
    comment?: StringNullableFilter<"serviceRating"> | string | null
    ratingDate?: DateTimeNullableFilter<"serviceRating"> | Date | string | null
    createdAt?: DateTimeFilter<"serviceRating"> | Date | string
    updatedAt?: DateTimeNullableFilter<"serviceRating"> | Date | string | null
  }

  export type userCreateWithoutMedicationReminderInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMedicationReminderInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMedicationReminderInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMedicationReminderInput, userUncheckedCreateWithoutMedicationReminderInput>
  }

  export type userUpsertWithoutMedicationReminderInput = {
    update: XOR<userUpdateWithoutMedicationReminderInput, userUncheckedUpdateWithoutMedicationReminderInput>
    create: XOR<userCreateWithoutMedicationReminderInput, userUncheckedCreateWithoutMedicationReminderInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMedicationReminderInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMedicationReminderInput, userUncheckedUpdateWithoutMedicationReminderInput>
  }

  export type userUpdateWithoutMedicationReminderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMedicationReminderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type conversationCreateWithoutMessageInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutConversationInput
    videoCall?: videoCallCreateNestedManyWithoutConversationInput
  }

  export type conversationUncheckedCreateWithoutMessageInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutConversationInput
  }

  export type conversationCreateOrConnectWithoutMessageInput = {
    where: conversationWhereUniqueInput
    create: XOR<conversationCreateWithoutMessageInput, conversationUncheckedCreateWithoutMessageInput>
  }

  export type userCreateWithoutMessageInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMessageInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMessageInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
  }

  export type conversationUpsertWithoutMessageInput = {
    update: XOR<conversationUpdateWithoutMessageInput, conversationUncheckedUpdateWithoutMessageInput>
    create: XOR<conversationCreateWithoutMessageInput, conversationUncheckedCreateWithoutMessageInput>
    where?: conversationWhereInput
  }

  export type conversationUpdateToOneWithWhereWithoutMessageInput = {
    where?: conversationWhereInput
    data: XOR<conversationUpdateWithoutMessageInput, conversationUncheckedUpdateWithoutMessageInput>
  }

  export type conversationUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationParticipant?: conversationParticipantUpdateManyWithoutConversationNestedInput
    videoCall?: videoCallUpdateManyWithoutConversationNestedInput
  }

  export type conversationUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type userUpsertWithoutMessageInput = {
    update: XOR<userUpdateWithoutMessageInput, userUncheckedUpdateWithoutMessageInput>
    create: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMessageInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMessageInput, userUncheckedUpdateWithoutMessageInput>
  }

  export type userUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutNotificationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotificationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotificationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
  }

  export type userUpsertWithoutNotificationInput = {
    update: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotificationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
  }

  export type userUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotificationPreferencesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotificationPreferencesInput, userUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type userUpsertWithoutNotificationPreferencesInput = {
    update: XOR<userUpdateWithoutNotificationPreferencesInput, userUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<userCreateWithoutNotificationPreferencesInput, userUncheckedCreateWithoutNotificationPreferencesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotificationPreferencesInput, userUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type userUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type nutritionalCategoryCreateWithoutNutritionalAdviceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalCategoryUncheckedCreateWithoutNutritionalAdviceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalCategoryCreateOrConnectWithoutNutritionalAdviceInput = {
    where: nutritionalCategoryWhereUniqueInput
    create: XOR<nutritionalCategoryCreateWithoutNutritionalAdviceInput, nutritionalCategoryUncheckedCreateWithoutNutritionalAdviceInput>
  }

  export type nutritionalCategoryUpsertWithoutNutritionalAdviceInput = {
    update: XOR<nutritionalCategoryUpdateWithoutNutritionalAdviceInput, nutritionalCategoryUncheckedUpdateWithoutNutritionalAdviceInput>
    create: XOR<nutritionalCategoryCreateWithoutNutritionalAdviceInput, nutritionalCategoryUncheckedCreateWithoutNutritionalAdviceInput>
    where?: nutritionalCategoryWhereInput
  }

  export type nutritionalCategoryUpdateToOneWithWhereWithoutNutritionalAdviceInput = {
    where?: nutritionalCategoryWhereInput
    data: XOR<nutritionalCategoryUpdateWithoutNutritionalAdviceInput, nutritionalCategoryUncheckedUpdateWithoutNutritionalAdviceInput>
  }

  export type nutritionalCategoryUpdateWithoutNutritionalAdviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalCategoryUncheckedUpdateWithoutNutritionalAdviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collaborativeProjectCreateWithoutProjectMemberInput = {
    id?: string
    title: string
    description?: string | null
    creationDate?: Date | string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutCollaborativeProjectInput
    projectCategory?: projectCategoryCreateNestedOneWithoutCollaborativeProjectInput
    projectTask?: projectTaskCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectUncheckedCreateWithoutProjectMemberInput = {
    id?: string
    title: string
    description?: string | null
    creatorId: string
    creationDate?: Date | string
    status?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectCreateOrConnectWithoutProjectMemberInput = {
    where: collaborativeProjectWhereUniqueInput
    create: XOR<collaborativeProjectCreateWithoutProjectMemberInput, collaborativeProjectUncheckedCreateWithoutProjectMemberInput>
  }

  export type userCreateWithoutProjectMemberInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProjectMemberInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProjectMemberInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProjectMemberInput, userUncheckedCreateWithoutProjectMemberInput>
  }

  export type collaborativeProjectUpsertWithoutProjectMemberInput = {
    update: XOR<collaborativeProjectUpdateWithoutProjectMemberInput, collaborativeProjectUncheckedUpdateWithoutProjectMemberInput>
    create: XOR<collaborativeProjectCreateWithoutProjectMemberInput, collaborativeProjectUncheckedCreateWithoutProjectMemberInput>
    where?: collaborativeProjectWhereInput
  }

  export type collaborativeProjectUpdateToOneWithWhereWithoutProjectMemberInput = {
    where?: collaborativeProjectWhereInput
    data: XOR<collaborativeProjectUpdateWithoutProjectMemberInput, collaborativeProjectUncheckedUpdateWithoutProjectMemberInput>
  }

  export type collaborativeProjectUpdateWithoutProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutCollaborativeProjectNestedInput
    projectCategory?: projectCategoryUpdateOneWithoutCollaborativeProjectNestedInput
    projectTask?: projectTaskUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectUncheckedUpdateWithoutProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectTask?: projectTaskUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type userUpsertWithoutProjectMemberInput = {
    update: XOR<userUpdateWithoutProjectMemberInput, userUncheckedUpdateWithoutProjectMemberInput>
    create: XOR<userCreateWithoutProjectMemberInput, userUncheckedCreateWithoutProjectMemberInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProjectMemberInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProjectMemberInput, userUncheckedUpdateWithoutProjectMemberInput>
  }

  export type userUpdateWithoutProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutProjectTaskInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProjectTaskInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProjectTaskInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
  }

  export type collaborativeProjectCreateWithoutProjectTaskInput = {
    id?: string
    title: string
    description?: string | null
    creationDate?: Date | string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutCollaborativeProjectInput
    projectCategory?: projectCategoryCreateNestedOneWithoutCollaborativeProjectInput
    projectMember?: projectMemberCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectUncheckedCreateWithoutProjectTaskInput = {
    id?: string
    title: string
    description?: string | null
    creatorId: string
    creationDate?: Date | string
    status?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectCreateOrConnectWithoutProjectTaskInput = {
    where: collaborativeProjectWhereUniqueInput
    create: XOR<collaborativeProjectCreateWithoutProjectTaskInput, collaborativeProjectUncheckedCreateWithoutProjectTaskInput>
  }

  export type userUpsertWithoutProjectTaskInput = {
    update: XOR<userUpdateWithoutProjectTaskInput, userUncheckedUpdateWithoutProjectTaskInput>
    create: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProjectTaskInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProjectTaskInput, userUncheckedUpdateWithoutProjectTaskInput>
  }

  export type userUpdateWithoutProjectTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProjectTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type collaborativeProjectUpsertWithoutProjectTaskInput = {
    update: XOR<collaborativeProjectUpdateWithoutProjectTaskInput, collaborativeProjectUncheckedUpdateWithoutProjectTaskInput>
    create: XOR<collaborativeProjectCreateWithoutProjectTaskInput, collaborativeProjectUncheckedCreateWithoutProjectTaskInput>
    where?: collaborativeProjectWhereInput
  }

  export type collaborativeProjectUpdateToOneWithWhereWithoutProjectTaskInput = {
    where?: collaborativeProjectWhereInput
    data: XOR<collaborativeProjectUpdateWithoutProjectTaskInput, collaborativeProjectUncheckedUpdateWithoutProjectTaskInput>
  }

  export type collaborativeProjectUpdateWithoutProjectTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutCollaborativeProjectNestedInput
    projectCategory?: projectCategoryUpdateOneWithoutCollaborativeProjectNestedInput
    projectMember?: projectMemberUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectUncheckedUpdateWithoutProjectTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectMember?: projectMemberUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type userCreateWithoutResourceInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutResourceInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutResourceInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutResourceInput, userUncheckedCreateWithoutResourceInput>
  }

  export type resourceCategoryCreateWithoutResourceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceCategoryUncheckedCreateWithoutResourceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceCategoryCreateOrConnectWithoutResourceInput = {
    where: resourceCategoryWhereUniqueInput
    create: XOR<resourceCategoryCreateWithoutResourceInput, resourceCategoryUncheckedCreateWithoutResourceInput>
  }

  export type userUpsertWithoutResourceInput = {
    update: XOR<userUpdateWithoutResourceInput, userUncheckedUpdateWithoutResourceInput>
    create: XOR<userCreateWithoutResourceInput, userUncheckedCreateWithoutResourceInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutResourceInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutResourceInput, userUncheckedUpdateWithoutResourceInput>
  }

  export type userUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type resourceCategoryUpsertWithoutResourceInput = {
    update: XOR<resourceCategoryUpdateWithoutResourceInput, resourceCategoryUncheckedUpdateWithoutResourceInput>
    create: XOR<resourceCategoryCreateWithoutResourceInput, resourceCategoryUncheckedCreateWithoutResourceInput>
    where?: resourceCategoryWhereInput
  }

  export type resourceCategoryUpdateToOneWithWhereWithoutResourceInput = {
    where?: resourceCategoryWhereInput
    data: XOR<resourceCategoryUpdateWithoutResourceInput, resourceCategoryUncheckedUpdateWithoutResourceInput>
  }

  export type resourceCategoryUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceCategoryUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseCreateWithoutSatisfactionSurveyInput = {
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutSurveyResponseInput
  }

  export type surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput = {
    userId: string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type surveyResponseCreateOrConnectWithoutSatisfactionSurveyInput = {
    where: surveyResponseWhereUniqueInput
    create: XOR<surveyResponseCreateWithoutSatisfactionSurveyInput, surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput>
  }

  export type surveyResponseCreateManySatisfactionSurveyInputEnvelope = {
    data: surveyResponseCreateManySatisfactionSurveyInput | surveyResponseCreateManySatisfactionSurveyInput[]
    skipDuplicates?: boolean
  }

  export type surveyResponseUpsertWithWhereUniqueWithoutSatisfactionSurveyInput = {
    where: surveyResponseWhereUniqueInput
    update: XOR<surveyResponseUpdateWithoutSatisfactionSurveyInput, surveyResponseUncheckedUpdateWithoutSatisfactionSurveyInput>
    create: XOR<surveyResponseCreateWithoutSatisfactionSurveyInput, surveyResponseUncheckedCreateWithoutSatisfactionSurveyInput>
  }

  export type surveyResponseUpdateWithWhereUniqueWithoutSatisfactionSurveyInput = {
    where: surveyResponseWhereUniqueInput
    data: XOR<surveyResponseUpdateWithoutSatisfactionSurveyInput, surveyResponseUncheckedUpdateWithoutSatisfactionSurveyInput>
  }

  export type surveyResponseUpdateManyWithWhereWithoutSatisfactionSurveyInput = {
    where: surveyResponseScalarWhereInput
    data: XOR<surveyResponseUpdateManyMutationInput, surveyResponseUncheckedUpdateManyWithoutSatisfactionSurveyInput>
  }

  export type surveyResponseScalarWhereInput = {
    AND?: surveyResponseScalarWhereInput | surveyResponseScalarWhereInput[]
    OR?: surveyResponseScalarWhereInput[]
    NOT?: surveyResponseScalarWhereInput | surveyResponseScalarWhereInput[]
    surveyId?: StringFilter<"surveyResponse"> | string
    userId?: StringFilter<"surveyResponse"> | string
    responses?: JsonNullableFilter<"surveyResponse">
    response_date?: DateTimeNullableFilter<"surveyResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"surveyResponse"> | Date | string
    updatedAt?: DateTimeNullableFilter<"surveyResponse"> | Date | string | null
  }

  export type userCreateWithoutSessionInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSessionInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSessionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
  }

  export type userUpsertWithoutSessionInput = {
    update: XOR<userUpdateWithoutSessionInput, userUncheckedUpdateWithoutSessionInput>
    create: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSessionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSessionInput, userUncheckedUpdateWithoutSessionInput>
  }

  export type userUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutServiceCompletedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutServiceCompletedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutServiceCompletedInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutServiceCompletedInput, userUncheckedCreateWithoutServiceCompletedInput>
  }

  export type helpRequestCreateWithoutServiceCompletedInput = {
    id?: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferCreateNestedManyWithoutHelpRequestInput
    user: userCreateNestedOneWithoutHelpRequestInput
    helpCategory?: helpCategoryCreateNestedOneWithoutHelpRequestInput
  }

  export type helpRequestUncheckedCreateWithoutServiceCompletedInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    categoryId: string
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutHelpRequestInput
  }

  export type helpRequestCreateOrConnectWithoutServiceCompletedInput = {
    where: helpRequestWhereUniqueInput
    create: XOR<helpRequestCreateWithoutServiceCompletedInput, helpRequestUncheckedCreateWithoutServiceCompletedInput>
  }

  export type userUpsertWithoutServiceCompletedInput = {
    update: XOR<userUpdateWithoutServiceCompletedInput, userUncheckedUpdateWithoutServiceCompletedInput>
    create: XOR<userCreateWithoutServiceCompletedInput, userUncheckedCreateWithoutServiceCompletedInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutServiceCompletedInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutServiceCompletedInput, userUncheckedUpdateWithoutServiceCompletedInput>
  }

  export type userUpdateWithoutServiceCompletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutServiceCompletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type helpRequestUpsertWithoutServiceCompletedInput = {
    update: XOR<helpRequestUpdateWithoutServiceCompletedInput, helpRequestUncheckedUpdateWithoutServiceCompletedInput>
    create: XOR<helpRequestCreateWithoutServiceCompletedInput, helpRequestUncheckedCreateWithoutServiceCompletedInput>
    where?: helpRequestWhereInput
  }

  export type helpRequestUpdateToOneWithWhereWithoutServiceCompletedInput = {
    where?: helpRequestWhereInput
    data: XOR<helpRequestUpdateWithoutServiceCompletedInput, helpRequestUncheckedUpdateWithoutServiceCompletedInput>
  }

  export type helpRequestUpdateWithoutServiceCompletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUpdateManyWithoutHelpRequestNestedInput
    user?: userUpdateOneRequiredWithoutHelpRequestNestedInput
    helpCategory?: helpCategoryUpdateOneWithoutHelpRequestNestedInput
  }

  export type helpRequestUncheckedUpdateWithoutServiceCompletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUncheckedUpdateManyWithoutHelpRequestNestedInput
  }

  export type localServiceCreateWithoutServiceRatingInput = {
    id?: string
    name: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    serviceCategory?: serviceCategoryCreateNestedOneWithoutLocalServiceInput
  }

  export type localServiceUncheckedCreateWithoutServiceRatingInput = {
    id?: string
    name: string
    categoryId: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type localServiceCreateOrConnectWithoutServiceRatingInput = {
    where: localServiceWhereUniqueInput
    create: XOR<localServiceCreateWithoutServiceRatingInput, localServiceUncheckedCreateWithoutServiceRatingInput>
  }

  export type userCreateWithoutServiceRatingInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutServiceRatingInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutServiceRatingInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutServiceRatingInput, userUncheckedCreateWithoutServiceRatingInput>
  }

  export type localServiceUpsertWithoutServiceRatingInput = {
    update: XOR<localServiceUpdateWithoutServiceRatingInput, localServiceUncheckedUpdateWithoutServiceRatingInput>
    create: XOR<localServiceCreateWithoutServiceRatingInput, localServiceUncheckedCreateWithoutServiceRatingInput>
    where?: localServiceWhereInput
  }

  export type localServiceUpdateToOneWithWhereWithoutServiceRatingInput = {
    where?: localServiceWhereInput
    data: XOR<localServiceUpdateWithoutServiceRatingInput, localServiceUncheckedUpdateWithoutServiceRatingInput>
  }

  export type localServiceUpdateWithoutServiceRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCategory?: serviceCategoryUpdateOneWithoutLocalServiceNestedInput
  }

  export type localServiceUncheckedUpdateWithoutServiceRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutServiceRatingInput = {
    update: XOR<userUpdateWithoutServiceRatingInput, userUncheckedUpdateWithoutServiceRatingInput>
    create: XOR<userCreateWithoutServiceRatingInput, userUncheckedCreateWithoutServiceRatingInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutServiceRatingInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutServiceRatingInput, userUncheckedUpdateWithoutServiceRatingInput>
  }

  export type userUpdateWithoutServiceRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutServiceRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type skillCategoryCreateWithoutSkillInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type skillCategoryUncheckedCreateWithoutSkillInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type skillCategoryCreateOrConnectWithoutSkillInput = {
    where: skillCategoryWhereUniqueInput
    create: XOR<skillCategoryCreateWithoutSkillInput, skillCategoryUncheckedCreateWithoutSkillInput>
  }

  export type userSkillCreateWithoutSkillInput = {
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
    user: userCreateNestedOneWithoutUserSkillInput
  }

  export type userSkillUncheckedCreateWithoutSkillInput = {
    userId: string
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
  }

  export type userSkillCreateOrConnectWithoutSkillInput = {
    where: userSkillWhereUniqueInput
    create: XOR<userSkillCreateWithoutSkillInput, userSkillUncheckedCreateWithoutSkillInput>
  }

  export type userSkillCreateManySkillInputEnvelope = {
    data: userSkillCreateManySkillInput | userSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type skillCategoryUpsertWithoutSkillInput = {
    update: XOR<skillCategoryUpdateWithoutSkillInput, skillCategoryUncheckedUpdateWithoutSkillInput>
    create: XOR<skillCategoryCreateWithoutSkillInput, skillCategoryUncheckedCreateWithoutSkillInput>
    where?: skillCategoryWhereInput
  }

  export type skillCategoryUpdateToOneWithWhereWithoutSkillInput = {
    where?: skillCategoryWhereInput
    data: XOR<skillCategoryUpdateWithoutSkillInput, skillCategoryUncheckedUpdateWithoutSkillInput>
  }

  export type skillCategoryUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type skillCategoryUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: userSkillWhereUniqueInput
    update: XOR<userSkillUpdateWithoutSkillInput, userSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<userSkillCreateWithoutSkillInput, userSkillUncheckedCreateWithoutSkillInput>
  }

  export type userSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: userSkillWhereUniqueInput
    data: XOR<userSkillUpdateWithoutSkillInput, userSkillUncheckedUpdateWithoutSkillInput>
  }

  export type userSkillUpdateManyWithWhereWithoutSkillInput = {
    where: userSkillScalarWhereInput
    data: XOR<userSkillUpdateManyMutationInput, userSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type userSkillScalarWhereInput = {
    AND?: userSkillScalarWhereInput | userSkillScalarWhereInput[]
    OR?: userSkillScalarWhereInput[]
    NOT?: userSkillScalarWhereInput | userSkillScalarWhereInput[]
    userId?: StringFilter<"userSkill"> | string
    skillId?: StringFilter<"userSkill"> | string
    level?: IntNullableFilter<"userSkill"> | number | null
    created_at?: DateTimeFilter<"userSkill"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userSkill"> | Date | string | null
  }

  export type satisfactionSurveyCreateWithoutSurveyResponseInput = {
    id?: string
    title: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type satisfactionSurveyUncheckedCreateWithoutSurveyResponseInput = {
    id?: string
    title: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type satisfactionSurveyCreateOrConnectWithoutSurveyResponseInput = {
    where: satisfactionSurveyWhereUniqueInput
    create: XOR<satisfactionSurveyCreateWithoutSurveyResponseInput, satisfactionSurveyUncheckedCreateWithoutSurveyResponseInput>
  }

  export type userCreateWithoutSurveyResponseInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSurveyResponseInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSurveyResponseInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSurveyResponseInput, userUncheckedCreateWithoutSurveyResponseInput>
  }

  export type satisfactionSurveyUpsertWithoutSurveyResponseInput = {
    update: XOR<satisfactionSurveyUpdateWithoutSurveyResponseInput, satisfactionSurveyUncheckedUpdateWithoutSurveyResponseInput>
    create: XOR<satisfactionSurveyCreateWithoutSurveyResponseInput, satisfactionSurveyUncheckedCreateWithoutSurveyResponseInput>
    where?: satisfactionSurveyWhereInput
  }

  export type satisfactionSurveyUpdateToOneWithWhereWithoutSurveyResponseInput = {
    where?: satisfactionSurveyWhereInput
    data: XOR<satisfactionSurveyUpdateWithoutSurveyResponseInput, satisfactionSurveyUncheckedUpdateWithoutSurveyResponseInput>
  }

  export type satisfactionSurveyUpdateWithoutSurveyResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type satisfactionSurveyUncheckedUpdateWithoutSurveyResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutSurveyResponseInput = {
    update: XOR<userUpdateWithoutSurveyResponseInput, userUncheckedUpdateWithoutSurveyResponseInput>
    create: XOR<userCreateWithoutSurveyResponseInput, userUncheckedCreateWithoutSurveyResponseInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSurveyResponseInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSurveyResponseInput, userUncheckedUpdateWithoutSurveyResponseInput>
  }

  export type userUpdateWithoutSurveyResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSurveyResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutTrustedContactInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTrustedContactInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTrustedContactInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTrustedContactInput, userUncheckedCreateWithoutTrustedContactInput>
  }

  export type userUpsertWithoutTrustedContactInput = {
    update: XOR<userUpdateWithoutTrustedContactInput, userUncheckedUpdateWithoutTrustedContactInput>
    create: XOR<userCreateWithoutTrustedContactInput, userUncheckedCreateWithoutTrustedContactInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTrustedContactInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTrustedContactInput, userUncheckedUpdateWithoutTrustedContactInput>
  }

  export type userUpdateWithoutTrustedContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTrustedContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutUrbanIssueReportInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUrbanIssueReportInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUrbanIssueReportInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUrbanIssueReportInput, userUncheckedCreateWithoutUrbanIssueReportInput>
  }

  export type issueCategoryCreateWithoutUrbanIssueReportInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type issueCategoryUncheckedCreateWithoutUrbanIssueReportInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type issueCategoryCreateOrConnectWithoutUrbanIssueReportInput = {
    where: issueCategoryWhereUniqueInput
    create: XOR<issueCategoryCreateWithoutUrbanIssueReportInput, issueCategoryUncheckedCreateWithoutUrbanIssueReportInput>
  }

  export type userUpsertWithoutUrbanIssueReportInput = {
    update: XOR<userUpdateWithoutUrbanIssueReportInput, userUncheckedUpdateWithoutUrbanIssueReportInput>
    create: XOR<userCreateWithoutUrbanIssueReportInput, userUncheckedCreateWithoutUrbanIssueReportInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUrbanIssueReportInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUrbanIssueReportInput, userUncheckedUpdateWithoutUrbanIssueReportInput>
  }

  export type userUpdateWithoutUrbanIssueReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUrbanIssueReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type issueCategoryUpsertWithoutUrbanIssueReportInput = {
    update: XOR<issueCategoryUpdateWithoutUrbanIssueReportInput, issueCategoryUncheckedUpdateWithoutUrbanIssueReportInput>
    create: XOR<issueCategoryCreateWithoutUrbanIssueReportInput, issueCategoryUncheckedCreateWithoutUrbanIssueReportInput>
    where?: issueCategoryWhereInput
  }

  export type issueCategoryUpdateToOneWithWhereWithoutUrbanIssueReportInput = {
    where?: issueCategoryWhereInput
    data: XOR<issueCategoryUpdateWithoutUrbanIssueReportInput, issueCategoryUncheckedUpdateWithoutUrbanIssueReportInput>
  }

  export type issueCategoryUpdateWithoutUrbanIssueReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issueCategoryUncheckedUpdateWithoutUrbanIssueReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activityCategory?: activityCategoryCreateNestedOneWithoutActivityInput
    activity_registration?: activityRegistrationCreateNestedManyWithoutActivityInput
  }

  export type activityUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    categoryId?: string | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity_registration?: activityRegistrationUncheckedCreateNestedManyWithoutActivityInput
  }

  export type activityCreateOrConnectWithoutUserInput = {
    where: activityWhereUniqueInput
    create: XOR<activityCreateWithoutUserInput, activityUncheckedCreateWithoutUserInput>
  }

  export type activityCreateManyUserInputEnvelope = {
    data: activityCreateManyUserInput | activityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type activityLogCreateWithoutUserInput = {
    id?: string
    actionType?: string | null
    description?: string | null
    ipAddress?: string | null
    device?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityLogUncheckedCreateWithoutUserInput = {
    id?: string
    actionType?: string | null
    description?: string | null
    ipAddress?: string | null
    device?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityLogCreateOrConnectWithoutUserInput = {
    where: activityLogWhereUniqueInput
    create: XOR<activityLogCreateWithoutUserInput, activityLogUncheckedCreateWithoutUserInput>
  }

  export type activityLogCreateManyUserInputEnvelope = {
    data: activityLogCreateManyUserInput | activityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type activityRegistrationCreateWithoutUserInput = {
    id?: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity: activityCreateNestedOneWithoutActivity_registrationInput
  }

  export type activityRegistrationUncheckedCreateWithoutUserInput = {
    id?: string
    activityId: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityRegistrationCreateOrConnectWithoutUserInput = {
    where: activityRegistrationWhereUniqueInput
    create: XOR<activityRegistrationCreateWithoutUserInput, activityRegistrationUncheckedCreateWithoutUserInput>
  }

  export type activityRegistrationCreateManyUserInputEnvelope = {
    data: activityRegistrationCreateManyUserInput | activityRegistrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type collaborativeProjectCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    creationDate?: Date | string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    projectCategory?: projectCategoryCreateNestedOneWithoutCollaborativeProjectInput
    projectMember?: projectMemberCreateNestedManyWithoutCollaborativeProjectInput
    projectTask?: projectTaskCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    creationDate?: Date | string
    status?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutCollaborativeProjectInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectCreateOrConnectWithoutUserInput = {
    where: collaborativeProjectWhereUniqueInput
    create: XOR<collaborativeProjectCreateWithoutUserInput, collaborativeProjectUncheckedCreateWithoutUserInput>
  }

  export type collaborativeProjectCreateManyUserInputEnvelope = {
    data: collaborativeProjectCreateManyUserInput | collaborativeProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type conversationParticipantCreateWithoutUserInput = {
    id?: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversation: conversationCreateNestedOneWithoutConversationParticipantInput
  }

  export type conversationParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type conversationParticipantCreateOrConnectWithoutUserInput = {
    where: conversationParticipantWhereUniqueInput
    create: XOR<conversationParticipantCreateWithoutUserInput, conversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type conversationParticipantCreateManyUserInputEnvelope = {
    data: conversationParticipantCreateManyUserInput | conversationParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type forumMessageCreateWithoutUserInput = {
    id?: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumTopic?: forumTopicCreateNestedOneWithoutForumMessageInput
  }

  export type forumMessageUncheckedCreateWithoutUserInput = {
    id?: string
    topicId: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumMessageCreateOrConnectWithoutUserInput = {
    where: forumMessageWhereUniqueInput
    create: XOR<forumMessageCreateWithoutUserInput, forumMessageUncheckedCreateWithoutUserInput>
  }

  export type forumMessageCreateManyUserInputEnvelope = {
    data: forumMessageCreateManyUserInput | forumMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type forumTopicCreateWithoutUserInput = {
    id?: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumMessage?: forumMessageCreateNestedManyWithoutForumTopicInput
    forumCategory?: forumCategoryCreateNestedOneWithoutForumTopicInput
  }

  export type forumTopicUncheckedCreateWithoutUserInput = {
    id?: string
    categoryId: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutForumTopicInput
  }

  export type forumTopicCreateOrConnectWithoutUserInput = {
    where: forumTopicWhereUniqueInput
    create: XOR<forumTopicCreateWithoutUserInput, forumTopicUncheckedCreateWithoutUserInput>
  }

  export type forumTopicCreateManyUserInputEnvelope = {
    data: forumTopicCreateManyUserInput | forumTopicCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type healthIndicatorCreateWithoutUserInput = {
    id?: string
    recordingDate: Date | string
    stepCount?: number | null
    sleepDurationMinutes?: number | null
    sleepQuality?: number | null
    weight?: number | null
    mood?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type healthIndicatorUncheckedCreateWithoutUserInput = {
    id?: string
    recordingDate: Date | string
    stepCount?: number | null
    sleepDurationMinutes?: number | null
    sleepQuality?: number | null
    weight?: number | null
    mood?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type healthIndicatorCreateOrConnectWithoutUserInput = {
    where: healthIndicatorWhereUniqueInput
    create: XOR<healthIndicatorCreateWithoutUserInput, healthIndicatorUncheckedCreateWithoutUserInput>
  }

  export type healthIndicatorCreateManyUserInputEnvelope = {
    data: healthIndicatorCreateManyUserInput | healthIndicatorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type helpOfferCreateWithoutUserInput = {
    id?: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpRequest: helpRequestCreateNestedOneWithoutHelpOfferInput
  }

  export type helpOfferUncheckedCreateWithoutUserInput = {
    id?: string
    requestId: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpOfferCreateOrConnectWithoutUserInput = {
    where: helpOfferWhereUniqueInput
    create: XOR<helpOfferCreateWithoutUserInput, helpOfferUncheckedCreateWithoutUserInput>
  }

  export type helpOfferCreateManyUserInputEnvelope = {
    data: helpOfferCreateManyUserInput | helpOfferCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type helpRequestCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferCreateNestedManyWithoutHelpRequestInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutHelpRequestInput
    helpCategory?: helpCategoryCreateNestedOneWithoutHelpRequestInput
  }

  export type helpRequestUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    categoryId: string
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutHelpRequestInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutHelpRequestInput
  }

  export type helpRequestCreateOrConnectWithoutUserInput = {
    where: helpRequestWhereUniqueInput
    create: XOR<helpRequestCreateWithoutUserInput, helpRequestUncheckedCreateWithoutUserInput>
  }

  export type helpRequestCreateManyUserInputEnvelope = {
    data: helpRequestCreateManyUserInput | helpRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type medicationReminderCreateWithoutUserInput = {
    id?: string
    medicationName: string
    dosage?: string | null
    morningReminderTime?: Date | string | null
    noonReminderTime?: Date | string | null
    eveningReminderTime?: Date | string | null
    nightReminderTime?: Date | string | null
    daysOfWeek?: string | null
    instructions?: string | null
    active?: boolean | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type medicationReminderUncheckedCreateWithoutUserInput = {
    id?: string
    medicationName: string
    dosage?: string | null
    morningReminderTime?: Date | string | null
    noonReminderTime?: Date | string | null
    eveningReminderTime?: Date | string | null
    nightReminderTime?: Date | string | null
    daysOfWeek?: string | null
    instructions?: string | null
    active?: boolean | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type medicationReminderCreateOrConnectWithoutUserInput = {
    where: medicationReminderWhereUniqueInput
    create: XOR<medicationReminderCreateWithoutUserInput, medicationReminderUncheckedCreateWithoutUserInput>
  }

  export type medicationReminderCreateManyUserInputEnvelope = {
    data: medicationReminderCreateManyUserInput | medicationReminderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutUserInput = {
    id?: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversation?: conversationCreateNestedOneWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type messageCreateOrConnectWithoutUserInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput>
  }

  export type messageCreateManyUserInputEnvelope = {
    data: messageCreateManyUserInput | messageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutUserInput = {
    id?: string
    type: string
    content: string
    read?: boolean | null
    actionLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    content: string
    read?: boolean | null
    actionLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationCreateOrConnectWithoutUserInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationCreateManyUserInputEnvelope = {
    data: notificationCreateManyUserInput | notificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type notificationPreferencesCreateWithoutUserInput = {
    messageNotification?: boolean | null
    activityNotification?: boolean | null
    helpNotification?: boolean | null
    forumNotification?: boolean | null
    emailNotification?: boolean | null
    smsNotification?: boolean | null
    pushNotification?: boolean | null
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationPreferencesUncheckedCreateWithoutUserInput = {
    messageNotification?: boolean | null
    activityNotification?: boolean | null
    helpNotification?: boolean | null
    forumNotification?: boolean | null
    emailNotification?: boolean | null
    smsNotification?: boolean | null
    pushNotification?: boolean | null
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationPreferencesCreateOrConnectWithoutUserInput = {
    where: notificationPreferencesWhereUniqueInput
    create: XOR<notificationPreferencesCreateWithoutUserInput, notificationPreferencesUncheckedCreateWithoutUserInput>
  }

  export type projectMemberCreateWithoutUserInput = {
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    collaborativeProject: collaborativeProjectCreateNestedOneWithoutProjectMemberInput
  }

  export type projectMemberUncheckedCreateWithoutUserInput = {
    projectId: string
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectMemberCreateOrConnectWithoutUserInput = {
    where: projectMemberWhereUniqueInput
    create: XOR<projectMemberCreateWithoutUserInput, projectMemberUncheckedCreateWithoutUserInput>
  }

  export type projectMemberCreateManyUserInputEnvelope = {
    data: projectMemberCreateManyUserInput | projectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type projectTaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    collaborativeProject?: collaborativeProjectCreateNestedOneWithoutProjectTaskInput
  }

  export type projectTaskUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectTaskCreateOrConnectWithoutUserInput = {
    where: projectTaskWhereUniqueInput
    create: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput>
  }

  export type projectTaskCreateManyUserInputEnvelope = {
    data: projectTaskCreateManyUserInput | projectTaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type resourceCreateWithoutUserInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    resourceCategory?: resourceCategoryCreateNestedOneWithoutResourceInput
  }

  export type resourceUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    categoryId?: string | null
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceCreateOrConnectWithoutUserInput = {
    where: resourceWhereUniqueInput
    create: XOR<resourceCreateWithoutUserInput, resourceUncheckedCreateWithoutUserInput>
  }

  export type resourceCreateManyUserInputEnvelope = {
    data: resourceCreateManyUserInput | resourceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type serviceCompletedCreateWithoutUserInput = {
    id?: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpRequest: helpRequestCreateNestedOneWithoutServiceCompletedInput
  }

  export type serviceCompletedUncheckedCreateWithoutUserInput = {
    id?: string
    requestId: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCompletedCreateOrConnectWithoutUserInput = {
    where: serviceCompletedWhereUniqueInput
    create: XOR<serviceCompletedCreateWithoutUserInput, serviceCompletedUncheckedCreateWithoutUserInput>
  }

  export type serviceCompletedCreateManyUserInputEnvelope = {
    data: serviceCompletedCreateManyUserInput | serviceCompletedCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type serviceRatingCreateWithoutUserInput = {
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    localService: localServiceCreateNestedOneWithoutServiceRatingInput
  }

  export type serviceRatingUncheckedCreateWithoutUserInput = {
    serviceId: string
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceRatingCreateOrConnectWithoutUserInput = {
    where: serviceRatingWhereUniqueInput
    create: XOR<serviceRatingCreateWithoutUserInput, serviceRatingUncheckedCreateWithoutUserInput>
  }

  export type serviceRatingCreateManyUserInputEnvelope = {
    data: serviceRatingCreateManyUserInput | serviceRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type surveyResponseCreateWithoutUserInput = {
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    satisfactionSurvey: satisfactionSurveyCreateNestedOneWithoutSurveyResponseInput
  }

  export type surveyResponseUncheckedCreateWithoutUserInput = {
    surveyId: string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type surveyResponseCreateOrConnectWithoutUserInput = {
    where: surveyResponseWhereUniqueInput
    create: XOR<surveyResponseCreateWithoutUserInput, surveyResponseUncheckedCreateWithoutUserInput>
  }

  export type surveyResponseCreateManyUserInputEnvelope = {
    data: surveyResponseCreateManyUserInput | surveyResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type trustedContactCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    relationship?: string | null
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustedContactUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    relationship?: string | null
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustedContactCreateOrConnectWithoutUserInput = {
    where: trustedContactWhereUniqueInput
    create: XOR<trustedContactCreateWithoutUserInput, trustedContactUncheckedCreateWithoutUserInput>
  }

  export type trustedContactCreateManyUserInputEnvelope = {
    data: trustedContactCreateManyUserInput | trustedContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type urbanIssueReportCreateWithoutUserInput = {
    id?: string
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    issueCategory?: issueCategoryCreateNestedOneWithoutUrbanIssueReportInput
  }

  export type urbanIssueReportUncheckedCreateWithoutUserInput = {
    id?: string
    categoryId?: string | null
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type urbanIssueReportCreateOrConnectWithoutUserInput = {
    where: urbanIssueReportWhereUniqueInput
    create: XOR<urbanIssueReportCreateWithoutUserInput, urbanIssueReportUncheckedCreateWithoutUserInput>
  }

  export type urbanIssueReportCreateManyUserInputEnvelope = {
    data: urbanIssueReportCreateManyUserInput | urbanIssueReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userActivityCreateWithoutUserInput = {
    id?: string
    completionDate: Date | string
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveExercise?: cognitiveExerciseCreateNestedOneWithoutUserActivityInput
    exerciseProgram?: exerciseProgramCreateNestedOneWithoutUserActivityInput
  }

  export type userActivityUncheckedCreateWithoutUserInput = {
    id?: string
    completionDate: Date | string
    exerciseProgramId?: string | null
    cognitiveExerciseId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityCreateOrConnectWithoutUserInput = {
    where: userActivityWhereUniqueInput
    create: XOR<userActivityCreateWithoutUserInput, userActivityUncheckedCreateWithoutUserInput>
  }

  export type userActivityCreateManyUserInputEnvelope = {
    data: userActivityCreateManyUserInput | userActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userBadgeCreateWithoutUserInput = {
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    badge: badgeCreateNestedOneWithoutUserBadgeInput
  }

  export type userBadgeUncheckedCreateWithoutUserInput = {
    badgeId: string
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userBadgeCreateOrConnectWithoutUserInput = {
    where: userBadgeWhereUniqueInput
    create: XOR<userBadgeCreateWithoutUserInput, userBadgeUncheckedCreateWithoutUserInput>
  }

  export type userBadgeCreateManyUserInputEnvelope = {
    data: userBadgeCreateManyUserInput | userBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userDeviceCreateWithoutUserInput = {
    id?: string
    deviceType: string
    deviceName?: string | null
    operatingSystem?: string | null
    notificationToken: string
    lastConnection: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userDeviceUncheckedCreateWithoutUserInput = {
    id?: string
    deviceType: string
    deviceName?: string | null
    operatingSystem?: string | null
    notificationToken: string
    lastConnection: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userDeviceCreateOrConnectWithoutUserInput = {
    where: userDeviceWhereUniqueInput
    create: XOR<userDeviceCreateWithoutUserInput, userDeviceUncheckedCreateWithoutUserInput>
  }

  export type userDeviceCreateManyUserInputEnvelope = {
    data: userDeviceCreateManyUserInput | userDeviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userSkillCreateWithoutUserInput = {
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
    skill: skillCreateNestedOneWithoutUserSkillInput
  }

  export type userSkillUncheckedCreateWithoutUserInput = {
    skillId: string
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
  }

  export type userSkillCreateOrConnectWithoutUserInput = {
    where: userSkillWhereUniqueInput
    create: XOR<userSkillCreateWithoutUserInput, userSkillUncheckedCreateWithoutUserInput>
  }

  export type userSkillCreateManyUserInputEnvelope = {
    data: userSkillCreateManyUserInput | userSkillCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userStatisticsCreateWithoutUserInput = {
    servicesProvided?: number | null
    servicesReceived?: number | null
    activitiesParticipated?: number | null
    activitiesOrganized?: number | null
    forumMessages?: number | null
    totalHelpPoints?: number | null
    networkSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userStatisticsUncheckedCreateWithoutUserInput = {
    servicesProvided?: number | null
    servicesReceived?: number | null
    activitiesParticipated?: number | null
    activitiesOrganized?: number | null
    forumMessages?: number | null
    totalHelpPoints?: number | null
    networkSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userStatisticsCreateOrConnectWithoutUserInput = {
    where: userStatisticsWhereUniqueInput
    create: XOR<userStatisticsCreateWithoutUserInput, userStatisticsUncheckedCreateWithoutUserInput>
  }

  export type videoCallCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversation?: conversationCreateNestedOneWithoutVideoCallInput
  }

  export type videoCallUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type videoCallCreateOrConnectWithoutUserInput = {
    where: videoCallWhereUniqueInput
    create: XOR<videoCallCreateWithoutUserInput, videoCallUncheckedCreateWithoutUserInput>
  }

  export type videoCallCreateManyUserInputEnvelope = {
    data: videoCallCreateManyUserInput | videoCallCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type wellnessGoalCreateWithoutUserInput = {
    id?: string
    title: string
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressCreateNestedManyWithoutWellnessGoalInput
    wellnessCategory?: wellnessCategoryCreateNestedOneWithoutWellnessGoalInput
  }

  export type wellnessGoalUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    categoryId?: string | null
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUncheckedCreateNestedManyWithoutWellnessGoalInput
  }

  export type wellnessGoalCreateOrConnectWithoutUserInput = {
    where: wellnessGoalWhereUniqueInput
    create: XOR<wellnessGoalCreateWithoutUserInput, wellnessGoalUncheckedCreateWithoutUserInput>
  }

  export type wellnessGoalCreateManyUserInputEnvelope = {
    data: wellnessGoalCreateManyUserInput | wellnessGoalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type sessionCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type sessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type sessionCreateOrConnectWithoutUserInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>
  }

  export type sessionCreateManyUserInputEnvelope = {
    data: sessionCreateManyUserInput | sessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type activityUpsertWithWhereUniqueWithoutUserInput = {
    where: activityWhereUniqueInput
    update: XOR<activityUpdateWithoutUserInput, activityUncheckedUpdateWithoutUserInput>
    create: XOR<activityCreateWithoutUserInput, activityUncheckedCreateWithoutUserInput>
  }

  export type activityUpdateWithWhereUniqueWithoutUserInput = {
    where: activityWhereUniqueInput
    data: XOR<activityUpdateWithoutUserInput, activityUncheckedUpdateWithoutUserInput>
  }

  export type activityUpdateManyWithWhereWithoutUserInput = {
    where: activityScalarWhereInput
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyWithoutUserInput>
  }

  export type activityScalarWhereInput = {
    AND?: activityScalarWhereInput | activityScalarWhereInput[]
    OR?: activityScalarWhereInput[]
    NOT?: activityScalarWhereInput | activityScalarWhereInput[]
    id?: StringFilter<"activity"> | string
    creatorId?: StringNullableFilter<"activity"> | string | null
    title?: StringFilter<"activity"> | string
    description?: StringNullableFilter<"activity"> | string | null
    startDate?: DateTimeFilter<"activity"> | Date | string
    endDate?: DateTimeNullableFilter<"activity"> | Date | string | null
    location?: StringNullableFilter<"activity"> | string | null
    gpsCoordinates?: StringNullableFilter<"activity"> | string | null
    maxSpots?: IntNullableFilter<"activity"> | number | null
    categoryId?: StringNullableFilter<"activity"> | string | null
    recurring?: BoolNullableFilter<"activity"> | boolean | null
    frequency?: StringNullableFilter<"activity"> | string | null
    reducedMobilityAccess?: BoolFilter<"activity"> | boolean
    difficultyLevel?: IntNullableFilter<"activity"> | number | null
    cost?: FloatNullableFilter<"activity"> | number | null
    status?: StringNullableFilter<"activity"> | string | null
    weatherRequirements?: StringNullableFilter<"activity"> | string | null
    transportOptions?: StringNullableFilter<"activity"> | string | null
    createdAt?: DateTimeFilter<"activity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activity"> | Date | string | null
  }

  export type activityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: activityLogWhereUniqueInput
    update: XOR<activityLogUpdateWithoutUserInput, activityLogUncheckedUpdateWithoutUserInput>
    create: XOR<activityLogCreateWithoutUserInput, activityLogUncheckedCreateWithoutUserInput>
  }

  export type activityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: activityLogWhereUniqueInput
    data: XOR<activityLogUpdateWithoutUserInput, activityLogUncheckedUpdateWithoutUserInput>
  }

  export type activityLogUpdateManyWithWhereWithoutUserInput = {
    where: activityLogScalarWhereInput
    data: XOR<activityLogUpdateManyMutationInput, activityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type activityLogScalarWhereInput = {
    AND?: activityLogScalarWhereInput | activityLogScalarWhereInput[]
    OR?: activityLogScalarWhereInput[]
    NOT?: activityLogScalarWhereInput | activityLogScalarWhereInput[]
    id?: StringFilter<"activityLog"> | string
    userId?: StringNullableFilter<"activityLog"> | string | null
    actionType?: StringNullableFilter<"activityLog"> | string | null
    description?: StringNullableFilter<"activityLog"> | string | null
    ipAddress?: StringNullableFilter<"activityLog"> | string | null
    device?: StringNullableFilter<"activityLog"> | string | null
    createdAt?: DateTimeFilter<"activityLog"> | Date | string
    updatedAt?: DateTimeNullableFilter<"activityLog"> | Date | string | null
  }

  export type activityRegistrationUpsertWithWhereUniqueWithoutUserInput = {
    where: activityRegistrationWhereUniqueInput
    update: XOR<activityRegistrationUpdateWithoutUserInput, activityRegistrationUncheckedUpdateWithoutUserInput>
    create: XOR<activityRegistrationCreateWithoutUserInput, activityRegistrationUncheckedCreateWithoutUserInput>
  }

  export type activityRegistrationUpdateWithWhereUniqueWithoutUserInput = {
    where: activityRegistrationWhereUniqueInput
    data: XOR<activityRegistrationUpdateWithoutUserInput, activityRegistrationUncheckedUpdateWithoutUserInput>
  }

  export type activityRegistrationUpdateManyWithWhereWithoutUserInput = {
    where: activityRegistrationScalarWhereInput
    data: XOR<activityRegistrationUpdateManyMutationInput, activityRegistrationUncheckedUpdateManyWithoutUserInput>
  }

  export type collaborativeProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: collaborativeProjectWhereUniqueInput
    update: XOR<collaborativeProjectUpdateWithoutUserInput, collaborativeProjectUncheckedUpdateWithoutUserInput>
    create: XOR<collaborativeProjectCreateWithoutUserInput, collaborativeProjectUncheckedCreateWithoutUserInput>
  }

  export type collaborativeProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: collaborativeProjectWhereUniqueInput
    data: XOR<collaborativeProjectUpdateWithoutUserInput, collaborativeProjectUncheckedUpdateWithoutUserInput>
  }

  export type collaborativeProjectUpdateManyWithWhereWithoutUserInput = {
    where: collaborativeProjectScalarWhereInput
    data: XOR<collaborativeProjectUpdateManyMutationInput, collaborativeProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type collaborativeProjectScalarWhereInput = {
    AND?: collaborativeProjectScalarWhereInput | collaborativeProjectScalarWhereInput[]
    OR?: collaborativeProjectScalarWhereInput[]
    NOT?: collaborativeProjectScalarWhereInput | collaborativeProjectScalarWhereInput[]
    id?: StringFilter<"collaborativeProject"> | string
    title?: StringFilter<"collaborativeProject"> | string
    description?: StringNullableFilter<"collaborativeProject"> | string | null
    creatorId?: StringFilter<"collaborativeProject"> | string
    creationDate?: DateTimeFilter<"collaborativeProject"> | Date | string
    status?: StringNullableFilter<"collaborativeProject"> | string | null
    categoryId?: StringNullableFilter<"collaborativeProject"> | string | null
    createdAt?: DateTimeFilter<"collaborativeProject"> | Date | string
    updatedAt?: DateTimeNullableFilter<"collaborativeProject"> | Date | string | null
  }

  export type conversationParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: conversationParticipantWhereUniqueInput
    update: XOR<conversationParticipantUpdateWithoutUserInput, conversationParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<conversationParticipantCreateWithoutUserInput, conversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type conversationParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: conversationParticipantWhereUniqueInput
    data: XOR<conversationParticipantUpdateWithoutUserInput, conversationParticipantUncheckedUpdateWithoutUserInput>
  }

  export type conversationParticipantUpdateManyWithWhereWithoutUserInput = {
    where: conversationParticipantScalarWhereInput
    data: XOR<conversationParticipantUpdateManyMutationInput, conversationParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type forumMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: forumMessageWhereUniqueInput
    update: XOR<forumMessageUpdateWithoutUserInput, forumMessageUncheckedUpdateWithoutUserInput>
    create: XOR<forumMessageCreateWithoutUserInput, forumMessageUncheckedCreateWithoutUserInput>
  }

  export type forumMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: forumMessageWhereUniqueInput
    data: XOR<forumMessageUpdateWithoutUserInput, forumMessageUncheckedUpdateWithoutUserInput>
  }

  export type forumMessageUpdateManyWithWhereWithoutUserInput = {
    where: forumMessageScalarWhereInput
    data: XOR<forumMessageUpdateManyMutationInput, forumMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type forumTopicUpsertWithWhereUniqueWithoutUserInput = {
    where: forumTopicWhereUniqueInput
    update: XOR<forumTopicUpdateWithoutUserInput, forumTopicUncheckedUpdateWithoutUserInput>
    create: XOR<forumTopicCreateWithoutUserInput, forumTopicUncheckedCreateWithoutUserInput>
  }

  export type forumTopicUpdateWithWhereUniqueWithoutUserInput = {
    where: forumTopicWhereUniqueInput
    data: XOR<forumTopicUpdateWithoutUserInput, forumTopicUncheckedUpdateWithoutUserInput>
  }

  export type forumTopicUpdateManyWithWhereWithoutUserInput = {
    where: forumTopicScalarWhereInput
    data: XOR<forumTopicUpdateManyMutationInput, forumTopicUncheckedUpdateManyWithoutUserInput>
  }

  export type healthIndicatorUpsertWithWhereUniqueWithoutUserInput = {
    where: healthIndicatorWhereUniqueInput
    update: XOR<healthIndicatorUpdateWithoutUserInput, healthIndicatorUncheckedUpdateWithoutUserInput>
    create: XOR<healthIndicatorCreateWithoutUserInput, healthIndicatorUncheckedCreateWithoutUserInput>
  }

  export type healthIndicatorUpdateWithWhereUniqueWithoutUserInput = {
    where: healthIndicatorWhereUniqueInput
    data: XOR<healthIndicatorUpdateWithoutUserInput, healthIndicatorUncheckedUpdateWithoutUserInput>
  }

  export type healthIndicatorUpdateManyWithWhereWithoutUserInput = {
    where: healthIndicatorScalarWhereInput
    data: XOR<healthIndicatorUpdateManyMutationInput, healthIndicatorUncheckedUpdateManyWithoutUserInput>
  }

  export type healthIndicatorScalarWhereInput = {
    AND?: healthIndicatorScalarWhereInput | healthIndicatorScalarWhereInput[]
    OR?: healthIndicatorScalarWhereInput[]
    NOT?: healthIndicatorScalarWhereInput | healthIndicatorScalarWhereInput[]
    id?: StringFilter<"healthIndicator"> | string
    userId?: StringFilter<"healthIndicator"> | string
    recordingDate?: DateTimeFilter<"healthIndicator"> | Date | string
    stepCount?: IntNullableFilter<"healthIndicator"> | number | null
    sleepDurationMinutes?: IntNullableFilter<"healthIndicator"> | number | null
    sleepQuality?: IntNullableFilter<"healthIndicator"> | number | null
    weight?: FloatNullableFilter<"healthIndicator"> | number | null
    mood?: StringNullableFilter<"healthIndicator"> | string | null
    notes?: StringNullableFilter<"healthIndicator"> | string | null
    createdAt?: DateTimeFilter<"healthIndicator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"healthIndicator"> | Date | string | null
  }

  export type helpOfferUpsertWithWhereUniqueWithoutUserInput = {
    where: helpOfferWhereUniqueInput
    update: XOR<helpOfferUpdateWithoutUserInput, helpOfferUncheckedUpdateWithoutUserInput>
    create: XOR<helpOfferCreateWithoutUserInput, helpOfferUncheckedCreateWithoutUserInput>
  }

  export type helpOfferUpdateWithWhereUniqueWithoutUserInput = {
    where: helpOfferWhereUniqueInput
    data: XOR<helpOfferUpdateWithoutUserInput, helpOfferUncheckedUpdateWithoutUserInput>
  }

  export type helpOfferUpdateManyWithWhereWithoutUserInput = {
    where: helpOfferScalarWhereInput
    data: XOR<helpOfferUpdateManyMutationInput, helpOfferUncheckedUpdateManyWithoutUserInput>
  }

  export type helpRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: helpRequestWhereUniqueInput
    update: XOR<helpRequestUpdateWithoutUserInput, helpRequestUncheckedUpdateWithoutUserInput>
    create: XOR<helpRequestCreateWithoutUserInput, helpRequestUncheckedCreateWithoutUserInput>
  }

  export type helpRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: helpRequestWhereUniqueInput
    data: XOR<helpRequestUpdateWithoutUserInput, helpRequestUncheckedUpdateWithoutUserInput>
  }

  export type helpRequestUpdateManyWithWhereWithoutUserInput = {
    where: helpRequestScalarWhereInput
    data: XOR<helpRequestUpdateManyMutationInput, helpRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type helpRequestScalarWhereInput = {
    AND?: helpRequestScalarWhereInput | helpRequestScalarWhereInput[]
    OR?: helpRequestScalarWhereInput[]
    NOT?: helpRequestScalarWhereInput | helpRequestScalarWhereInput[]
    id?: StringFilter<"helpRequest"> | string
    creatorId?: StringFilter<"helpRequest"> | string
    title?: StringFilter<"helpRequest"> | string
    description?: StringNullableFilter<"helpRequest"> | string | null
    neededDate?: DateTimeFilter<"helpRequest"> | Date | string
    estimatedDuration?: IntNullableFilter<"helpRequest"> | number | null
    location?: StringNullableFilter<"helpRequest"> | string | null
    gpsCoordinates?: StringNullableFilter<"helpRequest"> | string | null
    categoryId?: StringFilter<"helpRequest"> | string
    recurring?: BoolNullableFilter<"helpRequest"> | boolean | null
    frequency?: StringNullableFilter<"helpRequest"> | string | null
    status?: StringNullableFilter<"helpRequest"> | string | null
    pointsOffered?: IntNullableFilter<"helpRequest"> | number | null
    createdAt?: DateTimeFilter<"helpRequest"> | Date | string
    updatedAt?: DateTimeNullableFilter<"helpRequest"> | Date | string | null
  }

  export type medicationReminderUpsertWithWhereUniqueWithoutUserInput = {
    where: medicationReminderWhereUniqueInput
    update: XOR<medicationReminderUpdateWithoutUserInput, medicationReminderUncheckedUpdateWithoutUserInput>
    create: XOR<medicationReminderCreateWithoutUserInput, medicationReminderUncheckedCreateWithoutUserInput>
  }

  export type medicationReminderUpdateWithWhereUniqueWithoutUserInput = {
    where: medicationReminderWhereUniqueInput
    data: XOR<medicationReminderUpdateWithoutUserInput, medicationReminderUncheckedUpdateWithoutUserInput>
  }

  export type medicationReminderUpdateManyWithWhereWithoutUserInput = {
    where: medicationReminderScalarWhereInput
    data: XOR<medicationReminderUpdateManyMutationInput, medicationReminderUncheckedUpdateManyWithoutUserInput>
  }

  export type medicationReminderScalarWhereInput = {
    AND?: medicationReminderScalarWhereInput | medicationReminderScalarWhereInput[]
    OR?: medicationReminderScalarWhereInput[]
    NOT?: medicationReminderScalarWhereInput | medicationReminderScalarWhereInput[]
    id?: StringFilter<"medicationReminder"> | string
    userId?: StringFilter<"medicationReminder"> | string
    medicationName?: StringFilter<"medicationReminder"> | string
    dosage?: StringNullableFilter<"medicationReminder"> | string | null
    morningReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    noonReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    eveningReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    nightReminderTime?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    daysOfWeek?: StringNullableFilter<"medicationReminder"> | string | null
    instructions?: StringNullableFilter<"medicationReminder"> | string | null
    active?: BoolNullableFilter<"medicationReminder"> | boolean | null
    startDate?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    endDate?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
    createdAt?: DateTimeFilter<"medicationReminder"> | Date | string
    updatedAt?: DateTimeNullableFilter<"medicationReminder"> | Date | string | null
  }

  export type messageUpsertWithWhereUniqueWithoutUserInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutUserInput, messageUncheckedUpdateWithoutUserInput>
    create: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput>
  }

  export type messageUpdateWithWhereUniqueWithoutUserInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutUserInput, messageUncheckedUpdateWithoutUserInput>
  }

  export type messageUpdateManyWithWhereWithoutUserInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
  }

  export type notificationUpdateManyWithWhereWithoutUserInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: StringFilter<"notification"> | string
    userId?: StringFilter<"notification"> | string
    type?: StringFilter<"notification"> | string
    content?: StringFilter<"notification"> | string
    read?: BoolNullableFilter<"notification"> | boolean | null
    actionLink?: StringNullableFilter<"notification"> | string | null
    createdAt?: DateTimeFilter<"notification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"notification"> | Date | string | null
  }

  export type notificationPreferencesUpsertWithoutUserInput = {
    update: XOR<notificationPreferencesUpdateWithoutUserInput, notificationPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<notificationPreferencesCreateWithoutUserInput, notificationPreferencesUncheckedCreateWithoutUserInput>
    where?: notificationPreferencesWhereInput
  }

  export type notificationPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: notificationPreferencesWhereInput
    data: XOR<notificationPreferencesUpdateWithoutUserInput, notificationPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type notificationPreferencesUpdateWithoutUserInput = {
    messageNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    forumNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    smsNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationPreferencesUncheckedUpdateWithoutUserInput = {
    messageNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    forumNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    smsNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: projectMemberWhereUniqueInput
    update: XOR<projectMemberUpdateWithoutUserInput, projectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<projectMemberCreateWithoutUserInput, projectMemberUncheckedCreateWithoutUserInput>
  }

  export type projectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: projectMemberWhereUniqueInput
    data: XOR<projectMemberUpdateWithoutUserInput, projectMemberUncheckedUpdateWithoutUserInput>
  }

  export type projectMemberUpdateManyWithWhereWithoutUserInput = {
    where: projectMemberScalarWhereInput
    data: XOR<projectMemberUpdateManyMutationInput, projectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type projectTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: projectTaskWhereUniqueInput
    update: XOR<projectTaskUpdateWithoutUserInput, projectTaskUncheckedUpdateWithoutUserInput>
    create: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput>
  }

  export type projectTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: projectTaskWhereUniqueInput
    data: XOR<projectTaskUpdateWithoutUserInput, projectTaskUncheckedUpdateWithoutUserInput>
  }

  export type projectTaskUpdateManyWithWhereWithoutUserInput = {
    where: projectTaskScalarWhereInput
    data: XOR<projectTaskUpdateManyMutationInput, projectTaskUncheckedUpdateManyWithoutUserInput>
  }

  export type resourceUpsertWithWhereUniqueWithoutUserInput = {
    where: resourceWhereUniqueInput
    update: XOR<resourceUpdateWithoutUserInput, resourceUncheckedUpdateWithoutUserInput>
    create: XOR<resourceCreateWithoutUserInput, resourceUncheckedCreateWithoutUserInput>
  }

  export type resourceUpdateWithWhereUniqueWithoutUserInput = {
    where: resourceWhereUniqueInput
    data: XOR<resourceUpdateWithoutUserInput, resourceUncheckedUpdateWithoutUserInput>
  }

  export type resourceUpdateManyWithWhereWithoutUserInput = {
    where: resourceScalarWhereInput
    data: XOR<resourceUpdateManyMutationInput, resourceUncheckedUpdateManyWithoutUserInput>
  }

  export type resourceScalarWhereInput = {
    AND?: resourceScalarWhereInput | resourceScalarWhereInput[]
    OR?: resourceScalarWhereInput[]
    NOT?: resourceScalarWhereInput | resourceScalarWhereInput[]
    id?: StringFilter<"resource"> | string
    title?: StringFilter<"resource"> | string
    content?: StringNullableFilter<"resource"> | string | null
    type?: StringFilter<"resource"> | string
    categoryId?: StringNullableFilter<"resource"> | string | null
    authorId?: StringFilter<"resource"> | string
    adminValidated?: BoolNullableFilter<"resource"> | boolean | null
    createdAt?: DateTimeFilter<"resource"> | Date | string
    updatedAt?: DateTimeNullableFilter<"resource"> | Date | string | null
  }

  export type serviceCompletedUpsertWithWhereUniqueWithoutUserInput = {
    where: serviceCompletedWhereUniqueInput
    update: XOR<serviceCompletedUpdateWithoutUserInput, serviceCompletedUncheckedUpdateWithoutUserInput>
    create: XOR<serviceCompletedCreateWithoutUserInput, serviceCompletedUncheckedCreateWithoutUserInput>
  }

  export type serviceCompletedUpdateWithWhereUniqueWithoutUserInput = {
    where: serviceCompletedWhereUniqueInput
    data: XOR<serviceCompletedUpdateWithoutUserInput, serviceCompletedUncheckedUpdateWithoutUserInput>
  }

  export type serviceCompletedUpdateManyWithWhereWithoutUserInput = {
    where: serviceCompletedScalarWhereInput
    data: XOR<serviceCompletedUpdateManyMutationInput, serviceCompletedUncheckedUpdateManyWithoutUserInput>
  }

  export type serviceRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: serviceRatingWhereUniqueInput
    update: XOR<serviceRatingUpdateWithoutUserInput, serviceRatingUncheckedUpdateWithoutUserInput>
    create: XOR<serviceRatingCreateWithoutUserInput, serviceRatingUncheckedCreateWithoutUserInput>
  }

  export type serviceRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: serviceRatingWhereUniqueInput
    data: XOR<serviceRatingUpdateWithoutUserInput, serviceRatingUncheckedUpdateWithoutUserInput>
  }

  export type serviceRatingUpdateManyWithWhereWithoutUserInput = {
    where: serviceRatingScalarWhereInput
    data: XOR<serviceRatingUpdateManyMutationInput, serviceRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type surveyResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: surveyResponseWhereUniqueInput
    update: XOR<surveyResponseUpdateWithoutUserInput, surveyResponseUncheckedUpdateWithoutUserInput>
    create: XOR<surveyResponseCreateWithoutUserInput, surveyResponseUncheckedCreateWithoutUserInput>
  }

  export type surveyResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: surveyResponseWhereUniqueInput
    data: XOR<surveyResponseUpdateWithoutUserInput, surveyResponseUncheckedUpdateWithoutUserInput>
  }

  export type surveyResponseUpdateManyWithWhereWithoutUserInput = {
    where: surveyResponseScalarWhereInput
    data: XOR<surveyResponseUpdateManyMutationInput, surveyResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type trustedContactUpsertWithWhereUniqueWithoutUserInput = {
    where: trustedContactWhereUniqueInput
    update: XOR<trustedContactUpdateWithoutUserInput, trustedContactUncheckedUpdateWithoutUserInput>
    create: XOR<trustedContactCreateWithoutUserInput, trustedContactUncheckedCreateWithoutUserInput>
  }

  export type trustedContactUpdateWithWhereUniqueWithoutUserInput = {
    where: trustedContactWhereUniqueInput
    data: XOR<trustedContactUpdateWithoutUserInput, trustedContactUncheckedUpdateWithoutUserInput>
  }

  export type trustedContactUpdateManyWithWhereWithoutUserInput = {
    where: trustedContactScalarWhereInput
    data: XOR<trustedContactUpdateManyMutationInput, trustedContactUncheckedUpdateManyWithoutUserInput>
  }

  export type trustedContactScalarWhereInput = {
    AND?: trustedContactScalarWhereInput | trustedContactScalarWhereInput[]
    OR?: trustedContactScalarWhereInput[]
    NOT?: trustedContactScalarWhereInput | trustedContactScalarWhereInput[]
    id?: StringFilter<"trustedContact"> | string
    userId?: StringFilter<"trustedContact"> | string
    firstName?: StringFilter<"trustedContact"> | string
    lastName?: StringFilter<"trustedContact"> | string
    email?: StringNullableFilter<"trustedContact"> | string | null
    phone?: StringFilter<"trustedContact"> | string
    relationship?: StringNullableFilter<"trustedContact"> | string | null
    shareMedications?: BoolFilter<"trustedContact"> | boolean
    shareHealthIndicators?: BoolFilter<"trustedContact"> | boolean
    shareWellnessActivities?: BoolFilter<"trustedContact"> | boolean
    emergencyAlerts?: BoolFilter<"trustedContact"> | boolean
    createdAt?: DateTimeFilter<"trustedContact"> | Date | string
    updatedAt?: DateTimeNullableFilter<"trustedContact"> | Date | string | null
  }

  export type urbanIssueReportUpsertWithWhereUniqueWithoutUserInput = {
    where: urbanIssueReportWhereUniqueInput
    update: XOR<urbanIssueReportUpdateWithoutUserInput, urbanIssueReportUncheckedUpdateWithoutUserInput>
    create: XOR<urbanIssueReportCreateWithoutUserInput, urbanIssueReportUncheckedCreateWithoutUserInput>
  }

  export type urbanIssueReportUpdateWithWhereUniqueWithoutUserInput = {
    where: urbanIssueReportWhereUniqueInput
    data: XOR<urbanIssueReportUpdateWithoutUserInput, urbanIssueReportUncheckedUpdateWithoutUserInput>
  }

  export type urbanIssueReportUpdateManyWithWhereWithoutUserInput = {
    where: urbanIssueReportScalarWhereInput
    data: XOR<urbanIssueReportUpdateManyMutationInput, urbanIssueReportUncheckedUpdateManyWithoutUserInput>
  }

  export type urbanIssueReportScalarWhereInput = {
    AND?: urbanIssueReportScalarWhereInput | urbanIssueReportScalarWhereInput[]
    OR?: urbanIssueReportScalarWhereInput[]
    NOT?: urbanIssueReportScalarWhereInput | urbanIssueReportScalarWhereInput[]
    id?: StringFilter<"urbanIssueReport"> | string
    userId?: StringFilter<"urbanIssueReport"> | string
    categoryId?: StringNullableFilter<"urbanIssueReport"> | string | null
    description?: StringFilter<"urbanIssueReport"> | string
    address?: StringFilter<"urbanIssueReport"> | string
    gpsCoordinates?: StringNullableFilter<"urbanIssueReport"> | string | null
    reportDate?: DateTimeFilter<"urbanIssueReport"> | Date | string
    status?: StringNullableFilter<"urbanIssueReport"> | string | null
    cityReference?: StringNullableFilter<"urbanIssueReport"> | string | null
    createdAt?: DateTimeFilter<"urbanIssueReport"> | Date | string
    updatedAt?: DateTimeNullableFilter<"urbanIssueReport"> | Date | string | null
  }

  export type userActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: userActivityWhereUniqueInput
    update: XOR<userActivityUpdateWithoutUserInput, userActivityUncheckedUpdateWithoutUserInput>
    create: XOR<userActivityCreateWithoutUserInput, userActivityUncheckedCreateWithoutUserInput>
  }

  export type userActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: userActivityWhereUniqueInput
    data: XOR<userActivityUpdateWithoutUserInput, userActivityUncheckedUpdateWithoutUserInput>
  }

  export type userActivityUpdateManyWithWhereWithoutUserInput = {
    where: userActivityScalarWhereInput
    data: XOR<userActivityUpdateManyMutationInput, userActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type userBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: userBadgeWhereUniqueInput
    update: XOR<userBadgeUpdateWithoutUserInput, userBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<userBadgeCreateWithoutUserInput, userBadgeUncheckedCreateWithoutUserInput>
  }

  export type userBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: userBadgeWhereUniqueInput
    data: XOR<userBadgeUpdateWithoutUserInput, userBadgeUncheckedUpdateWithoutUserInput>
  }

  export type userBadgeUpdateManyWithWhereWithoutUserInput = {
    where: userBadgeScalarWhereInput
    data: XOR<userBadgeUpdateManyMutationInput, userBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type userBadgeScalarWhereInput = {
    AND?: userBadgeScalarWhereInput | userBadgeScalarWhereInput[]
    OR?: userBadgeScalarWhereInput[]
    NOT?: userBadgeScalarWhereInput | userBadgeScalarWhereInput[]
    userId?: StringFilter<"userBadge"> | string
    badgeId?: StringFilter<"userBadge"> | string
    achievementDate?: DateTimeFilter<"userBadge"> | Date | string
    createdAt?: DateTimeFilter<"userBadge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userBadge"> | Date | string | null
  }

  export type userDeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: userDeviceWhereUniqueInput
    update: XOR<userDeviceUpdateWithoutUserInput, userDeviceUncheckedUpdateWithoutUserInput>
    create: XOR<userDeviceCreateWithoutUserInput, userDeviceUncheckedCreateWithoutUserInput>
  }

  export type userDeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: userDeviceWhereUniqueInput
    data: XOR<userDeviceUpdateWithoutUserInput, userDeviceUncheckedUpdateWithoutUserInput>
  }

  export type userDeviceUpdateManyWithWhereWithoutUserInput = {
    where: userDeviceScalarWhereInput
    data: XOR<userDeviceUpdateManyMutationInput, userDeviceUncheckedUpdateManyWithoutUserInput>
  }

  export type userDeviceScalarWhereInput = {
    AND?: userDeviceScalarWhereInput | userDeviceScalarWhereInput[]
    OR?: userDeviceScalarWhereInput[]
    NOT?: userDeviceScalarWhereInput | userDeviceScalarWhereInput[]
    id?: StringFilter<"userDevice"> | string
    userId?: StringFilter<"userDevice"> | string
    deviceType?: StringFilter<"userDevice"> | string
    deviceName?: StringNullableFilter<"userDevice"> | string | null
    operatingSystem?: StringNullableFilter<"userDevice"> | string | null
    notificationToken?: StringFilter<"userDevice"> | string
    lastConnection?: DateTimeFilter<"userDevice"> | Date | string
    createdAt?: DateTimeFilter<"userDevice"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userDevice"> | Date | string | null
  }

  export type userSkillUpsertWithWhereUniqueWithoutUserInput = {
    where: userSkillWhereUniqueInput
    update: XOR<userSkillUpdateWithoutUserInput, userSkillUncheckedUpdateWithoutUserInput>
    create: XOR<userSkillCreateWithoutUserInput, userSkillUncheckedCreateWithoutUserInput>
  }

  export type userSkillUpdateWithWhereUniqueWithoutUserInput = {
    where: userSkillWhereUniqueInput
    data: XOR<userSkillUpdateWithoutUserInput, userSkillUncheckedUpdateWithoutUserInput>
  }

  export type userSkillUpdateManyWithWhereWithoutUserInput = {
    where: userSkillScalarWhereInput
    data: XOR<userSkillUpdateManyMutationInput, userSkillUncheckedUpdateManyWithoutUserInput>
  }

  export type userStatisticsUpsertWithoutUserInput = {
    update: XOR<userStatisticsUpdateWithoutUserInput, userStatisticsUncheckedUpdateWithoutUserInput>
    create: XOR<userStatisticsCreateWithoutUserInput, userStatisticsUncheckedCreateWithoutUserInput>
    where?: userStatisticsWhereInput
  }

  export type userStatisticsUpdateToOneWithWhereWithoutUserInput = {
    where?: userStatisticsWhereInput
    data: XOR<userStatisticsUpdateWithoutUserInput, userStatisticsUncheckedUpdateWithoutUserInput>
  }

  export type userStatisticsUpdateWithoutUserInput = {
    servicesProvided?: NullableIntFieldUpdateOperationsInput | number | null
    servicesReceived?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesParticipated?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesOrganized?: NullableIntFieldUpdateOperationsInput | number | null
    forumMessages?: NullableIntFieldUpdateOperationsInput | number | null
    totalHelpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userStatisticsUncheckedUpdateWithoutUserInput = {
    servicesProvided?: NullableIntFieldUpdateOperationsInput | number | null
    servicesReceived?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesParticipated?: NullableIntFieldUpdateOperationsInput | number | null
    activitiesOrganized?: NullableIntFieldUpdateOperationsInput | number | null
    forumMessages?: NullableIntFieldUpdateOperationsInput | number | null
    totalHelpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    networkSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallUpsertWithWhereUniqueWithoutUserInput = {
    where: videoCallWhereUniqueInput
    update: XOR<videoCallUpdateWithoutUserInput, videoCallUncheckedUpdateWithoutUserInput>
    create: XOR<videoCallCreateWithoutUserInput, videoCallUncheckedCreateWithoutUserInput>
  }

  export type videoCallUpdateWithWhereUniqueWithoutUserInput = {
    where: videoCallWhereUniqueInput
    data: XOR<videoCallUpdateWithoutUserInput, videoCallUncheckedUpdateWithoutUserInput>
  }

  export type videoCallUpdateManyWithWhereWithoutUserInput = {
    where: videoCallScalarWhereInput
    data: XOR<videoCallUpdateManyMutationInput, videoCallUncheckedUpdateManyWithoutUserInput>
  }

  export type wellnessGoalUpsertWithWhereUniqueWithoutUserInput = {
    where: wellnessGoalWhereUniqueInput
    update: XOR<wellnessGoalUpdateWithoutUserInput, wellnessGoalUncheckedUpdateWithoutUserInput>
    create: XOR<wellnessGoalCreateWithoutUserInput, wellnessGoalUncheckedCreateWithoutUserInput>
  }

  export type wellnessGoalUpdateWithWhereUniqueWithoutUserInput = {
    where: wellnessGoalWhereUniqueInput
    data: XOR<wellnessGoalUpdateWithoutUserInput, wellnessGoalUncheckedUpdateWithoutUserInput>
  }

  export type wellnessGoalUpdateManyWithWhereWithoutUserInput = {
    where: wellnessGoalScalarWhereInput
    data: XOR<wellnessGoalUpdateManyMutationInput, wellnessGoalUncheckedUpdateManyWithoutUserInput>
  }

  export type wellnessGoalScalarWhereInput = {
    AND?: wellnessGoalScalarWhereInput | wellnessGoalScalarWhereInput[]
    OR?: wellnessGoalScalarWhereInput[]
    NOT?: wellnessGoalScalarWhereInput | wellnessGoalScalarWhereInput[]
    id?: StringFilter<"wellnessGoal"> | string
    userId?: StringFilter<"wellnessGoal"> | string
    title?: StringFilter<"wellnessGoal"> | string
    categoryId?: StringNullableFilter<"wellnessGoal"> | string | null
    targetValue?: IntFilter<"wellnessGoal"> | number
    unit?: StringFilter<"wellnessGoal"> | string
    frequency?: StringFilter<"wellnessGoal"> | string
    startDate?: DateTimeFilter<"wellnessGoal"> | Date | string
    endDate?: DateTimeFilter<"wellnessGoal"> | Date | string
    active?: BoolFilter<"wellnessGoal"> | boolean
    createdAt?: DateTimeFilter<"wellnessGoal"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessGoal"> | Date | string | null
  }

  export type sessionUpsertWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput
    update: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>
  }

  export type sessionUpdateWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput
    data: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>
  }

  export type sessionUpdateManyWithWhereWithoutUserInput = {
    where: sessionScalarWhereInput
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyWithoutUserInput>
  }

  export type sessionScalarWhereInput = {
    AND?: sessionScalarWhereInput | sessionScalarWhereInput[]
    OR?: sessionScalarWhereInput[]
    NOT?: sessionScalarWhereInput | sessionScalarWhereInput[]
    id?: StringFilter<"session"> | string
    refreshToken?: StringFilter<"session"> | string
    userId?: StringFilter<"session"> | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    userAgent?: StringNullableFilter<"session"> | string | null
    ipAddress?: StringNullableFilter<"session"> | string | null
  }

  export type cognitiveExerciseCreateWithoutUserActivityInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveCategory?: cognitiveCategoryCreateNestedOneWithoutCognitiveExerciseInput
    programCategory?: programCategoryCreateNestedOneWithoutCognitiveExerciseInput
  }

  export type cognitiveExerciseUncheckedCreateWithoutUserActivityInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    programCategoryId?: string | null
  }

  export type cognitiveExerciseCreateOrConnectWithoutUserActivityInput = {
    where: cognitiveExerciseWhereUniqueInput
    create: XOR<cognitiveExerciseCreateWithoutUserActivityInput, cognitiveExerciseUncheckedCreateWithoutUserActivityInput>
  }

  export type exerciseProgramCreateWithoutUserActivityInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    programCategory?: programCategoryCreateNestedOneWithoutExerciseProgramInput
  }

  export type exerciseProgramUncheckedCreateWithoutUserActivityInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type exerciseProgramCreateOrConnectWithoutUserActivityInput = {
    where: exerciseProgramWhereUniqueInput
    create: XOR<exerciseProgramCreateWithoutUserActivityInput, exerciseProgramUncheckedCreateWithoutUserActivityInput>
  }

  export type userCreateWithoutUserActivityInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserActivityInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserActivityInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserActivityInput, userUncheckedCreateWithoutUserActivityInput>
  }

  export type cognitiveExerciseUpsertWithoutUserActivityInput = {
    update: XOR<cognitiveExerciseUpdateWithoutUserActivityInput, cognitiveExerciseUncheckedUpdateWithoutUserActivityInput>
    create: XOR<cognitiveExerciseCreateWithoutUserActivityInput, cognitiveExerciseUncheckedCreateWithoutUserActivityInput>
    where?: cognitiveExerciseWhereInput
  }

  export type cognitiveExerciseUpdateToOneWithWhereWithoutUserActivityInput = {
    where?: cognitiveExerciseWhereInput
    data: XOR<cognitiveExerciseUpdateWithoutUserActivityInput, cognitiveExerciseUncheckedUpdateWithoutUserActivityInput>
  }

  export type cognitiveExerciseUpdateWithoutUserActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveCategory?: cognitiveCategoryUpdateOneWithoutCognitiveExerciseNestedInput
    programCategory?: programCategoryUpdateOneWithoutCognitiveExerciseNestedInput
  }

  export type cognitiveExerciseUncheckedUpdateWithoutUserActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type exerciseProgramUpsertWithoutUserActivityInput = {
    update: XOR<exerciseProgramUpdateWithoutUserActivityInput, exerciseProgramUncheckedUpdateWithoutUserActivityInput>
    create: XOR<exerciseProgramCreateWithoutUserActivityInput, exerciseProgramUncheckedCreateWithoutUserActivityInput>
    where?: exerciseProgramWhereInput
  }

  export type exerciseProgramUpdateToOneWithWhereWithoutUserActivityInput = {
    where?: exerciseProgramWhereInput
    data: XOR<exerciseProgramUpdateWithoutUserActivityInput, exerciseProgramUncheckedUpdateWithoutUserActivityInput>
  }

  export type exerciseProgramUpdateWithoutUserActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programCategory?: programCategoryUpdateOneWithoutExerciseProgramNestedInput
  }

  export type exerciseProgramUncheckedUpdateWithoutUserActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutUserActivityInput = {
    update: XOR<userUpdateWithoutUserActivityInput, userUncheckedUpdateWithoutUserActivityInput>
    create: XOR<userCreateWithoutUserActivityInput, userUncheckedCreateWithoutUserActivityInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserActivityInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserActivityInput, userUncheckedUpdateWithoutUserActivityInput>
  }

  export type userUpdateWithoutUserActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type badgeCreateWithoutUserBadgeInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    badgeCategory?: badgeCategoryCreateNestedOneWithoutBadgeInput
  }

  export type badgeUncheckedCreateWithoutUserBadgeInput = {
    id?: string
    name: string
    categoryId?: string | null
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type badgeCreateOrConnectWithoutUserBadgeInput = {
    where: badgeWhereUniqueInput
    create: XOR<badgeCreateWithoutUserBadgeInput, badgeUncheckedCreateWithoutUserBadgeInput>
  }

  export type userCreateWithoutUserBadgeInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserBadgeInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserBadgeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserBadgeInput, userUncheckedCreateWithoutUserBadgeInput>
  }

  export type badgeUpsertWithoutUserBadgeInput = {
    update: XOR<badgeUpdateWithoutUserBadgeInput, badgeUncheckedUpdateWithoutUserBadgeInput>
    create: XOR<badgeCreateWithoutUserBadgeInput, badgeUncheckedCreateWithoutUserBadgeInput>
    where?: badgeWhereInput
  }

  export type badgeUpdateToOneWithWhereWithoutUserBadgeInput = {
    where?: badgeWhereInput
    data: XOR<badgeUpdateWithoutUserBadgeInput, badgeUncheckedUpdateWithoutUserBadgeInput>
  }

  export type badgeUpdateWithoutUserBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badgeCategory?: badgeCategoryUpdateOneWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateWithoutUserBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutUserBadgeInput = {
    update: XOR<userUpdateWithoutUserBadgeInput, userUncheckedUpdateWithoutUserBadgeInput>
    create: XOR<userCreateWithoutUserBadgeInput, userUncheckedCreateWithoutUserBadgeInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserBadgeInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserBadgeInput, userUncheckedUpdateWithoutUserBadgeInput>
  }

  export type userUpdateWithoutUserBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutUserDeviceInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserDeviceInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserDeviceInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserDeviceInput, userUncheckedCreateWithoutUserDeviceInput>
  }

  export type userUpsertWithoutUserDeviceInput = {
    update: XOR<userUpdateWithoutUserDeviceInput, userUncheckedUpdateWithoutUserDeviceInput>
    create: XOR<userCreateWithoutUserDeviceInput, userUncheckedCreateWithoutUserDeviceInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserDeviceInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserDeviceInput, userUncheckedUpdateWithoutUserDeviceInput>
  }

  export type userUpdateWithoutUserDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type skillCreateWithoutUserSkillInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    skillCategory?: skillCategoryCreateNestedOneWithoutSkillInput
  }

  export type skillUncheckedCreateWithoutUserSkillInput = {
    id?: string
    name: string
    description?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type skillCreateOrConnectWithoutUserSkillInput = {
    where: skillWhereUniqueInput
    create: XOR<skillCreateWithoutUserSkillInput, skillUncheckedCreateWithoutUserSkillInput>
  }

  export type userCreateWithoutUserSkillInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserSkillInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserSkillInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserSkillInput, userUncheckedCreateWithoutUserSkillInput>
  }

  export type skillUpsertWithoutUserSkillInput = {
    update: XOR<skillUpdateWithoutUserSkillInput, skillUncheckedUpdateWithoutUserSkillInput>
    create: XOR<skillCreateWithoutUserSkillInput, skillUncheckedCreateWithoutUserSkillInput>
    where?: skillWhereInput
  }

  export type skillUpdateToOneWithWhereWithoutUserSkillInput = {
    where?: skillWhereInput
    data: XOR<skillUpdateWithoutUserSkillInput, skillUncheckedUpdateWithoutUserSkillInput>
  }

  export type skillUpdateWithoutUserSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skillCategory?: skillCategoryUpdateOneWithoutSkillNestedInput
  }

  export type skillUncheckedUpdateWithoutUserSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutUserSkillInput = {
    update: XOR<userUpdateWithoutUserSkillInput, userUncheckedUpdateWithoutUserSkillInput>
    create: XOR<userCreateWithoutUserSkillInput, userUncheckedCreateWithoutUserSkillInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserSkillInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserSkillInput, userUncheckedUpdateWithoutUserSkillInput>
  }

  export type userUpdateWithoutUserSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutUserStatisticsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserStatisticsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserStatisticsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserStatisticsInput, userUncheckedCreateWithoutUserStatisticsInput>
  }

  export type userUpsertWithoutUserStatisticsInput = {
    update: XOR<userUpdateWithoutUserStatisticsInput, userUncheckedUpdateWithoutUserStatisticsInput>
    create: XOR<userCreateWithoutUserStatisticsInput, userUncheckedCreateWithoutUserStatisticsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserStatisticsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserStatisticsInput, userUncheckedUpdateWithoutUserStatisticsInput>
  }

  export type userUpdateWithoutUserStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type conversationCreateWithoutVideoCallInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutConversationInput
    message?: messageCreateNestedManyWithoutConversationInput
  }

  export type conversationUncheckedCreateWithoutVideoCallInput = {
    id?: string
    type: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    message?: messageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type conversationCreateOrConnectWithoutVideoCallInput = {
    where: conversationWhereUniqueInput
    create: XOR<conversationCreateWithoutVideoCallInput, conversationUncheckedCreateWithoutVideoCallInput>
  }

  export type userCreateWithoutVideoCallInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutVideoCallInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutVideoCallInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutVideoCallInput, userUncheckedCreateWithoutVideoCallInput>
  }

  export type conversationUpsertWithoutVideoCallInput = {
    update: XOR<conversationUpdateWithoutVideoCallInput, conversationUncheckedUpdateWithoutVideoCallInput>
    create: XOR<conversationCreateWithoutVideoCallInput, conversationUncheckedCreateWithoutVideoCallInput>
    where?: conversationWhereInput
  }

  export type conversationUpdateToOneWithWhereWithoutVideoCallInput = {
    where?: conversationWhereInput
    data: XOR<conversationUpdateWithoutVideoCallInput, conversationUncheckedUpdateWithoutVideoCallInput>
  }

  export type conversationUpdateWithoutVideoCallInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationParticipant?: conversationParticipantUpdateManyWithoutConversationNestedInput
    message?: messageUpdateManyWithoutConversationNestedInput
  }

  export type conversationUncheckedUpdateWithoutVideoCallInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    message?: messageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type userUpsertWithoutVideoCallInput = {
    update: XOR<userUpdateWithoutVideoCallInput, userUncheckedUpdateWithoutVideoCallInput>
    create: XOR<userCreateWithoutVideoCallInput, userUncheckedCreateWithoutVideoCallInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutVideoCallInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutVideoCallInput, userUncheckedUpdateWithoutVideoCallInput>
  }

  export type userUpdateWithoutVideoCallInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutVideoCallInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type wellnessCategoryCreateWithoutWellnessBadgeInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoal?: wellnessGoalCreateNestedManyWithoutWellnessCategoryInput
  }

  export type wellnessCategoryUncheckedCreateWithoutWellnessBadgeInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoal?: wellnessGoalUncheckedCreateNestedManyWithoutWellnessCategoryInput
  }

  export type wellnessCategoryCreateOrConnectWithoutWellnessBadgeInput = {
    where: wellnessCategoryWhereUniqueInput
    create: XOR<wellnessCategoryCreateWithoutWellnessBadgeInput, wellnessCategoryUncheckedCreateWithoutWellnessBadgeInput>
  }

  export type wellnessCategoryUpsertWithoutWellnessBadgeInput = {
    update: XOR<wellnessCategoryUpdateWithoutWellnessBadgeInput, wellnessCategoryUncheckedUpdateWithoutWellnessBadgeInput>
    create: XOR<wellnessCategoryCreateWithoutWellnessBadgeInput, wellnessCategoryUncheckedCreateWithoutWellnessBadgeInput>
    where?: wellnessCategoryWhereInput
  }

  export type wellnessCategoryUpdateToOneWithWhereWithoutWellnessBadgeInput = {
    where?: wellnessCategoryWhereInput
    data: XOR<wellnessCategoryUpdateWithoutWellnessBadgeInput, wellnessCategoryUncheckedUpdateWithoutWellnessBadgeInput>
  }

  export type wellnessCategoryUpdateWithoutWellnessBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoal?: wellnessGoalUpdateManyWithoutWellnessCategoryNestedInput
  }

  export type wellnessCategoryUncheckedUpdateWithoutWellnessBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoal?: wellnessGoalUncheckedUpdateManyWithoutWellnessCategoryNestedInput
  }

  export type wellnessGoalProgressCreateWithoutWellnessGoalInput = {
    id?: string
    recordingDate: Date | string
    achievedValue: number
    goalAchieved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput = {
    id?: string
    recordingDate: Date | string
    achievedValue: number
    goalAchieved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalProgressCreateOrConnectWithoutWellnessGoalInput = {
    where: wellnessGoalProgressWhereUniqueInput
    create: XOR<wellnessGoalProgressCreateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput>
  }

  export type wellnessGoalProgressCreateManyWellnessGoalInputEnvelope = {
    data: wellnessGoalProgressCreateManyWellnessGoalInput | wellnessGoalProgressCreateManyWellnessGoalInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutWellnessGoalInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityCreateNestedManyWithoutUserInput
    activityLog?: activityLogCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderCreateNestedManyWithoutUserInput
    message?: messageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesCreateNestedOneWithoutUserInput
    projectMember?: projectMemberCreateNestedManyWithoutUserInput
    projectTask?: projectTaskCreateNestedManyWithoutUserInput
    resource?: resourceCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportCreateNestedManyWithoutUserInput
    userActivity?: userActivityCreateNestedManyWithoutUserInput
    userBadge?: userBadgeCreateNestedManyWithoutUserInput
    userDevice?: userDeviceCreateNestedManyWithoutUserInput
    userSkill?: userSkillCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsCreateNestedOneWithoutUserInput
    videoCall?: videoCallCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutWellnessGoalInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    birthDate?: Date | string | null
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    profilePicture?: string | null
    registrationDate?: Date | string
    accountVerified?: boolean
    interfacePreferences?: string | null
    twoFactorAuthentication?: boolean
    helpPoints?: number | null
    reducedMobility?: boolean | null
    activityLevel?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity?: activityUncheckedCreateNestedManyWithoutUserInput
    activityLog?: activityLogUncheckedCreateNestedManyWithoutUserInput
    activityRegistration?: activityRegistrationUncheckedCreateNestedManyWithoutUserInput
    collaborativeProject?: collaborativeProjectUncheckedCreateNestedManyWithoutUserInput
    conversationParticipant?: conversationParticipantUncheckedCreateNestedManyWithoutUserInput
    forumMessage?: forumMessageUncheckedCreateNestedManyWithoutUserInput
    forumTopic?: forumTopicUncheckedCreateNestedManyWithoutUserInput
    healthIndicator?: healthIndicatorUncheckedCreateNestedManyWithoutUserInput
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutUserInput
    helpRequest?: helpRequestUncheckedCreateNestedManyWithoutUserInput
    medicationReminder?: medicationReminderUncheckedCreateNestedManyWithoutUserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: notificationPreferencesUncheckedCreateNestedOneWithoutUserInput
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutUserInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    resource?: resourceUncheckedCreateNestedManyWithoutUserInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutUserInput
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutUserInput
    surveyResponse?: surveyResponseUncheckedCreateNestedManyWithoutUserInput
    trustedContact?: trustedContactUncheckedCreateNestedManyWithoutUserInput
    urbanIssueReport?: urbanIssueReportUncheckedCreateNestedManyWithoutUserInput
    userActivity?: userActivityUncheckedCreateNestedManyWithoutUserInput
    userBadge?: userBadgeUncheckedCreateNestedManyWithoutUserInput
    userDevice?: userDeviceUncheckedCreateNestedManyWithoutUserInput
    userSkill?: userSkillUncheckedCreateNestedManyWithoutUserInput
    userStatistics?: userStatisticsUncheckedCreateNestedOneWithoutUserInput
    videoCall?: videoCallUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutWellnessGoalInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutWellnessGoalInput, userUncheckedCreateWithoutWellnessGoalInput>
  }

  export type wellnessCategoryCreateWithoutWellnessGoalInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessBadge?: wellnessBadgeCreateNestedManyWithoutWellnessCategoryInput
  }

  export type wellnessCategoryUncheckedCreateWithoutWellnessGoalInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessBadge?: wellnessBadgeUncheckedCreateNestedManyWithoutWellnessCategoryInput
  }

  export type wellnessCategoryCreateOrConnectWithoutWellnessGoalInput = {
    where: wellnessCategoryWhereUniqueInput
    create: XOR<wellnessCategoryCreateWithoutWellnessGoalInput, wellnessCategoryUncheckedCreateWithoutWellnessGoalInput>
  }

  export type wellnessGoalProgressUpsertWithWhereUniqueWithoutWellnessGoalInput = {
    where: wellnessGoalProgressWhereUniqueInput
    update: XOR<wellnessGoalProgressUpdateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedUpdateWithoutWellnessGoalInput>
    create: XOR<wellnessGoalProgressCreateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedCreateWithoutWellnessGoalInput>
  }

  export type wellnessGoalProgressUpdateWithWhereUniqueWithoutWellnessGoalInput = {
    where: wellnessGoalProgressWhereUniqueInput
    data: XOR<wellnessGoalProgressUpdateWithoutWellnessGoalInput, wellnessGoalProgressUncheckedUpdateWithoutWellnessGoalInput>
  }

  export type wellnessGoalProgressUpdateManyWithWhereWithoutWellnessGoalInput = {
    where: wellnessGoalProgressScalarWhereInput
    data: XOR<wellnessGoalProgressUpdateManyMutationInput, wellnessGoalProgressUncheckedUpdateManyWithoutWellnessGoalInput>
  }

  export type wellnessGoalProgressScalarWhereInput = {
    AND?: wellnessGoalProgressScalarWhereInput | wellnessGoalProgressScalarWhereInput[]
    OR?: wellnessGoalProgressScalarWhereInput[]
    NOT?: wellnessGoalProgressScalarWhereInput | wellnessGoalProgressScalarWhereInput[]
    id?: StringFilter<"wellnessGoalProgress"> | string
    goalId?: StringFilter<"wellnessGoalProgress"> | string
    recordingDate?: DateTimeFilter<"wellnessGoalProgress"> | Date | string
    achievedValue?: IntFilter<"wellnessGoalProgress"> | number
    goalAchieved?: BoolFilter<"wellnessGoalProgress"> | boolean
    createdAt?: DateTimeFilter<"wellnessGoalProgress"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessGoalProgress"> | Date | string | null
  }

  export type userUpsertWithoutWellnessGoalInput = {
    update: XOR<userUpdateWithoutWellnessGoalInput, userUncheckedUpdateWithoutWellnessGoalInput>
    create: XOR<userCreateWithoutWellnessGoalInput, userUncheckedCreateWithoutWellnessGoalInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutWellnessGoalInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutWellnessGoalInput, userUncheckedUpdateWithoutWellnessGoalInput>
  }

  export type userUpdateWithoutWellnessGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUpdateManyWithoutUserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUpdateManyWithoutUserNestedInput
    resource?: resourceUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutWellnessGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountVerified?: BoolFieldUpdateOperationsInput | boolean
    interfacePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorAuthentication?: BoolFieldUpdateOperationsInput | boolean
    helpPoints?: NullableIntFieldUpdateOperationsInput | number | null
    reducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUncheckedUpdateManyWithoutUserNestedInput
    activityLog?: activityLogUncheckedUpdateManyWithoutUserNestedInput
    activityRegistration?: activityRegistrationUncheckedUpdateManyWithoutUserNestedInput
    collaborativeProject?: collaborativeProjectUncheckedUpdateManyWithoutUserNestedInput
    conversationParticipant?: conversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    forumMessage?: forumMessageUncheckedUpdateManyWithoutUserNestedInput
    forumTopic?: forumTopicUncheckedUpdateManyWithoutUserNestedInput
    healthIndicator?: healthIndicatorUncheckedUpdateManyWithoutUserNestedInput
    helpOffer?: helpOfferUncheckedUpdateManyWithoutUserNestedInput
    helpRequest?: helpRequestUncheckedUpdateManyWithoutUserNestedInput
    medicationReminder?: medicationReminderUncheckedUpdateManyWithoutUserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: notificationPreferencesUncheckedUpdateOneWithoutUserNestedInput
    projectMember?: projectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutUserNestedInput
    resource?: resourceUncheckedUpdateManyWithoutUserNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutUserNestedInput
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutUserNestedInput
    surveyResponse?: surveyResponseUncheckedUpdateManyWithoutUserNestedInput
    trustedContact?: trustedContactUncheckedUpdateManyWithoutUserNestedInput
    urbanIssueReport?: urbanIssueReportUncheckedUpdateManyWithoutUserNestedInput
    userActivity?: userActivityUncheckedUpdateManyWithoutUserNestedInput
    userBadge?: userBadgeUncheckedUpdateManyWithoutUserNestedInput
    userDevice?: userDeviceUncheckedUpdateManyWithoutUserNestedInput
    userSkill?: userSkillUncheckedUpdateManyWithoutUserNestedInput
    userStatistics?: userStatisticsUncheckedUpdateOneWithoutUserNestedInput
    videoCall?: videoCallUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type wellnessCategoryUpsertWithoutWellnessGoalInput = {
    update: XOR<wellnessCategoryUpdateWithoutWellnessGoalInput, wellnessCategoryUncheckedUpdateWithoutWellnessGoalInput>
    create: XOR<wellnessCategoryCreateWithoutWellnessGoalInput, wellnessCategoryUncheckedCreateWithoutWellnessGoalInput>
    where?: wellnessCategoryWhereInput
  }

  export type wellnessCategoryUpdateToOneWithWhereWithoutWellnessGoalInput = {
    where?: wellnessCategoryWhereInput
    data: XOR<wellnessCategoryUpdateWithoutWellnessGoalInput, wellnessCategoryUncheckedUpdateWithoutWellnessGoalInput>
  }

  export type wellnessCategoryUpdateWithoutWellnessGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessBadge?: wellnessBadgeUpdateManyWithoutWellnessCategoryNestedInput
  }

  export type wellnessCategoryUncheckedUpdateWithoutWellnessGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessBadge?: wellnessBadgeUncheckedUpdateManyWithoutWellnessCategoryNestedInput
  }

  export type wellnessGoalCreateWithoutWellnessGoalProgressInput = {
    id?: string
    title: string
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutWellnessGoalInput
    wellnessCategory?: wellnessCategoryCreateNestedOneWithoutWellnessGoalInput
  }

  export type wellnessGoalUncheckedCreateWithoutWellnessGoalProgressInput = {
    id?: string
    userId: string
    title: string
    categoryId?: string | null
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalCreateOrConnectWithoutWellnessGoalProgressInput = {
    where: wellnessGoalWhereUniqueInput
    create: XOR<wellnessGoalCreateWithoutWellnessGoalProgressInput, wellnessGoalUncheckedCreateWithoutWellnessGoalProgressInput>
  }

  export type wellnessGoalUpsertWithoutWellnessGoalProgressInput = {
    update: XOR<wellnessGoalUpdateWithoutWellnessGoalProgressInput, wellnessGoalUncheckedUpdateWithoutWellnessGoalProgressInput>
    create: XOR<wellnessGoalCreateWithoutWellnessGoalProgressInput, wellnessGoalUncheckedCreateWithoutWellnessGoalProgressInput>
    where?: wellnessGoalWhereInput
  }

  export type wellnessGoalUpdateToOneWithWhereWithoutWellnessGoalProgressInput = {
    where?: wellnessGoalWhereInput
    data: XOR<wellnessGoalUpdateWithoutWellnessGoalProgressInput, wellnessGoalUncheckedUpdateWithoutWellnessGoalProgressInput>
  }

  export type wellnessGoalUpdateWithoutWellnessGoalProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutWellnessGoalNestedInput
    wellnessCategory?: wellnessCategoryUpdateOneWithoutWellnessGoalNestedInput
  }

  export type wellnessGoalUncheckedUpdateWithoutWellnessGoalProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityCreateWithoutActivityCategoryInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutActivityInput
    activity_registration?: activityRegistrationCreateNestedManyWithoutActivityInput
  }

  export type activityUncheckedCreateWithoutActivityCategoryInput = {
    id?: string
    creatorId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    activity_registration?: activityRegistrationUncheckedCreateNestedManyWithoutActivityInput
  }

  export type activityCreateOrConnectWithoutActivityCategoryInput = {
    where: activityWhereUniqueInput
    create: XOR<activityCreateWithoutActivityCategoryInput, activityUncheckedCreateWithoutActivityCategoryInput>
  }

  export type activityCreateManyActivityCategoryInputEnvelope = {
    data: activityCreateManyActivityCategoryInput | activityCreateManyActivityCategoryInput[]
    skipDuplicates?: boolean
  }

  export type activityUpsertWithWhereUniqueWithoutActivityCategoryInput = {
    where: activityWhereUniqueInput
    update: XOR<activityUpdateWithoutActivityCategoryInput, activityUncheckedUpdateWithoutActivityCategoryInput>
    create: XOR<activityCreateWithoutActivityCategoryInput, activityUncheckedCreateWithoutActivityCategoryInput>
  }

  export type activityUpdateWithWhereUniqueWithoutActivityCategoryInput = {
    where: activityWhereUniqueInput
    data: XOR<activityUpdateWithoutActivityCategoryInput, activityUncheckedUpdateWithoutActivityCategoryInput>
  }

  export type activityUpdateManyWithWhereWithoutActivityCategoryInput = {
    where: activityScalarWhereInput
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyWithoutActivityCategoryInput>
  }

  export type badgeCreateWithoutBadgeCategoryInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userBadge?: userBadgeCreateNestedOneWithoutBadgeInput
  }

  export type badgeUncheckedCreateWithoutBadgeCategoryInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userBadge?: userBadgeUncheckedCreateNestedOneWithoutBadgeInput
  }

  export type badgeCreateOrConnectWithoutBadgeCategoryInput = {
    where: badgeWhereUniqueInput
    create: XOR<badgeCreateWithoutBadgeCategoryInput, badgeUncheckedCreateWithoutBadgeCategoryInput>
  }

  export type badgeCreateManyBadgeCategoryInputEnvelope = {
    data: badgeCreateManyBadgeCategoryInput | badgeCreateManyBadgeCategoryInput[]
    skipDuplicates?: boolean
  }

  export type badgeUpsertWithWhereUniqueWithoutBadgeCategoryInput = {
    where: badgeWhereUniqueInput
    update: XOR<badgeUpdateWithoutBadgeCategoryInput, badgeUncheckedUpdateWithoutBadgeCategoryInput>
    create: XOR<badgeCreateWithoutBadgeCategoryInput, badgeUncheckedCreateWithoutBadgeCategoryInput>
  }

  export type badgeUpdateWithWhereUniqueWithoutBadgeCategoryInput = {
    where: badgeWhereUniqueInput
    data: XOR<badgeUpdateWithoutBadgeCategoryInput, badgeUncheckedUpdateWithoutBadgeCategoryInput>
  }

  export type badgeUpdateManyWithWhereWithoutBadgeCategoryInput = {
    where: badgeScalarWhereInput
    data: XOR<badgeUpdateManyMutationInput, badgeUncheckedUpdateManyWithoutBadgeCategoryInput>
  }

  export type badgeScalarWhereInput = {
    AND?: badgeScalarWhereInput | badgeScalarWhereInput[]
    OR?: badgeScalarWhereInput[]
    NOT?: badgeScalarWhereInput | badgeScalarWhereInput[]
    id?: StringFilter<"badge"> | string
    name?: StringFilter<"badge"> | string
    categoryId?: StringNullableFilter<"badge"> | string | null
    description?: StringNullableFilter<"badge"> | string | null
    icon?: StringNullableFilter<"badge"> | string | null
    level?: IntNullableFilter<"badge"> | number | null
    createdAt?: DateTimeFilter<"badge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"badge"> | Date | string | null
  }

  export type cognitiveExerciseCreateWithoutCognitiveCategoryInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userActivity?: userActivityCreateNestedManyWithoutCognitiveExerciseInput
    programCategory?: programCategoryCreateNestedOneWithoutCognitiveExerciseInput
  }

  export type cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    programCategoryId?: string | null
    userActivity?: userActivityUncheckedCreateNestedManyWithoutCognitiveExerciseInput
  }

  export type cognitiveExerciseCreateOrConnectWithoutCognitiveCategoryInput = {
    where: cognitiveExerciseWhereUniqueInput
    create: XOR<cognitiveExerciseCreateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput>
  }

  export type cognitiveExerciseCreateManyCognitiveCategoryInputEnvelope = {
    data: cognitiveExerciseCreateManyCognitiveCategoryInput | cognitiveExerciseCreateManyCognitiveCategoryInput[]
    skipDuplicates?: boolean
  }

  export type cognitiveExerciseUpsertWithWhereUniqueWithoutCognitiveCategoryInput = {
    where: cognitiveExerciseWhereUniqueInput
    update: XOR<cognitiveExerciseUpdateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedUpdateWithoutCognitiveCategoryInput>
    create: XOR<cognitiveExerciseCreateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedCreateWithoutCognitiveCategoryInput>
  }

  export type cognitiveExerciseUpdateWithWhereUniqueWithoutCognitiveCategoryInput = {
    where: cognitiveExerciseWhereUniqueInput
    data: XOR<cognitiveExerciseUpdateWithoutCognitiveCategoryInput, cognitiveExerciseUncheckedUpdateWithoutCognitiveCategoryInput>
  }

  export type cognitiveExerciseUpdateManyWithWhereWithoutCognitiveCategoryInput = {
    where: cognitiveExerciseScalarWhereInput
    data: XOR<cognitiveExerciseUpdateManyMutationInput, cognitiveExerciseUncheckedUpdateManyWithoutCognitiveCategoryInput>
  }

  export type cognitiveExerciseScalarWhereInput = {
    AND?: cognitiveExerciseScalarWhereInput | cognitiveExerciseScalarWhereInput[]
    OR?: cognitiveExerciseScalarWhereInput[]
    NOT?: cognitiveExerciseScalarWhereInput | cognitiveExerciseScalarWhereInput[]
    id?: StringFilter<"cognitiveExercise"> | string
    name?: StringFilter<"cognitiveExercise"> | string
    categoryId?: StringNullableFilter<"cognitiveExercise"> | string | null
    difficultyLevel?: IntNullableFilter<"cognitiveExercise"> | number | null
    durationMinutes?: IntNullableFilter<"cognitiveExercise"> | number | null
    description?: StringNullableFilter<"cognitiveExercise"> | string | null
    image?: StringNullableFilter<"cognitiveExercise"> | string | null
    createdAt?: DateTimeFilter<"cognitiveExercise"> | Date | string
    updatedAt?: DateTimeNullableFilter<"cognitiveExercise"> | Date | string | null
    programCategoryId?: StringNullableFilter<"cognitiveExercise"> | string | null
  }

  export type helpRequestCreateWithoutHelpCategoryInput = {
    id?: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferCreateNestedManyWithoutHelpRequestInput
    user: userCreateNestedOneWithoutHelpRequestInput
    serviceCompleted?: serviceCompletedCreateNestedManyWithoutHelpRequestInput
  }

  export type helpRequestUncheckedCreateWithoutHelpCategoryInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    helpOffer?: helpOfferUncheckedCreateNestedManyWithoutHelpRequestInput
    serviceCompleted?: serviceCompletedUncheckedCreateNestedManyWithoutHelpRequestInput
  }

  export type helpRequestCreateOrConnectWithoutHelpCategoryInput = {
    where: helpRequestWhereUniqueInput
    create: XOR<helpRequestCreateWithoutHelpCategoryInput, helpRequestUncheckedCreateWithoutHelpCategoryInput>
  }

  export type helpRequestCreateManyHelpCategoryInputEnvelope = {
    data: helpRequestCreateManyHelpCategoryInput | helpRequestCreateManyHelpCategoryInput[]
    skipDuplicates?: boolean
  }

  export type helpRequestUpsertWithWhereUniqueWithoutHelpCategoryInput = {
    where: helpRequestWhereUniqueInput
    update: XOR<helpRequestUpdateWithoutHelpCategoryInput, helpRequestUncheckedUpdateWithoutHelpCategoryInput>
    create: XOR<helpRequestCreateWithoutHelpCategoryInput, helpRequestUncheckedCreateWithoutHelpCategoryInput>
  }

  export type helpRequestUpdateWithWhereUniqueWithoutHelpCategoryInput = {
    where: helpRequestWhereUniqueInput
    data: XOR<helpRequestUpdateWithoutHelpCategoryInput, helpRequestUncheckedUpdateWithoutHelpCategoryInput>
  }

  export type helpRequestUpdateManyWithWhereWithoutHelpCategoryInput = {
    where: helpRequestScalarWhereInput
    data: XOR<helpRequestUpdateManyMutationInput, helpRequestUncheckedUpdateManyWithoutHelpCategoryInput>
  }

  export type urbanIssueReportCreateWithoutIssueCategoryInput = {
    id?: string
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutUrbanIssueReportInput
  }

  export type urbanIssueReportUncheckedCreateWithoutIssueCategoryInput = {
    id?: string
    userId: string
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type urbanIssueReportCreateOrConnectWithoutIssueCategoryInput = {
    where: urbanIssueReportWhereUniqueInput
    create: XOR<urbanIssueReportCreateWithoutIssueCategoryInput, urbanIssueReportUncheckedCreateWithoutIssueCategoryInput>
  }

  export type urbanIssueReportCreateManyIssueCategoryInputEnvelope = {
    data: urbanIssueReportCreateManyIssueCategoryInput | urbanIssueReportCreateManyIssueCategoryInput[]
    skipDuplicates?: boolean
  }

  export type urbanIssueReportUpsertWithWhereUniqueWithoutIssueCategoryInput = {
    where: urbanIssueReportWhereUniqueInput
    update: XOR<urbanIssueReportUpdateWithoutIssueCategoryInput, urbanIssueReportUncheckedUpdateWithoutIssueCategoryInput>
    create: XOR<urbanIssueReportCreateWithoutIssueCategoryInput, urbanIssueReportUncheckedCreateWithoutIssueCategoryInput>
  }

  export type urbanIssueReportUpdateWithWhereUniqueWithoutIssueCategoryInput = {
    where: urbanIssueReportWhereUniqueInput
    data: XOR<urbanIssueReportUpdateWithoutIssueCategoryInput, urbanIssueReportUncheckedUpdateWithoutIssueCategoryInput>
  }

  export type urbanIssueReportUpdateManyWithWhereWithoutIssueCategoryInput = {
    where: urbanIssueReportScalarWhereInput
    data: XOR<urbanIssueReportUpdateManyMutationInput, urbanIssueReportUncheckedUpdateManyWithoutIssueCategoryInput>
  }

  export type nutritionalAdviceCreateWithoutNutritionalCategoryInput = {
    id?: string
    title: string
    description?: string | null
    season?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput = {
    id?: string
    title: string
    description?: string | null
    season?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalAdviceCreateOrConnectWithoutNutritionalCategoryInput = {
    where: nutritionalAdviceWhereUniqueInput
    create: XOR<nutritionalAdviceCreateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput>
  }

  export type nutritionalAdviceCreateManyNutritionalCategoryInputEnvelope = {
    data: nutritionalAdviceCreateManyNutritionalCategoryInput | nutritionalAdviceCreateManyNutritionalCategoryInput[]
    skipDuplicates?: boolean
  }

  export type nutritionalAdviceUpsertWithWhereUniqueWithoutNutritionalCategoryInput = {
    where: nutritionalAdviceWhereUniqueInput
    update: XOR<nutritionalAdviceUpdateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedUpdateWithoutNutritionalCategoryInput>
    create: XOR<nutritionalAdviceCreateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedCreateWithoutNutritionalCategoryInput>
  }

  export type nutritionalAdviceUpdateWithWhereUniqueWithoutNutritionalCategoryInput = {
    where: nutritionalAdviceWhereUniqueInput
    data: XOR<nutritionalAdviceUpdateWithoutNutritionalCategoryInput, nutritionalAdviceUncheckedUpdateWithoutNutritionalCategoryInput>
  }

  export type nutritionalAdviceUpdateManyWithWhereWithoutNutritionalCategoryInput = {
    where: nutritionalAdviceScalarWhereInput
    data: XOR<nutritionalAdviceUpdateManyMutationInput, nutritionalAdviceUncheckedUpdateManyWithoutNutritionalCategoryInput>
  }

  export type nutritionalAdviceScalarWhereInput = {
    AND?: nutritionalAdviceScalarWhereInput | nutritionalAdviceScalarWhereInput[]
    OR?: nutritionalAdviceScalarWhereInput[]
    NOT?: nutritionalAdviceScalarWhereInput | nutritionalAdviceScalarWhereInput[]
    id?: StringFilter<"nutritionalAdvice"> | string
    title?: StringFilter<"nutritionalAdvice"> | string
    description?: StringNullableFilter<"nutritionalAdvice"> | string | null
    categoryId?: StringFilter<"nutritionalAdvice"> | string
    season?: StringNullableFilter<"nutritionalAdvice"> | string | null
    image?: StringNullableFilter<"nutritionalAdvice"> | string | null
    createdAt?: DateTimeFilter<"nutritionalAdvice"> | Date | string
    updatedAt?: DateTimeNullableFilter<"nutritionalAdvice"> | Date | string | null
  }

  export type cognitiveExerciseCreateWithoutProgramCategoryInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cognitiveCategory?: cognitiveCategoryCreateNestedOneWithoutCognitiveExerciseInput
    userActivity?: userActivityCreateNestedManyWithoutCognitiveExerciseInput
  }

  export type cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userActivity?: userActivityUncheckedCreateNestedManyWithoutCognitiveExerciseInput
  }

  export type cognitiveExerciseCreateOrConnectWithoutProgramCategoryInput = {
    where: cognitiveExerciseWhereUniqueInput
    create: XOR<cognitiveExerciseCreateWithoutProgramCategoryInput, cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput>
  }

  export type cognitiveExerciseCreateManyProgramCategoryInputEnvelope = {
    data: cognitiveExerciseCreateManyProgramCategoryInput | cognitiveExerciseCreateManyProgramCategoryInput[]
    skipDuplicates?: boolean
  }

  export type exerciseProgramCreateWithoutProgramCategoryInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userActivity?: userActivityCreateNestedManyWithoutExerciseProgramInput
  }

  export type exerciseProgramUncheckedCreateWithoutProgramCategoryInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userActivity?: userActivityUncheckedCreateNestedManyWithoutExerciseProgramInput
  }

  export type exerciseProgramCreateOrConnectWithoutProgramCategoryInput = {
    where: exerciseProgramWhereUniqueInput
    create: XOR<exerciseProgramCreateWithoutProgramCategoryInput, exerciseProgramUncheckedCreateWithoutProgramCategoryInput>
  }

  export type exerciseProgramCreateManyProgramCategoryInputEnvelope = {
    data: exerciseProgramCreateManyProgramCategoryInput | exerciseProgramCreateManyProgramCategoryInput[]
    skipDuplicates?: boolean
  }

  export type cognitiveExerciseUpsertWithWhereUniqueWithoutProgramCategoryInput = {
    where: cognitiveExerciseWhereUniqueInput
    update: XOR<cognitiveExerciseUpdateWithoutProgramCategoryInput, cognitiveExerciseUncheckedUpdateWithoutProgramCategoryInput>
    create: XOR<cognitiveExerciseCreateWithoutProgramCategoryInput, cognitiveExerciseUncheckedCreateWithoutProgramCategoryInput>
  }

  export type cognitiveExerciseUpdateWithWhereUniqueWithoutProgramCategoryInput = {
    where: cognitiveExerciseWhereUniqueInput
    data: XOR<cognitiveExerciseUpdateWithoutProgramCategoryInput, cognitiveExerciseUncheckedUpdateWithoutProgramCategoryInput>
  }

  export type cognitiveExerciseUpdateManyWithWhereWithoutProgramCategoryInput = {
    where: cognitiveExerciseScalarWhereInput
    data: XOR<cognitiveExerciseUpdateManyMutationInput, cognitiveExerciseUncheckedUpdateManyWithoutProgramCategoryInput>
  }

  export type exerciseProgramUpsertWithWhereUniqueWithoutProgramCategoryInput = {
    where: exerciseProgramWhereUniqueInput
    update: XOR<exerciseProgramUpdateWithoutProgramCategoryInput, exerciseProgramUncheckedUpdateWithoutProgramCategoryInput>
    create: XOR<exerciseProgramCreateWithoutProgramCategoryInput, exerciseProgramUncheckedCreateWithoutProgramCategoryInput>
  }

  export type exerciseProgramUpdateWithWhereUniqueWithoutProgramCategoryInput = {
    where: exerciseProgramWhereUniqueInput
    data: XOR<exerciseProgramUpdateWithoutProgramCategoryInput, exerciseProgramUncheckedUpdateWithoutProgramCategoryInput>
  }

  export type exerciseProgramUpdateManyWithWhereWithoutProgramCategoryInput = {
    where: exerciseProgramScalarWhereInput
    data: XOR<exerciseProgramUpdateManyMutationInput, exerciseProgramUncheckedUpdateManyWithoutProgramCategoryInput>
  }

  export type exerciseProgramScalarWhereInput = {
    AND?: exerciseProgramScalarWhereInput | exerciseProgramScalarWhereInput[]
    OR?: exerciseProgramScalarWhereInput[]
    NOT?: exerciseProgramScalarWhereInput | exerciseProgramScalarWhereInput[]
    id?: StringFilter<"exerciseProgram"> | string
    name?: StringFilter<"exerciseProgram"> | string
    categoryId?: StringNullableFilter<"exerciseProgram"> | string | null
    difficultyLevel?: IntNullableFilter<"exerciseProgram"> | number | null
    adaptedForReducedMobility?: BoolNullableFilter<"exerciseProgram"> | boolean | null
    durationMinutes?: IntNullableFilter<"exerciseProgram"> | number | null
    description?: StringNullableFilter<"exerciseProgram"> | string | null
    videoLink?: StringNullableFilter<"exerciseProgram"> | string | null
    image?: StringNullableFilter<"exerciseProgram"> | string | null
    createdAt?: DateTimeFilter<"exerciseProgram"> | Date | string
    updatedAt?: DateTimeNullableFilter<"exerciseProgram"> | Date | string | null
  }

  export type collaborativeProjectCreateWithoutProjectCategoryInput = {
    id?: string
    title: string
    description?: string | null
    creationDate?: Date | string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutCollaborativeProjectInput
    projectMember?: projectMemberCreateNestedManyWithoutCollaborativeProjectInput
    projectTask?: projectTaskCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectUncheckedCreateWithoutProjectCategoryInput = {
    id?: string
    title: string
    description?: string | null
    creatorId: string
    creationDate?: Date | string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    projectMember?: projectMemberUncheckedCreateNestedManyWithoutCollaborativeProjectInput
    projectTask?: projectTaskUncheckedCreateNestedManyWithoutCollaborativeProjectInput
  }

  export type collaborativeProjectCreateOrConnectWithoutProjectCategoryInput = {
    where: collaborativeProjectWhereUniqueInput
    create: XOR<collaborativeProjectCreateWithoutProjectCategoryInput, collaborativeProjectUncheckedCreateWithoutProjectCategoryInput>
  }

  export type collaborativeProjectCreateManyProjectCategoryInputEnvelope = {
    data: collaborativeProjectCreateManyProjectCategoryInput | collaborativeProjectCreateManyProjectCategoryInput[]
    skipDuplicates?: boolean
  }

  export type collaborativeProjectUpsertWithWhereUniqueWithoutProjectCategoryInput = {
    where: collaborativeProjectWhereUniqueInput
    update: XOR<collaborativeProjectUpdateWithoutProjectCategoryInput, collaborativeProjectUncheckedUpdateWithoutProjectCategoryInput>
    create: XOR<collaborativeProjectCreateWithoutProjectCategoryInput, collaborativeProjectUncheckedCreateWithoutProjectCategoryInput>
  }

  export type collaborativeProjectUpdateWithWhereUniqueWithoutProjectCategoryInput = {
    where: collaborativeProjectWhereUniqueInput
    data: XOR<collaborativeProjectUpdateWithoutProjectCategoryInput, collaborativeProjectUncheckedUpdateWithoutProjectCategoryInput>
  }

  export type collaborativeProjectUpdateManyWithWhereWithoutProjectCategoryInput = {
    where: collaborativeProjectScalarWhereInput
    data: XOR<collaborativeProjectUpdateManyMutationInput, collaborativeProjectUncheckedUpdateManyWithoutProjectCategoryInput>
  }

  export type resourceCreateWithoutResourceCategoryInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: userCreateNestedOneWithoutResourceInput
  }

  export type resourceUncheckedCreateWithoutResourceCategoryInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    authorId: string
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceCreateOrConnectWithoutResourceCategoryInput = {
    where: resourceWhereUniqueInput
    create: XOR<resourceCreateWithoutResourceCategoryInput, resourceUncheckedCreateWithoutResourceCategoryInput>
  }

  export type resourceCreateManyResourceCategoryInputEnvelope = {
    data: resourceCreateManyResourceCategoryInput | resourceCreateManyResourceCategoryInput[]
    skipDuplicates?: boolean
  }

  export type resourceUpsertWithWhereUniqueWithoutResourceCategoryInput = {
    where: resourceWhereUniqueInput
    update: XOR<resourceUpdateWithoutResourceCategoryInput, resourceUncheckedUpdateWithoutResourceCategoryInput>
    create: XOR<resourceCreateWithoutResourceCategoryInput, resourceUncheckedCreateWithoutResourceCategoryInput>
  }

  export type resourceUpdateWithWhereUniqueWithoutResourceCategoryInput = {
    where: resourceWhereUniqueInput
    data: XOR<resourceUpdateWithoutResourceCategoryInput, resourceUncheckedUpdateWithoutResourceCategoryInput>
  }

  export type resourceUpdateManyWithWhereWithoutResourceCategoryInput = {
    where: resourceScalarWhereInput
    data: XOR<resourceUpdateManyMutationInput, resourceUncheckedUpdateManyWithoutResourceCategoryInput>
  }

  export type localServiceCreateWithoutServiceCategoryInput = {
    id?: string
    name: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    serviceRating?: serviceRatingCreateNestedManyWithoutLocalServiceInput
  }

  export type localServiceUncheckedCreateWithoutServiceCategoryInput = {
    id?: string
    name: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    serviceRating?: serviceRatingUncheckedCreateNestedManyWithoutLocalServiceInput
  }

  export type localServiceCreateOrConnectWithoutServiceCategoryInput = {
    where: localServiceWhereUniqueInput
    create: XOR<localServiceCreateWithoutServiceCategoryInput, localServiceUncheckedCreateWithoutServiceCategoryInput>
  }

  export type localServiceCreateManyServiceCategoryInputEnvelope = {
    data: localServiceCreateManyServiceCategoryInput | localServiceCreateManyServiceCategoryInput[]
    skipDuplicates?: boolean
  }

  export type localServiceUpsertWithWhereUniqueWithoutServiceCategoryInput = {
    where: localServiceWhereUniqueInput
    update: XOR<localServiceUpdateWithoutServiceCategoryInput, localServiceUncheckedUpdateWithoutServiceCategoryInput>
    create: XOR<localServiceCreateWithoutServiceCategoryInput, localServiceUncheckedCreateWithoutServiceCategoryInput>
  }

  export type localServiceUpdateWithWhereUniqueWithoutServiceCategoryInput = {
    where: localServiceWhereUniqueInput
    data: XOR<localServiceUpdateWithoutServiceCategoryInput, localServiceUncheckedUpdateWithoutServiceCategoryInput>
  }

  export type localServiceUpdateManyWithWhereWithoutServiceCategoryInput = {
    where: localServiceScalarWhereInput
    data: XOR<localServiceUpdateManyMutationInput, localServiceUncheckedUpdateManyWithoutServiceCategoryInput>
  }

  export type localServiceScalarWhereInput = {
    AND?: localServiceScalarWhereInput | localServiceScalarWhereInput[]
    OR?: localServiceScalarWhereInput[]
    NOT?: localServiceScalarWhereInput | localServiceScalarWhereInput[]
    id?: StringFilter<"localService"> | string
    name?: StringFilter<"localService"> | string
    categoryId?: StringFilter<"localService"> | string
    address?: StringNullableFilter<"localService"> | string | null
    gpsCoordinates?: StringNullableFilter<"localService"> | string | null
    phone?: StringNullableFilter<"localService"> | string | null
    website?: StringNullableFilter<"localService"> | string | null
    description?: StringNullableFilter<"localService"> | string | null
    hours?: StringNullableFilter<"localService"> | string | null
    seniorFriendly?: BoolNullableFilter<"localService"> | boolean | null
    createdAt?: DateTimeFilter<"localService"> | Date | string
    updatedAt?: DateTimeNullableFilter<"localService"> | Date | string | null
  }

  export type skillCreateWithoutSkillCategoryInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userSkill?: userSkillCreateNestedManyWithoutSkillInput
  }

  export type skillUncheckedCreateWithoutSkillCategoryInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userSkill?: userSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type skillCreateOrConnectWithoutSkillCategoryInput = {
    where: skillWhereUniqueInput
    create: XOR<skillCreateWithoutSkillCategoryInput, skillUncheckedCreateWithoutSkillCategoryInput>
  }

  export type skillCreateManySkillCategoryInputEnvelope = {
    data: skillCreateManySkillCategoryInput | skillCreateManySkillCategoryInput[]
    skipDuplicates?: boolean
  }

  export type skillUpsertWithWhereUniqueWithoutSkillCategoryInput = {
    where: skillWhereUniqueInput
    update: XOR<skillUpdateWithoutSkillCategoryInput, skillUncheckedUpdateWithoutSkillCategoryInput>
    create: XOR<skillCreateWithoutSkillCategoryInput, skillUncheckedCreateWithoutSkillCategoryInput>
  }

  export type skillUpdateWithWhereUniqueWithoutSkillCategoryInput = {
    where: skillWhereUniqueInput
    data: XOR<skillUpdateWithoutSkillCategoryInput, skillUncheckedUpdateWithoutSkillCategoryInput>
  }

  export type skillUpdateManyWithWhereWithoutSkillCategoryInput = {
    where: skillScalarWhereInput
    data: XOR<skillUpdateManyMutationInput, skillUncheckedUpdateManyWithoutSkillCategoryInput>
  }

  export type skillScalarWhereInput = {
    AND?: skillScalarWhereInput | skillScalarWhereInput[]
    OR?: skillScalarWhereInput[]
    NOT?: skillScalarWhereInput | skillScalarWhereInput[]
    id?: StringFilter<"skill"> | string
    name?: StringFilter<"skill"> | string
    description?: StringNullableFilter<"skill"> | string | null
    categoryId?: StringNullableFilter<"skill"> | string | null
    createdAt?: DateTimeFilter<"skill"> | Date | string
    updatedAt?: DateTimeNullableFilter<"skill"> | Date | string | null
  }

  export type wellnessBadgeCreateWithoutWellnessCategoryInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    level: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    level: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessBadgeCreateOrConnectWithoutWellnessCategoryInput = {
    where: wellnessBadgeWhereUniqueInput
    create: XOR<wellnessBadgeCreateWithoutWellnessCategoryInput, wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput>
  }

  export type wellnessBadgeCreateManyWellnessCategoryInputEnvelope = {
    data: wellnessBadgeCreateManyWellnessCategoryInput | wellnessBadgeCreateManyWellnessCategoryInput[]
    skipDuplicates?: boolean
  }

  export type wellnessGoalCreateWithoutWellnessCategoryInput = {
    id?: string
    title: string
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressCreateNestedManyWithoutWellnessGoalInput
    user?: userCreateNestedOneWithoutWellnessGoalInput
  }

  export type wellnessGoalUncheckedCreateWithoutWellnessCategoryInput = {
    id?: string
    userId: string
    title: string
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUncheckedCreateNestedManyWithoutWellnessGoalInput
  }

  export type wellnessGoalCreateOrConnectWithoutWellnessCategoryInput = {
    where: wellnessGoalWhereUniqueInput
    create: XOR<wellnessGoalCreateWithoutWellnessCategoryInput, wellnessGoalUncheckedCreateWithoutWellnessCategoryInput>
  }

  export type wellnessGoalCreateManyWellnessCategoryInputEnvelope = {
    data: wellnessGoalCreateManyWellnessCategoryInput | wellnessGoalCreateManyWellnessCategoryInput[]
    skipDuplicates?: boolean
  }

  export type wellnessBadgeUpsertWithWhereUniqueWithoutWellnessCategoryInput = {
    where: wellnessBadgeWhereUniqueInput
    update: XOR<wellnessBadgeUpdateWithoutWellnessCategoryInput, wellnessBadgeUncheckedUpdateWithoutWellnessCategoryInput>
    create: XOR<wellnessBadgeCreateWithoutWellnessCategoryInput, wellnessBadgeUncheckedCreateWithoutWellnessCategoryInput>
  }

  export type wellnessBadgeUpdateWithWhereUniqueWithoutWellnessCategoryInput = {
    where: wellnessBadgeWhereUniqueInput
    data: XOR<wellnessBadgeUpdateWithoutWellnessCategoryInput, wellnessBadgeUncheckedUpdateWithoutWellnessCategoryInput>
  }

  export type wellnessBadgeUpdateManyWithWhereWithoutWellnessCategoryInput = {
    where: wellnessBadgeScalarWhereInput
    data: XOR<wellnessBadgeUpdateManyMutationInput, wellnessBadgeUncheckedUpdateManyWithoutWellnessCategoryInput>
  }

  export type wellnessBadgeScalarWhereInput = {
    AND?: wellnessBadgeScalarWhereInput | wellnessBadgeScalarWhereInput[]
    OR?: wellnessBadgeScalarWhereInput[]
    NOT?: wellnessBadgeScalarWhereInput | wellnessBadgeScalarWhereInput[]
    id?: StringFilter<"wellnessBadge"> | string
    name?: StringFilter<"wellnessBadge"> | string
    description?: StringNullableFilter<"wellnessBadge"> | string | null
    categoryId?: StringNullableFilter<"wellnessBadge"> | string | null
    image?: StringNullableFilter<"wellnessBadge"> | string | null
    level?: IntFilter<"wellnessBadge"> | number
    createdAt?: DateTimeFilter<"wellnessBadge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"wellnessBadge"> | Date | string | null
  }

  export type wellnessGoalUpsertWithWhereUniqueWithoutWellnessCategoryInput = {
    where: wellnessGoalWhereUniqueInput
    update: XOR<wellnessGoalUpdateWithoutWellnessCategoryInput, wellnessGoalUncheckedUpdateWithoutWellnessCategoryInput>
    create: XOR<wellnessGoalCreateWithoutWellnessCategoryInput, wellnessGoalUncheckedCreateWithoutWellnessCategoryInput>
  }

  export type wellnessGoalUpdateWithWhereUniqueWithoutWellnessCategoryInput = {
    where: wellnessGoalWhereUniqueInput
    data: XOR<wellnessGoalUpdateWithoutWellnessCategoryInput, wellnessGoalUncheckedUpdateWithoutWellnessCategoryInput>
  }

  export type wellnessGoalUpdateManyWithWhereWithoutWellnessCategoryInput = {
    where: wellnessGoalScalarWhereInput
    data: XOR<wellnessGoalUpdateManyMutationInput, wellnessGoalUncheckedUpdateManyWithoutWellnessCategoryInput>
  }

  export type activityRegistrationCreateManyActivityInput = {
    id?: string
    userId: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityRegistrationUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutActivityRegistrationNestedInput
  }

  export type activityRegistrationUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityRegistrationUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityCreateManyCognitiveExerciseInput = {
    id?: string
    userId: string
    completionDate: Date | string
    exerciseProgramId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityUpdateWithoutCognitiveExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exerciseProgram?: exerciseProgramUpdateOneWithoutUserActivityNestedInput
    user?: userUpdateOneRequiredWithoutUserActivityNestedInput
  }

  export type userActivityUncheckedUpdateWithoutCognitiveExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityUncheckedUpdateManyWithoutCognitiveExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberCreateManyCollaborativeProjectInput = {
    userId: string
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectTaskCreateManyCollaborativeProjectInput = {
    id?: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    assigneeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectMemberUpdateWithoutCollaborativeProjectInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProjectMemberNestedInput
  }

  export type projectMemberUncheckedUpdateWithoutCollaborativeProjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberUncheckedUpdateManyWithoutCollaborativeProjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectTaskUpdateWithoutCollaborativeProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutProjectTaskNestedInput
  }

  export type projectTaskUncheckedUpdateWithoutCollaborativeProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectTaskUncheckedUpdateManyWithoutCollaborativeProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationParticipantCreateManyConversationInput = {
    id?: string
    userId: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type messageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type videoCallCreateManyConversationInput = {
    id?: string
    initiatorId: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type conversationParticipantUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutConversationParticipantNestedInput
  }

  export type conversationParticipantUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutVideoCallNestedInput
  }

  export type videoCallUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityCreateManyExerciseProgramInput = {
    id?: string
    userId: string
    completionDate: Date | string
    cognitiveExerciseId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityUpdateWithoutExerciseProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUpdateOneWithoutUserActivityNestedInput
    user?: userUpdateOneRequiredWithoutUserActivityNestedInput
  }

  export type userActivityUncheckedUpdateWithoutExerciseProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cognitiveExerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityUncheckedUpdateManyWithoutExerciseProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cognitiveExerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumTopicCreateManyForumCategoryInput = {
    id?: string
    authorId: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumTopicUpdateWithoutForumCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumMessage?: forumMessageUpdateManyWithoutForumTopicNestedInput
    user?: userUpdateOneRequiredWithoutForumTopicNestedInput
  }

  export type forumTopicUncheckedUpdateWithoutForumCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumMessage?: forumMessageUncheckedUpdateManyWithoutForumTopicNestedInput
  }

  export type forumTopicUncheckedUpdateManyWithoutForumCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageCreateManyForumTopicInput = {
    id?: string
    authorId: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumMessageUpdateWithoutForumTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutForumMessageNestedInput
  }

  export type forumMessageUncheckedUpdateWithoutForumTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageUncheckedUpdateManyWithoutForumTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpOfferCreateManyHelpRequestInput = {
    id?: string
    helperId: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCompletedCreateManyHelpRequestInput = {
    id?: string
    helperId: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpOfferUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutHelpOfferNestedInput
  }

  export type helpOfferUncheckedUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpOfferUncheckedUpdateManyWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCompletedUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceCompletedNestedInput
  }

  export type serviceCompletedUncheckedUpdateWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCompletedUncheckedUpdateManyWithoutHelpRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    helperId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingCreateManyLocalServiceInput = {
    userId: string
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceRatingUpdateWithoutLocalServiceInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceRatingNestedInput
  }

  export type serviceRatingUncheckedUpdateWithoutLocalServiceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingUncheckedUpdateManyWithoutLocalServiceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseCreateManySatisfactionSurveyInput = {
    userId: string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type surveyResponseUpdateWithoutSatisfactionSurveyInput = {
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutSurveyResponseNestedInput
  }

  export type surveyResponseUncheckedUpdateWithoutSatisfactionSurveyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseUncheckedUpdateManyWithoutSatisfactionSurveyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillCreateManySkillInput = {
    userId: string
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
  }

  export type userSkillUpdateWithoutSkillInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutUserSkillNestedInput
  }

  export type userSkillUncheckedUpdateWithoutSkillInput = {
    userId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillUncheckedUpdateManyWithoutSkillInput = {
    userId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    categoryId?: string | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityLogCreateManyUserInput = {
    id?: string
    actionType?: string | null
    description?: string | null
    ipAddress?: string | null
    device?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityRegistrationCreateManyUserInput = {
    id?: string
    activityId: string
    registrationDate: Date | string
    status?: string | null
    attendanceConfirmed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type collaborativeProjectCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    creationDate?: Date | string
    status?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type conversationParticipantCreateManyUserInput = {
    id?: string
    conversationId: string
    dateAdded?: Date | string | null
    administrator?: boolean | null
    lastAccess?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumMessageCreateManyUserInput = {
    id?: string
    topicId: string
    content: string
    solutionMessage?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type forumTopicCreateManyUserInput = {
    id?: string
    categoryId: string
    title: string
    pinned?: boolean | null
    status?: string | null
    views?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type healthIndicatorCreateManyUserInput = {
    id?: string
    recordingDate: Date | string
    stepCount?: number | null
    sleepDurationMinutes?: number | null
    sleepQuality?: number | null
    weight?: number | null
    mood?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpOfferCreateManyUserInput = {
    id?: string
    requestId: string
    offerDate: Date | string
    message?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpRequestCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    categoryId: string
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type medicationReminderCreateManyUserInput = {
    id?: string
    medicationName: string
    dosage?: string | null
    morningReminderTime?: Date | string | null
    noonReminderTime?: Date | string | null
    eveningReminderTime?: Date | string | null
    nightReminderTime?: Date | string | null
    daysOfWeek?: string | null
    instructions?: string | null
    active?: boolean | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type messageCreateManyUserInput = {
    id?: string
    conversationId: string
    content: string
    sendDate: Date | string
    type?: string | null
    read?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type notificationCreateManyUserInput = {
    id?: string
    type: string
    content: string
    read?: boolean | null
    actionLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectMemberCreateManyUserInput = {
    projectId: string
    role: string
    joinDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type projectTaskCreateManyUserInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    creationDate: Date | string
    dueDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceCreateManyUserInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    categoryId?: string | null
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceCompletedCreateManyUserInput = {
    id?: string
    requestId: string
    completionDate: Date | string
    actualDuration?: number | null
    creatorComment?: string | null
    helperComment?: string | null
    creatorRating?: number | null
    helperRating?: number | null
    pointsExchanged?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type serviceRatingCreateManyUserInput = {
    serviceId: string
    rating?: number | null
    comment?: string | null
    ratingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type surveyResponseCreateManyUserInput = {
    surveyId: string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type trustedContactCreateManyUserInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    relationship?: string | null
    shareMedications?: boolean
    shareHealthIndicators?: boolean
    shareWellnessActivities?: boolean
    emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type urbanIssueReportCreateManyUserInput = {
    id?: string
    categoryId?: string | null
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userActivityCreateManyUserInput = {
    id?: string
    completionDate: Date | string
    exerciseProgramId?: string | null
    cognitiveExerciseId?: string | null
    durationMinutes?: number | null
    perceivedDifficultyLevel?: number | null
    enjoymentLevel?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userBadgeCreateManyUserInput = {
    badgeId: string
    achievementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userDeviceCreateManyUserInput = {
    id?: string
    deviceType: string
    deviceName?: string | null
    operatingSystem?: string | null
    notificationToken: string
    lastConnection: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type userSkillCreateManyUserInput = {
    skillId: string
    level?: number | null
    created_at?: Date | string
    updatedAt?: Date | string | null
  }

  export type videoCallCreateManyUserInput = {
    id?: string
    conversationId: string
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalCreateManyUserInput = {
    id?: string
    title: string
    categoryId?: string | null
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type sessionCreateManyUserInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type activityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityCategory?: activityCategoryUpdateOneWithoutActivityNestedInput
    activity_registration?: activityRegistrationUpdateManyWithoutActivityNestedInput
  }

  export type activityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_registration?: activityRegistrationUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type activityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityRegistrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: activityUpdateOneRequiredWithoutActivity_registrationNestedInput
  }

  export type activityRegistrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityRegistrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collaborativeProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectCategory?: projectCategoryUpdateOneWithoutCollaborativeProjectNestedInput
    projectMember?: projectMemberUpdateManyWithoutCollaborativeProjectNestedInput
    projectTask?: projectTaskUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectMember?: projectMemberUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: conversationUpdateOneRequiredWithoutConversationParticipantNestedInput
  }

  export type conversationParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    dateAdded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    administrator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastAccess?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumTopic?: forumTopicUpdateOneWithoutForumMessageNestedInput
  }

  export type forumMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    solutionMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forumTopicUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumMessage?: forumMessageUpdateManyWithoutForumTopicNestedInput
    forumCategory?: forumCategoryUpdateOneWithoutForumTopicNestedInput
  }

  export type forumTopicUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forumMessage?: forumMessageUncheckedUpdateManyWithoutForumTopicNestedInput
  }

  export type forumTopicUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type healthIndicatorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCount?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type healthIndicatorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCount?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type healthIndicatorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCount?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpOfferUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpRequest?: helpRequestUpdateOneRequiredWithoutHelpOfferNestedInput
  }

  export type helpOfferUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpOfferUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    offerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type helpRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUpdateManyWithoutHelpRequestNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutHelpRequestNestedInput
    helpCategory?: helpCategoryUpdateOneWithoutHelpRequestNestedInput
  }

  export type helpRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUncheckedUpdateManyWithoutHelpRequestNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutHelpRequestNestedInput
  }

  export type helpRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicationReminderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    morningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noonReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eveningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicationReminderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    morningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noonReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eveningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicationReminderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    morningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noonReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eveningReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightReminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: conversationUpdateOneWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    actionLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    actionLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    actionLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborativeProject?: collaborativeProjectUpdateOneRequiredWithoutProjectMemberNestedInput
  }

  export type projectMemberUncheckedUpdateWithoutUserInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectMemberUncheckedUpdateManyWithoutUserInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectTaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborativeProject?: collaborativeProjectUpdateOneWithoutProjectTaskNestedInput
  }

  export type projectTaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectTaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceCategory?: resourceCategoryUpdateOneWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCompletedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpRequest?: helpRequestUpdateOneRequiredWithoutServiceCompletedNestedInput
  }

  export type serviceCompletedUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCompletedUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    creatorComment?: NullableStringFieldUpdateOperationsInput | string | null
    helperComment?: NullableStringFieldUpdateOperationsInput | string | null
    creatorRating?: NullableIntFieldUpdateOperationsInput | number | null
    helperRating?: NullableIntFieldUpdateOperationsInput | number | null
    pointsExchanged?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingUpdateWithoutUserInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localService?: localServiceUpdateOneRequiredWithoutServiceRatingNestedInput
  }

  export type serviceRatingUncheckedUpdateWithoutUserInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceRatingUncheckedUpdateManyWithoutUserInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseUpdateWithoutUserInput = {
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    satisfactionSurvey?: satisfactionSurveyUpdateOneRequiredWithoutSurveyResponseNestedInput
  }

  export type surveyResponseUncheckedUpdateWithoutUserInput = {
    surveyId?: StringFieldUpdateOperationsInput | string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyResponseUncheckedUpdateManyWithoutUserInput = {
    surveyId?: StringFieldUpdateOperationsInput | string
    responses?: NullableJsonNullValueInput | InputJsonValue
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustedContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    shareMedications?: BoolFieldUpdateOperationsInput | boolean
    shareHealthIndicators?: BoolFieldUpdateOperationsInput | boolean
    shareWellnessActivities?: BoolFieldUpdateOperationsInput | boolean
    emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustedContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    shareMedications?: BoolFieldUpdateOperationsInput | boolean
    shareHealthIndicators?: BoolFieldUpdateOperationsInput | boolean
    shareWellnessActivities?: BoolFieldUpdateOperationsInput | boolean
    emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trustedContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    shareMedications?: BoolFieldUpdateOperationsInput | boolean
    shareHealthIndicators?: BoolFieldUpdateOperationsInput | boolean
    shareWellnessActivities?: BoolFieldUpdateOperationsInput | boolean
    emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type urbanIssueReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issueCategory?: issueCategoryUpdateOneWithoutUrbanIssueReportNestedInput
  }

  export type urbanIssueReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type urbanIssueReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveExercise?: cognitiveExerciseUpdateOneWithoutUserActivityNestedInput
    exerciseProgram?: exerciseProgramUpdateOneWithoutUserActivityNestedInput
  }

  export type userActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    cognitiveExerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    cognitiveExerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    perceivedDifficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    enjoymentLevel?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userBadgeUpdateWithoutUserInput = {
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateOneRequiredWithoutUserBadgeNestedInput
  }

  export type userBadgeUncheckedUpdateWithoutUserInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userBadgeUncheckedUpdateManyWithoutUserInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    achievementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userDeviceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToken?: StringFieldUpdateOperationsInput | string
    lastConnection?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userDeviceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToken?: StringFieldUpdateOperationsInput | string
    lastConnection?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userDeviceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToken?: StringFieldUpdateOperationsInput | string
    lastConnection?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillUpdateWithoutUserInput = {
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skill?: skillUpdateOneRequiredWithoutUserSkillNestedInput
  }

  export type userSkillUncheckedUpdateWithoutUserInput = {
    skillId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSkillUncheckedUpdateManyWithoutUserInput = {
    skillId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: conversationUpdateOneWithoutVideoCallNestedInput
  }

  export type videoCallUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videoCallUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUpdateManyWithoutWellnessGoalNestedInput
    wellnessCategory?: wellnessCategoryUpdateOneWithoutWellnessGoalNestedInput
  }

  export type wellnessGoalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUncheckedUpdateManyWithoutWellnessGoalNestedInput
  }

  export type wellnessGoalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wellnessGoalProgressCreateManyWellnessGoalInput = {
    id?: string
    recordingDate: Date | string
    achievedValue: number
    goalAchieved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalProgressUpdateWithoutWellnessGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievedValue?: IntFieldUpdateOperationsInput | number
    goalAchieved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalProgressUncheckedUpdateWithoutWellnessGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievedValue?: IntFieldUpdateOperationsInput | number
    goalAchieved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalProgressUncheckedUpdateManyWithoutWellnessGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievedValue?: IntFieldUpdateOperationsInput | number
    goalAchieved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activityCreateManyActivityCategoryInput = {
    id?: string
    creatorId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    gpsCoordinates?: string | null
    maxSpots?: number | null
    recurring?: boolean | null
    frequency?: string | null
    reducedMobilityAccess?: boolean
    difficultyLevel?: number | null
    cost?: number | null
    status?: string | null
    weatherRequirements?: string | null
    transportOptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type activityUpdateWithoutActivityCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutActivityNestedInput
    activity_registration?: activityRegistrationUpdateManyWithoutActivityNestedInput
  }

  export type activityUncheckedUpdateWithoutActivityCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_registration?: activityRegistrationUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type activityUncheckedUpdateManyWithoutActivityCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    maxSpots?: NullableIntFieldUpdateOperationsInput | number | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    reducedMobilityAccess?: BoolFieldUpdateOperationsInput | boolean
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    weatherRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    transportOptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCreateManyBadgeCategoryInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type badgeUpdateWithoutBadgeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBadge?: userBadgeUpdateOneWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateWithoutBadgeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBadge?: userBadgeUncheckedUpdateOneWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateManyWithoutBadgeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveExerciseCreateManyCognitiveCategoryInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    programCategoryId?: string | null
  }

  export type cognitiveExerciseUpdateWithoutCognitiveCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userActivity?: userActivityUpdateManyWithoutCognitiveExerciseNestedInput
    programCategory?: programCategoryUpdateOneWithoutCognitiveExerciseNestedInput
  }

  export type cognitiveExerciseUncheckedUpdateWithoutCognitiveCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    userActivity?: userActivityUncheckedUpdateManyWithoutCognitiveExerciseNestedInput
  }

  export type cognitiveExerciseUncheckedUpdateManyWithoutCognitiveCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type helpRequestCreateManyHelpCategoryInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    neededDate: Date | string
    estimatedDuration?: number | null
    location?: string | null
    gpsCoordinates?: string | null
    recurring?: boolean | null
    frequency?: string | null
    status?: string | null
    pointsOffered?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type helpRequestUpdateWithoutHelpCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUpdateManyWithoutHelpRequestNestedInput
    user?: userUpdateOneRequiredWithoutHelpRequestNestedInput
    serviceCompleted?: serviceCompletedUpdateManyWithoutHelpRequestNestedInput
  }

  export type helpRequestUncheckedUpdateWithoutHelpCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpOffer?: helpOfferUncheckedUpdateManyWithoutHelpRequestNestedInput
    serviceCompleted?: serviceCompletedUncheckedUpdateManyWithoutHelpRequestNestedInput
  }

  export type helpRequestUncheckedUpdateManyWithoutHelpCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    neededDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    pointsOffered?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type urbanIssueReportCreateManyIssueCategoryInput = {
    id?: string
    userId: string
    description: string
    address: string
    gpsCoordinates?: string | null
    reportDate: Date | string
    status?: string | null
    cityReference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type urbanIssueReportUpdateWithoutIssueCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutUrbanIssueReportNestedInput
  }

  export type urbanIssueReportUncheckedUpdateWithoutIssueCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type urbanIssueReportUncheckedUpdateManyWithoutIssueCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cityReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalAdviceCreateManyNutritionalCategoryInput = {
    id?: string
    title: string
    description?: string | null
    season?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type nutritionalAdviceUpdateWithoutNutritionalCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalAdviceUncheckedUpdateWithoutNutritionalCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nutritionalAdviceUncheckedUpdateManyWithoutNutritionalCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cognitiveExerciseCreateManyProgramCategoryInput = {
    id?: string
    name: string
    categoryId?: string | null
    difficultyLevel?: number | null
    durationMinutes?: number | null
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type exerciseProgramCreateManyProgramCategoryInput = {
    id?: string
    name: string
    difficultyLevel?: number | null
    adaptedForReducedMobility?: boolean | null
    durationMinutes?: number | null
    description?: string | null
    videoLink?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type cognitiveExerciseUpdateWithoutProgramCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitiveCategory?: cognitiveCategoryUpdateOneWithoutCognitiveExerciseNestedInput
    userActivity?: userActivityUpdateManyWithoutCognitiveExerciseNestedInput
  }

  export type cognitiveExerciseUncheckedUpdateWithoutProgramCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userActivity?: userActivityUncheckedUpdateManyWithoutCognitiveExerciseNestedInput
  }

  export type cognitiveExerciseUncheckedUpdateManyWithoutProgramCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type exerciseProgramUpdateWithoutProgramCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userActivity?: userActivityUpdateManyWithoutExerciseProgramNestedInput
  }

  export type exerciseProgramUncheckedUpdateWithoutProgramCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userActivity?: userActivityUncheckedUpdateManyWithoutExerciseProgramNestedInput
  }

  export type exerciseProgramUncheckedUpdateManyWithoutProgramCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    adaptedForReducedMobility?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoLink?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collaborativeProjectCreateManyProjectCategoryInput = {
    id?: string
    title: string
    description?: string | null
    creatorId: string
    creationDate?: Date | string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type collaborativeProjectUpdateWithoutProjectCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutCollaborativeProjectNestedInput
    projectMember?: projectMemberUpdateManyWithoutCollaborativeProjectNestedInput
    projectTask?: projectTaskUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectUncheckedUpdateWithoutProjectCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectMember?: projectMemberUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
    projectTask?: projectTaskUncheckedUpdateManyWithoutCollaborativeProjectNestedInput
  }

  export type collaborativeProjectUncheckedUpdateManyWithoutProjectCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceCreateManyResourceCategoryInput = {
    id?: string
    title: string
    content?: string | null
    type: string
    authorId: string
    adminValidated?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type resourceUpdateWithoutResourceCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateWithoutResourceCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourceUncheckedUpdateManyWithoutResourceCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    adminValidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type localServiceCreateManyServiceCategoryInput = {
    id?: string
    name: string
    address?: string | null
    gpsCoordinates?: string | null
    phone?: string | null
    website?: string | null
    description?: string | null
    hours?: string | null
    seniorFriendly?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type localServiceUpdateWithoutServiceCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceRating?: serviceRatingUpdateManyWithoutLocalServiceNestedInput
  }

  export type localServiceUncheckedUpdateWithoutServiceCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceRating?: serviceRatingUncheckedUpdateManyWithoutLocalServiceNestedInput
  }

  export type localServiceUncheckedUpdateManyWithoutServiceCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gpsCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    seniorFriendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type skillCreateManySkillCategoryInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type skillUpdateWithoutSkillCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userSkill?: userSkillUpdateManyWithoutSkillNestedInput
  }

  export type skillUncheckedUpdateWithoutSkillCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userSkill?: userSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type skillUncheckedUpdateManyWithoutSkillCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessBadgeCreateManyWellnessCategoryInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    level: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessGoalCreateManyWellnessCategoryInput = {
    id?: string
    userId: string
    title: string
    targetValue: number
    unit: string
    frequency: string
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type wellnessBadgeUpdateWithoutWellnessCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessBadgeUncheckedUpdateWithoutWellnessCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessBadgeUncheckedUpdateManyWithoutWellnessCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wellnessGoalUpdateWithoutWellnessCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUpdateManyWithoutWellnessGoalNestedInput
    user?: userUpdateOneWithoutWellnessGoalNestedInput
  }

  export type wellnessGoalUncheckedUpdateWithoutWellnessCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wellnessGoalProgress?: wellnessGoalProgressUncheckedUpdateManyWithoutWellnessGoalNestedInput
  }

  export type wellnessGoalUncheckedUpdateManyWithoutWellnessCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}